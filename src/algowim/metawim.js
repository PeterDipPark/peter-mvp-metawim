/**
 * @license
 * PlayCanvas Engine v1.52.1 revision 0f56653b1
 * Copyright 2011-2022 PlayCanvas Ltd. All rights reserved.
 */
if (!Array.prototype.fill) {
	Object.defineProperty(Array.prototype, 'fill', {
		value: function (value) {
			if (this == null) {
				throw new TypeError('this is null or not defined');
			}

			var O = Object(this);
			var len = O.length >>> 0;
			var start = arguments[1];
			var relativeStart = start >> 0;
			var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
			var end = arguments[2];
			var relativeEnd = end === undefined ? len : end >> 0;
			var finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

			while (k < finalValue) {
				O[k] = value;
				k++;
			}

			return O;
		}
	});
}

if (!Array.prototype.find) {
	Object.defineProperty(Array.prototype, 'find', {
		value: function (predicate) {
			if (this == null) {
				throw TypeError('"this" is null or not defined');
			}

			var o = Object(this);
			var len = o.length >>> 0;

			if (typeof predicate !== 'function') {
				throw TypeError('predicate must be a function');
			}

			var thisArg = arguments[1];
			var k = 0;

			while (k < len) {
				var kValue = o[k];

				if (predicate.call(thisArg, kValue, k, o)) {
					return kValue;
				}

				k++;
			}

			return undefined;
		},
		configurable: true,
		writable: true
	});
}

if (!Array.prototype.findIndex) {
	Object.defineProperty(Array.prototype, 'findIndex', {
		value: function (predicate) {
			if (this == null) {
				throw new TypeError('"this" is null or not defined');
			}

			var o = Object(this);
			var len = o.length >>> 0;

			if (typeof predicate !== 'function') {
				throw new TypeError('predicate must be a function');
			}

			var thisArg = arguments[1];
			var k = 0;

			while (k < len) {
				var kValue = o[k];

				if (predicate.call(thisArg, kValue, k, o)) {
					return k;
				}

				k++;
			}

			return -1;
		},
		configurable: true,
		writable: true
	});
}

Math.log2 = Math.log2 || function (x) {
	return Math.log(x) * Math.LOG2E;
};

if (!Math.sign) {
	Math.sign = function (x) {
		return (x > 0) - (x < 0) || +x;
	};
}

if (Number.isFinite === undefined) Number.isFinite = function (value) {
	return typeof value === 'number' && isFinite(value);
};

if (typeof Object.assign != 'function') {
	Object.defineProperty(Object, "assign", {
		value: function assign(target, varArgs) {

			if (target == null) {
				throw new TypeError('Cannot convert undefined or null to object');
			}

			var to = Object(target);

			for (var index = 1; index < arguments.length; index++) {
				var nextSource = arguments[index];

				if (nextSource != null) {
					for (var nextKey in nextSource) {
						if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
							to[nextKey] = nextSource[nextKey];
						}
					}
				}
			}

			return to;
		},
		writable: true,
		configurable: true
	});
}

(function () {
	if (typeof navigator === 'undefined' || typeof document === 'undefined') {
		return;
	}

	navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;

	var pointerlockchange = function pointerlockchange() {
		var e = document.createEvent('CustomEvent');
		e.initCustomEvent('pointerlockchange', true, false, null);
		document.dispatchEvent(e);
	};

	var pointerlockerror = function pointerlockerror() {
		var e = document.createEvent('CustomEvent');
		e.initCustomEvent('pointerlockerror', true, false, null);
		document.dispatchEvent(e);
	};

	document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
	document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
	document.addEventListener('mozpointerlockchange', pointerlockchange, false);
	document.addEventListener('mozpointerlocklost', pointerlockchange, false);
	document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
	document.addEventListener('mozpointerlockerror', pointerlockerror, false);

	if (Element.prototype.mozRequestPointerLock) {
		Element.prototype.requestPointerLock = function () {
			this.mozRequestPointerLock();
		};
	} else {
		Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
	}

	if (!Element.prototype.requestPointerLock && navigator.pointer) {
		Element.prototype.requestPointerLock = function () {
			var el = this;
			document.pointerLockElement = el;
			navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
		};
	}

	document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;

	if (!document.exitPointerLock) {
		document.exitPointerLock = function () {
			if (navigator.pointer) {
				document.pointerLockElement = null;
				navigator.pointer.unlock();
			}
		};
	}
})();

(function () {
	if (typeof window === 'undefined') return;
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];

	for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	}

	if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
		var currTime = new Date().getTime();
		var timeToCall = Math.max(0, 16 - (currTime - lastTime));
		var id = window.setTimeout(function () {
			callback(currTime + timeToCall);
		}, timeToCall);
		lastTime = currTime + timeToCall;
		return id;
	};
	if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
		clearTimeout(id);
	};
})();

if (!String.prototype.endsWith) {
	String.prototype.endsWith = function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}

		return this.substring(this_len - search.length, this_len) === search;
	};
}

if (!String.prototype.includes) {
	String.prototype.includes = function (search, start) {

		if (typeof start !== 'number') {
			start = 0;
		}

		if (start + search.length > this.length) {
			return false;
		} else {
			return this.indexOf(search, start) !== -1;
		}
	};
}

if (!String.prototype.startsWith) {
	String.prototype.startsWith = function (search, pos) {
		return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	};
}

if (!Int8Array.prototype.fill) {
	Int8Array.prototype.fill = Array.prototype.fill;
}

if (!Uint8Array.prototype.fill) {
	Uint8Array.prototype.fill = Array.prototype.fill;
}

if (!Uint8ClampedArray.prototype.fill) {
	Uint8ClampedArray.prototype.fill = Array.prototype.fill;
}

if (!Int16Array.prototype.fill) {
	Int16Array.prototype.fill = Array.prototype.fill;
}

if (!Uint16Array.prototype.fill) {
	Uint16Array.prototype.fill = Array.prototype.fill;
}

if (!Int32Array.prototype.fill) {
	Int32Array.prototype.fill = Array.prototype.fill;
}

if (!Uint32Array.prototype.fill) {
	Uint32Array.prototype.fill = Array.prototype.fill;
}

if (!Float32Array.prototype.fill) {
	Float32Array.prototype.fill = Array.prototype.fill;
}

var glErrorShadow = {};

function error(msg) {
	if (window.console && window.console.error) {
		window.console.error(msg);
	}
}

function log$1(msg) {
	if (window.console && window.console.log) {
		window.console.log(msg);
	}
}

function synthesizeGLError(err, opt_msg) {
	glErrorShadow[err] = true;

	if (opt_msg !== undefined) {
		error(opt_msg);
	}
}

function wrapGLError(gl) {
	var f = gl.getError;

	gl.getError = function () {
		var err;

		do {
			err = f.apply(gl);

			if (err != gl.NO_ERROR) {
				glErrorShadow[err] = true;
			}
		} while (err != gl.NO_ERROR);

		for (var err in glErrorShadow) {
			if (glErrorShadow[err]) {
				delete glErrorShadow[err];
				return parseInt(err);
			}
		}

		return gl.NO_ERROR;
	};
}

var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
	var gl = ext.gl;
	this.ext = ext;
	this.isAlive = true;
	this.hasBeenBound = false;
	this.elementArrayBuffer = null;
	this.attribs = new Array(ext.maxVertexAttribs);

	for (var n = 0; n < this.attribs.length; n++) {
		var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
		this.attribs[n] = attrib;
	}

	this.maxAttrib = 0;
};

WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
	this.enabled = false;
	this.buffer = null;
	this.size = 4;
	this.type = gl.FLOAT;
	this.normalized = false;
	this.stride = 16;
	this.offset = 0;
	this.cached = "";
	this.recache();
};

WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
	this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};

var OESVertexArrayObject = function OESVertexArrayObject(gl) {
	var self = this;
	this.gl = gl;
	wrapGLError(gl);
	var original = this.original = {
		getParameter: gl.getParameter,
		enableVertexAttribArray: gl.enableVertexAttribArray,
		disableVertexAttribArray: gl.disableVertexAttribArray,
		bindBuffer: gl.bindBuffer,
		getVertexAttrib: gl.getVertexAttrib,
		vertexAttribPointer: gl.vertexAttribPointer
	};

	gl.getParameter = function getParameter(pname) {
		if (pname == self.VERTEX_ARRAY_BINDING_OES) {
			if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
				return null;
			} else {
				return self.currentVertexArrayObject;
			}
		}

		return original.getParameter.apply(this, arguments);
	};

	gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
		var vao = self.currentVertexArrayObject;
		vao.maxAttrib = Math.max(vao.maxAttrib, index);
		var attrib = vao.attribs[index];
		attrib.enabled = true;
		return original.enableVertexAttribArray.apply(this, arguments);
	};

	gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
		var vao = self.currentVertexArrayObject;
		vao.maxAttrib = Math.max(vao.maxAttrib, index);
		var attrib = vao.attribs[index];
		attrib.enabled = false;
		return original.disableVertexAttribArray.apply(this, arguments);
	};

	gl.bindBuffer = function bindBuffer(target, buffer) {
		switch (target) {
			case gl.ARRAY_BUFFER:
				self.currentArrayBuffer = buffer;
				break;

			case gl.ELEMENT_ARRAY_BUFFER:
				self.currentVertexArrayObject.elementArrayBuffer = buffer;
				break;
		}

		return original.bindBuffer.apply(this, arguments);
	};

	gl.getVertexAttrib = function getVertexAttrib(index, pname) {
		var vao = self.currentVertexArrayObject;
		var attrib = vao.attribs[index];

		switch (pname) {
			case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
				return attrib.buffer;

			case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
				return attrib.enabled;

			case gl.VERTEX_ATTRIB_ARRAY_SIZE:
				return attrib.size;

			case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
				return attrib.stride;

			case gl.VERTEX_ATTRIB_ARRAY_TYPE:
				return attrib.type;

			case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
				return attrib.normalized;

			default:
				return original.getVertexAttrib.apply(this, arguments);
		}
	};

	gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
		var vao = self.currentVertexArrayObject;
		vao.maxAttrib = Math.max(vao.maxAttrib, indx);
		var attrib = vao.attribs[indx];
		attrib.buffer = self.currentArrayBuffer;
		attrib.size = size;
		attrib.type = type;
		attrib.normalized = normalized;
		attrib.stride = stride;
		attrib.offset = offset;
		attrib.recache();
		return original.vertexAttribPointer.apply(this, arguments);
	};

	if (gl.instrumentExtension) {
		gl.instrumentExtension(this, "OES_vertex_array_object");
	}

	gl.canvas.addEventListener('webglcontextrestored', function () {
		log$1("OESVertexArrayObject emulation library context restored");
		self.reset_();
	}, true);
	this.reset_();
};

OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;

OESVertexArrayObject.prototype.reset_ = function reset_() {
	var contextWasLost = this.vertexArrayObjects !== undefined;

	if (contextWasLost) {
		for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
			this.vertexArrayObjects.isAlive = false;
		}
	}

	var gl = this.gl;
	this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
	this.currentVertexArrayObject = null;
	this.currentArrayBuffer = null;
	this.vertexArrayObjects = [this.defaultVertexArrayObject];
	this.bindVertexArrayOES(null);
};

OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
	var arrayObject = new WebGLVertexArrayObjectOES(this);
	this.vertexArrayObjects.push(arrayObject);
	return arrayObject;
};

OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
	arrayObject.isAlive = false;
	this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);

	if (this.currentVertexArrayObject == arrayObject) {
		this.bindVertexArrayOES(null);
	}
};

OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
	if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
		if (arrayObject.hasBeenBound && arrayObject.ext == this) {
			return true;
		}
	}

	return false;
};

OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
	var gl = this.gl;

	if (arrayObject && !arrayObject.isAlive) {
		synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
		return;
	}

	var original = this.original;
	var oldVAO = this.currentVertexArrayObject;
	this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
	this.currentVertexArrayObject.hasBeenBound = true;
	var newVAO = this.currentVertexArrayObject;

	if (oldVAO == newVAO) {
		return;
	}

	if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
		original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
	}

	var currentBinding = this.currentArrayBuffer;
	var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);

	for (var n = 0; n <= maxAttrib; n++) {
		var attrib = newVAO.attribs[n];
		var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;

		if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
			if (attrib.enabled) {
				original.enableVertexAttribArray.call(gl, n);
			} else {
				original.disableVertexAttribArray.call(gl, n);
			}
		}

		if (attrib.enabled) {
			var bufferChanged = false;

			if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
				if (currentBinding != attrib.buffer) {
					original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
					currentBinding = attrib.buffer;
				}

				bufferChanged = true;
			}

			if (bufferChanged || attrib.cached != oldAttrib.cached) {
				original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
			}
		}
	}

	if (this.currentArrayBuffer != currentBinding) {
		original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
	}
};

const setupVertexArrayObject = function setupVertexArrayObject(gl) {
	if (gl.getSupportedExtensions) {
		var exts = gl.getSupportedExtensions();

		if (exts.indexOf("OES_vertex_array_object") != -1) {
			return;
		}
	} else if (gl.getExtension) {
		var vao = gl.getExtension("OES_vertex_array_object");

		if (vao) {
			return;
		}
	}

	if (gl.getSupportedExtensions) {
		var original_getSupportedExtensions = gl.getSupportedExtensions;

		gl.getSupportedExtensions = function getSupportedExtensions() {
			var list = original_getSupportedExtensions.call(this) || [];
			list.push("OES_vertex_array_object");
			return list;
		};
	}

	var original_getExtension = gl.getExtension;

	gl.getExtension = function getExtension(name) {
		if (name == "OES_vertex_array_object") {
			if (!gl.__OESVertexArrayObject) {
				gl.__OESVertexArrayObject = new OESVertexArrayObject(gl);
			}

			return gl.__OESVertexArrayObject;
		}

		if (original_getExtension) {
			return original_getExtension.call(this, name);
		} else {
			return null;
		}
	};
};

const version = "1.52.1";
const revision = "0f56653b1";

const _typeLookup = function () {
	const result = {};
	const names = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];

	for (let i = 0; i < names.length; i++) result["[object " + names[i] + "]"] = names[i].toLowerCase();

	return result;
}();

function type(obj) {
	if (obj === null) {
		return "null";
	}

	const type = typeof obj;

	if (type === "undefined" || type === "number" || type === "string" || type === "boolean") {
		return type;
	}

	return _typeLookup[Object.prototype.toString.call(obj)];
}

function extend(target, ex) {
	for (const prop in ex) {
		const copy = ex[prop];

		if (type(copy) === "object") {
			target[prop] = extend({}, copy);
		} else if (type(copy) === "array") {
			target[prop] = extend([], copy);
		} else {
			target[prop] = copy;
		}
	}

	return target;
}

function isDefined(o) {
	let a;
	return o !== a;
}

class EventHandler {
	constructor() {
		this._callbacks = {};
		this._callbackActive = {};
	}

	initEventHandler() {
		this._callbacks = {};
		this._callbackActive = {};
	}

	_addCallback(name, callback, scope, once = false) {
		if (!name || typeof name !== 'string' || !callback) return;
		if (!this._callbacks[name]) this._callbacks[name] = [];
		if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();

		this._callbacks[name].push({
			callback: callback,
			scope: scope || this,
			once: once
		});
	}

	on(name, callback, scope) {
		this._addCallback(name, callback, scope, false);

		return this;
	}

	off(name, callback, scope) {
		if (name) {
			if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
		} else {
			for (const key in this._callbackActive) {
				if (!this._callbacks[key]) continue;
				if (this._callbacks[key] !== this._callbackActive[key]) continue;
				this._callbackActive[key] = this._callbackActive[key].slice();
			}
		}

		if (!name) {
			this._callbacks = {};
		} else if (!callback) {
			if (this._callbacks[name]) this._callbacks[name] = [];
		} else {
			const events = this._callbacks[name];
			if (!events) return this;
			let count = events.length;

			for (let i = 0; i < count; i++) {
				if (events[i].callback !== callback) continue;
				if (scope && events[i].scope !== scope) continue;
				events[i--] = events[--count];
			}

			events.length = count;
		}

		return this;
	}

	fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
		if (!name || !this._callbacks[name]) return this;
		let callbacks;

		if (!this._callbackActive[name]) {
			this._callbackActive[name] = this._callbacks[name];
		} else {
			if (this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
			callbacks = this._callbacks[name].slice();
		}

		for (let i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {
			const evt = (callbacks || this._callbackActive[name])[i];
			evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

			if (evt.once) {
				const existingCallback = this._callbacks[name];
				const ind = existingCallback ? existingCallback.indexOf(evt) : -1;

				if (ind !== -1) {
					if (this._callbackActive[name] === existingCallback) this._callbackActive[name] = this._callbackActive[name].slice();

					this._callbacks[name].splice(ind, 1);
				}
			}
		}

		if (!callbacks) this._callbackActive[name] = null;
		return this;
	}

	once(name, callback, scope) {
		this._addCallback(name, callback, scope, true);

		return this;
	}

	hasEvent(name) {
		return this._callbacks[name] && this._callbacks[name].length !== 0 || false;
	}

}

const events = {
	attach: function (target) {
		const ev = events;
		target._addCallback = ev._addCallback;
		target.on = ev.on;
		target.off = ev.off;
		target.fire = ev.fire;
		target.once = ev.once;
		target.hasEvent = ev.hasEvent;
		target._callbacks = {};
		target._callbackActive = {};
		return target;
	},
	_addCallback: EventHandler.prototype._addCallback,
	on: EventHandler.prototype.on,
	off: EventHandler.prototype.off,
	fire: EventHandler.prototype.fire,
	once: EventHandler.prototype.once,
	hasEvent: EventHandler.prototype.hasEvent
};

const guid = {
	create: function () {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
			const r = Math.random() * 16 | 0;
			const v = c === 'x' ? r : r & 0x3 | 0x8;
			return v.toString(16);
		});
	}
};

const path = {
	delimiter: "/",
	join: function () {
		const num = arguments.length;
		let result = arguments[0];

		for (let index = 0; index < num - 1; ++index) {
			const one = arguments[index];
			const two = arguments[index + 1];

			if (!isDefined(one) || !isDefined(two)) {
				throw new Error("undefined argument to pc.path.join");
			}

			if (two[0] === path.delimiter) {
				result = two;
				continue;
			}

			if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
				result += path.delimiter + two;
			} else {
				result += two;
			}
		}

		return result;
	},
	normalize: function (pathname) {
		const lead = pathname.startsWith(path.delimiter);
		const trail = pathname.endsWith(path.delimiter);
		const parts = pathname.split('/');
		let result = '';
		let cleaned = [];

		for (let i = 0; i < parts.length; i++) {
			if (parts[i] === '') continue;
			if (parts[i] === '.') continue;

			if (parts[i] === '..' && cleaned.length > 0) {
				cleaned = cleaned.slice(0, cleaned.length - 2);
				continue;
			}

			if (i > 0) cleaned.push(path.delimiter);
			cleaned.push(parts[i]);
		}

		result = cleaned.join('');

		if (!lead && result[0] === path.delimiter) {
			result = result.slice(1);
		}

		if (trail && result[result.length - 1] !== path.delimiter) {
			result += path.delimiter;
		}

		return result;
	},
	split: function (pathname) {
		const parts = pathname.split(path.delimiter);
		const tail = parts.slice(parts.length - 1)[0];
		const head = parts.slice(0, parts.length - 1).join(path.delimiter);
		return [head, tail];
	},
	getBasename: function (pathname) {
		return path.split(pathname)[1];
	},
	getDirectory: function (pathname) {
		const parts = pathname.split(path.delimiter);
		return parts.slice(0, parts.length - 1).join(path.delimiter);
	},
	getExtension: function (pathname) {
		const ext = pathname.split('?')[0].split('.').pop();

		if (ext !== pathname) {
			return "." + ext;
		}

		return "";
	},
	isRelativePath: function (pathname) {
		return pathname.charAt(0) !== "/" && pathname.match(/:\/\//) === null;
	},
	extractPath: function (pathname) {
		let result = "";
		const parts = pathname.split("/");
		let i = 0;

		if (parts.length > 1) {
			if (path.isRelativePath(pathname)) {
				if (parts[0] === ".") {
					for (i = 0; i < parts.length - 1; ++i) {
						result += i === 0 ? parts[i] : "/" + parts[i];
					}
				} else if (parts[0] === "..") {
					for (i = 0; i < parts.length - 1; ++i) {
						result += i === 0 ? parts[i] : "/" + parts[i];
					}
				} else {
					result = ".";

					for (i = 0; i < parts.length - 1; ++i) {
						result += "/" + parts[i];
					}
				}
			} else {
				for (i = 0; i < parts.length - 1; ++i) {
					result += i === 0 ? parts[i] : "/" + parts[i];
				}
			}
		}

		return result;
	}
};

let desktop = false;
let mobile = false;
let windows = false;
let xbox = false;
let android = false;
let ios = false;
let touch = false;
let gamepads = false;
let workers = false;
let passiveEvents = false;

if (typeof navigator !== 'undefined') {
	const ua = navigator.userAgent;
	if (/(windows|mac os|linux|cros)/i.test(ua)) desktop = true;
	if (/xbox/i.test(ua)) xbox = true;

	if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
		desktop = false;
		mobile = true;
		windows = true;
	} else if (/android/i.test(ua)) {
		desktop = false;
		mobile = true;
		android = true;
	} else if (/ip([ao]d|hone)/i.test(ua)) {
		desktop = false;
		mobile = true;
		ios = true;
	}

	if (typeof window !== 'undefined') {
		touch = 'ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0;
	}

	gamepads = 'getGamepads' in navigator;
	workers = typeof Worker !== 'undefined';

	try {
		const opts = Object.defineProperty({}, 'passive', {
			get: function () {
				passiveEvents = true;
				return false;
			}
		});
		window.addEventListener("testpassive", null, opts);
		window.removeEventListener("testpassive", null, opts);
	} catch (e) {}
}

const environment = typeof window !== 'undefined' ? 'browser' : 'node';
const platform = {
	environment: environment,
	global: environment === 'browser' ? window : global,
	browser: environment === 'browser',
	desktop: desktop,
	mobile: mobile,
	ios: ios,
	android: android,
	windows: windows,
	xbox: xbox,
	gamepads: gamepads,
	touch: touch,
	workers: workers,
	passiveEvents: passiveEvents
};

const ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
const ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
const HIGH_SURROGATE_BEGIN = 0xD800;
const HIGH_SURROGATE_END = 0xDBFF;
const LOW_SURROGATE_BEGIN = 0xDC00;
const LOW_SURROGATE_END = 0xDFFF;
const ZERO_WIDTH_JOINER = 0x200D;
const REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
const REGIONAL_INDICATOR_END = 0x1F1FF;
const FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
const FITZPATRICK_MODIFIER_END = 0x1F3FF;
const DIACRITICAL_MARKS_BEGIN = 0x20D0;
const DIACRITICAL_MARKS_END = 0x20FF;
const VARIATION_MODIFIER_BEGIN = 0xFE00;
const VARIATION_MODIFIER_END = 0xFE0F;

function getCodePointData(string, i = 0) {
	const size = string.length;

	if (i < 0 || i >= size) {
		return null;
	}

	const first = string.charCodeAt(i);

	if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
		const second = string.charCodeAt(i + 1);

		if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
			return {
				code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
				long: true
			};
		}
	}

	return {
		code: first,
		long: false
	};
}

function isCodeBetween(string, begin, end) {
	if (!string) return false;
	const codeData = getCodePointData(string);

	if (codeData) {
		const code = codeData.code;
		return code >= begin && code <= end;
	}

	return false;
}

function numCharsToTakeForNextSymbol(string, index) {
	if (index === string.length - 1) {
		return 1;
	}

	if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
		const first = string.substring(index, index + 2);
		const second = string.substring(index + 2, index + 4);

		if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
			return 4;
		}

		if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
			return 3;
		}

		return 2;
	}

	if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
		return 2;
	}

	return 1;
}

const string = {
	ASCII_LOWERCASE: ASCII_LOWERCASE,
	ASCII_UPPERCASE: ASCII_UPPERCASE,
	ASCII_LETTERS: ASCII_LETTERS,
	format: function (s) {
		for (let i = 1; i < arguments.length; i++) {
			s = s.replace('{' + (i - 1) + '}', arguments[i]);
		}

		return s;
	},
	toBool: function (s, strict = false) {
		if (s === 'true') {
			return true;
		}

		if (strict) {
			if (s === 'false') {
				return false;
			}

			throw new TypeError('Not a boolean string');
		}

		return false;
	},
	getCodePoint: function (string, i) {
		const codePointData = getCodePointData(string, i);
		return codePointData && codePointData.code;
	},
	getCodePoints: function (string) {
		if (typeof string !== 'string') {
			throw new TypeError('Not a string');
		}

		let i = 0;
		const arr = [];
		let codePoint;

		while (!!(codePoint = getCodePointData(string, i))) {
			arr.push(codePoint.code);
			i += codePoint.long ? 2 : 1;
		}

		return arr;
	},
	getSymbols: function (string) {
		if (typeof string !== 'string') {
			throw new TypeError('Not a string');
		}

		let index = 0;
		const length = string.length;
		const output = [];
		let take = 0;
		let ch;

		while (index < length) {
			take += numCharsToTakeForNextSymbol(string, index + take);
			ch = string[index + take];

			if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
				ch = string[index + take++];
			}

			if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
				ch = string[index + take++];
			}

			if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
				ch = string[index + take++];
				continue;
			}

			const char = string.substring(index, index + take);
			output.push(char);
			index += take;
			take = 0;
		}

		return output;
	},
	fromCodePoint: function () {
		const chars = [];
		let current;
		let codePoint;
		let units;

		for (let i = 0; i < arguments.length; ++i) {
			current = Number(arguments[i]);
			codePoint = current - 0x10000;
			units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];
			chars.push(String.fromCharCode.apply(null, units));
		}

		return chars.join('');
	}
};

class IndexedList {
	constructor() {
		this._list = [];
		this._index = {};
	}

	push(key, item) {
		if (this._index[key]) {
			throw Error("Key already in index " + key);
		}

		const location = this._list.push(item) - 1;
		this._index[key] = location;
	}

	has(key) {
		return this._index[key] !== undefined;
	}

	get(key) {
		const location = this._index[key];

		if (location !== undefined) {
			return this._list[location];
		}

		return null;
	}

	remove(key) {
		const location = this._index[key];

		if (location !== undefined) {
			this._list.splice(location, 1);

			delete this._index[key];

			for (key in this._index) {
				const idx = this._index[key];

				if (idx > location) {
					this._index[key] = idx - 1;
				}
			}

			return true;
		}

		return false;
	}

	list() {
		return this._list;
	}

	clear() {
		this._list.length = 0;

		for (const prop in this._index) {
			delete this._index[prop];
		}
	}

}

class ReadStream {
	constructor(arraybuffer) {
		this.arraybuffer = arraybuffer;
		this.dataView = new DataView(arraybuffer);
		this.offset = 0;
		this.stack = [];
	}

	get remainingBytes() {
		return this.dataView.byteLength - this.offset;
	}

	reset(offset = 0) {
		this.offset = offset;
	}

	skip(bytes) {
		this.offset += bytes;
	}

	align(bytes) {
		this.offset = this.offset + bytes - 1 & ~(bytes - 1);
	}

	_inc(amount) {
		this.offset += amount;
		return this.offset - amount;
	}

	readChar() {
		return String.fromCharCode(this.dataView.getUint8(this.offset++));
	}

	readChars(numChars) {
		let result = '';

		for (let i = 0; i < numChars; ++i) {
			result += this.readChar();
		}

		return result;
	}

	readU8() {
		return this.dataView.getUint8(this.offset++);
	}

	readU16() {
		return this.dataView.getUint16(this._inc(2), true);
	}

	readU32() {
		return this.dataView.getUint32(this._inc(4), true);
	}

	readU64() {
		return this.readU32() + 2 ** 32 * this.readU32();
	}

	readU32be() {
		return this.dataView.getUint32(this._inc(4), false);
	}

	readArray(result) {
		for (let i = 0; i < result.length; ++i) {
			result[i] = this.readU8();
		}
	}

	readLine() {
		const view = this.dataView;
		let result = "";

		while (true) {
			if (this.offset >= view.byteLength) {
				break;
			}

			const c = String.fromCharCode(this.readU8());

			if (c === '\n') {
				break;
			}

			result += c;
		}

		return result;
	}

}

class SortedLoopArray {
	constructor(args) {
		this.items = [];
		this.length = 0;
		this.loopIndex = -1;
		this._sortBy = args.sortBy;
		this._sortHandler = this._doSort.bind(this);
	}

	_binarySearch(item) {
		let left = 0;
		let right = this.items.length - 1;
		const search = item[this._sortBy];
		let middle;
		let current;

		while (left <= right) {
			middle = Math.floor((left + right) / 2);
			current = this.items[middle][this._sortBy];

			if (current <= search) {
				left = middle + 1;
			} else if (current > search) {
				right = middle - 1;
			}
		}

		return left;
	}

	_doSort(a, b) {
		const sortBy = this._sortBy;
		return a[sortBy] - b[sortBy];
	}

	insert(item) {
		const index = this._binarySearch(item);

		this.items.splice(index, 0, item);
		this.length++;

		if (this.loopIndex >= index) {
			this.loopIndex++;
		}
	}

	append(item) {
		this.items.push(item);
		this.length++;
	}

	remove(item) {
		const idx = this.items.indexOf(item);
		if (idx < 0) return;
		this.items.splice(idx, 1);
		this.length--;

		if (this.loopIndex >= idx) {
			this.loopIndex--;
		}
	}

	sort() {
		const current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
		this.items.sort(this._sortHandler);

		if (current !== null) {
			this.loopIndex = this.items.indexOf(current);
		}
	}

}

class Tags extends EventHandler {
	constructor(parent) {
		super();
		this._index = {};
		this._list = [];
		this._parent = parent;
	}

	add() {
		let changed = false;

		const tags = this._processArguments(arguments, true);

		if (!tags.length) return changed;

		for (let i = 0; i < tags.length; i++) {
			if (this._index[tags[i]]) continue;
			changed = true;
			this._index[tags[i]] = true;

			this._list.push(tags[i]);

			this.fire('add', tags[i], this._parent);
		}

		if (changed) this.fire('change', this._parent);
		return changed;
	}

	remove() {
		let changed = false;
		if (!this._list.length) return changed;

		const tags = this._processArguments(arguments, true);

		if (!tags.length) return changed;

		for (let i = 0; i < tags.length; i++) {
			if (!this._index[tags[i]]) continue;
			changed = true;
			delete this._index[tags[i]];

			this._list.splice(this._list.indexOf(tags[i]), 1);

			this.fire('remove', tags[i], this._parent);
		}

		if (changed) this.fire('change', this._parent);
		return changed;
	}

	clear() {
		if (!this._list.length) return;

		const tags = this._list.slice(0);

		this._list = [];
		this._index = {};

		for (let i = 0; i < tags.length; i++) this.fire('remove', tags[i], this._parent);

		this.fire('change', this._parent);
	}

	has() {
		if (!this._list.length) return false;
		return this._has(this._processArguments(arguments));
	}

	_has(tags) {
		if (!this._list.length || !tags.length) return false;

		for (let i = 0; i < tags.length; i++) {
			if (tags[i].length === 1) {
				if (this._index[tags[i][0]]) return true;
			} else {
				let multiple = true;

				for (let t = 0; t < tags[i].length; t++) {
					if (this._index[tags[i][t]]) continue;
					multiple = false;
					break;
				}

				if (multiple) return true;
			}
		}

		return false;
	}

	list() {
		return this._list.slice(0);
	}

	_processArguments(args, flat) {
		const tags = [];
		let tmp = [];
		if (!args || !args.length) return tags;

		for (let i = 0; i < args.length; i++) {
			if (args[i] instanceof Array) {
				if (!flat) tmp = [];

				for (let t = 0; t < args[i].length; t++) {
					if (typeof args[i][t] !== 'string') continue;

					if (flat) {
						tags.push(args[i][t]);
					} else {
						tmp.push(args[i][t]);
					}
				}

				if (!flat && tmp.length) tags.push(tmp);
			} else if (typeof args[i] === 'string') {
				if (flat) {
					tags.push(args[i]);
				} else {
					tags.push([args[i]]);
				}
			}
		}

		return tags;
	}

	get size() {
		return this._list.length;
	}

}

const now = typeof window !== 'undefined' && window.performance && window.performance.now && window.performance.timing ? function () {
	return window.performance.now();
} : Date.now;

const re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

class URI {
	constructor(uri) {
		const result = uri.match(re);
		this.scheme = result[2];
		this.authority = result[4];
		this.path = result[5];
		this.query = result[7];
		this.fragment = result[9];
	}

	toString() {
		let s = "";

		if (this.scheme) {
			s += this.scheme + ":";
		}

		if (this.authority) {
			s += "//" + this.authority;
		}

		s += this.path;

		if (this.query) {
			s += "?" + this.query;
		}

		if (this.fragment) {
			s += "#" + this.fragment;
		}

		return s;
	}

	getQuery() {
		const result = {};

		if (this.query) {
			const queryParams = decodeURIComponent(this.query).split("&");

			for (const queryParam of queryParams) {
				const pair = queryParam.split("=");
				result[pair[0]] = pair[1];
			}
		}

		return result;
	}

	setQuery(params) {
		let q = "";

		for (const key in params) {
			if (params.hasOwnProperty(key)) {
				if (q !== "") {
					q += "&";
				}

				q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
			}
		}

		this.query = q;
	}

}

const math = {
	DEG_TO_RAD: Math.PI / 180,
	RAD_TO_DEG: 180 / Math.PI,
	clamp: function (value, min, max) {
		if (value >= max) return max;
		if (value <= min) return min;
		return value;
	},
	intToBytes24: function (i) {
		const r = i >> 16 & 0xff;
		const g = i >> 8 & 0xff;
		const b = i & 0xff;
		return [r, g, b];
	},
	intToBytes32: function (i) {
		const r = i >> 24 & 0xff;
		const g = i >> 16 & 0xff;
		const b = i >> 8 & 0xff;
		const a = i & 0xff;
		return [r, g, b, a];
	},
	bytesToInt24: function (r, g, b) {
		if (r.length) {
			b = r[2];
			g = r[1];
			r = r[0];
		}

		return r << 16 | g << 8 | b;
	},
	bytesToInt32: function (r, g, b, a) {
		if (r.length) {
			a = r[3];
			b = r[2];
			g = r[1];
			r = r[0];
		}

		return (r << 24 | g << 16 | b << 8 | a) >>> 0;
	},
	lerp: function (a, b, alpha) {
		return a + (b - a) * math.clamp(alpha, 0, 1);
	},
	lerpAngle: function (a, b, alpha) {
		if (b - a > 180) {
			b -= 360;
		}

		if (b - a < -180) {
			b += 360;
		}

		return math.lerp(a, b, math.clamp(alpha, 0, 1));
	},
	powerOfTwo: function (x) {
		return x !== 0 && !(x & x - 1);
	},
	nextPowerOfTwo: function (val) {
		val--;
		val |= val >> 1;
		val |= val >> 2;
		val |= val >> 4;
		val |= val >> 8;
		val |= val >> 16;
		val++;
		return val;
	},
	random: function (min, max) {
		const diff = max - min;
		return Math.random() * diff + min;
	},
	smoothstep: function (min, max, x) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	},
	smootherstep: function (min, max, x) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	},
	roundUp: function (numToRound, multiple) {
		if (multiple === 0) return numToRound;
		return Math.ceil(numToRound / multiple) * multiple;
	},
	between: function (num, a, b, inclusive) {
		const min = Math.min(a, b);
		const max = Math.max(a, b);
		return inclusive ? num >= min && num <= max : num > min && num < max;
	}
};

class Http {
	get(url, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		return this.request("GET", url, options, callback);
	}

	post(url, data, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		options.postdata = data;
		return this.request("POST", url, options, callback);
	}

	put(url, data, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		options.postdata = data;
		return this.request("PUT", url, options, callback);
	}

	del(url, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		return this.request("DELETE", url, options, callback);
	}

	request(method, url, options, callback) {
		let uri, query, postdata;
		let errored = false;

		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		if (options.retry) {
			options = Object.assign({
				retries: 0,
				maxRetries: 5
			}, options);
		}

		options.callback = callback;

		if (options.async == null) {
			options.async = true;
		}

		if (options.headers == null) {
			options.headers = {};
		}

		if (options.postdata != null) {
			if (options.postdata instanceof Document) {
				postdata = options.postdata;
			} else if (options.postdata instanceof FormData) {
				postdata = options.postdata;
			} else if (options.postdata instanceof Object) {
				let contentType = options.headers["Content-Type"];

				if (contentType === undefined) {
					options.headers["Content-Type"] = Http.ContentType.FORM_URLENCODED;
					contentType = options.headers["Content-Type"];
				}

				switch (contentType) {
					case Http.ContentType.FORM_URLENCODED:
						{
							postdata = "";
							let bFirstItem = true;

							for (const key in options.postdata) {
								if (options.postdata.hasOwnProperty(key)) {
									if (bFirstItem) {
										bFirstItem = false;
									} else {
										postdata += "&";
									}

									const encodedKey = encodeURIComponent(key);
									const encodedValue = encodeURIComponent(options.postdata[key]);
									postdata += `${encodedKey}=${encodedValue}`;
								}
							}

							break;
						}

					default:
					case Http.ContentType.JSON:
						if (contentType == null) {
							options.headers["Content-Type"] = Http.ContentType.JSON;
						}

						postdata = JSON.stringify(options.postdata);
						break;
				}
			} else {
				postdata = options.postdata;
			}
		}

		if (options.cache === false) {
			const timestamp = now();
			uri = new URI(url);

			if (!uri.query) {
				uri.query = "ts=" + timestamp;
			} else {
				uri.query = uri.query + "&ts=" + timestamp;
			}

			url = uri.toString();
		}

		if (options.query) {
			uri = new URI(url);
			query = extend(uri.getQuery(), options.query);
			uri.setQuery(query);
			url = uri.toString();
		}

		const xhr = new XMLHttpRequest();
		xhr.open(method, url, options.async);
		xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
		xhr.responseType = options.responseType || this._guessResponseType(url);

		for (const header in options.headers) {
			if (options.headers.hasOwnProperty(header)) {
				xhr.setRequestHeader(header, options.headers[header]);
			}
		}

		xhr.onreadystatechange = () => {
			this._onReadyStateChange(method, url, options, xhr);
		};

		xhr.onerror = () => {
			this._onError(method, url, options, xhr);

			errored = true;
		};

		try {
			xhr.send(postdata);
		} catch (e) {
			if (!errored) {
				options.error(xhr.status, xhr, e);
			}
		}

		return xhr;
	}

	_guessResponseType(url) {
		const uri = new URI(url);
		const ext = path.getExtension(uri.path);

		if (Http.binaryExtensions.indexOf(ext) >= 0) {
			return Http.ResponseType.ARRAY_BUFFER;
		}

		if (ext === ".xml") {
			return Http.ResponseType.DOCUMENT;
		}

		return Http.ResponseType.TEXT;
	}

	_isBinaryContentType(contentType) {
		const binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.BASIS, Http.ContentType.GLB];

		if (binTypes.indexOf(contentType) >= 0) {
			return true;
		}

		return false;
	}

	_onReadyStateChange(method, url, options, xhr) {
		if (xhr.readyState === 4) {
			switch (xhr.status) {
				case 0:
					{
						if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
							this._onSuccess(method, url, options, xhr);
						} else {
							this._onError(method, url, options, xhr);
						}

						break;
					}

				case 200:
				case 201:
				case 206:
				case 304:
					{
						this._onSuccess(method, url, options, xhr);

						break;
					}

				default:
					{
						this._onError(method, url, options, xhr);

						break;
					}
			}
		}
	}

	_onSuccess(method, url, options, xhr) {
		let response;
		let contentType;
		const header = xhr.getResponseHeader("Content-Type");

		if (header) {
			const parts = header.split(";");
			contentType = parts[0].trim();
		}

		try {
			if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith(".json")) {
				response = JSON.parse(xhr.responseText);
			} else if (this._isBinaryContentType(contentType)) {
				response = xhr.response;
			} else {
				if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
					response = xhr.response;
				} else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {
					response = xhr.response;
				} else {
					if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
						response = xhr.responseXML;
					} else {
						response = xhr.responseText;
					}
				}
			}

			options.callback(null, response);
		} catch (err) {
			options.callback(err);
		}
	}

	_onError(method, url, options, xhr) {
		if (options.retrying) {
			return;
		}

		if (options.retry && options.retries < options.maxRetries) {
			options.retries++;
			options.retrying = true;
			const retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
			console.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);
			setTimeout(() => {
				options.retrying = false;
				this.request(method, url, options, options.callback);
			}, retryDelay);
		} else {
			options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
		}
	}

}

Http.ContentType = {
	FORM_URLENCODED: "application/x-www-form-urlencoded",
	GIF: "image/gif",
	JPEG: "image/jpeg",
	DDS: "image/dds",
	JSON: "application/json",
	PNG: "image/png",
	TEXT: "text/plain",
	XML: "application/xml",
	WAV: "audio/x-wav",
	OGG: "audio/ogg",
	MP3: "audio/mpeg",
	MP4: "audio/mp4",
	AAC: "audio/aac",
	BIN: "application/octet-stream",
	BASIS: "image/basis",
	GLB: "model/gltf-binary"
};
Http.ResponseType = {
	TEXT: 'text',
	ARRAY_BUFFER: 'arraybuffer',
	BLOB: 'blob',
	DOCUMENT: 'document',
	JSON: 'json'
};
Http.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb'];
Http.retryDelay = 100;
const http = new Http();

const CURVE_LINEAR = 0;
const CURVE_SMOOTHSTEP = 1;
const CURVE_CATMULL = 2;
const CURVE_CARDINAL = 3;
const CURVE_SPLINE = 4;
const CURVE_STEP = 5;

class Color {
	constructor(r = 0, g = 0, b = 0, a = 1) {
		const length = r.length;

		if (length === 3 || length === 4) {
			this.r = r[0];
			this.g = r[1];
			this.b = r[2];
			this.a = r[3] !== undefined ? r[3] : 1;
		} else {
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
		}
	}

	clone() {
		return new Color(this.r, this.g, this.b, this.a);
	}

	copy(rhs) {
		this.r = rhs.r;
		this.g = rhs.g;
		this.b = rhs.b;
		this.a = rhs.a;
		return this;
	}

	equals(rhs) {
		return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
	}

	set(r, g, b, a = 1) {
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
		return this;
	}

	lerp(lhs, rhs, alpha) {
		this.r = lhs.r + alpha * (rhs.r - lhs.r);
		this.g = lhs.g + alpha * (rhs.g - lhs.g);
		this.b = lhs.b + alpha * (rhs.b - lhs.b);
		this.a = lhs.a + alpha * (rhs.a - lhs.a);
		return this;
	}

	fromString(hex) {
		const i = parseInt(hex.replace('#', '0x'), 16);
		let bytes;

		if (hex.length > 7) {
			bytes = math.intToBytes32(i);
		} else {
			bytes = math.intToBytes24(i);
			bytes[3] = 255;
		}

		this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
		return this;
	}

	toString(alpha) {
		let s = "#" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);

		if (alpha === true) {
			const a = Math.round(this.a * 255).toString(16);

			if (this.a < 16 / 255) {
				s += '0' + a;
			} else {
				s += a;
			}
		}

		return s;
	}

}

Color.BLACK = Object.freeze(new Color(0, 0, 0, 1));
Color.BLUE = Object.freeze(new Color(0, 0, 1, 1));
Color.CYAN = Object.freeze(new Color(0, 1, 1, 1));
Color.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));
Color.GREEN = Object.freeze(new Color(0, 1, 0, 1));
Color.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));
Color.RED = Object.freeze(new Color(1, 0, 0, 1));
Color.WHITE = Object.freeze(new Color(1, 1, 1, 1));
Color.YELLOW = Object.freeze(new Color(1, 1, 0, 1));

class CurveEvaluator {
	constructor(curve, time = 0) {
		this._curve = curve;
		this._left = -Infinity;
		this._right = Infinity;
		this._recip = 0;
		this._p0 = 0;
		this._p1 = 0;
		this._m0 = 0;
		this._m1 = 0;

		this._reset(time);
	}

	evaluate(time, forceReset = false) {
		if (forceReset || time < this._left || time >= this._right) {
			this._reset(time);
		}

		let result;
		const type = this._curve.type;

		if (type === CURVE_STEP) {
			result = this._p0;
		} else {
			const t = this._recip === 0 ? 0 : (time - this._left) * this._recip;

			if (type === CURVE_LINEAR) {
				result = math.lerp(this._p0, this._p1, t);
			} else if (type === CURVE_SMOOTHSTEP) {
				result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
			} else {
				result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
			}
		}

		return result;
	}

	_reset(time) {
		const keys = this._curve.keys;
		const len = keys.length;

		if (!len) {
			this._left = -Infinity;
			this._right = Infinity;
			this._recip = 0;
			this._p0 = this._p1 = this._m0 = this._m1 = 0;
		} else {
			if (time < keys[0][0]) {
				this._left = -Infinity;
				this._right = keys[0][0];
				this._recip = 0;
				this._p0 = this._p1 = keys[0][1];
				this._m0 = this._m1 = 0;
			} else if (time >= keys[len - 1][0]) {
				this._left = keys[len - 1][0];
				this._right = Infinity;
				this._recip = 0;
				this._p0 = this._p1 = keys[len - 1][1];
				this._m0 = this._m1 = 0;
			} else {
				let index = 0;

				while (time >= keys[index + 1][0]) {
					index++;
				}

				this._left = keys[index][0];
				this._right = keys[index + 1][0];
				const diff = 1.0 / (this._right - this._left);
				this._recip = isFinite(diff) ? diff : 0;
				this._p0 = keys[index][1];
				this._p1 = keys[index + 1][1];

				if (this._isHermite()) {
					this._calcTangents(keys, index);
				}
			}
		}
	}

	_isHermite() {
		return this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;
	}

	_calcTangents(keys, index) {
		let a;
		const b = keys[index];
		const c = keys[index + 1];
		let d;

		if (index === 0) {
			a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];
		} else {
			a = keys[index - 1];
		}

		if (index === keys.length - 2) {
			d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
		} else {
			d = keys[index + 2];
		}

		if (this._curve.type === CURVE_SPLINE) {
			const s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
			const s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
			this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
			this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
		} else {
			const s1 = (c[0] - b[0]) / (b[0] - a[0]);
			const s2 = (c[0] - b[0]) / (d[0] - c[0]);
			const a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
			const d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
			const tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;
			this._m0 = tension * (c[1] - a_);
			this._m1 = tension * (d_ - b[1]);
		}
	}

	_evaluateHermite(p0, p1, m0, m1, t) {
		const t2 = t * t;
		const twot = t + t;
		const omt = 1 - t;
		const omt2 = omt * omt;
		return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
	}

}

class Curve {
	constructor(data) {
		this.keys = [];
		this.type = CURVE_SMOOTHSTEP;
		this.tension = 0.5;
		this._eval = new CurveEvaluator(this);

		if (data) {
			for (let i = 0; i < data.length - 1; i += 2) {
				this.keys.push([data[i], data[i + 1]]);
			}
		}

		this.sort();
	}

	get length() {
		return this.keys.length;
	}

	add(time, value) {
		const keys = this.keys;
		const len = keys.length;
		let i = 0;

		for (; i < len; i++) {
			if (keys[i][0] > time) {
				break;
			}
		}

		const key = [time, value];
		this.keys.splice(i, 0, key);
		return key;
	}

	get(index) {
		return this.keys[index];
	}

	sort() {
		this.keys.sort(function (a, b) {
			return a[0] - b[0];
		});
	}

	value(time) {
		return this._eval.evaluate(time, true);
	}

	closest(time) {
		const keys = this.keys;
		const length = keys.length;
		let min = 2;
		let result = null;

		for (let i = 0; i < length; i++) {
			const diff = Math.abs(time - keys[i][0]);

			if (min >= diff) {
				min = diff;
				result = keys[i];
			} else {
				break;
			}
		}

		return result;
	}

	clone() {
		const result = new Curve();
		result.keys = extend(result.keys, this.keys);
		result.type = this.type;
		result.tension = this.tension;
		return result;
	}

	quantize(precision) {
		precision = Math.max(precision, 2);
		const values = new Float32Array(precision);
		const step = 1.0 / (precision - 1);
		values[0] = this._eval.evaluate(0, true);

		for (let i = 1; i < precision; i++) {
			values[i] = this._eval.evaluate(step * i);
		}

		return values;
	}

	quantizeClamped(precision, min, max) {
		const result = this.quantize(precision);

		for (let i = 0; i < result.length; ++i) {
			result[i] = Math.min(max, Math.max(min, result[i]));
		}

		return result;
	}

}

class CurveSet {
	constructor() {
		this.curves = [];
		this._type = CURVE_SMOOTHSTEP;

		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) {
				this.curves.push(new Curve(arguments[i]));
			}
		} else {
			if (arguments.length === 0) {
				this.curves.push(new Curve());
			} else {
				const arg = arguments[0];

				if (typeof arg === 'number') {
					for (let i = 0; i < arg; i++) {
						this.curves.push(new Curve());
					}
				} else {
					for (let i = 0; i < arg.length; i++) {
						this.curves.push(new Curve(arg[i]));
					}
				}
			}
		}
	}

	get length() {
		return this.curves.length;
	}

	set type(value) {
		this._type = value;

		for (let i = 0; i < this.curves.length; i++) {
			this.curves[i].type = value;
		}
	}

	get type() {
		return this._type;
	}

	get(index) {
		return this.curves[index];
	}

	value(time, result = []) {
		const length = this.curves.length;
		result.length = length;

		for (let i = 0; i < length; i++) {
			result[i] = this.curves[i].value(time);
		}

		return result;
	}

	clone() {
		const result = new CurveSet();
		result.curves = [];

		for (let i = 0; i < this.curves.length; i++) {
			result.curves.push(this.curves[i].clone());
		}

		result._type = this._type;
		return result;
	}

	quantize(precision) {
		precision = Math.max(precision, 2);
		const numCurves = this.curves.length;
		const values = new Float32Array(precision * numCurves);
		const step = 1.0 / (precision - 1);

		for (let c = 0; c < numCurves; c++) {
			const ev = new CurveEvaluator(this.curves[c]);

			for (let i = 0; i < precision; i++) {
				values[i * numCurves + c] = ev.evaluate(step * i);
			}
		}

		return values;
	}

	quantizeClamped(precision, min, max) {
		const result = this.quantize(precision);

		for (let i = 0; i < result.length; ++i) {
			result[i] = Math.min(max, Math.max(min, result[i]));
		}

		return result;
	}

}

class Vec3 {
	constructor(x = 0, y = 0, z = 0) {
		if (x.length === 3) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
		} else {
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	add(rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		this.z += rhs.z;
		return this;
	}

	add2(lhs, rhs) {
		this.x = lhs.x + rhs.x;
		this.y = lhs.y + rhs.y;
		this.z = lhs.z + rhs.z;
		return this;
	}

	addScalar(scalar) {
		this.x += scalar;
		this.y += scalar;
		this.z += scalar;
		return this;
	}

	clone() {
		return new Vec3(this.x, this.y, this.z);
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		return this;
	}

	cross(lhs, rhs) {
		const lx = lhs.x;
		const ly = lhs.y;
		const lz = lhs.z;
		const rx = rhs.x;
		const ry = rhs.y;
		const rz = rhs.z;
		this.x = ly * rz - ry * lz;
		this.y = lz * rx - rz * lx;
		this.z = lx * ry - rx * ly;
		return this;
	}

	distance(rhs) {
		const x = this.x - rhs.x;
		const y = this.y - rhs.y;
		const z = this.z - rhs.z;
		return Math.sqrt(x * x + y * y + z * z);
	}

	div(rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		this.z /= rhs.z;
		return this;
	}

	div2(lhs, rhs) {
		this.x = lhs.x / rhs.x;
		this.y = lhs.y / rhs.y;
		this.z = lhs.z / rhs.z;
		return this;
	}

	divScalar(scalar) {
		this.x /= scalar;
		this.y /= scalar;
		this.z /= scalar;
		return this;
	}

	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}

	lerp(lhs, rhs, alpha) {
		this.x = lhs.x + alpha * (rhs.x - lhs.x);
		this.y = lhs.y + alpha * (rhs.y - lhs.y);
		this.z = lhs.z + alpha * (rhs.z - lhs.z);
		return this;
	}

	mul(rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		this.z *= rhs.z;
		return this;
	}

	mul2(lhs, rhs) {
		this.x = lhs.x * rhs.x;
		this.y = lhs.y * rhs.y;
		this.z = lhs.z * rhs.z;
		return this;
	}

	mulScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		return this;
	}

	normalize() {
		const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;

		if (lengthSq > 0) {
			const invLength = 1 / Math.sqrt(lengthSq);
			this.x *= invLength;
			this.y *= invLength;
			this.z *= invLength;
		}

		return this;
	}

	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		return this;
	}

	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		return this;
	}

	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		return this;
	}

	min(rhs) {
		if (rhs.x < this.x) this.x = rhs.x;
		if (rhs.y < this.y) this.y = rhs.y;
		if (rhs.z < this.z) this.z = rhs.z;
		return this;
	}

	max(rhs) {
		if (rhs.x > this.x) this.x = rhs.x;
		if (rhs.y > this.y) this.y = rhs.y;
		if (rhs.z > this.z) this.z = rhs.z;
		return this;
	}

	project(rhs) {
		const a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		const b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
		const s = a_dot_b / b_dot_b;
		this.x = rhs.x * s;
		this.y = rhs.y * s;
		this.z = rhs.z * s;
		return this;
	}

	set(x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	}

	sub(rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;
		return this;
	}

	sub2(lhs, rhs) {
		this.x = lhs.x - rhs.x;
		this.y = lhs.y - rhs.y;
		this.z = lhs.z - rhs.z;
		return this;
	}

	subScalar(scalar) {
		this.x -= scalar;
		this.y -= scalar;
		this.z -= scalar;
		return this;
	}

	toString() {
		return `[${this.x}, ${this.y}, ${this.z}]`;
	}

}

Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
Vec3.DOWN = Object.freeze(new Vec3(0, -1, 0));
Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
Vec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));
Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
Vec3.BACK = Object.freeze(new Vec3(0, 0, 1));

class Mat3 {
	constructor() {
		const data = new Float32Array(9);
		data[0] = data[4] = data[8] = 1;
		this.data = data;
	}

	clone() {
		return new Mat3().copy(this);
	}

	copy(rhs) {
		const src = rhs.data;
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		return this;
	}

	set(src) {
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		return this;
	}

	equals(rhs) {
		const l = this.data;
		const r = rhs.data;
		return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
	}

	isIdentity() {
		const m = this.data;
		return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
	}

	setIdentity() {
		const m = this.data;
		m[0] = 1;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 1;
		m[5] = 0;
		m[6] = 0;
		m[7] = 0;
		m[8] = 1;
		return this;
	}

	toString() {
		let t = '[';

		for (let i = 0; i < 9; i++) {
			t += this.data[i];
			t += i !== 8 ? ', ' : '';
		}

		t += ']';
		return t;
	}

	transpose() {
		const m = this.data;
		let tmp;
		tmp = m[1];
		m[1] = m[3];
		m[3] = tmp;
		tmp = m[2];
		m[2] = m[6];
		m[6] = tmp;
		tmp = m[5];
		m[5] = m[7];
		m[7] = tmp;
		return this;
	}

	setFromMat4(m) {
		const src = m.data;
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[4];
		dst[4] = src[5];
		dst[5] = src[6];
		dst[6] = src[8];
		dst[7] = src[9];
		dst[8] = src[10];
		return this;
	}

	transformVector(vec, res = new Vec3()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		res.x = x * m[0] + y * m[3] + z * m[6];
		res.y = x * m[1] + y * m[4] + z * m[7];
		res.z = x * m[2] + y * m[5] + z * m[8];
		return res;
	}

}

Mat3.IDENTITY = Object.freeze(new Mat3());
Mat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));

class Vec2 {
	constructor(x = 0, y = 0) {
		if (x.length === 2) {
			this.x = x[0];
			this.y = x[1];
		} else {
			this.x = x;
			this.y = y;
		}
	}

	add(rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		return this;
	}

	add2(lhs, rhs) {
		this.x = lhs.x + rhs.x;
		this.y = lhs.y + rhs.y;
		return this;
	}

	addScalar(scalar) {
		this.x += scalar;
		this.y += scalar;
		return this;
	}

	clone() {
		return new Vec2(this.x, this.y);
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		return this;
	}

	cross(rhs) {
		return this.x * rhs.y - this.y * rhs.x;
	}

	distance(rhs) {
		const x = this.x - rhs.x;
		const y = this.y - rhs.y;
		return Math.sqrt(x * x + y * y);
	}

	div(rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		return this;
	}

	div2(lhs, rhs) {
		this.x = lhs.x / rhs.x;
		this.y = lhs.y / rhs.y;
		return this;
	}

	divScalar(scalar) {
		this.x /= scalar;
		this.y /= scalar;
		return this;
	}

	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y;
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y;
	}

	lerp(lhs, rhs, alpha) {
		this.x = lhs.x + alpha * (rhs.x - lhs.x);
		this.y = lhs.y + alpha * (rhs.y - lhs.y);
		return this;
	}

	mul(rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		return this;
	}

	mul2(lhs, rhs) {
		this.x = lhs.x * rhs.x;
		this.y = lhs.y * rhs.y;
		return this;
	}

	mulScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}

	normalize() {
		const lengthSq = this.x * this.x + this.y * this.y;

		if (lengthSq > 0) {
			const invLength = 1 / Math.sqrt(lengthSq);
			this.x *= invLength;
			this.y *= invLength;
		}

		return this;
	}

	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}

	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	}

	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	}

	min(rhs) {
		if (rhs.x < this.x) this.x = rhs.x;
		if (rhs.y < this.y) this.y = rhs.y;
		return this;
	}

	max(rhs) {
		if (rhs.x > this.x) this.x = rhs.x;
		if (rhs.y > this.y) this.y = rhs.y;
		return this;
	}

	set(x, y) {
		this.x = x;
		this.y = y;
		return this;
	}

	sub(rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		return this;
	}

	sub2(lhs, rhs) {
		this.x = lhs.x - rhs.x;
		this.y = lhs.y - rhs.y;
		return this;
	}

	subScalar(scalar) {
		this.x -= scalar;
		this.y -= scalar;
		return this;
	}

	toString() {
		return `[${this.x}, ${this.y}]`;
	}

	static angleRad(lhs, rhs) {
		return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
	}

}

Vec2.ZERO = Object.freeze(new Vec2(0, 0));
Vec2.ONE = Object.freeze(new Vec2(1, 1));
Vec2.UP = Object.freeze(new Vec2(0, 1));
Vec2.DOWN = Object.freeze(new Vec2(0, -1));
Vec2.RIGHT = Object.freeze(new Vec2(1, 0));
Vec2.LEFT = Object.freeze(new Vec2(-1, 0));

class Vec4 {
	constructor(x = 0, y = 0, z = 0, w = 0) {
		if (x.length === 4) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
			this.w = x[3];
		} else {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
	}

	add(rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		this.z += rhs.z;
		this.w += rhs.w;
		return this;
	}

	add2(lhs, rhs) {
		this.x = lhs.x + rhs.x;
		this.y = lhs.y + rhs.y;
		this.z = lhs.z + rhs.z;
		this.w = lhs.w + rhs.w;
		return this;
	}

	addScalar(scalar) {
		this.x += scalar;
		this.y += scalar;
		this.z += scalar;
		this.w += scalar;
		return this;
	}

	clone() {
		return new Vec4(this.x, this.y, this.z, this.w);
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		this.w = rhs.w;
		return this;
	}

	div(rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		this.z /= rhs.z;
		this.w /= rhs.w;
		return this;
	}

	div2(lhs, rhs) {
		this.x = lhs.x / rhs.x;
		this.y = lhs.y / rhs.y;
		this.z = lhs.z / rhs.z;
		this.w = lhs.w / rhs.w;
		return this;
	}

	divScalar(scalar) {
		this.x /= scalar;
		this.y /= scalar;
		this.z /= scalar;
		this.w /= scalar;
		return this;
	}

	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}

	lerp(lhs, rhs, alpha) {
		this.x = lhs.x + alpha * (rhs.x - lhs.x);
		this.y = lhs.y + alpha * (rhs.y - lhs.y);
		this.z = lhs.z + alpha * (rhs.z - lhs.z);
		this.w = lhs.w + alpha * (rhs.w - lhs.w);
		return this;
	}

	mul(rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		this.z *= rhs.z;
		this.w *= rhs.w;
		return this;
	}

	mul2(lhs, rhs) {
		this.x = lhs.x * rhs.x;
		this.y = lhs.y * rhs.y;
		this.z = lhs.z * rhs.z;
		this.w = lhs.w * rhs.w;
		return this;
	}

	mulScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;
		return this;
	}

	normalize() {
		const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		if (lengthSq > 0) {
			const invLength = 1 / Math.sqrt(lengthSq);
			this.x *= invLength;
			this.y *= invLength;
			this.z *= invLength;
			this.w *= invLength;
		}

		return this;
	}

	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		this.w = Math.floor(this.w);
		return this;
	}

	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		this.w = Math.ceil(this.w);
		return this;
	}

	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		this.w = Math.round(this.w);
		return this;
	}

	min(rhs) {
		if (rhs.x < this.x) this.x = rhs.x;
		if (rhs.y < this.y) this.y = rhs.y;
		if (rhs.z < this.z) this.z = rhs.z;
		if (rhs.w < this.w) this.w = rhs.w;
		return this;
	}

	max(rhs) {
		if (rhs.x > this.x) this.x = rhs.x;
		if (rhs.y > this.y) this.y = rhs.y;
		if (rhs.z > this.z) this.z = rhs.z;
		if (rhs.w > this.w) this.w = rhs.w;
		return this;
	}

	set(x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}

	sub(rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;
		this.w -= rhs.w;
		return this;
	}

	sub2(lhs, rhs) {
		this.x = lhs.x - rhs.x;
		this.y = lhs.y - rhs.y;
		this.z = lhs.z - rhs.z;
		this.w = lhs.w - rhs.w;
		return this;
	}

	subScalar(scalar) {
		this.x -= scalar;
		this.y -= scalar;
		this.z -= scalar;
		this.w -= scalar;
		return this;
	}

	toString() {
		return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
	}

}

Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));

const _halfSize$1 = new Vec2();

const x = new Vec3();
const y = new Vec3();
const z = new Vec3();
const scale = new Vec3();

class Mat4 {
	constructor() {
		const data = new Float32Array(16);
		data[0] = data[5] = data[10] = data[15] = 1;
		this.data = data;
	}

	static _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
		if (fovIsHorizontal) {
			halfSize.x = znear * Math.tan(fov * Math.PI / 360);
			halfSize.y = halfSize.x / aspect;
		} else {
			halfSize.y = znear * Math.tan(fov * Math.PI / 360);
			halfSize.x = halfSize.y * aspect;
		}
	}

	add2(lhs, rhs) {
		const a = lhs.data,
					b = rhs.data,
					r = this.data;
		r[0] = a[0] + b[0];
		r[1] = a[1] + b[1];
		r[2] = a[2] + b[2];
		r[3] = a[3] + b[3];
		r[4] = a[4] + b[4];
		r[5] = a[5] + b[5];
		r[6] = a[6] + b[6];
		r[7] = a[7] + b[7];
		r[8] = a[8] + b[8];
		r[9] = a[9] + b[9];
		r[10] = a[10] + b[10];
		r[11] = a[11] + b[11];
		r[12] = a[12] + b[12];
		r[13] = a[13] + b[13];
		r[14] = a[14] + b[14];
		r[15] = a[15] + b[15];
		return this;
	}

	add(rhs) {
		return this.add2(this, rhs);
	}

	clone() {
		return new Mat4().copy(this);
	}

	copy(rhs) {
		const src = rhs.data,
					dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		dst[9] = src[9];
		dst[10] = src[10];
		dst[11] = src[11];
		dst[12] = src[12];
		dst[13] = src[13];
		dst[14] = src[14];
		dst[15] = src[15];
		return this;
	}

	equals(rhs) {
		const l = this.data,
					r = rhs.data;
		return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
	}

	isIdentity() {
		const m = this.data;
		return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
	}

	mul2(lhs, rhs) {
		const a = lhs.data;
		const b = rhs.data;
		const r = this.data;
		const a00 = a[0];
		const a01 = a[1];
		const a02 = a[2];
		const a03 = a[3];
		const a10 = a[4];
		const a11 = a[5];
		const a12 = a[6];
		const a13 = a[7];
		const a20 = a[8];
		const a21 = a[9];
		const a22 = a[10];
		const a23 = a[11];
		const a30 = a[12];
		const a31 = a[13];
		const a32 = a[14];
		const a33 = a[15];
		let b0, b1, b2, b3;
		b0 = b[0];
		b1 = b[1];
		b2 = b[2];
		b3 = b[3];
		r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		b0 = b[4];
		b1 = b[5];
		b2 = b[6];
		b3 = b[7];
		r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		b0 = b[8];
		b1 = b[9];
		b2 = b[10];
		b3 = b[11];
		r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		b0 = b[12];
		b1 = b[13];
		b2 = b[14];
		b3 = b[15];
		r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		return this;
	}

	mulAffine2(lhs, rhs) {
		const a = lhs.data;
		const b = rhs.data;
		const r = this.data;
		const a00 = a[0];
		const a01 = a[1];
		const a02 = a[2];
		const a10 = a[4];
		const a11 = a[5];
		const a12 = a[6];
		const a20 = a[8];
		const a21 = a[9];
		const a22 = a[10];
		const a30 = a[12];
		const a31 = a[13];
		const a32 = a[14];
		let b0, b1, b2;
		b0 = b[0];
		b1 = b[1];
		b2 = b[2];
		r[0] = a00 * b0 + a10 * b1 + a20 * b2;
		r[1] = a01 * b0 + a11 * b1 + a21 * b2;
		r[2] = a02 * b0 + a12 * b1 + a22 * b2;
		r[3] = 0;
		b0 = b[4];
		b1 = b[5];
		b2 = b[6];
		r[4] = a00 * b0 + a10 * b1 + a20 * b2;
		r[5] = a01 * b0 + a11 * b1 + a21 * b2;
		r[6] = a02 * b0 + a12 * b1 + a22 * b2;
		r[7] = 0;
		b0 = b[8];
		b1 = b[9];
		b2 = b[10];
		r[8] = a00 * b0 + a10 * b1 + a20 * b2;
		r[9] = a01 * b0 + a11 * b1 + a21 * b2;
		r[10] = a02 * b0 + a12 * b1 + a22 * b2;
		r[11] = 0;
		b0 = b[12];
		b1 = b[13];
		b2 = b[14];
		r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
		r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
		r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
		r[15] = 1;
		return this;
	}

	mul(rhs) {
		return this.mul2(this, rhs);
	}

	transformPoint(vec, res = new Vec3()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
		res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
		res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
		return res;
	}

	transformVector(vec, res = new Vec3()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		res.x = x * m[0] + y * m[4] + z * m[8];
		res.y = x * m[1] + y * m[5] + z * m[9];
		res.z = x * m[2] + y * m[6] + z * m[10];
		return res;
	}

	transformVec4(vec, res = new Vec4()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		const w = vec.w;
		res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
		res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
		res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
		res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
		return res;
	}

	setLookAt(position, target, up) {
		z.sub2(position, target).normalize();
		y.copy(up).normalize();
		x.cross(y, z).normalize();
		y.cross(z, x);
		const r = this.data;
		r[0] = x.x;
		r[1] = x.y;
		r[2] = x.z;
		r[3] = 0;
		r[4] = y.x;
		r[5] = y.y;
		r[6] = y.z;
		r[7] = 0;
		r[8] = z.x;
		r[9] = z.y;
		r[10] = z.z;
		r[11] = 0;
		r[12] = position.x;
		r[13] = position.y;
		r[14] = position.z;
		r[15] = 1;
		return this;
	}

	setFrustum(left, right, bottom, top, znear, zfar) {
		const temp1 = 2 * znear;
		const temp2 = right - left;
		const temp3 = top - bottom;
		const temp4 = zfar - znear;
		const r = this.data;
		r[0] = temp1 / temp2;
		r[1] = 0;
		r[2] = 0;
		r[3] = 0;
		r[4] = 0;
		r[5] = temp1 / temp3;
		r[6] = 0;
		r[7] = 0;
		r[8] = (right + left) / temp2;
		r[9] = (top + bottom) / temp3;
		r[10] = (-zfar - znear) / temp4;
		r[11] = -1;
		r[12] = 0;
		r[13] = 0;
		r[14] = -temp1 * zfar / temp4;
		r[15] = 0;
		return this;
	}

	setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
		Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);

		return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
	}

	setOrtho(left, right, bottom, top, near, far) {
		const r = this.data;
		r[0] = 2 / (right - left);
		r[1] = 0;
		r[2] = 0;
		r[3] = 0;
		r[4] = 0;
		r[5] = 2 / (top - bottom);
		r[6] = 0;
		r[7] = 0;
		r[8] = 0;
		r[9] = 0;
		r[10] = -2 / (far - near);
		r[11] = 0;
		r[12] = -(right + left) / (right - left);
		r[13] = -(top + bottom) / (top - bottom);
		r[14] = -(far + near) / (far - near);
		r[15] = 1;
		return this;
	}

	setFromAxisAngle(axis, angle) {
		angle *= math.DEG_TO_RAD;
		const x = axis.x;
		const y = axis.y;
		const z = axis.z;
		const c = Math.cos(angle);
		const s = Math.sin(angle);
		const t = 1 - c;
		const tx = t * x;
		const ty = t * y;
		const m = this.data;
		m[0] = tx * x + c;
		m[1] = tx * y + s * z;
		m[2] = tx * z - s * y;
		m[3] = 0;
		m[4] = tx * y - s * z;
		m[5] = ty * y + c;
		m[6] = ty * z + s * x;
		m[7] = 0;
		m[8] = tx * z + s * y;
		m[9] = ty * z - x * s;
		m[10] = t * z * z + c;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	setTranslate(x, y, z) {
		const m = this.data;
		m[0] = 1;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = 1;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = 1;
		m[11] = 0;
		m[12] = x;
		m[13] = y;
		m[14] = z;
		m[15] = 1;
		return this;
	}

	setScale(x, y, z) {
		const m = this.data;
		m[0] = x;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = y;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = z;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	setViewport(x, y, width, height) {
		const m = this.data;
		m[0] = width * 0.5;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = height * 0.5;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = 0.5;
		m[11] = 0;
		m[12] = x + width * 0.5;
		m[13] = y + height * 0.5;
		m[14] = 0.5;
		m[15] = 1;
		return this;
	}

	invert() {
		const m = this.data;
		const a00 = m[0];
		const a01 = m[1];
		const a02 = m[2];
		const a03 = m[3];
		const a10 = m[4];
		const a11 = m[5];
		const a12 = m[6];
		const a13 = m[7];
		const a20 = m[8];
		const a21 = m[9];
		const a22 = m[10];
		const a23 = m[11];
		const a30 = m[12];
		const a31 = m[13];
		const a32 = m[14];
		const a33 = m[15];
		const b00 = a00 * a11 - a01 * a10;
		const b01 = a00 * a12 - a02 * a10;
		const b02 = a00 * a13 - a03 * a10;
		const b03 = a01 * a12 - a02 * a11;
		const b04 = a01 * a13 - a03 * a11;
		const b05 = a02 * a13 - a03 * a12;
		const b06 = a20 * a31 - a21 * a30;
		const b07 = a20 * a32 - a22 * a30;
		const b08 = a20 * a33 - a23 * a30;
		const b09 = a21 * a32 - a22 * a31;
		const b10 = a21 * a33 - a23 * a31;
		const b11 = a22 * a33 - a23 * a32;
		const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		if (det === 0) {
			this.setIdentity();
		} else {
			const invDet = 1 / det;
			m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
			m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
			m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
			m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
			m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
			m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
			m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
			m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
			m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
			m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
			m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
			m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
			m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
			m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
			m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
			m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
		}

		return this;
	}

	set(src) {
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		dst[9] = src[9];
		dst[10] = src[10];
		dst[11] = src[11];
		dst[12] = src[12];
		dst[13] = src[13];
		dst[14] = src[14];
		dst[15] = src[15];
		return this;
	}

	setIdentity() {
		const m = this.data;
		m[0] = 1;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = 1;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = 1;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	setTRS(t, r, s) {
		const qx = r.x;
		const qy = r.y;
		const qz = r.z;
		const qw = r.w;
		const sx = s.x;
		const sy = s.y;
		const sz = s.z;
		const x2 = qx + qx;
		const y2 = qy + qy;
		const z2 = qz + qz;
		const xx = qx * x2;
		const xy = qx * y2;
		const xz = qx * z2;
		const yy = qy * y2;
		const yz = qy * z2;
		const zz = qz * z2;
		const wx = qw * x2;
		const wy = qw * y2;
		const wz = qw * z2;
		const m = this.data;
		m[0] = (1 - (yy + zz)) * sx;
		m[1] = (xy + wz) * sx;
		m[2] = (xz - wy) * sx;
		m[3] = 0;
		m[4] = (xy - wz) * sy;
		m[5] = (1 - (xx + zz)) * sy;
		m[6] = (yz + wx) * sy;
		m[7] = 0;
		m[8] = (xz + wy) * sz;
		m[9] = (yz - wx) * sz;
		m[10] = (1 - (xx + yy)) * sz;
		m[11] = 0;
		m[12] = t.x;
		m[13] = t.y;
		m[14] = t.z;
		m[15] = 1;
		return this;
	}

	transpose() {
		let tmp;
		const m = this.data;
		tmp = m[1];
		m[1] = m[4];
		m[4] = tmp;
		tmp = m[2];
		m[2] = m[8];
		m[8] = tmp;
		tmp = m[3];
		m[3] = m[12];
		m[12] = tmp;
		tmp = m[6];
		m[6] = m[9];
		m[9] = tmp;
		tmp = m[7];
		m[7] = m[13];
		m[13] = tmp;
		tmp = m[11];
		m[11] = m[14];
		m[14] = tmp;
		return this;
	}

	invertTo3x3(res) {
		const m = this.data;
		const r = res.data;
		const m0 = m[0];
		const m1 = m[1];
		const m2 = m[2];
		const m4 = m[4];
		const m5 = m[5];
		const m6 = m[6];
		const m8 = m[8];
		const m9 = m[9];
		const m10 = m[10];
		const a11 = m10 * m5 - m6 * m9;
		const a21 = -m10 * m1 + m2 * m9;
		const a31 = m6 * m1 - m2 * m5;
		const a12 = -m10 * m4 + m6 * m8;
		const a22 = m10 * m0 - m2 * m8;
		const a32 = -m6 * m0 + m2 * m4;
		const a13 = m9 * m4 - m5 * m8;
		const a23 = -m9 * m0 + m1 * m8;
		const a33 = m5 * m0 - m1 * m4;
		const det = m0 * a11 + m1 * a12 + m2 * a13;

		if (det === 0) {
			return this;
		}

		const idet = 1 / det;
		r[0] = idet * a11;
		r[1] = idet * a21;
		r[2] = idet * a31;
		r[3] = idet * a12;
		r[4] = idet * a22;
		r[5] = idet * a32;
		r[6] = idet * a13;
		r[7] = idet * a23;
		r[8] = idet * a33;
		return this;
	}

	getTranslation(t = new Vec3()) {
		return t.set(this.data[12], this.data[13], this.data[14]);
	}

	getX(x = new Vec3()) {
		return x.set(this.data[0], this.data[1], this.data[2]);
	}

	getY(y = new Vec3()) {
		return y.set(this.data[4], this.data[5], this.data[6]);
	}

	getZ(z = new Vec3()) {
		return z.set(this.data[8], this.data[9], this.data[10]);
	}

	getScale(scale = new Vec3()) {
		this.getX(x);
		this.getY(y);
		this.getZ(z);
		scale.set(x.length(), y.length(), z.length());
		return scale;
	}

	setFromEulerAngles(ex, ey, ez) {
		ex *= math.DEG_TO_RAD;
		ey *= math.DEG_TO_RAD;
		ez *= math.DEG_TO_RAD;
		const s1 = Math.sin(-ex);
		const c1 = Math.cos(-ex);
		const s2 = Math.sin(-ey);
		const c2 = Math.cos(-ey);
		const s3 = Math.sin(-ez);
		const c3 = Math.cos(-ez);
		const m = this.data;
		m[0] = c2 * c3;
		m[1] = -c2 * s3;
		m[2] = s2;
		m[3] = 0;
		m[4] = c1 * s3 + c3 * s1 * s2;
		m[5] = c1 * c3 - s1 * s2 * s3;
		m[6] = -c2 * s1;
		m[7] = 0;
		m[8] = s1 * s3 - c1 * c3 * s2;
		m[9] = c3 * s1 + c1 * s2 * s3;
		m[10] = c1 * c2;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	getEulerAngles(eulers = new Vec3()) {
		this.getScale(scale);
		const sx = scale.x;
		const sy = scale.y;
		const sz = scale.z;
		if (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);
		const m = this.data;
		const y = Math.asin(-m[2] / sx);
		const halfPi = Math.PI * 0.5;
		let x, z;

		if (y < halfPi) {
			if (y > -halfPi) {
				x = Math.atan2(m[6] / sy, m[10] / sz);
				z = Math.atan2(m[1] / sx, m[0] / sx);
			} else {
				z = 0;
				x = -Math.atan2(m[4] / sy, m[5] / sy);
			}
		} else {
			z = 0;
			x = Math.atan2(m[4] / sy, m[5] / sy);
		}

		return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
	}

	toString() {
		let t = '[';

		for (let i = 0; i < 16; i += 1) {
			t += this.data[i];
			t += i !== 15 ? ', ' : '';
		}

		t += ']';
		return t;
	}

}

Mat4.IDENTITY = Object.freeze(new Mat4());
Mat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));

class Quat {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		if (x.length === 4) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
			this.w = x[3];
		} else {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
	}

	clone() {
		return new Quat(this.x, this.y, this.z, this.w);
	}

	conjugate() {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;
		return this;
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		this.w = rhs.w;
		return this;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
	}

	getAxisAngle(axis) {
		let rad = Math.acos(this.w) * 2;
		const s = Math.sin(rad / 2);

		if (s !== 0) {
			axis.x = this.x / s;
			axis.y = this.y / s;
			axis.z = this.z / s;

			if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
				axis.x *= -1;
				axis.y *= -1;
				axis.z *= -1;
				rad *= -1;
			}
		} else {
			axis.x = 1;
			axis.y = 0;
			axis.z = 0;
		}

		return rad * math.RAD_TO_DEG;
	}

	getEulerAngles(eulers = new Vec3()) {
		let x, y, z;
		const qx = this.x;
		const qy = this.y;
		const qz = this.z;
		const qw = this.w;
		const a2 = 2 * (qw * qy - qx * qz);

		if (a2 <= -0.99999) {
			x = 2 * Math.atan2(qx, qw);
			y = -Math.PI / 2;
			z = 0;
		} else if (a2 >= 0.99999) {
			x = 2 * Math.atan2(qx, qw);
			y = Math.PI / 2;
			z = 0;
		} else {
			x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
			y = Math.asin(a2);
			z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
		}

		return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
	}

	invert() {
		return this.conjugate().normalize();
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}

	mul(rhs) {
		const q1x = this.x;
		const q1y = this.y;
		const q1z = this.z;
		const q1w = this.w;
		const q2x = rhs.x;
		const q2y = rhs.y;
		const q2z = rhs.z;
		const q2w = rhs.w;
		this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
		this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
		this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
		this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
		return this;
	}

	mul2(lhs, rhs) {
		const q1x = lhs.x;
		const q1y = lhs.y;
		const q1z = lhs.z;
		const q1w = lhs.w;
		const q2x = rhs.x;
		const q2y = rhs.y;
		const q2z = rhs.z;
		const q2w = rhs.w;
		this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
		this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
		this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
		this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
		return this;
	}

	normalize() {
		let len = this.length();

		if (len === 0) {
			this.x = this.y = this.z = 0;
			this.w = 1;
		} else {
			len = 1 / len;
			this.x *= len;
			this.y *= len;
			this.z *= len;
			this.w *= len;
		}

		return this;
	}

	set(x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}

	setFromAxisAngle(axis, angle) {
		angle *= 0.5 * math.DEG_TO_RAD;
		const sa = Math.sin(angle);
		const ca = Math.cos(angle);
		this.x = sa * axis.x;
		this.y = sa * axis.y;
		this.z = sa * axis.z;
		this.w = ca;
		return this;
	}

	setFromEulerAngles(ex, ey, ez) {
		const halfToRad = 0.5 * math.DEG_TO_RAD;
		ex *= halfToRad;
		ey *= halfToRad;
		ez *= halfToRad;
		const sx = Math.sin(ex);
		const cx = Math.cos(ex);
		const sy = Math.sin(ey);
		const cy = Math.cos(ey);
		const sz = Math.sin(ez);
		const cz = Math.cos(ez);
		this.x = sx * cy * cz - cx * sy * sz;
		this.y = cx * sy * cz + sx * cy * sz;
		this.z = cx * cy * sz - sx * sy * cz;
		this.w = cx * cy * cz + sx * sy * sz;
		return this;
	}

	setFromMat4(m) {
		let m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;
		m = m.data;
		m00 = m[0];
		m01 = m[1];
		m02 = m[2];
		m10 = m[4];
		m11 = m[5];
		m12 = m[6];
		m20 = m[8];
		m21 = m[9];
		m22 = m[10];
		lx = m00 * m00 + m01 * m01 + m02 * m02;
		if (lx === 0) return this;
		lx = 1 / Math.sqrt(lx);
		ly = m10 * m10 + m11 * m11 + m12 * m12;
		if (ly === 0) return this;
		ly = 1 / Math.sqrt(ly);
		lz = m20 * m20 + m21 * m21 + m22 * m22;
		if (lz === 0) return this;
		lz = 1 / Math.sqrt(lz);
		m00 *= lx;
		m01 *= lx;
		m02 *= lx;
		m10 *= ly;
		m11 *= ly;
		m12 *= ly;
		m20 *= lz;
		m21 *= lz;
		m22 *= lz;
		const tr = m00 + m11 + m22;

		if (tr >= 0) {
			s = Math.sqrt(tr + 1);
			this.w = s * 0.5;
			s = 0.5 / s;
			this.x = (m12 - m21) * s;
			this.y = (m20 - m02) * s;
			this.z = (m01 - m10) * s;
		} else {
			if (m00 > m11) {
				if (m00 > m22) {
					rs = m00 - (m11 + m22) + 1;
					rs = Math.sqrt(rs);
					this.x = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m12 - m21) * rs;
					this.y = (m01 + m10) * rs;
					this.z = (m02 + m20) * rs;
				} else {
					rs = m22 - (m00 + m11) + 1;
					rs = Math.sqrt(rs);
					this.z = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m01 - m10) * rs;
					this.x = (m20 + m02) * rs;
					this.y = (m21 + m12) * rs;
				}
			} else if (m11 > m22) {
				rs = m11 - (m22 + m00) + 1;
				rs = Math.sqrt(rs);
				this.y = rs * 0.5;
				rs = 0.5 / rs;
				this.w = (m20 - m02) * rs;
				this.z = (m12 + m21) * rs;
				this.x = (m10 + m01) * rs;
			} else {
				rs = m22 - (m00 + m11) + 1;
				rs = Math.sqrt(rs);
				this.z = rs * 0.5;
				rs = 0.5 / rs;
				this.w = (m01 - m10) * rs;
				this.x = (m20 + m02) * rs;
				this.y = (m21 + m12) * rs;
			}
		}

		return this;
	}

	slerp(lhs, rhs, alpha) {
		const lx = lhs.x;
		const ly = lhs.y;
		const lz = lhs.z;
		const lw = lhs.w;
		let rx = rhs.x;
		let ry = rhs.y;
		let rz = rhs.z;
		let rw = rhs.w;
		let cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;

		if (cosHalfTheta < 0) {
			rw = -rw;
			rx = -rx;
			ry = -ry;
			rz = -rz;
			cosHalfTheta = -cosHalfTheta;
		}

		if (Math.abs(cosHalfTheta) >= 1) {
			this.w = lw;
			this.x = lx;
			this.y = ly;
			this.z = lz;
			return this;
		}

		const halfTheta = Math.acos(cosHalfTheta);
		const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);

		if (Math.abs(sinHalfTheta) < 0.001) {
			this.w = lw * 0.5 + rw * 0.5;
			this.x = lx * 0.5 + rx * 0.5;
			this.y = ly * 0.5 + ry * 0.5;
			this.z = lz * 0.5 + rz * 0.5;
			return this;
		}

		const ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
		const ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
		this.w = lw * ratioA + rw * ratioB;
		this.x = lx * ratioA + rx * ratioB;
		this.y = ly * ratioA + ry * ratioB;
		this.z = lz * ratioA + rz * ratioB;
		return this;
	}

	transformVector(vec, res = new Vec3()) {
		const x = vec.x,
					y = vec.y,
					z = vec.z;
		const qx = this.x,
					qy = this.y,
					qz = this.z,
					qw = this.w;
		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = -qx * x - qy * y - qz * z;
		res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		return res;
	}

	toString() {
		return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
	}

}

Quat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));
Quat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));

const tmpVecA$2 = new Vec3();
const tmpVecB$1 = new Vec3();
const tmpVecC = new Vec3();
const tmpVecD = new Vec3();
const tmpVecE = new Vec3();

class BoundingBox {
	constructor(center = new Vec3(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {
		this.center = center;
		this.halfExtents = halfExtents;
		this._min = new Vec3();
		this._max = new Vec3();
	}

	add(other) {
		const tc = this.center;
		const tcx = tc.x;
		const tcy = tc.y;
		const tcz = tc.z;
		const th = this.halfExtents;
		const thx = th.x;
		const thy = th.y;
		const thz = th.z;
		let tminx = tcx - thx;
		let tmaxx = tcx + thx;
		let tminy = tcy - thy;
		let tmaxy = tcy + thy;
		let tminz = tcz - thz;
		let tmaxz = tcz + thz;
		const oc = other.center;
		const ocx = oc.x;
		const ocy = oc.y;
		const ocz = oc.z;
		const oh = other.halfExtents;
		const ohx = oh.x;
		const ohy = oh.y;
		const ohz = oh.z;
		const ominx = ocx - ohx;
		const omaxx = ocx + ohx;
		const ominy = ocy - ohy;
		const omaxy = ocy + ohy;
		const ominz = ocz - ohz;
		const omaxz = ocz + ohz;
		if (ominx < tminx) tminx = ominx;
		if (omaxx > tmaxx) tmaxx = omaxx;
		if (ominy < tminy) tminy = ominy;
		if (omaxy > tmaxy) tmaxy = omaxy;
		if (ominz < tminz) tminz = ominz;
		if (omaxz > tmaxz) tmaxz = omaxz;
		tc.x = (tminx + tmaxx) * 0.5;
		tc.y = (tminy + tmaxy) * 0.5;
		tc.z = (tminz + tmaxz) * 0.5;
		th.x = (tmaxx - tminx) * 0.5;
		th.y = (tmaxy - tminy) * 0.5;
		th.z = (tmaxz - tminz) * 0.5;
	}

	copy(src) {
		this.center.copy(src.center);
		this.halfExtents.copy(src.halfExtents);
	}

	clone() {
		return new BoundingBox(this.center.clone(), this.halfExtents.clone());
	}

	intersects(other) {
		const aMax = this.getMax();
		const aMin = this.getMin();
		const bMax = other.getMax();
		const bMin = other.getMin();
		return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
	}

	_intersectsRay(ray, point) {
		const tMin = tmpVecA$2.copy(this.getMin()).sub(ray.origin);
		const tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
		const dir = ray.direction;

		if (dir.x === 0) {
			tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
		} else {
			tMin.x /= dir.x;
			tMax.x /= dir.x;
		}

		if (dir.y === 0) {
			tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
		} else {
			tMin.y /= dir.y;
			tMax.y /= dir.y;
		}

		if (dir.z === 0) {
			tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
		} else {
			tMin.z /= dir.z;
			tMax.z /= dir.z;
		}

		const realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
		const realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
		const minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
		const maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
		const intersects = minMax >= maxMin && maxMin >= 0;
		if (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
		return intersects;
	}

	_fastIntersectsRay(ray) {
		const diff = tmpVecA$2;
		const cross = tmpVecB$1;
		const prod = tmpVecC;
		const absDiff = tmpVecD;
		const absDir = tmpVecE;
		const rayDir = ray.direction;
		diff.sub2(ray.origin, this.center);
		absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
		prod.mul2(diff, rayDir);
		if (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;
		if (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;
		if (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;
		absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
		cross.cross(rayDir, diff);
		cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
		if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;
		if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;
		if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;
		return true;
	}

	intersectsRay(ray, point) {
		if (point) {
			return this._intersectsRay(ray, point);
		}

		return this._fastIntersectsRay(ray);
	}

	setMinMax(min, max) {
		this.center.add2(max, min).mulScalar(0.5);
		this.halfExtents.sub2(max, min).mulScalar(0.5);
	}

	getMin() {
		return this._min.copy(this.center).sub(this.halfExtents);
	}

	getMax() {
		return this._max.copy(this.center).add(this.halfExtents);
	}

	containsPoint(point) {
		const min = this.getMin();
		const max = this.getMax();

		if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
			return false;
		}

		return true;
	}

	setFromTransformedAabb(aabb, m, ignoreScale = false) {
		const ac = aabb.center;
		const ar = aabb.halfExtents;
		const d = m.data;
		let mx0 = d[0];
		let mx1 = d[4];
		let mx2 = d[8];
		let my0 = d[1];
		let my1 = d[5];
		let my2 = d[9];
		let mz0 = d[2];
		let mz1 = d[6];
		let mz2 = d[10];

		if (ignoreScale) {
			let lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;

			if (lengthSq > 0) {
				const invLength = 1 / Math.sqrt(lengthSq);
				mx0 *= invLength;
				mx1 *= invLength;
				mx2 *= invLength;
			}

			lengthSq = my0 * my0 + my1 * my1 + my2 * my2;

			if (lengthSq > 0) {
				const invLength = 1 / Math.sqrt(lengthSq);
				my0 *= invLength;
				my1 *= invLength;
				my2 *= invLength;
			}

			lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;

			if (lengthSq > 0) {
				const invLength = 1 / Math.sqrt(lengthSq);
				mz0 *= invLength;
				mz1 *= invLength;
				mz2 *= invLength;
			}
		}

		this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
		this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
	}

	compute(vertices, numVerts) {
		numVerts = numVerts === undefined ? vertices.length / 3 : numVerts;

		if (numVerts > 0) {
			const min = tmpVecA$2.set(vertices[0], vertices[1], vertices[2]);
			const max = tmpVecB$1.set(vertices[0], vertices[1], vertices[2]);

			for (let i = 1; i < numVerts; i++) {
				const x = vertices[i * 3 + 0];
				const y = vertices[i * 3 + 1];
				const z = vertices[i * 3 + 2];
				if (x < min.x) min.x = x;
				if (y < min.y) min.y = y;
				if (z < min.z) min.z = z;
				if (x > max.x) max.x = x;
				if (y > max.y) max.y = y;
				if (z > max.z) max.z = z;
			}

			this.setMinMax(min, max);
		}
	}

	intersectsBoundingSphere(sphere) {
		const sq = this._distanceToBoundingSphereSq(sphere);

		if (sq <= sphere.radius * sphere.radius) {
			return true;
		}

		return false;
	}

	_distanceToBoundingSphereSq(sphere) {
		const boxMin = this.getMin();
		const boxMax = this.getMax();
		let sq = 0;
		const axis = ['x', 'y', 'z'];

		for (let i = 0; i < 3; ++i) {
			let out = 0;
			const pn = sphere.center[axis[i]];
			const bMin = boxMin[axis[i]];
			const bMax = boxMax[axis[i]];
			let val = 0;

			if (pn < bMin) {
				val = bMin - pn;
				out += val * val;
			}

			if (pn > bMax) {
				val = pn - bMax;
				out += val * val;
			}

			sq += out;
		}

		return sq;
	}

	_expand(expandMin, expandMax) {
		tmpVecA$2.add2(this.getMin(), expandMin);
		tmpVecB$1.add2(this.getMax(), expandMax);
		this.setMinMax(tmpVecA$2, tmpVecB$1);
	}

}

const tmpVecA$1 = new Vec3();
const tmpVecB = new Vec3();

class BoundingSphere {
	constructor(center = new Vec3(), radius = 0.5) {
		this.center = center;
		this.radius = radius;
	}

	containsPoint(point) {
		const lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();
		const r = this.radius;
		return lenSq < r * r;
	}

	intersectsRay(ray, point) {
		const m = tmpVecA$1.copy(ray.origin).sub(this.center);
		const b = m.dot(tmpVecB.copy(ray.direction).normalize());
		const c = m.dot(m) - this.radius * this.radius;
		if (c > 0 && b > 0) return false;
		const discr = b * b - c;
		if (discr < 0) return false;
		const t = Math.abs(-b - Math.sqrt(discr));
		if (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
		return true;
	}

	intersectsBoundingSphere(sphere) {
		tmpVecA$1.sub2(sphere.center, this.center);
		const totalRadius = sphere.radius + this.radius;

		if (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {
			return true;
		}

		return false;
	}

}

const BLEND_SUBTRACTIVE = 0;
const BLEND_ADDITIVE = 1;
const BLEND_NORMAL = 2;
const BLEND_NONE = 3;
const BLEND_PREMULTIPLIED = 4;
const BLEND_MULTIPLICATIVE = 5;
const BLEND_ADDITIVEALPHA = 6;
const BLEND_MULTIPLICATIVE2X = 7;
const BLEND_SCREEN = 8;
const BLEND_MIN = 9;
const BLEND_MAX = 10;
const FOG_NONE = 'none';
const FOG_LINEAR = 'linear';
const FRESNEL_SCHLICK = 2;
const LAYER_HUD = 0;
const LAYER_FX = 2;
const LAYER_WORLD = 15;
const LAYERID_WORLD = 0;
const LAYERID_DEPTH = 1;
const LAYERID_SKYBOX = 2;
const LAYERID_IMMEDIATE = 3;
const LAYERID_UI = 4;
const LIGHTTYPE_DIRECTIONAL = 0;
const LIGHTTYPE_OMNI = 1;
const LIGHTTYPE_SPOT = 2;
const LIGHTSHAPE_PUNCTUAL = 0;
const LIGHTSHAPE_RECT = 1;
const LIGHTSHAPE_DISK = 2;
const LIGHTSHAPE_SPHERE = 3;
const LIGHTFALLOFF_LINEAR = 0;
const LIGHTFALLOFF_INVERSESQUARED = 1;
const SHADOW_PCF3 = 0;
const SHADOW_VSM8 = 1;
const SHADOW_VSM16 = 2;
const SHADOW_VSM32 = 3;
const SHADOW_PCF5 = 4;
const SHADOW_PCF1 = 5;
const SHADOW_COUNT = 6;
const shadowTypeToString = {};
shadowTypeToString[SHADOW_PCF3] = "PCF3";
shadowTypeToString[SHADOW_VSM8] = "VSM8";
shadowTypeToString[SHADOW_VSM16] = "VSM16";
shadowTypeToString[SHADOW_VSM32] = "VSM32";
shadowTypeToString[SHADOW_PCF5] = "PCF5";
shadowTypeToString[SHADOW_PCF1] = "PCF1";
const BLUR_GAUSSIAN = 1;
const PARTICLESORT_NONE = 0;
const PARTICLEMODE_GPU = 0;
const EMITTERSHAPE_BOX = 0;
const EMITTERSHAPE_SPHERE = 1;
const PARTICLEORIENTATION_SCREEN = 0;
const PARTICLEORIENTATION_WORLD = 1;
const PROJECTION_PERSPECTIVE = 0;
const PROJECTION_ORTHOGRAPHIC = 1;
const RENDERSTYLE_SOLID = 0;
const RENDERSTYLE_WIREFRAME = 1;
const RENDERSTYLE_POINTS = 2;
const CUBEPROJ_NONE = 0;
const CUBEPROJ_BOX = 1;
const SPECULAR_PHONG = 0;
const SPECULAR_BLINN = 1;
const DETAILMODE_MUL = 'mul';
const GAMMA_NONE = 0;
const GAMMA_SRGB = 1;
const GAMMA_SRGBFAST = 2;
const GAMMA_SRGBHDR = 3;
const TONEMAP_LINEAR = 0;
const TONEMAP_FILMIC = 1;
const TONEMAP_HEJL = 2;
const TONEMAP_ACES = 3;
const TONEMAP_ACES2 = 4;
const SPECOCC_NONE = 0;
const SPECOCC_AO = 1;
const SPECOCC_GLOSSDEPENDENT = 2;
const SHADERDEF_NOSHADOW = 1;
const SHADERDEF_SKIN = 2;
const SHADERDEF_UV0 = 4;
const SHADERDEF_UV1 = 8;
const SHADERDEF_VCOLOR = 16;
const SHADERDEF_INSTANCING = 32;
const SHADERDEF_LM = 64;
const SHADERDEF_DIRLM = 128;
const SHADERDEF_SCREENSPACE = 256;
const SHADERDEF_TANGENTS = 512;
const SHADERDEF_MORPH_POSITION = 1024;
const SHADERDEF_MORPH_NORMAL = 2048;
const SHADERDEF_MORPH_TEXTURE_BASED = 4096;
const SHADERDEF_LMAMBIENT = 8192;
const LINEBATCH_OVERLAY = 1;
const SHADOWUPDATE_NONE = 0;
const SHADOWUPDATE_THISFRAME = 1;
const SHADOWUPDATE_REALTIME = 2;
const SORTKEY_FORWARD = 0;
const SORTKEY_DEPTH = 1;
const MASK_AFFECT_DYNAMIC = 1;
const MASK_AFFECT_LIGHTMAPPED = 2;
const MASK_BAKE = 4;
const SHADER_FORWARD = 0;
const SHADER_FORWARDHDR = 1;
const SHADER_DEPTH = 2;
const SHADER_SHADOW = 3;
const SHADER_PICK = 18;
const SPRITE_RENDERMODE_SIMPLE = 0;
const SPRITE_RENDERMODE_SLICED = 1;
const SPRITE_RENDERMODE_TILED = 2;
const BAKE_COLORDIR = 1;
const VIEW_CENTER = 0;
const VIEW_LEFT = 1;
const VIEW_RIGHT = 2;
const SORTMODE_NONE = 0;
const SORTMODE_MANUAL = 1;
const SORTMODE_MATERIALMESH = 2;
const SORTMODE_BACK2FRONT = 3;
const SORTMODE_FRONT2BACK = 4;
const SORTMODE_CUSTOM = 5;
const COMPUPDATED_INSTANCES = 1;
const COMPUPDATED_LIGHTS = 2;
const COMPUPDATED_CAMERAS = 4;
const COMPUPDATED_BLEND = 8;
const ASPECT_AUTO = 0;
const ASPECT_MANUAL = 1;
const ORIENTATION_HORIZONTAL = 0;
const ORIENTATION_VERTICAL = 1;

const _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

class Frustum {
	constructor() {
		this.planes = [];

		for (let i = 0; i < 6; i++) this.planes[i] = [];
	}

	setFromMat4(matrix) {
		const vpm = matrix.data;
		let plane;
		const planes = this.planes;
		plane = planes[0];
		plane[0] = vpm[3] - vpm[0];
		plane[1] = vpm[7] - vpm[4];
		plane[2] = vpm[11] - vpm[8];
		plane[3] = vpm[15] - vpm[12];
		let t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[1];
		plane[0] = vpm[3] + vpm[0];
		plane[1] = vpm[7] + vpm[4];
		plane[2] = vpm[11] + vpm[8];
		plane[3] = vpm[15] + vpm[12];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[2];
		plane[0] = vpm[3] + vpm[1];
		plane[1] = vpm[7] + vpm[5];
		plane[2] = vpm[11] + vpm[9];
		plane[3] = vpm[15] + vpm[13];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[3];
		plane[0] = vpm[3] - vpm[1];
		plane[1] = vpm[7] - vpm[5];
		plane[2] = vpm[11] - vpm[9];
		plane[3] = vpm[15] - vpm[13];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[4];
		plane[0] = vpm[3] - vpm[2];
		plane[1] = vpm[7] - vpm[6];
		plane[2] = vpm[11] - vpm[10];
		plane[3] = vpm[15] - vpm[14];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[5];
		plane[0] = vpm[3] + vpm[2];
		plane[1] = vpm[7] + vpm[6];
		plane[2] = vpm[11] + vpm[10];
		plane[3] = vpm[15] + vpm[14];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
	}

	containsPoint(point) {
		let p, plane;

		for (p = 0; p < 6; p++) {
			plane = this.planes[p];

			if (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {
				return false;
			}
		}

		return true;
	}

	containsSphere(sphere) {
		let c = 0;
		let d;
		let p;
		const sr = sphere.radius;
		const sc = sphere.center;
		const scx = sc.x;
		const scy = sc.y;
		const scz = sc.z;
		const planes = this.planes;
		let plane;

		for (p = 0; p < 6; p++) {
			plane = planes[p];
			d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
			if (d <= -sr) return 0;
			if (d > sr) c++;
		}

		return c === 6 ? 2 : 1;
	}

	static getPoints(camera, near, far) {
		near = near || camera._nearClip;
		far = far || camera._farClip;
		const fov = camera._fov * Math.PI / 180.0;
		let y = camera._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : camera._orthoHeight;
		let x = y * camera._aspectRatio;
		const points = _frustumPoints;
		points[0].x = x;
		points[0].y = -y;
		points[0].z = -near;
		points[1].x = x;
		points[1].y = y;
		points[1].z = -near;
		points[2].x = -x;
		points[2].y = y;
		points[2].z = -near;
		points[3].x = -x;
		points[3].y = -y;
		points[3].z = -near;

		if (camera._projection === PROJECTION_PERSPECTIVE) {
			y = Math.tan(fov / 2.0) * far;
			x = y * camera._aspectRatio;
		}

		points[4].x = x;
		points[4].y = -y;
		points[4].z = -far;
		points[5].x = x;
		points[5].y = y;
		points[5].z = -far;
		points[6].x = -x;
		points[6].y = y;
		points[6].z = -far;
		points[7].x = -x;
		points[7].y = -y;
		points[7].z = -far;
		return points;
	}

}

class Ray {
	constructor(origin = new Vec3(), direction = new Vec3(0, 0, -1)) {
		this.origin = origin;
		this.direction = direction;
	}

	set(origin, direction) {
		this.origin.copy(origin);
		this.direction.copy(direction);
		return this;
	}

}

new Ray();
new Vec3();
new BoundingSphere();
new Mat4();

new Vec3();

const ADDRESS_REPEAT = 0;
const ADDRESS_CLAMP_TO_EDGE = 1;
const ADDRESS_MIRRORED_REPEAT = 2;
const BLENDMODE_ZERO = 0;
const BLENDMODE_ONE = 1;
const BLENDMODE_SRC_COLOR = 2;
const BLENDMODE_DST_COLOR = 4;
const BLENDMODE_ONE_MINUS_DST_COLOR = 5;
const BLENDMODE_SRC_ALPHA = 6;
const BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
const BLENDEQUATION_ADD = 0;
const BLENDEQUATION_MIN = 3;
const BLENDEQUATION_MAX = 4;
const BUFFER_STATIC = 0;
const BUFFER_DYNAMIC = 1;
const BUFFER_STREAM = 2;
const BUFFER_GPUDYNAMIC = 3;
const CLEARFLAG_COLOR = 1;
const CLEARFLAG_DEPTH = 2;
const CLEARFLAG_STENCIL = 4;
const CULLFACE_NONE = 0;
const CULLFACE_BACK = 1;
const CULLFACE_FRONT = 2;
const CULLFACE_FRONTANDBACK = 3;
const FILTER_NEAREST = 0;
const FILTER_LINEAR = 1;
const FILTER_NEAREST_MIPMAP_NEAREST = 2;
const FILTER_NEAREST_MIPMAP_LINEAR = 3;
const FILTER_LINEAR_MIPMAP_NEAREST = 4;
const FILTER_LINEAR_MIPMAP_LINEAR = 5;
const FUNC_LESS = 1;
const FUNC_EQUAL = 2;
const FUNC_LESSEQUAL = 3;
const FUNC_ALWAYS = 7;
const INDEXFORMAT_UINT8 = 0;
const INDEXFORMAT_UINT16 = 1;
const INDEXFORMAT_UINT32 = 2;
const PIXELFORMAT_A8 = 0;
const PIXELFORMAT_L8 = 1;
const PIXELFORMAT_L8_A8 = 2;
const PIXELFORMAT_R5_G6_B5 = 3;
const PIXELFORMAT_R5_G5_B5_A1 = 4;
const PIXELFORMAT_R4_G4_B4_A4 = 5;
const PIXELFORMAT_R8_G8_B8 = 6;
const PIXELFORMAT_R8_G8_B8_A8 = 7;
const PIXELFORMAT_DXT1 = 8;
const PIXELFORMAT_DXT3 = 9;
const PIXELFORMAT_DXT5 = 10;
const PIXELFORMAT_RGB16F = 11;
const PIXELFORMAT_RGBA16F = 12;
const PIXELFORMAT_RGB32F = 13;
const PIXELFORMAT_RGBA32F = 14;
const PIXELFORMAT_R32F = 15;
const PIXELFORMAT_DEPTH = 16;
const PIXELFORMAT_DEPTHSTENCIL = 17;
const PIXELFORMAT_111110F = 18;
const PIXELFORMAT_SRGB = 19;
const PIXELFORMAT_SRGBA = 20;
const PIXELFORMAT_ETC1 = 21;
const PIXELFORMAT_ETC2_RGB = 22;
const PIXELFORMAT_ETC2_RGBA = 23;
const PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
const PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
const PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
const PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
const PIXELFORMAT_ASTC_4x4 = 28;
const PIXELFORMAT_ATC_RGB = 29;
const PIXELFORMAT_ATC_RGBA = 30;
const PRIMITIVE_POINTS = 0;
const PRIMITIVE_LINES = 1;
const PRIMITIVE_LINELOOP = 2;
const PRIMITIVE_LINESTRIP = 3;
const PRIMITIVE_TRIANGLES = 4;
const PRIMITIVE_TRISTRIP = 5;
const PRIMITIVE_TRIFAN = 6;
const SEMANTIC_POSITION = "POSITION";
const SEMANTIC_NORMAL = "NORMAL";
const SEMANTIC_TANGENT = "TANGENT";
const SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
const SEMANTIC_BLENDINDICES = "BLENDINDICES";
const SEMANTIC_COLOR = "COLOR";
const SEMANTIC_TEXCOORD = "TEXCOORD";
const SEMANTIC_TEXCOORD0 = "TEXCOORD0";
const SEMANTIC_TEXCOORD1 = "TEXCOORD1";
const SEMANTIC_TEXCOORD2 = "TEXCOORD2";
const SEMANTIC_TEXCOORD3 = "TEXCOORD3";
const SEMANTIC_TEXCOORD4 = "TEXCOORD4";
const SEMANTIC_TEXCOORD5 = "TEXCOORD5";
const SEMANTIC_TEXCOORD6 = "TEXCOORD6";
const SEMANTIC_TEXCOORD7 = "TEXCOORD7";
const SEMANTIC_ATTR = "ATTR";
const SEMANTIC_ATTR0 = "ATTR0";
const SEMANTIC_ATTR1 = "ATTR1";
const SEMANTIC_ATTR2 = "ATTR2";
const SEMANTIC_ATTR3 = "ATTR3";
const SEMANTIC_ATTR4 = "ATTR4";
const SEMANTIC_ATTR5 = "ATTR5";
const SEMANTIC_ATTR6 = "ATTR6";
const SEMANTIC_ATTR7 = "ATTR7";
const SEMANTIC_ATTR8 = "ATTR8";
const SEMANTIC_ATTR9 = "ATTR9";
const SEMANTIC_ATTR10 = "ATTR10";
const SEMANTIC_ATTR11 = "ATTR11";
const SEMANTIC_ATTR12 = "ATTR12";
const SEMANTIC_ATTR13 = "ATTR13";
const SEMANTIC_ATTR14 = "ATTR14";
const SEMANTIC_ATTR15 = "ATTR15";
const SHADERTAG_MATERIAL = 1;
const STENCILOP_KEEP = 0;
const STENCILOP_REPLACE = 2;
const STENCILOP_INCREMENT = 3;
const STENCILOP_DECREMENT = 5;
const TEXTURELOCK_WRITE = 2;
const TEXTURETYPE_DEFAULT = 'default';
const TEXTURETYPE_RGBM = 'rgbm';
const TEXTURETYPE_RGBE = 'rgbe';
const TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
const TEXTUREPROJECTION_NONE = "none";
const TEXTUREPROJECTION_CUBE = "cube";
const TEXTUREPROJECTION_EQUIRECT = "equirect";
const TEXTUREPROJECTION_OCTAHEDRAL = "octahedral";
const TYPE_INT8 = 0;
const TYPE_UINT8 = 1;
const TYPE_INT16 = 2;
const TYPE_UINT16 = 3;
const TYPE_INT32 = 4;
const TYPE_UINT32 = 5;
const TYPE_FLOAT32 = 6;
const UNIFORMTYPE_BOOL = 0;
const UNIFORMTYPE_INT = 1;
const UNIFORMTYPE_FLOAT = 2;
const UNIFORMTYPE_VEC2 = 3;
const UNIFORMTYPE_VEC3 = 4;
const UNIFORMTYPE_VEC4 = 5;
const UNIFORMTYPE_IVEC2 = 6;
const UNIFORMTYPE_IVEC3 = 7;
const UNIFORMTYPE_IVEC4 = 8;
const UNIFORMTYPE_BVEC2 = 9;
const UNIFORMTYPE_BVEC3 = 10;
const UNIFORMTYPE_BVEC4 = 11;
const UNIFORMTYPE_MAT2 = 12;
const UNIFORMTYPE_MAT3 = 13;
const UNIFORMTYPE_MAT4 = 14;
const UNIFORMTYPE_TEXTURE2D = 15;
const UNIFORMTYPE_TEXTURECUBE = 16;
const UNIFORMTYPE_FLOATARRAY = 17;
const UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
const UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
const UNIFORMTYPE_TEXTURE3D = 20;
const UNIFORMTYPE_VEC2ARRAY = 21;
const UNIFORMTYPE_VEC3ARRAY = 22;
const UNIFORMTYPE_VEC4ARRAY = 23;
const typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
const typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];
const typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
const semanticToLocation = {};
semanticToLocation[SEMANTIC_POSITION] = 0;
semanticToLocation[SEMANTIC_NORMAL] = 1;
semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
semanticToLocation[SEMANTIC_COLOR] = 4;
semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
semanticToLocation[SEMANTIC_TANGENT] = 13;
semanticToLocation[SEMANTIC_ATTR0] = 0;
semanticToLocation[SEMANTIC_ATTR1] = 1;
semanticToLocation[SEMANTIC_ATTR2] = 2;
semanticToLocation[SEMANTIC_ATTR3] = 3;
semanticToLocation[SEMANTIC_ATTR4] = 4;
semanticToLocation[SEMANTIC_ATTR5] = 5;
semanticToLocation[SEMANTIC_ATTR6] = 6;
semanticToLocation[SEMANTIC_ATTR7] = 7;
semanticToLocation[SEMANTIC_ATTR8] = 8;
semanticToLocation[SEMANTIC_ATTR9] = 9;
semanticToLocation[SEMANTIC_ATTR10] = 10;
semanticToLocation[SEMANTIC_ATTR11] = 11;
semanticToLocation[SEMANTIC_ATTR12] = 12;
semanticToLocation[SEMANTIC_ATTR13] = 13;
semanticToLocation[SEMANTIC_ATTR14] = 14;
semanticToLocation[SEMANTIC_ATTR15] = 15;

let id$3 = 0;

class VertexBuffer {
	constructor(graphicsDevice, format, numVertices, usage = BUFFER_STATIC, initialData) {
		this.device = graphicsDevice;
		this.format = format;
		this.numVertices = numVertices;
		this.usage = usage;
		this.id = id$3++;
		this._vao = null;
		this.instancing = false;
		this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
		graphicsDevice._vram.vb += this.numBytes;

		if (initialData) {
			this.setData(initialData);
		} else {
			this.storage = new ArrayBuffer(this.numBytes);
		}

		this.device.buffers.push(this);
	}

	destroy() {
		const device = this.device;
		const idx = device.buffers.indexOf(this);

		if (idx !== -1) {
			device.buffers.splice(idx, 1);
		}

		if (this.bufferId) {
			const gl = device.gl;
			device.boundVao = null;
			gl.bindVertexArray(null);
			gl.deleteBuffer(this.bufferId);
			device._vram.vb -= this.storage.byteLength;
			this.bufferId = null;
		}
	}

	loseContext() {
		this.bufferId = undefined;
		this._vao = null;
	}

	getFormat() {
		return this.format;
	}

	getUsage() {
		return this.usage;
	}

	getNumVertices() {
		return this.numVertices;
	}

	lock() {
		return this.storage;
	}

	unlock() {
		const gl = this.device.gl;

		if (!this.bufferId) {
			this.bufferId = gl.createBuffer();
		}

		let glUsage;

		switch (this.usage) {
			case BUFFER_STATIC:
				glUsage = gl.STATIC_DRAW;
				break;

			case BUFFER_DYNAMIC:
				glUsage = gl.DYNAMIC_DRAW;
				break;

			case BUFFER_STREAM:
				glUsage = gl.STREAM_DRAW;
				break;

			case BUFFER_GPUDYNAMIC:
				if (this.device.webgl2) {
					glUsage = gl.DYNAMIC_COPY;
				} else {
					glUsage = gl.STATIC_DRAW;
				}

				break;
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferId);
		gl.bufferData(gl.ARRAY_BUFFER, this.storage, glUsage);
	}

	setData(data) {
		if (data.byteLength !== this.numBytes) {
			return false;
		}

		this.storage = data;
		this.unlock();
		return true;
	}

}

function hashCode(str) {
	let hash = 0;

	for (let i = 0, len = str.length; i < len; i++) {
		hash = (hash << 5) - hash + str.charCodeAt(i);
		hash |= 0;
	}

	return hash;
}

class VertexFormat {
	constructor(graphicsDevice, description, vertexCount) {
		this.elements = [];
		this.hasUv0 = false;
		this.hasUv1 = false;
		this.hasColor = false;
		this.hasTangents = false;
		this.verticesByteSize = 0;
		this.vertexCount = vertexCount;
		this.interleaved = vertexCount === undefined;
		this.size = description.reduce((total, desc) => {
			return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
		}, 0);
		let offset = 0,
				elementSize;

		for (let i = 0, len = description.length; i < len; i++) {
			const elementDesc = description[i];
			elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];

			if (vertexCount) {
				offset = math.roundUp(offset, elementSize);
			}

			const element = {
				name: elementDesc.semantic,
				offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
				stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
				dataType: elementDesc.type,
				numComponents: elementDesc.components,
				normalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,
				size: elementSize
			};
			this.elements.push(element);

			if (vertexCount) {
				offset += elementSize * vertexCount;
			} else {
				offset += Math.ceil(elementSize / 4) * 4;
			}

			if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
				this.hasUv0 = true;
			} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
				this.hasUv1 = true;
			} else if (elementDesc.semantic === SEMANTIC_COLOR) {
				this.hasColor = true;
			} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
				this.hasTangents = true;
			}
		}

		if (vertexCount) {
			this.verticesByteSize = offset;
		}

		this.update();
	}

	static init(graphicsDevice) {
		const formatDesc = [{
			semantic: SEMANTIC_ATTR12,
			components: 4,
			type: TYPE_FLOAT32
		}, {
			semantic: SEMANTIC_ATTR13,
			components: 4,
			type: TYPE_FLOAT32
		}, {
			semantic: SEMANTIC_ATTR14,
			components: 4,
			type: TYPE_FLOAT32
		}, {
			semantic: SEMANTIC_ATTR15,
			components: 4,
			type: TYPE_FLOAT32
		}];
		VertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, formatDesc);
	}

	static get defaultInstancingFormat() {
		return VertexFormat._defaultInstancingFormat;
	}

	update() {
		this._evaluateHash();
	}

	_evaluateHash() {
		let stringElementBatch;
		const stringElementsBatch = [];
		let stringElementRender;
		const stringElementsRender = [];
		const len = this.elements.length;

		for (let i = 0; i < len; i++) {
			const element = this.elements[i];
			stringElementBatch = element.name;
			stringElementBatch += element.dataType;
			stringElementBatch += element.numComponents;
			stringElementBatch += element.normalize;
			stringElementsBatch.push(stringElementBatch);
			stringElementRender = stringElementBatch;
			stringElementRender += element.offset;
			stringElementRender += element.stride;
			stringElementRender += element.size;
			stringElementsRender.push(stringElementRender);
		}

		stringElementsBatch.sort();
		this.batchingHash = hashCode(stringElementsBatch.join());
		this.renderingingHash = hashCode(stringElementsRender.join());
	}

}

VertexFormat._defaultInstancingFormat = null;

let _postEffectQuadVB = null;
const _postEffectQuadDraw = {
	type: PRIMITIVE_TRISTRIP,
	base: 0,
	count: 4,
	indexed: false
};

function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend = false) {
	if (_postEffectQuadVB === null) {
		const vertexFormat = new VertexFormat(device, [{
			semantic: SEMANTIC_POSITION,
			components: 2,
			type: TYPE_FLOAT32
		}]);
		const positions = new Float32Array(8);
		positions.set([-1, -1, 1, -1, -1, 1, 1, 1]);
		_postEffectQuadVB = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, positions);
	}

	const oldRt = device.renderTarget;
	device.setRenderTarget(target);
	device.updateBegin();
	let x, y, w, h;
	let sx, sy, sw, sh;

	if (!rect) {
		w = target ? target.width : device.width;
		h = target ? target.height : device.height;
		x = 0;
		y = 0;
	} else {
		x = rect.x;
		y = rect.y;
		w = rect.z;
		h = rect.w;
	}

	if (!scissorRect) {
		sx = x;
		sy = y;
		sw = w;
		sh = h;
	} else {
		sx = scissorRect.x;
		sy = scissorRect.y;
		sw = scissorRect.z;
		sh = scissorRect.w;
	}

	const oldVx = device.vx;
	const oldVy = device.vy;
	const oldVw = device.vw;
	const oldVh = device.vh;
	device.setViewport(x, y, w, h);
	const oldSx = device.sx;
	const oldSy = device.sy;
	const oldSw = device.sw;
	const oldSh = device.sh;
	device.setScissor(sx, sy, sw, sh);
	const oldDepthTest = device.getDepthTest();
	const oldDepthWrite = device.getDepthWrite();
	const oldCullMode = device.getCullMode();
	const oldWR = device.writeRed;
	const oldWG = device.writeGreen;
	const oldWB = device.writeBlue;
	const oldWA = device.writeAlpha;
	device.setDepthTest(false);
	device.setDepthWrite(false);
	device.setCullMode(CULLFACE_NONE);
	device.setColorWrite(true, true, true, true);
	if (!useBlend) device.setBlending(false);
	device.setVertexBuffer(_postEffectQuadVB, 0);
	device.setShader(shader);
	device.draw(_postEffectQuadDraw);
	device.setDepthTest(oldDepthTest);
	device.setDepthWrite(oldDepthWrite);
	device.setCullMode(oldCullMode);
	device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
	device.updateEnd();
	device.setRenderTarget(oldRt);
	device.updateBegin();
	device.setViewport(oldVx, oldVy, oldVw, oldVh);
	device.setScissor(oldSx, oldSy, oldSw, oldSh);
}

function destroyPostEffectQuad() {
	if (_postEffectQuadVB) {
		_postEffectQuadVB.destroy();

		_postEffectQuadVB = null;
	}
}

class Shader {
	constructor(graphicsDevice, definition) {
		this.device = graphicsDevice;
		this.definition = definition;
		this.init();
		this.device.createShader(this);
	}

	init() {
		this.attributes = [];
		this.uniforms = [];
		this.samplers = [];
		this.ready = false;
		this.failed = false;
	}

	destroy() {
		this.device.destroyShader(this);
	}

	loseContext() {
		this.init();
	}

}

var alphaTestPS = "uniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n";

var ambientConstantPS = "void addAmbient() {\n\tdDiffuseLight += light_globalAmbient;\n}\n";

var ambientEnvPS = "#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nvoid addAmbient() {\n\tvec3 dir = cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\tvec4 raw = texture2D(texture_envAtlas, uv);\n\tvec3 linear = $DECODE(raw);\n\tdDiffuseLight += processEnvironment(linear);\n}\n";

var ambientSHPS = "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n\tvec3 n = cubeMapRotate(dNormalW);\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";

var aoPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid applyAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tdAo *= texture2D(texture_aoMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight *= dAo;\n}\n";

var aoSpecOccPS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var aoSpecOccConstPS = "void occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var aoSpecOccConstSimplePS = "void occludeSpecular() {\n\tfloat specOcc = dAo;\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var aoSpecOccSimplePS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var bakeDirLmEndPS = "\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n";

var bakeLmEndPS = "\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n";

var basePS = "uniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n";

var baseVS = "attribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n";

var baseNineSlicedPS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

var baseNineSlicedVS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

var baseNineSlicedTiledPS = "#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

var biasConstPS = "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n";

var blurVSMPS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n";

var clearCoatPS = "#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatMap;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2D(texture_clearCoatMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

var clearCoatGlossPS = "#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n";

var clearCoatNormalPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatNormalMap;\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n\t#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\n\tccNormalW = dTBN * normalMap;\n\t#else\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n}\n";

var clusteredLightUtilsPS = "vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n\tvec3 vAbs = abs(dir);\n\tfloat ma;\n\tvec2 uv;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n\t\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\t\ttileOffset.x = 2.0;\n\t\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\t} else if(vAbs.y >= vAbs.x) {\n\t\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\t\ttileOffset.x = 1.0;\n\t\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\t} else {\n\t\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\t\ttileOffset.x = 0.0;\n\t\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\t}\n\treturn uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\tfloat faceIndex;\n\tvec2 tileOffset;\n\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\tfloat atlasFaceSize = omniAtlasViewport.z;\n\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\n\tfloat offset = shadowEdgePixels / tileSize;\n\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\tuv *= atlasFaceSize;\n\tuv += tileOffset * atlasFaceSize;\n\tuv += omniAtlasViewport.xy;\n\treturn uv;\n}\n";

var clusteredLightCookiesPS = "vec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\n\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 projPos = transform * vec4(worldPosition, 1.0);\n\treturn _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\treturn _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\n}\n";

var clusteredLightShadowsPS = "#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn texture(shadowMap, vec3(uv, shadowZ));\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, uv));\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn depth > shadowZ ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\treturn getShadowOmniClusteredPCF3(shadowMap, shadowParams, omniAtlasViewport, shadowEdgePixels, dir);\n\t}\n\t#endif\n#endif\n#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn texture(shadowMap, dShadowCoord);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, dShadowCoord.xy));\n\t\treturn depth > dShadowCoord.z ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotClusteredPCF3(shadowMap, shadowParams);\n\t}\n\t#endif\n#endif\n";

var clusteredLightPS = "uniform sampler2D clusterWorldTexture;\nuniform sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n#ifdef CLUSTER_SHADOWS\n\t#ifdef GL2\n\t\tuniform sampler2DShadow shadowAtlasTexture;\n\t#else\n\t\tuniform sampler2D shadowAtlasTexture;\n\t#endif\n#endif\n#ifdef CLUSTER_COOKIES\n\tuniform sampler2D cookieAtlasTexture;\n#endif\nuniform float clusterPixelsPerCell;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec4 lightsTextureInvSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\nfloat LTCLightValuesEvaluated = 0.0;\nstruct ClusterLightData {\n\tfloat lightV;\n\tfloat type;\n\tfloat shape;\n\tvec3 halfWidth;\n\tvec3 halfHeight;\n\tfloat falloffMode;\n\tfloat castShadows;\n\tfloat shadowBias;\n\tfloat shadowNormalBias;\n\tvec3 position;\n\tvec3 direction;\n\tfloat range;\n\tfloat innerConeAngleCos;\n\tfloat outerConeAngleCos;\n\tvec3 color;\n\tvec3 omniAtlasViewport;\n\tfloat cookie;\n\tfloat cookieRgb;\n\tfloat cookieIntensity;\n\tvec4 cookieChannelMask;\n\tfloat mask;\n};\nmat4 lightProjectionMatrix;\n#define isClusteredLightCastShadow(light) ( light.castShadows > 0.5 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n\t#define acceptLightMask(light) ( light.mask < 0.75)\n#else\n\t#define acceptLightMask(light) ( light.mask > 0.25)\n#endif\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n\treturn vec4(\n\t\tbytes2floatRange4(d0, -2.0, 2.0),\n\t\tbytes2floatRange4(d1, -2.0, 2.0),\n\t\tbytes2floatRange4(d2, -2.0, 2.0),\n\t\tbytes2floatRange4(d3, -2.0, 2.0)\n\t);\n}\n#ifdef SUPPORTS_TEXLOD\n\t#define textureData(texture, uv) texture2DLodEXT(texture, uv, 0.0)\n#else\n\t#define textureData(texture, uv) texture2D(texture, uv)\n#endif\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV));\n}\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV));\n}\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n\tclusterLightData.type = lightInfo.x;\n\tclusterLightData.shape = lightInfo.y;\n\tclusterLightData.falloffMode = lightInfo.z;\n\tclusterLightData.castShadows = lightInfo.w;\n\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\tclusterLightData.cookie = colorB.z;\n\tclusterLightData.mask = colorB.w;\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n\t\tclusterLightData.position = lightPosRange.xyz;\n\t\tclusterLightData.range = lightPosRange.w;\n\t\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n\t\tclusterLightData.direction = lightDir_Unused.xyz;\n\t#else\n\t\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n\t\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n\t\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n\t\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\t\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n\t\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\t\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n\t\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n\t\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n\t\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\t#endif\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n\t#else\n\t\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n\t\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n\t\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n\t#endif\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n\t\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n\t#else\n\t\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n\t\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n\t\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n\t\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\t\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n\t\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n\t\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n\t\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n\t#endif\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n\t\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n\t\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n\t\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n\t#else\n\t\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n\t\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n\t\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n\t\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n\t\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\t\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n\t\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n\t\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n\t\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n\t\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\t\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n\t\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n\t\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n\t\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n\t\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\t\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n\t\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n\t\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n\t\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n\t\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n\t#endif\n\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n\tclusterLightData.cookieIntensity = cookieA.x;\n\tclusterLightData.cookieRgb = cookieA.y;\n\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\nvoid evaluateLight(ClusterLightData light) {\n\tdAtten3 = vec3(1.0);\n\tgetLightDirPoint(light.position);\n\t#ifdef CLUSTER_AREALIGHTS\n\tif (isClusteredLightArea(light)) {\n\t\tdecodeClusterLightAreaData(light);\n\t\tif (LTCLightValuesEvaluated < 0.5) {\n\t\t\tLTCLightValuesEvaluated = 1.0;\n\t\t\tcalcLTCLightValues();\n\t\t}\n\t\tif (isClusteredLightRect(light)) {\n\t\t\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else {\n\t\t\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t}\n\t\tdAtten = getFalloffWindow(light.range);\n\t} else\n\t#endif\n\t{\n\t\tif (isClusteredLightFalloffLinear(light))\n\t\t\tdAtten = getFalloffLinear(light.range);\n\t\telse\n\t\t\tdAtten = getFalloffInvSquared(light.range);\n\t}\n\tif (dAtten > 0.00001) {\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\tdAttenD = getRectLightDiffuse() * 16.0;\n\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\tdAttenD = getDiskLightDiffuse() * 16.0;\n\t\t\t} else {\n\t\t\t\tdAttenD = getSphereLightDiffuse() * 16.0;\n\t\t\t}\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\tdAtten *= getLightDiffuse();\n\t\t}\n\t\tif (isClusteredLightSpot(light)) {\n\t\t\tdecodeClusterLightSpot(light);\n\t\t\tdAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\n\t\t}\n\t\t#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n\t\tif (dAtten > 0.00001) {\n\t\t\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\tdecodeClusterLightProjectionMatrixData(light);\n\t\t\t\t} else {\n\t\t\t\t\tdecodeClusterLightOmniAtlasViewport(light);\n\t\t\t\t}\n\t\t\t\tfloat shadowTextureResolution = shadowAtlasParams.x;\n\t\t\t\tfloat shadowEdgePixels = shadowAtlasParams.y;\n\t\t\t\t#ifdef CLUSTER_COOKIES\n\t\t\t\tif (isClusteredLightCookie(light)) {\n\t\t\t\t\tdecodeClusterLightCookieData(light);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tdAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef CLUSTER_SHADOWS\n\t\t\t\tif (isClusteredLightCastShadow(light)) {\n\t\t\t\t\tdecodeClusterLightShadowData(light);\n\t\t\t\t\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnormalOffsetPointShadow(shadowParams);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\t{\n\t\t\t\tvec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\n\t\t\t\t#if defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += areaDiffuse;\n\t\t\t}\n\t\t\t#ifdef CLUSTER_SPECULAR\n\t\t\t\tfloat areaLightSpecular;\n\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\tareaLightSpecular = getRectLightSpecular();\n\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\tareaLightSpecular = getDiskLightSpecular();\n\t\t\t\t} else {\n\t\t\t\t\tareaLightSpecular = getSphereLightSpecular();\n\t\t\t\t}\n\t\t\t\tdSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\t\t\t\t\tfloat areaLightSpecularCC;\n\t\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getRectLightSpecularCC();\n\t\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getDiskLightSpecularCC();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tareaLightSpecularCC = getSphereLightSpecularCC();\n\t\t\t\t\t}\n\t\t\t\t\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color	* dAtten3;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\t{\n\t\t\t\tvec3 punctualDiffuse = dAtten * light.color * dAtten3;\n\t\t\t\t#if defined(CLUSTER_AREALIGHTS) && defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += punctualDiffuse;\n\t\t\t}\n\t\t\t#ifdef CLUSTER_SPECULAR\n\t\t\t\t{\n\t\t\t\t\tvec3 punctualSpecular = getLightSpecular() * dAtten * light.color * dAtten3;\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualSpecular *= dSpecularity;\n\t\t\t\t\t#endif\n\t\t\t\t\tdSpecularLight += punctualSpecular;\n\t\t\t\t}\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\t\t\t\t\tvec3 punctualCC = getLightSpecularCC() * dAtten * light.color * dAtten3;\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualCC *= ccSpecularity;\n\t\t\t\t\t#endif\n\t\t\t\t\tccSpecularLight += punctualCC;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t}\n}\nvoid evaluateClusterLight(float lightIndex) {\n\tClusterLightData clusterLightData;\n\tdecodeClusterLightCore(clusterLightData, lightIndex);\n\tif (acceptLightMask(clusterLightData))\n\t\tevaluateLight(clusterLightData);\n}\nvoid addClusteredLights() {\n\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\t\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\n\t\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\n\t\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\t\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\t\tconst float maxLightCells = 256.0 / 4.0;\n\t\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\t\t\tvec4 lightIndices = textureData(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV));\n\t\t\tvec4 indices = lightIndices * 255.0;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (indices.x <= 0.0)\n\t\t\t\t\treturn;\n\t\t\t\tevaluateClusterLight(indices.x);\n\t\t\t\tindices = indices.yzwx;\n\t\t\t}\n\t\t\tif (lightCellIndex > clusterPixelsPerCell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n";

var combineClearCoatPS = "vec3 combineColorCC() {\n\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n";

var combineDiffusePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight;\n}\n";

var combineDiffuseSpecularPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n";

var combineDiffuseSpecularNoConservePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n";

var combineDiffuseSpecularNoReflPS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n";

var combineDiffuseSpecularNoReflSeparateAmbientPS = "uniform vec3 material_ambient;\nvec3 combineColor() {\n\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n";

var combineDiffuseSpecularOldPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n";

var cookiePS = "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

var cubeMapProjectBoxPS = "uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn normalize(posonbox - envBoxPos);\n}\n";

var cubeMapProjectNonePS = "vec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n";

var cubeMapRotatePS = "#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n";

var decodePS = "vec3 decodeLinear(vec4 raw) {\n\treturn raw.rgb;\n}\nvec3 decodeGamma(vec4 raw) {\n\treturn pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n\tvec3 color = (8.0 * raw.a) * raw.rgb;\n\treturn color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n\tif (raw.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n\t}\n}\nconst float PI = 3.141592653589793;\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n\treturn vec2(uv.x, 1.0 - uv.y);\n}\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n\t\t\t\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapMip(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";

var detailModesPS = "vec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n";

var diffusePS = "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n";

var diffuseDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\nvec3 addAlbedoDetail(vec3 albedo) {\n\t#ifdef MAPTEXTURE\n\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n\t#else\n\treturn albedo;\n\t#endif\n}\n";

var dilatePS = "#define SHADER_NAME Dilate\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n";

var bilateralDeNoisePS = "#define SHADER_NAME BilateralDeNoise\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n\tvec4 pixelRgbm = texture2D(source, vUv0);\n\tif (pixelRgbm.a <= 0.0) {\n\t\tgl_FragColor = pixelRgbm;\n\t\treturn ;\n\t}\n\tfloat sigma = sigmas.x;\n\tfloat bSigma = sigmas.y;\n\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\tvec3 accumulatedHdr = vec3(0.0);\n\tfloat accumulatedFactor = 0.0;\n\tconst int kSize = (MSIZE-1)/2;\n\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\tvec4 rgbm = texture2D(source, coord);\n\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\taccumulatedFactor += factor;\n\t\t\t}\n\t\t}\n\t}\n\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n";

var emissivePS = "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n\tvec3 emission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\temission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\temission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n\treturn emission;\n}\n";

var endPS = "\t#ifdef CLEARCOAT\n\tgl_FragColor.rgb = combineColorCC();\n\t#else\n\tgl_FragColor.rgb = combineColor();\n\t#endif\n\tgl_FragColor.rgb += getEmission();\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n";

var endVS = "\n";

var envConstPS = "vec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n";

var envMultiplyPS = "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n";

var extensionPS = "\n";

var extensionVS = "\n";

var falloffInvSquaredPS = "float getFalloffWindow(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat invRadius = 1.0 / lightRadius;\n\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n";

var falloffLinearPS = "float getFalloffLinear(float lightRadius) {\n\tfloat d = length(dLightDirW);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

var fixCubemapSeamsNonePS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\treturn vec3(0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec;\n}\n";

var fixCubemapSeamsStretchPS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tvec3 avec = abs(vec);\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat M = max(avec.x, max(avec.y, avec.z));\n\treturn vec3(avec.x != M ? 1.0 : 0.0,\n\t\t\t\tavec.y != M ? 1.0 : 0.0,\n\t\t\t\tavec.z != M ? 1.0 : 0.0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec * (seam * -scale + vec3(1.0));\n}\n";

var floatUnpackingPS = "float bytes2float2(vec2 data) {\n\treturn dot(data, vec2(1.0, 1.0 / 255.0));\n}\nfloat bytes2float3(vec3 data) {\n\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\nfloat bytes2float4(vec4 data) {\n\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n\treturn mix(min, max, bytes2float2(data));\n}\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n\treturn mix(min, max, bytes2float3(data));\n}\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n\treturn mix(min, max, bytes2float4(data));\n}\nfloat mantissaExponent2Float(vec4 pack)\n{\n\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n\tfloat exponent = floor(pack.w * 255.0 - 127.0);\n\treturn value * exp2(exponent);\n}\n";

var fogExpPS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

var fogExp2PS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

var fogLinearPS = "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\tfogFactor = gammaCorrectInput(fogFactor);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

var fogNonePS = "float dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n";

var fresnelSchlickPS = "uniform float material_fresnelFactor;\nvoid getFresnel() {\n\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n\tfloat fresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= dGlossiness * dGlossiness;\n\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n\t#ifdef CLEARCOAT\n\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n\tfresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= ccGlossiness * ccGlossiness;\n\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n\t#endif\n}\n";

var fullscreenQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

var fullscreenQuadVS = "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n";

var gamma1_0PS = "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\treturn textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\n";

var gamma2_2PS = "vec3 gammaCorrectInput(vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n\treturn pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 rgba = texture2D(tex, uv);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\tvec4 rgba = texture2D(tex, uv, bias);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\tvec4 rgba = textureCube(tex, uvw);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\t#ifdef HDR\n\treturn color;\n\t#else\n\tcolor += vec3(0.0000001);\n\treturn pow(color, vec3(0.45));\n\t#endif\n}\n";

var gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n#define SUPPORTS_TEXLOD\n";

var gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";

var glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n";

var instancingVS = "attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";

var lightDiffuseLambertPS = "float getLightDiffuse() {\n\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n";

var lightDirPointPS = "void getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n";

var lightmapDirPS = "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tvec3 dir = texture2D(texture_dirLightMap, $UV).xyz;\n\tif (dot(dir, vec3(1.0)) < 0.00001) {\n\t\tdDiffuseLight += color;\n\t} else {\n\t\tdLightDirNormW = normalize(dir * 2.0 - vec3(1.0));\n\t\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n\t\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\n\t\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\n\t\tdDiffuseLight += color * nlight * 2.0;\n\t}\n\tdSpecularLight += color * getLightSpecular();\n}\n";

var lightmapSinglePS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n\tvec3 lm = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tlm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tlm *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight += lm;\n}\n";

var lightmapSingleVertPS = "void addLightMap() {\n\tdDiffuseLight += saturate(vVertexColor.$CH);\n}\n";

var lightSpecularAnisoGGXPS = "float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\tfloat NoH = dot(tNormalW, h);\n\tfloat ToH = dot(dTBN[0], h);\n\tfloat BoH = dot(dTBN[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(dTBN[0], dViewDirW);\n\tfloat BoV = dot(dTBN[1], dViewDirW);\n\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\n\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\n\tfloat NoV = dot(tNormalW, dViewDirW);\n\tfloat NoL = dot(tNormalW, -dLightDirNormW);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

var lightSpecularBlinnPS = "float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\n\tfloat nh = max( dot( h, tNormalW ), 0.0 );\n\tfloat specPow = exp2(tGlossiness * 11.0);\n\tspecPow = antiAliasGlossiness(specPow);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

var lightSpecularPhongPS = "float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n\tfloat specPow = tGlossiness;\n\tspecPow = antiAliasGlossiness(specPow);\n\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dReflDirW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n";

var ltc = "mat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n\tvec3 coord0;\n\tvec3 coord1;\n\tvec3 coord2;\n\tvec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\tvec3 lightNormal = cross( v1, v2 );\n\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 =	factor * cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tCoords coords;\n\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\treturn coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\tvec3 w = normalize(cross(f, halfHeight));\n\tvec3 h = normalize(cross(f, w));\n\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\n{\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\treturn LTC_Uv( tNormalW, dViewDirW, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\n{\n\tvec4 t2 = texture2D( areaLightsLutTex2, uv );\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt2 *= vec4(0.693103,1,1,1);\n\tt2 += vec4(0.306897,0,0,0);\n\t#endif\n\treturn tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\n}\nvoid calcLTCLightValues()\n{\n\tdLTCUV = getLTCLightUV(dGlossiness, dNormalW);\n\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularityNoFres);\n#ifdef CLEARCOAT\n\tccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\n\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularityNoFres));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n\tfloat pi = 3.14159;\n\tCoefficient.xyz /= Coefficient.w;\n\tCoefficient.yz /= 3.0;\n\tfloat A = Coefficient.w;\n\tfloat B = Coefficient.z;\n\tfloat C = Coefficient.y;\n\tfloat D = Coefficient.x;\n\tvec3 Delta = vec3(\n\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t);\n\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\tvec3 RootsA, RootsD;\n\tvec2 xlc, xsc;\n\t{\n\t\tfloat A_a = 1.0;\n\t\tfloat C_a = Delta.x;\n\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xl;\n\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\txl = x_1a;\n\t\telse\n\t\t\txl = x_3a;\n\t\txlc = vec2(xl - B, A);\n\t}\n\t{\n\t\tfloat A_d = D;\n\t\tfloat C_d = Delta.z;\n\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xs;\n\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\txs = x_1d;\n\t\telse\n\t\t\txs = x_3d;\n\t\txsc = vec2(-D, xs + C);\n\t}\n\tfloat E =	xlc.y * xsc.y;\n\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\tfloat G =	xlc.x * xsc.x;\n\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\tif (Root.x < Root.y && Root.x < Root.z)\n\t\tRoot.xyz = Root.yxz;\n\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\tRoot.xyz = Root.xzy;\n\treturn Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot(V, N));\n\tT2 = cross(N, T1);\n\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\tvec3 L_[ 3 ];\n\tL_[ 0 ] = R * ( points.coord0 - P );\n\tL_[ 1 ] = R * ( points.coord1 - P );\n\tL_[ 2 ] = R * ( points.coord2 - P );\n\tvec3 Lo_i = vec3(0);\n\tvec3 C	= 0.5 * (L_[0] + L_[2]);\n\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\tC	= Minv * C;\n\tV1 = Minv * V1;\n\tV2 = Minv * V2;\n\tfloat a, b;\n\tfloat d11 = dot(V1, V1);\n\tfloat d22 = dot(V2, V2);\n\tfloat d12 = dot(V1, V2);\n\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t{\n\t\tfloat tr = d11 + d22;\n\t\tfloat det = -d12 * d12 + d11 * d22;\n\t\tdet = sqrt(det);\n\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\tfloat e_max = (u + v) * (u + v);\n\t\tfloat e_min = (u - v) * (u - v);\n\t\tvec3 V1_, V2_;\n\t\tif (d11 > d22)\n\t\t{\n\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t}\n\t\ta = 1.0 / e_max;\n\t\tb = 1.0 / e_min;\n\t\tV1 = normalize(V1_);\n\t\tV2 = normalize(V2_);\n\t}\n\telse\n\t{\n\t\ta = 1.0 / dot(V1, V1);\n\t\tb = 1.0 / dot(V2, V2);\n\t\tV1 *= sqrt(a);\n\t\tV2 *= sqrt(b);\n\t}\n\tvec3 V3 = cross(V1, V2);\n\tif (dot(C, V3) < 0.0)\n\t\tV3 *= -1.0;\n\tfloat L	= dot(V3, C);\n\tfloat x0 = dot(V1, C) / L;\n\tfloat y0 = dot(V2, C) / L;\n\tfloat E1 = inversesqrt(a);\n\tfloat E2 = inversesqrt(b);\n\ta *= L * L;\n\tb *= L * L;\n\tfloat c0 = a * b;\n\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\tfloat c3 = 1.0;\n\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\tfloat e1 = roots.x;\n\tfloat e2 = roots.y;\n\tfloat e3 = roots.z;\n\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\tmat3 rotate = mat3(V1, V2, V3);\n\tavgDir = rotate * avgDir;\n\tavgDir = normalize(avgDir);\n\tfloat L1 = sqrt(-e2 / e3);\n\tfloat L2 = sqrt(-e2 / e1);\n\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\tuv = uv*LUT_SCALE + LUT_BIAS;\n\tfloat scale = texture2D( areaLightsLutTex2, uv ).w;\n\treturn formFactor*scale;\n}\nfloat getRectLightDiffuse() {\n\treturn LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse() {\n\treturn LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getSphereLightDiffuse() {\n\tfloat falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\n\treturn getLightDiffuse()*falloff;\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\tvec4 t1 = texture2D( areaLightsLutTex1, uv );\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n\t#endif\n\treturn mat3(\n\t\tvec3( t1.x, 0, t1.y ),\n\t\tvec3(\t0, 1,\t0 ),\n\t\tvec3( t1.z, 0, t1.w )\n\t);\n}\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular() {\n\treturn calcRectLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getRectLightSpecularCC() {\n\treturn calcRectLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getDiskLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\nfloat getSphereLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getSphereLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n";

var metalnessPS = "void processMetalness(float metalness) {\n\tconst float dielectricF0 = 0.04;\n\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n\tdAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\nvoid getSpecularity() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2D(texture_metalnessMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tprocessMetalness(metalness);\n}\n";

var msdfPS = "uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\tfloat smoothingMax = 0.2;\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\treturn tcolor;\n}\n";

var normalVS = "#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n";

var normalDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n\t#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\n\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n\treturn blendNormals(normalMap, normalDetailMap);\n\t#else\n\treturn normalMap;\n\t#endif\n}\n";

var normalInstancedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

var normalMapPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n";

var normalMapFastPS = "uniform sampler2D texture_normalMap;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n";

var normalSkinnedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

var normalVertexPS = "void getNormal() {\n\tdNormalW = normalize(dVertexNormalW);\n}\n";

var normalXYPS = "vec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n";

var normalXYZPS = "vec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n";

var opacityPS = "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n";

var outputAlphaPS = "gl_FragColor.a = dAlpha;\n";

var outputAlphaOpaquePS = "gl_FragColor.a = 1.0;\n";

var outputAlphaPremulPS = "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";

var outputCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec4 color) {\n\tcolor.rgb = pow(color.rgb, vec3(0.5));\n\tcolor.rgb *= 1.0 / 8.0;\n\tcolor.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n\tcolor.a = ceil(color.a * 255.0) / 255.0;\n\tcolor.rgb /= color.a;\n\treturn color;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tgl_FragColor = textureCube(source, vec);\n\tif (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n";

var outputTex2DPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

var packDepthPS = "vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

var packDepthMaskPS = "vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres.x = 0.0;\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

var parallaxPS = "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2D(texture_heightMap, $UV).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

var particlePS = "varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex	= texture2DSRGB(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\n\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a	= tex.a * ramp.a;\n";

var particleVS = "vec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n";

var particleAnimFrameClampVS = "\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

var particleAnimFrameLoopVS = "\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

var particleAnimTexVS = "\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

var particleInputFloatPS = "void readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n";

var particleInputRgba8PS = "#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

var particleOutputFloatPS = "void writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n";

var particleOutputRgba8PS = "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n";

var particleUpdaterAABBPS = "uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n";

var particleUpdaterEndPS = "\twriteOutput();\n}\n";

var particleUpdaterInitPS = "varying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

var particleUpdaterNoRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n";

var particleUpdaterOnStopPS = "\tvisMode = outLife < 0.0? -1.0: visMode;\n";

var particleUpdaterRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n";

var particleUpdaterSpherePS = "uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

var particleUpdaterStartPS = "float saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t	tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n";

var particle_billboardVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n";

var particle_blendAddPS = "\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

var particle_blendMultiplyPS = "\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

var particle_blendNormalPS = "\tif (a < 0.01) discard;\n";

var particle_cpuVS = "attribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n";

var particle_cpu_endVS = "\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

var particle_customFaceVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n";

var particle_endPS = "\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n";

var particle_endVS = "\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n";

var particle_halflambertPS = "\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n";

var particle_initVS = "attribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

var particle_lambertPS = "\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n";

var particle_lightingPS = "\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n";

var particle_localShiftVS = "\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

var particle_meshVS = "\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n";

var particle_normalVS = "\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

var particle_normalMapPS = "\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n";

var particle_pointAlongVS = "\tinAngle = atan(velocityV.x, velocityV.y);\n";

var particle_softPS = "\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n";

var particle_softVS = "\tvDepth = getLinearDepth(localPos);\n";

var particle_stretchVS = "\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n";

var particle_TBNVS = "\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

var particle_wrapVS = "\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n";

var precisionTestPS = "void main(void) {\n\tgl_FragColor = vec4(2147483648.0);\n}\n";

var precisionTest2PS = "uniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n";

var reflDirPS = "void getReflDir() {\n\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n";

var reflDirAnisoPS = "void getReflDir() {\n\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-dViewDirW, bentNormal);\n}\n";

var reflectionCCPS = "#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\nvoid addReflectionCC() {\n\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n";

var reflectionCubePS = "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n\tlookupVec.x *= -1.0;\n\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var reflectionEnvPS = "#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\tvec2 dx2 = dFdx(uv2);\n\tvec2 dy2 = dFdy(uv2);\n\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\treturn clamp(0.5 * log2(maxd) - 1.0, 0.0, 6.0);\n}\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - tGlossiness) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\tfloat ilevel2 = floor(level2);\n\tvec2 uv0, uv1;\n\tfloat weight;\n\tif (ilevel == 0.0) {\n\t\tuv0 = mapMip(uv, ilevel2);\n\t\tuv1 = mapMip(uv, ilevel2 + 1.0);\n\t\tweight = level2 - ilevel2;\n\t} else {\n\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\tweight = 0.0;\n\t}\n\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\tvec3 linear0 = mix(linearA, linearB, weight);\n\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var reflectionSpherePS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var reflectionSphereLowPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = vNormalV;\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var refractionPS = "uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n\tfloat vn = dot(viewVec, Normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n\treturn refrVec;\n}\nvoid addRefraction() {\n\tvec3 tmp = dReflDirW;\n\tvec4 tmp2 = dReflection;\n\tdReflection = vec4(0.0);\n\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\taddReflection();\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n\tdReflDirW = tmp;\n\tdReflection = tmp2;\n}\n";

var reprojectPS = "varying vec2 vUv0;\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\nuniform sampler2D samplesTex;\nuniform vec2 samplesTexInverseSize;\nuniform vec4 params;\nuniform vec2 params2;\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\nfloat targetTotalPixels() { return params2.x; }\nfloat sourceTotalPixels() { return params2.y; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 decodeLinear(vec4 source) {\n\treturn source.rgb;\n}\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec3 decodeGamma(vec4 source) {\n\treturn pow(source.xyz, vec3(2.2));\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec3 decodeRGBE(vec4 source) {\n\tif (source.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\n\t}\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\nvec3 modifySeams(vec3 dir, float scale) {\n\tvec3 adir = abs(dir);\n\tfloat M = max(max(adir.x, adir.y), adir.z);\n\treturn dir / M * vec3(\n\t\tadir.x == M ? 1.0 : scale,\n\t\tadir.y == M ? 1.0 : scale,\n\t\tadir.z == M ? 1.0 : scale\n\t);\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * sin(uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nvec4 sampleEquirect(vec2 sph) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\nvec4 sampleEquirect(vec3 dir) {\n\treturn sampleEquirect(toSpherical(dir));\n}\nvec4 sampleCubemap(vec3 dir) {\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n}\nvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\n\treturn sampleEquirect(toSpherical(dir), mipLevel);\n}\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\n#ifdef SUPPORTS_TEXLOD\n\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n#else\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\n#endif\n}\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\n\treturn sampleCubemap(fromSpherical(sph), mipLevel);\n}\nfloat signNotZero(float k){\n\treturn(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n\treturn vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n\tif (v.y < 0.0) {\n\t\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n\t}\n\treturn normalize(v);\n}\nvec3 getDirectionOctahedral() {\n\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n\tvec2 result = v.xz * (1.0 / l1norm);\n\tif (v.y < 0.0) {\n\t\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n\t}\n\treturn result;\n}\nvec4 sampleOctahedral(vec3 dir) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\nvec4 sampleOctahedral(vec2 sph) {\n\treturn sampleOctahedral(fromSpherical(sph));\n}\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\n}\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 x = normalize(cross(up, n));\n\tvec3 y = cross(n, x);\n\treturn mat3(x, y, n);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec2 sph = toSpherical(TARGET_FUNC());\n\t\tvec2 sphu = dFdx(sph);\n\t\tvec2 sphv = dFdy(sph);\n\t\tconst float NUM_SAMPLES_SQRT = sqrt(float(NUM_SAMPLES));\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n\t\t\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\n\t\t\t\t\t\t\t\t\t\t\t\t	sphu * (u / NUM_SAMPLES_SQRT - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t	sphv * (v / NUM_SAMPLES_SQRT - 0.5)));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n\t}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\tvec4 raw;\n\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\tL.xyz = raw.xyz * 2.0 - 1.0;\n\tmipLevel = raw.w * 8.0;\n}\nvec4 prefilterSamples() {\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\tvec3 L;\n\tfloat mipLevel;\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n\t\ttotalWeight += L.z;\n\t}\n\treturn ENCODE_FUNC(result / totalWeight);\n}\nvec4 prefilterSamplesUnweighted() {\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\tvec3 L;\n\tfloat mipLevel;\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n\t}\n\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n";

var rgbmPS = "vec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n\treturn decodeRGBM(textureCube(tex, uvw));\n}\n";

var screenDepthPS = "uniform highp sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tz = z * 2.0 - 1.0;\n\treturn 1.0 / (camera_params.z * z + camera_params.w);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n\t#else\n\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

var shadowCascadesPS = "const float maxCascades = 4.0;\nmat4 cascadeShadowMat;\nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tfloat cascadeIndex = 0.0;\n\tfor (float i = 0.0; i < maxCascades; i++) {\n\t\tif (depth < shadowCascadeDistances[int(i)]) {\n\t\t\tcascadeIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\t#ifdef GL2\n\t\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n\t#else\n\t\tif (cascadeIndex == 0.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[0];\n\t\t}\n\t\telse if (cascadeIndex == 1.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[1];\n\t\t}\n\t\telse if (cascadeIndex == 2.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[2];\n\t\t}\n\t\telse {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[3];\n\t\t}\n\t#endif\n}\nvoid fadeShadow(float shadowCascadeDistances[4]) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n\t\tdShadowCoord.z = -9999999.0;\n\t}\n}\n";

var shadowCommonPS = "void normalOffsetPointShadow(vec4 shadowParams) {\n\tfloat distScale = length(dLightDirW);\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - dLightPosW;\n\tdLightDirW = dir;\n}\n";

var shadowCoordPS = "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xy /= projPos.w;\n\tdShadowCoord.xy = projPos.xy;\n\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";

var shadowCoordPerspZbufferPS = "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n";

var shadowEVSMPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

var shadowEVSMnPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

var shadowStandardPS = "vec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowCoord = dShadowCoord;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\tvec3 shadowCoord = dShadowCoord;\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n";

var shadowStandardGL2PS = "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = gammaCorrectInput(sum);\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";

var shadowVSM8PS = "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";

var shadowVSM_commonPS = "float linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n	 return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";

var skinBatchConstVS = "attribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

var skinBatchTexVS = "attribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

var skinConstVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

var skinTexVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

var skyboxEnvPS = "varying vec3 vViewDir;\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\nvoid main(void) {\n\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(normalize(dir));\n\tvec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n";

var skyboxHDRPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tvec3 dir=vViewDir;\n\tdir.x *= -1.0;\n\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)).rgb);\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n";

var skyboxVS = "attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition * cubeMapRotationMatrix;\n}\n";

var specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdSpecularity *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

var specularAaNonePS = "float antiAliasGlossiness(float power) {\n\treturn power;\n}\n";

var specularAaToksvigPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * mix(1.0, toksvig, material_bumpiness);\n}\n";

var specularAaToksvigFastPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * toksvig;\n}\n";

var spotPS = "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

var startPS = "void main(void) {\n\tdDiffuseLight = vec3(0);\n\tdSpecularLight = vec3(0);\n\tdReflection = vec4(0);\n\tdSpecularity = vec3(0);\n\t#ifdef CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec4(0);\n\t#endif\n";

var startVS = "void main(void) {\n\tgl_Position = getPosition();\n";

var startNineSlicedPS = "\tnineSlicedUv = vUv0;\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";

var startNineSlicedTiledPS = "\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";

var storeEVSMPS = "float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =	exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";

var tangentBinormalVS = "vec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\nvec3 getObjectSpaceUp() {\n\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n";

var TBNPS = "void getTBN() {\n\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n";

var TBNderivativePS = "uniform float tbnBasis;\nvoid getTBN() {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, dVertexNormalW );\n\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat denom = max( dot(T,T), dot(B,B) );\n\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n\tdTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\n}\n";

var TBNfastPS = "void getTBN() {\n\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n";

var TBNObjectSpacePS = "void getTBN() {\n\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n\tvec3 T = cross(dVertexNormalW, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\t\tif (dVertexNormalW.x==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,1,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.y==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,0,1));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.z==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(1,0,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n";

var tonemappingAcesPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

var tonemappingAces2PS = "uniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,	1.10813, -0.00605,\n\t-0.00327, -0.07276,	1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n";

var tonemappingFilmicPS = "const float A =	0.15;\nconst float B =	0.50;\nconst float C =	0.10;\nconst float D =	0.20;\nconst float E =	0.02;\nconst float F =	0.30;\nconst float W =	11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n";

var tonemappingHejlPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float	A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

var tonemappingLinearPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n";

var tonemappingNonePS = "vec3 toneMap(vec3 color) {\n\treturn color;\n}\n";

var transformVS = "#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\nvec2 getTextureMorphCoords() {\n\tfloat vertexId = morph_vertex_id;\n\tvec2 textureSize = morph_tex_params.xy;\n\tvec2 invTextureSize = morph_tex_params.zw;\n\tfloat morphGridV = floor(vertexId * invTextureSize.x);\n\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\n\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n";

var transformDeclVS = "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n";

var uv0VS = "#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n";

var uv1VS = "vec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n";

var viewDirPS = "void getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n";

var viewNormalVS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n";

const shaderChunks = {
	alphaTestPS,
	ambientConstantPS,
	ambientEnvPS,
	ambientSHPS,
	aoPS,
	aoSpecOccPS,
	aoSpecOccConstPS,
	aoSpecOccConstSimplePS,
	aoSpecOccSimplePS,
	bakeDirLmEndPS,
	bakeLmEndPS,
	basePS,
	baseVS,
	baseNineSlicedPS,
	baseNineSlicedVS,
	baseNineSlicedTiledPS,
	biasConstPS,
	blurVSMPS,
	clearCoatPS,
	clearCoatGlossPS,
	clearCoatNormalPS,
	clusteredLightCookiesPS,
	clusteredLightShadowsPS,
	clusteredLightUtilsPS,
	clusteredLightPS,
	combineClearCoatPS,
	combineDiffusePS,
	combineDiffuseSpecularPS,
	combineDiffuseSpecularNoConservePS,
	combineDiffuseSpecularNoReflPS,
	combineDiffuseSpecularNoReflSeparateAmbientPS,
	combineDiffuseSpecularOldPS,
	cookiePS,
	cubeMapProjectBoxPS,
	cubeMapProjectNonePS,
	cubeMapRotatePS,
	detailModesPS,
	diffusePS,
	diffuseDetailMapPS,
	dilatePS,
	bilateralDeNoisePS,
	decodePS,
	emissivePS,
	endPS,
	endVS,
	envConstPS,
	envMultiplyPS,
	extensionPS,
	extensionVS,
	falloffInvSquaredPS,
	falloffLinearPS,
	fixCubemapSeamsNonePS,
	fixCubemapSeamsStretchPS,
	floatUnpackingPS,
	fogExpPS,
	fogExp2PS,
	fogLinearPS,
	fogNonePS,
	fresnelSchlickPS,
	fullscreenQuadPS,
	fullscreenQuadVS,
	gamma1_0PS,
	gamma2_2PS,
	gles3PS,
	gles3VS,
	glossPS,
	instancingVS,
	lightDiffuseLambertPS,
	lightDirPointPS,
	lightmapDirPS,
	lightmapSinglePS,
	lightmapSingleVertPS,
	lightSpecularAnisoGGXPS,
	lightSpecularBlinnPS,
	lightSpecularPhongPS,
	ltc,
	metalnessPS,
	msdfPS,
	normalVS,
	normalDetailMapPS,
	normalInstancedVS,
	normalMapPS,
	normalMapFastPS,
	normalSkinnedVS,
	normalVertexPS,
	normalXYPS,
	normalXYZPS,
	opacityPS,
	outputAlphaPS,
	outputAlphaOpaquePS,
	outputAlphaPremulPS,
	outputCubemapPS,
	outputTex2DPS,
	packDepthPS,
	packDepthMaskPS,
	parallaxPS,
	particlePS,
	particleVS,
	particleAnimFrameClampVS,
	particleAnimFrameLoopVS,
	particleAnimTexVS,
	particleInputFloatPS,
	particleInputRgba8PS,
	particleOutputFloatPS,
	particleOutputRgba8PS,
	particleUpdaterAABBPS,
	particleUpdaterEndPS,
	particleUpdaterInitPS,
	particleUpdaterNoRespawnPS,
	particleUpdaterOnStopPS,
	particleUpdaterRespawnPS,
	particleUpdaterSpherePS,
	particleUpdaterStartPS,
	particle_billboardVS,
	particle_blendAddPS,
	particle_blendMultiplyPS,
	particle_blendNormalPS,
	particle_cpuVS,
	particle_cpu_endVS,
	particle_customFaceVS,
	particle_endPS,
	particle_endVS,
	particle_halflambertPS,
	particle_initVS,
	particle_lambertPS,
	particle_lightingPS,
	particle_localShiftVS,
	particle_meshVS,
	particle_normalVS,
	particle_normalMapPS,
	particle_pointAlongVS,
	particle_softPS,
	particle_softVS,
	particle_stretchVS,
	particle_TBNVS,
	particle_wrapVS,
	precisionTestPS,
	precisionTest2PS,
	reflDirPS,
	reflDirAnisoPS,
	reflectionCCPS,
	reflectionCubePS,
	reflectionEnvPS,
	reflectionSpherePS,
	reflectionSphereLowPS,
	refractionPS,
	reprojectPS,
	rgbmPS,
	screenDepthPS,
	shadowCascadesPS,
	shadowCommonPS,
	shadowCoordPS,
	shadowCoordPerspZbufferPS,
	shadowEVSMPS,
	shadowEVSMnPS,
	shadowStandardPS,
	shadowStandardGL2PS,
	shadowVSM8PS,
	shadowVSM_commonPS,
	skinBatchConstVS,
	skinBatchTexVS,
	skinConstVS,
	skinTexVS,
	skyboxEnvPS,
	skyboxHDRPS,
	skyboxVS,
	specularPS,
	specularAaNonePS,
	specularAaToksvigPS,
	specularAaToksvigFastPS,
	spotPS,
	startPS,
	startVS,
	startNineSlicedPS,
	startNineSlicedTiledPS,
	storeEVSMPS,
	tangentBinormalVS,
	TBNPS,
	TBNderivativePS,
	TBNfastPS,
	TBNObjectSpacePS,
	tonemappingAcesPS,
	tonemappingAces2PS,
	tonemappingFilmicPS,
	tonemappingHejlPS,
	tonemappingLinearPS,
	tonemappingNonePS,
	transformVS,
	transformDeclVS,
	uv0VS,
	uv1VS,
	viewDirPS,
	viewNormalVS
};

function gammaCode(value, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {
		return chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;
	} else if (value === GAMMA_SRGBHDR) {
		return "#define HDR\n" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);
	}

	return chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;
}

function tonemapCode(value, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (value === TONEMAP_FILMIC) {
		return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;
	} else if (value === TONEMAP_LINEAR) {
		return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;
	} else if (value === TONEMAP_HEJL) {
		return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;
	} else if (value === TONEMAP_ACES) {
		return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;
	} else if (value === TONEMAP_ACES2) {
		return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;
	}

	return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;
}

function fogCode(value, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (value === 'linear') {
		return chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;
	} else if (value === 'exp') {
		return chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;
	} else if (value === 'exp2') {
		return chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;
	}

	return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
}

function skinCode(device, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (device.supportsBoneTextures) {
		return chunks.skinTexVS;
	}

	return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
}

function precisionCode(device) {
	let pcode = 'precision ' + device.precision + ' float;\n';

	if (device.webgl2) {
		pcode += '#ifdef GL2\nprecision ' + device.precision + ' sampler2DShadow;\n#endif\n';
	}

	return pcode;
}

function versionCode(device) {
	return device.webgl2 ? "#version 300 es\n" : "";
}

function dummyFragmentCode() {
	return "void main(void) {gl_FragColor = vec4(0.0);}";
}

function begin() {
	return 'void main(void)\n{\n';
}

function end() {
	return '}\n';
}

const attrib2Semantic = {
	vertex_position: SEMANTIC_POSITION,
	vertex_normal: SEMANTIC_NORMAL,
	vertex_tangent: SEMANTIC_TANGENT,
	vertex_texCoord0: SEMANTIC_TEXCOORD0,
	vertex_texCoord1: SEMANTIC_TEXCOORD1,
	vertex_texCoord2: SEMANTIC_TEXCOORD2,
	vertex_texCoord3: SEMANTIC_TEXCOORD3,
	vertex_texCoord4: SEMANTIC_TEXCOORD4,
	vertex_texCoord5: SEMANTIC_TEXCOORD5,
	vertex_texCoord6: SEMANTIC_TEXCOORD6,
	vertex_texCoord7: SEMANTIC_TEXCOORD7,
	vertex_color: SEMANTIC_COLOR,
	vertex_boneIndices: SEMANTIC_BLENDINDICES,
	vertex_boneWeights: SEMANTIC_BLENDWEIGHT
};

function collectAttribs(vsCode) {
	const attribs = {};
	let attrs = 0;
	let found = vsCode.indexOf("attribute");

	while (found >= 0) {
		if (found > 0 && vsCode[found - 1] === "/") break;
		const endOfLine = vsCode.indexOf(';', found);
		const startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
		const attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));
		const semantic = attrib2Semantic[attribName];

		if (semantic !== undefined) {
			attribs[attribName] = semantic;
		} else {
			attribs[attribName] = "ATTR" + attrs;
			attrs++;
		}

		found = vsCode.indexOf("attribute", found + 1);
	}

	return attribs;
}

function createShader(device, vsName, psName, useTransformFeedback = false) {
	let vsCode = shaderChunks[vsName];
	let psCode = precisionCode(device) + "\n" + shaderChunks[psName];
	const attribs = collectAttribs(vsCode);

	if (device.webgl2) {
		vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
		psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
	}

	return new Shader(device, {
		attributes: attribs,
		vshader: vsCode,
		fshader: psCode,
		useTransformFeedback: useTransformFeedback
	});
}

function createShaderFromCode(device, vsCode, psCode, uName, useTransformFeedback = false, psPreamble = "") {
	const shaderCache = device.programLib._cache;
	const cached = shaderCache[uName];
	if (cached !== undefined) return cached;
	psCode = precisionCode(device) + "\n" + (psCode || dummyFragmentCode());
	const attribs = collectAttribs(vsCode);

	if (device.webgl2) {
		vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
		psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
	}

	shaderCache[uName] = new Shader(device, {
		attributes: attribs,
		vshader: vsCode,
		fshader: psPreamble + psCode,
		useTransformFeedback: useTransformFeedback
	});
	return shaderCache[uName];
}

shaderChunks.collectAttribs = collectAttribs;
shaderChunks.createShader = createShader;
shaderChunks.createShaderFromCode = createShaderFromCode;

const basic = {
	generateKey: function (options) {
		let key = 'basic';
		if (options.fog) key += '_fog';
		if (options.alphaTest) key += '_atst';
		if (options.vertexColors) key += '_vcol';
		if (options.diffuseMap) key += '_diff';
		if (options.skin) key += '_skin';
		if (options.screenSpace) key += '_ss';
		if (options.useInstancing) key += '_inst';
		if (options.useMorphPosition) key += '_morphp';
		if (options.useMorphNormal) key += '_morphn';
		if (options.useMorphTextureBased) key += '_morpht';
		key += '_' + options.pass;
		return key;
	},
	createShaderDefinition: function (device, options) {
		const attributes = {
			vertex_position: SEMANTIC_POSITION
		};

		if (options.skin) {
			attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
			attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
		}

		if (options.vertexColors) {
			attributes.vertex_color = SEMANTIC_COLOR;
		}

		if (options.diffuseMap) {
			attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
		}

		let code = '';
		code += shaderChunks.transformDeclVS;

		if (options.skin) {
			code += skinCode(device);
			code += shaderChunks.transformSkinnedVS;
		} else {
			code += shaderChunks.transformVS;
		}

		if (options.vertexColors) {
			code += 'attribute vec4 vertex_color;\n';
			code += 'varying vec4 vColor;\n';
		}

		if (options.diffuseMap) {
			code += 'attribute vec2 vertex_texCoord0;\n';
			code += 'varying vec2 vUv0;\n';
		}

		if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += '#ifndef VIEWMATRIX\n';
			code += '#define VIEWMATRIX\n';
			code += 'uniform mat4 matrix_view;\n';
			code += '#endif\n';
			code += '#ifndef CAMERAPLANES\n';
			code += '#define CAMERAPLANES\n';
			code += 'uniform vec4 camera_params;\n\n';
			code += '#endif\n';
		}

		code += begin();
		code += "	 gl_Position = getPosition();\n";

		if (options.pass === SHADER_DEPTH) {
			code += "		vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
		}

		if (options.vertexColors) {
			code += '		vColor = vertex_color;\n';
		}

		if (options.diffuseMap) {
			code += '		vUv0 = vertex_texCoord0;\n';
		}

		code += end();
		const vshader = code;
		code = precisionCode(device);

		if (options.vertexColors) {
			code += 'varying vec4 vColor;\n';
		} else {
			code += 'uniform vec4 uColor;\n';
		}

		if (options.diffuseMap) {
			code += 'varying vec2 vUv0;\n';
			code += 'uniform sampler2D texture_diffuseMap;\n';
		}

		if (options.fog) {
			code += fogCode(options.fog);
		}

		if (options.alphatest) {
			code += shaderChunks.alphaTestPS;
		}

		if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += shaderChunks.packDepthPS;
		}

		code += begin();

		if (options.vertexColors) {
			code += '		gl_FragColor = vColor;\n';
		} else {
			code += '		gl_FragColor = uColor;\n';
		}

		if (options.diffuseMap) {
			code += '		gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n';
		}

		if (options.alphatest) {
			code += "	 alphaTest(gl_FragColor.a);\n";
		}

		if (options.pass !== SHADER_PICK) {
			if (options.pass === SHADER_DEPTH) {
				code += "		gl_FragColor = packFloat(vDepth);\n";
			} else {
				if (options.fog) {
					code += "	 glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
				}
			}
		}

		code += end();
		const fshader = code;
		return {
			attributes: attributes,
			vshader: vshader,
			fshader: fshader
		};
	}
};

const particle = {
	generateKey: function (options) {
		let key = "particle";

		for (const prop in options) {
			if (options.hasOwnProperty(prop)) {
				key += options[prop];
			}
		}

		return key;
	},
	_animTex: function (options) {
		let vshader = "";
		vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
		vshader += shaderChunks.particleAnimTexVS;
		return vshader;
	},
	createShaderDefinition: function (device, options) {
		let vshader = "";
		let fshader = precisionCode(device) + "\n";
		fshader += '#define PARTICLE\n';

		if (device.webgl2) {
			vshader += "#define GL2\n";
			fshader += "#define GL2\n";
		}

		vshader += "#define VERTEXSHADER\n";
		if (options.mesh) vshader += "#define USE_MESH\n";
		if (options.localSpace) vshader += "#define LOCAL_SPACE\n";
		if (options.screenSpace) vshader += "#define SCREEN_SPACE\n";
		if (options.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
		if (options.animTex) vshader += "\nuniform vec4 animTexParams;\n";
		if (options.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
		if (options.normal === 2) vshader += "\nvarying mat3 ParticleMat;\n";
		if (options.normal === 1) vshader += "\nvarying vec3 Normal;\n";
		if (options.soft) vshader += "\nvarying float vDepth;\n";
		const faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;

		if (!options.useCpu) {
			vshader += shaderChunks.particle_initVS;
			vshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
			if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
			vshader += shaderChunks.particleVS;
			if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
			if (options.animTex) vshader += this._animTex(options);
			if (options.wrap) vshader += shaderChunks.particle_wrapVS;
			if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
			vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
			if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
			if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
			if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
			vshader += shaderChunks.particle_endVS;
			if (options.soft > 0) vshader += shaderChunks.particle_softVS;
		} else {
			if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
			vshader += shaderChunks.particle_cpuVS;
			if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
			if (options.animTex) vshader += this._animTex(options);
			if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
			vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
			if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
			if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
			if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
			vshader += shaderChunks.particle_cpu_endVS;
			if (options.soft > 0) vshader += shaderChunks.particle_softVS;
		}

		vshader += "}\n";

		if (options.normal > 0) {
			if (options.normal === 1) {
				fshader += "\nvarying vec3 Normal;\n";
			} else if (options.normal === 2) {
				fshader += "\nvarying mat3 ParticleMat;\n";
			}

			fshader += "\nuniform vec3 lightCube[6];\n";
		}

		if (options.soft) fshader += "\nvarying float vDepth;\n";
		if (options.normal === 0 && options.fog === "none") options.srgb = false;
		fshader += gammaCode(options.gamma);
		fshader += tonemapCode(options.toneMap);

		if (options.fog === 'linear') {
			fshader += shaderChunks.fogLinearPS;
		} else if (options.fog === 'exp') {
			fshader += shaderChunks.fogExpPS;
		} else if (options.fog === 'exp2') {
			fshader += shaderChunks.fogExp2PS;
		} else {
			fshader += shaderChunks.fogNonePS;
		}

		if (options.normal === 2) fshader += "\nuniform sampler2D normalMap;\n";
		if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
		fshader += shaderChunks.particlePS;
		if (options.soft > 0) fshader += shaderChunks.particle_softPS;
		if (options.normal === 1) fshader += "\nvec3 normal = Normal;\n";
		if (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;
		if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
		if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;

		if (options.blend === BLEND_NORMAL) {
			fshader += shaderChunks.particle_blendNormalPS;
		} else if (options.blend === BLEND_ADDITIVE) {
			fshader += shaderChunks.particle_blendAddPS;
		} else if (options.blend === BLEND_MULTIPLICATIVE) {
			fshader += shaderChunks.particle_blendMultiplyPS;
		}

		fshader += shaderChunks.particle_endPS;
		const attributes = collectAttribs(vshader);
		return {
			attributes: attributes,
			vshader: vshader,
			fshader: fshader
		};
	}
};

const skybox = {
	generateKey: function (options) {
		return options.type === 'cubemap' ? `skybox-${options.type}-${options.rgbm}-${options.hdr}-${options.fixSeams}-${options.toneMapping}-${options.gamma}-${options.useIntensity}-${options.mip}` : `skybox-${options.type}-${options.encoding}-${options.useIntensity}-${options.gamma}-${options.toneMapping}`;
	},
	createShaderDefinition: function (device, options) {
		let fshader;

		if (options.type === 'cubemap') {
			const mip2size = [128, 64, 16, 8, 4, 2];
			fshader = precisionCode(device);
			fshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;
			fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
			fshader += gammaCode(options.gamma);
			fshader += tonemapCode(options.toneMapping);
			fshader += shaderChunks.decodePS;
			fshader += shaderChunks.rgbmPS;
			fshader += shaderChunks.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, options.rgbm ? "textureCubeRGBM" : options.hdr ? "textureCube" : "textureCubeSRGB").replace(/\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + "");
		} else {
			const decodeTable = {
				'rgbm': 'decodeRGBM',
				'rgbe': 'decodeRGBE',
				'linear': 'decodeLinear'
			};
			fshader = precisionCode(device);
			fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
			fshader += gammaCode(options.gamma);
			fshader += tonemapCode(options.toneMapping);
			fshader += shaderChunks.decodePS;
			fshader += shaderChunks.skyboxEnvPS.replace(/\$DECODE/g, decodeTable[options.encoding] || "decodeGamma");
		}

		return {
			attributes: {
				aPosition: SEMANTIC_POSITION
			},
			vshader: shaderChunks.skyboxVS,
			fshader: fshader
		};
	}
};

const oneDiv255 = 1 / 255;
const floatView = new Float32Array(1);
const int32View = new Int32Array(floatView.buffer);

class FloatPacking {
	static float2Half(value) {
		floatView[0] = value;
		const x = int32View[0];
		let bits = x >> 16 & 0x8000;
		let m = x >> 12 & 0x07ff;
		const e = x >> 23 & 0xff;

		if (e < 103) {
			return bits;
		}

		if (e > 142) {
			bits |= 0x7c00;
			bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
			return bits;
		}

		if (e < 113) {
			m |= 0x0800;
			bits |= (m >> 114 - e) + (m >> 113 - e & 1);
			return bits;
		}

		bits |= e - 112 << 10 | m >> 1;
		bits += m & 1;
		return bits;
	}

	static float2Bytes(value, array, offset, numBytes) {
		const enc1 = 255.0 * value % 1;
		array[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);

		if (numBytes > 1) {
			const enc2 = 65025.0 * value % 1;
			array[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);

			if (numBytes > 2) {
				const enc3 = 16581375.0 * value % 1;
				array[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);

				if (numBytes > 3) {
					array[offset + 3] = Math.round(enc3 * 255);
				}
			}
		}
	}

	static float2BytesRange(value, array, offset, min, max, numBytes) {
		value = math.clamp((value - min) / (max - min), 0, 1);
		FloatPacking.float2Bytes(value, array, offset, numBytes);
	}

	static float2MantissaExponent(value, array, offset, numBytes) {
		const exponent = Math.floor(Math.log2(Math.abs(value))) + 1;
		value /= Math.pow(2, exponent);
		FloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);
		array[offset + numBytes - 1] = Math.round(exponent + 127);
	}

}

let _pixelSizeTable = null;
let _blockSizeTable = null;

class Texture {
	constructor(graphicsDevice, options) {
		this.device = graphicsDevice;
		this.name = null;
		this._width = 4;
		this._height = 4;
		this._depth = 1;
		this._format = PIXELFORMAT_R8_G8_B8_A8;
		this.type = TEXTURETYPE_DEFAULT;
		this.projection = TEXTUREPROJECTION_NONE;
		this._cubemap = false;
		this._volume = false;
		this.fixCubemapSeams = false;
		this._flipY = false;
		this._premultiplyAlpha = false;
		this._isRenderTarget = false;
		this._mipmaps = true;
		this._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
		this._magFilter = FILTER_LINEAR;
		this._anisotropy = 1;
		this._addressU = ADDRESS_REPEAT;
		this._addressV = ADDRESS_REPEAT;
		this._addressW = ADDRESS_REPEAT;
		this._compareOnRead = false;
		this._compareFunc = FUNC_LESS;

		if (options !== undefined) {
			if (options.name !== undefined) {
				this.name = options.name;
			}

			this._width = options.width !== undefined ? options.width : this._width;
			this._height = options.height !== undefined ? options.height : this._height;
			this._format = options.format !== undefined ? options.format : this._format;

			if (options.hasOwnProperty('type')) {
				this.type = options.type;
			} else if (options.hasOwnProperty('rgbm')) {
				this.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			} else if (options.hasOwnProperty('swizzleGGGR')) {
				this.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}

			if (options.mipmaps !== undefined) {
				this._mipmaps = options.mipmaps;
			} else {
				this._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;
			}

			this._levels = options.levels;
			this._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;
			this.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;

			if (this._cubemap) {
				this.projection = TEXTUREPROJECTION_CUBE;
			} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
				this.projection = options.projection;
			}

			this._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;
			this._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;
			this._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;
			this._addressU = options.addressU !== undefined ? options.addressU : this._addressU;
			this._addressV = options.addressV !== undefined ? options.addressV : this._addressV;
			this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;
			this._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;
			this._flipY = options.flipY !== undefined ? options.flipY : this._flipY;
			this._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;

			if (graphicsDevice.webgl2) {
				this._depth = options.depth !== undefined ? options.depth : this._depth;
				this._volume = options.volume !== undefined ? options.volume : this._volume;
				this._addressW = options.addressW !== undefined ? options.addressW : this._addressW;
			}
		}

		this._compressed = this._format === PIXELFORMAT_DXT1 || this._format === PIXELFORMAT_DXT3 || this._format === PIXELFORMAT_DXT5 || this._format >= PIXELFORMAT_ETC1;
		this._invalid = false;
		this._lockedLevel = -1;

		if (!this._levels) {
			this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
		}

		this.dirtyAll();
		this._gpuSize = 0;
	}

	set minFilter(v) {
		if (this._minFilter !== v) {
			this._minFilter = v;
			this._parameterFlags |= 1;
		}
	}

	get minFilter() {
		return this._minFilter;
	}

	set magFilter(v) {
		if (this._magFilter !== v) {
			this._magFilter = v;
			this._parameterFlags |= 2;
		}
	}

	get magFilter() {
		return this._magFilter;
	}

	set addressU(v) {
		if (this._addressU !== v) {
			this._addressU = v;
			this._parameterFlags |= 4;
		}
	}

	get addressU() {
		return this._addressU;
	}

	set addressV(v) {
		if (this._addressV !== v) {
			this._addressV = v;
			this._parameterFlags |= 8;
		}
	}

	get addressV() {
		return this._addressV;
	}

	set addressW(addressW) {
		if (!this.device.webgl2) return;

		if (!this._volume) {
			return;
		}

		if (addressW !== this._addressW) {
			this._addressW = addressW;
			this._parameterFlags |= 16;
		}
	}

	get addressW() {
		return this._addressW;
	}

	set compareOnRead(v) {
		if (this._compareOnRead !== v) {
			this._compareOnRead = v;
			this._parameterFlags |= 32;
		}
	}

	get compareOnRead() {
		return this._compareOnRead;
	}

	set compareFunc(v) {
		if (this._compareFunc !== v) {
			this._compareFunc = v;
			this._parameterFlags |= 64;
		}
	}

	get compareFunc() {
		return this._compareFunc;
	}

	set anisotropy(v) {
		if (this._anisotropy !== v) {
			this._anisotropy = v;
			this._parameterFlags |= 128;
		}
	}

	get anisotropy() {
		return this._anisotropy;
	}

	set autoMipmap(v) {
		this._mipmaps = v;
	}

	get autoMipmap() {
		return this._mipmaps;
	}

	set mipmaps(v) {
		if (this._mipmaps !== v) {
			this._mipmaps = v;
			if (v) this._needsMipmapsUpload = true;
		}
	}

	get mipmaps() {
		return this._mipmaps;
	}

	get width() {
		return this._width;
	}

	get height() {
		return this._height;
	}

	get depth() {
		return this._depth;
	}

	get format() {
		return this._format;
	}

	get cubemap() {
		return this._cubemap;
	}

	get gpuSize() {
		const mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
		return Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
	}

	get volume() {
		return this._volume;
	}

	set flipY(flipY) {
		if (this._flipY !== flipY) {
			this._flipY = flipY;
			this._needsUpload = true;
		}
	}

	get flipY() {
		return this._flipY;
	}

	set premultiplyAlpha(premultiplyAlpha) {
		if (this._premultiplyAlpha !== premultiplyAlpha) {
			this._premultiplyAlpha = premultiplyAlpha;
			this._needsUpload = true;
		}
	}

	get premultiplyAlpha() {
		return this._premultiplyAlpha;
	}

	get pot() {
		return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
	}

	get encoding() {
		if (this.type === TEXTURETYPE_RGBM) {
			return 'rgbm';
		}

		if (this.type === TEXTURETYPE_RGBE) {
			return 'rgbe';
		}

		if (this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F) {
			return 'linear';
		}

		return 'srgb';
	}

	static calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
		if (!_pixelSizeTable) {
			_pixelSizeTable = [];
			_pixelSizeTable[PIXELFORMAT_A8] = 1;
			_pixelSizeTable[PIXELFORMAT_L8] = 1;
			_pixelSizeTable[PIXELFORMAT_L8_A8] = 2;
			_pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;
			_pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;
			_pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;
			_pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;
			_pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;
			_pixelSizeTable[PIXELFORMAT_RGB16F] = 8;
			_pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;
			_pixelSizeTable[PIXELFORMAT_RGB32F] = 16;
			_pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;
			_pixelSizeTable[PIXELFORMAT_R32F] = 4;
			_pixelSizeTable[PIXELFORMAT_DEPTH] = 4;
			_pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;
			_pixelSizeTable[PIXELFORMAT_111110F] = 4;
			_pixelSizeTable[PIXELFORMAT_SRGB] = 4;
			_pixelSizeTable[PIXELFORMAT_SRGBA] = 4;
		}

		if (!_blockSizeTable) {
			_blockSizeTable = [];
			_blockSizeTable[PIXELFORMAT_ETC1] = 8;
			_blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;
			_blockSizeTable[PIXELFORMAT_DXT1] = 8;
			_blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;
			_blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;
			_blockSizeTable[PIXELFORMAT_DXT3] = 16;
			_blockSizeTable[PIXELFORMAT_DXT5] = 16;
			_blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;
			_blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;
		}

		const pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;
		const blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;
		let result = 0;

		while (1) {
			if (pixelSize > 0) {
				result += width * height * depth * pixelSize;
			} else {
				let blockWidth = Math.floor((width + 3) / 4);
				const blockHeight = Math.floor((height + 3) / 4);
				const blockDepth = Math.floor((depth + 3) / 4);

				if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
					blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
				}

				result += blockWidth * blockHeight * blockDepth * blockSize;
			}

			if (!mipmaps || width === 1 && height === 1 && depth === 1) {
				break;
			}

			width = Math.max(Math.floor(width / 2), 1);
			height = Math.max(Math.floor(height / 2), 1);
			depth = Math.max(Math.floor(depth / 2), 1);
		}

		return result * (cubemap ? 6 : 1);
	}

	destroy() {
		if (this.device) {
			this.device.destroyTexture(this);
		}

		this.device = null;
		this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
	}

	dirtyAll() {
		this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
		this._needsUpload = true;
		this._needsMipmapsUpload = this._mipmaps;
		this._mipmapsUploaded = false;
		this._parameterFlags = 255;
	}

	lock(options = {}) {
		if (options.level === undefined) {
			options.level = 0;
		}

		if (options.face === undefined) {
			options.face = 0;
		}

		if (options.mode === undefined) {
			options.mode = TEXTURELOCK_WRITE;
		}

		this._lockedLevel = options.level;

		if (this._levels[options.level] === null) {
			switch (this._format) {
				case PIXELFORMAT_A8:
				case PIXELFORMAT_L8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
					break;

				case PIXELFORMAT_L8_A8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);
					break;

				case PIXELFORMAT_R5_G6_B5:
				case PIXELFORMAT_R5_G5_B5_A1:
				case PIXELFORMAT_R4_G4_B4_A4:
					this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
					break;

				case PIXELFORMAT_R8_G8_B8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
					break;

				case PIXELFORMAT_R8_G8_B8_A8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
					break;

				case PIXELFORMAT_DXT1:
					this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
					break;

				case PIXELFORMAT_DXT3:
				case PIXELFORMAT_DXT5:
					this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
					break;

				case PIXELFORMAT_RGB16F:
					this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
					break;

				case PIXELFORMAT_RGB32F:
					this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
					break;

				case PIXELFORMAT_RGBA16F:
					this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
					break;

				case PIXELFORMAT_RGBA32F:
					this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
					break;
			}
		}

		return this._levels[options.level];
	}

	setSource(source, mipLevel = 0) {
		let invalid = false;
		let width, height;

		if (this._cubemap) {
			if (source[0]) {
				width = source[0].width || 0;
				height = source[0].height || 0;

				for (let i = 0; i < 6; i++) {
					const face = source[i];

					if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
						invalid = true;
						break;
					}
				}
			} else {
				invalid = true;
			}

			if (!invalid) {
				for (let i = 0; i < 6; i++) {
					if (this._levels[mipLevel][i] !== source[i]) this._levelsUpdated[mipLevel][i] = true;
				}
			}
		} else {
			if (!this.device._isBrowserInterface(source)) invalid = true;

			if (!invalid) {
				if (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;
				width = source.width;
				height = source.height;
			}
		}

		if (invalid) {
			this._width = 4;
			this._height = 4;

			if (this._cubemap) {
				for (let i = 0; i < 6; i++) {
					this._levels[mipLevel][i] = null;
					this._levelsUpdated[mipLevel][i] = true;
				}
			} else {
				this._levels[mipLevel] = null;
				this._levelsUpdated[mipLevel] = true;
			}
		} else {
			if (mipLevel === 0) {
				this._width = width;
				this._height = height;
			}

			this._levels[mipLevel] = source;
		}

		if (this._invalid !== invalid || !invalid) {
			this._invalid = invalid;
			this.upload();
		}
	}

	getSource(mipLevel = 0) {
		return this._levels[mipLevel];
	}

	unlock() {
		if (this._lockedLevel === -1) ;

		this.upload();
		this._lockedLevel = -1;
	}

	upload() {
		this._needsUpload = true;
		this._needsMipmapsUpload = this._mipmaps;
	}

	getDds() {
		let fsize = 128;
		let idx = 0;

		while (this._levels[idx]) {
			if (!this.cubemap) {
				const mipSize = this._levels[idx].length;

				if (!mipSize) {
					return;
				}

				fsize += mipSize;
			} else {
				for (let face = 0; face < 6; face++) {
					if (!this._levels[idx][face]) {
						return;
					}

					const mipSize = this._levels[idx][face].length;

					if (!mipSize) {
						return;
					}

					fsize += mipSize;
				}
			}

			fsize += this._levels[idx].length;
			idx++;
		}

		const buff = new ArrayBuffer(fsize);
		const header = new Uint32Array(buff, 0, 128 / 4);
		const DDS_MAGIC = 542327876;
		const DDS_HEADER_SIZE = 124;
		const DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;
		const DDS_FLAGS_MIPMAP = 0x20000;
		const DDS_PIXELFORMAT_SIZE = 32;
		const DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;
		const DDS_CAPS_REQUIRED = 0x1000;
		const DDS_CAPS_MIPMAP = 0x400000;
		const DDS_CAPS_COMPLEX = 0x8;
		const DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;
		let flags = DDS_FLAGS_REQUIRED;
		if (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;
		let caps = DDS_CAPS_REQUIRED;
		if (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;
		if (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;
		const caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;
		header[0] = DDS_MAGIC;
		header[1] = DDS_HEADER_SIZE;
		header[2] = flags;
		header[3] = this.height;
		header[4] = this.width;
		header[5] = this.width * this.height * 4;
		header[6] = 0;
		header[7] = this._levels.length;

		for (let i = 0; i < 11; i++) {
			header[8 + i] = 0;
		}

		header[19] = DDS_PIXELFORMAT_SIZE;
		header[20] = DDS_PIXELFLAGS_RGBA8;
		header[21] = 0;
		header[22] = 32;
		header[23] = 0x00FF0000;
		header[24] = 0x0000FF00;
		header[25] = 0x000000FF;
		header[26] = 0xFF000000;
		header[27] = caps;
		header[28] = caps2;
		header[29] = 0;
		header[30] = 0;
		header[31] = 0;
		let offset = 128;

		if (!this.cubemap) {
			for (let i = 0; i < this._levels.length; i++) {
				const level = this._levels[i];
				const mip = new Uint8Array(buff, offset, level.length);

				for (let j = 0; j < level.length; j++) {
					mip[j] = level[j];
				}

				offset += level.length;
			}
		} else {
			for (let face = 0; face < 6; face++) {
				for (let i = 0; i < this._levels.length; i++) {
					const level = this._levels[i][face];
					const mip = new Uint8Array(buff, offset, level.length);

					for (let j = 0; j < level.length; j++) {
						mip[j] = level[j];
					}

					offset += level.length;
				}
			}
		}

		return buff;
	}

}

const _deviceCoord = new Vec3();

const _halfSize = new Vec3();

const _point = new Vec3();

const _invViewProjMat = new Mat4();

class Camera {
	constructor() {
		this._aspectRatio = 16 / 9;
		this._aspectRatioMode = ASPECT_AUTO;
		this._calculateProjection = null;
		this._calculateTransform = null;
		this._clearColor = new Color(0.75, 0.75, 0.75, 1);
		this._clearColorBuffer = true;
		this._clearDepth = 1;
		this._clearDepthBuffer = true;
		this._clearStencil = 0;
		this._clearStencilBuffer = true;
		this._cullingMask = 0xFFFFFFFF;
		this._cullFaces = true;
		this._farClip = 1000;
		this._flipFaces = false;
		this._fov = 45;
		this._frustumCulling = true;
		this._horizontalFov = false;
		this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
		this._nearClip = 0.1;
		this._node = null;
		this._orthoHeight = 10;
		this._projection = PROJECTION_PERSPECTIVE;
		this._rect = new Vec4(0, 0, 1, 1);
		this._renderTarget = null;
		this._scissorRect = new Vec4(0, 0, 1, 1);
		this._scissorRectClear = false;
		this._vrDisplay = null;
		this._projMat = new Mat4();
		this._projMatDirty = true;
		this._projMatSkybox = new Mat4();
		this._viewMat = new Mat4();
		this._viewMatDirty = true;
		this._viewProjMat = new Mat4();
		this._viewProjMatDirty = true;
		this.frustum = new Frustum();
	}

	set aspectRatio(newValue) {
		if (this._aspectRatio !== newValue) {
			this._aspectRatio = newValue;
			this._projMatDirty = true;
		}
	}

	get aspectRatio() {
		return this._aspectRatio;
	}

	set aspectRatioMode(newValue) {
		if (this._aspectRatioMode !== newValue) {
			this._aspectRatioMode = newValue;
			this._projMatDirty = true;
		}
	}

	get aspectRatioMode() {
		return this._aspectRatioMode;
	}

	set calculateProjection(newValue) {
		this._calculateProjection = newValue;
		this._projMatDirty = true;
	}

	get calculateProjection() {
		return this._calculateProjection;
	}

	set calculateTransform(newValue) {
		this._calculateTransform = newValue;
	}

	get calculateTransform() {
		return this._calculateTransform;
	}

	set clearColor(newValue) {
		this._clearColor.copy(newValue);
	}

	get clearColor() {
		return this._clearColor;
	}

	set clearColorBuffer(newValue) {
		this._clearColorBuffer = newValue;
	}

	get clearColorBuffer() {
		return this._clearColorBuffer;
	}

	set clearDepth(newValue) {
		this._clearDepth = newValue;
	}

	get clearDepth() {
		return this._clearDepth;
	}

	set clearDepthBuffer(newValue) {
		this._clearDepthBuffer = newValue;
	}

	get clearDepthBuffer() {
		return this._clearDepthBuffer;
	}

	set clearStencil(newValue) {
		this._clearStencil = newValue;
	}

	get clearStencil() {
		return this._clearStencil;
	}

	set clearStencilBuffer(newValue) {
		this._clearStencilBuffer = newValue;
	}

	get clearStencilBuffer() {
		return this._clearStencilBuffer;
	}

	set cullingMask(newValue) {
		this._cullingMask = newValue;
	}

	get cullingMask() {
		return this._cullingMask;
	}

	set cullFaces(newValue) {
		this._cullFaces = newValue;
	}

	get cullFaces() {
		return this._cullFaces;
	}

	set farClip(newValue) {
		if (this._farClip !== newValue) {
			this._farClip = newValue;
			this._projMatDirty = true;
		}
	}

	get farClip() {
		return this._farClip;
	}

	set flipFaces(newValue) {
		this._flipFaces = newValue;
	}

	get flipFaces() {
		return this._flipFaces;
	}

	set fov(newValue) {
		if (this._fov !== newValue) {
			this._fov = newValue;
			this._projMatDirty = true;
		}
	}

	get fov() {
		return this._fov;
	}

	set frustumCulling(newValue) {
		this._frustumCulling = newValue;
	}

	get frustumCulling() {
		return this._frustumCulling;
	}

	set horizontalFov(newValue) {
		if (this._horizontalFov !== newValue) {
			this._horizontalFov = newValue;
			this._projMatDirty = true;
		}
	}

	get horizontalFov() {
		return this._horizontalFov;
	}

	set layers(newValue) {
		this._layers = newValue.slice(0);
	}

	get layers() {
		return this._layers;
	}

	set nearClip(newValue) {
		if (this._nearClip !== newValue) {
			this._nearClip = newValue;
			this._projMatDirty = true;
		}
	}

	get nearClip() {
		return this._nearClip;
	}

	set node(newValue) {
		this._node = newValue;
	}

	get node() {
		return this._node;
	}

	set orthoHeight(newValue) {
		if (this._orthoHeight !== newValue) {
			this._orthoHeight = newValue;
			this._projMatDirty = true;
		}
	}

	get orthoHeight() {
		return this._orthoHeight;
	}

	set projection(newValue) {
		if (this._projection !== newValue) {
			this._projection = newValue;
			this._projMatDirty = true;
		}
	}

	get projection() {
		return this._projection;
	}

	get projectionMatrix() {
		this._evaluateProjectionMatrix();

		return this._projMat;
	}

	set rect(newValue) {
		this._rect.copy(newValue);
	}

	get rect() {
		return this._rect;
	}

	set renderTarget(newValue) {
		this._renderTarget = newValue;
	}

	get renderTarget() {
		return this._renderTarget;
	}

	set scissorRect(newValue) {
		this._scissorRect.copy(newValue);
	}

	get scissorRect() {
		return this._scissorRect;
	}

	get viewMatrix() {
		if (this._viewMatDirty) {
			const wtm = this._node.getWorldTransform();

			this._viewMat.copy(wtm).invert();

			this._viewMatDirty = false;
		}

		return this._viewMat;
	}

	set vrDisplay(newValue) {
		this._vrDisplay = newValue;

		if (newValue) {
			newValue._camera = this;
		}
	}

	get vrDisplay() {
		return this._vrDisplay;
	}

	clone() {
		return new Camera().copy(this);
	}

	copy(other) {
		this.aspectRatio = other.aspectRatio;
		this.aspectRatioMode = other.aspectRatioMode;
		this.calculateProjection = other.calculateProjection;
		this.calculateTransform = other.calculateTransform;
		this.clearColor = other.clearColor;
		this.clearColorBuffer = other.clearColorBuffer;
		this.clearDepth = other.clearDepth;
		this.clearDepthBuffer = other.clearDepthBuffer;
		this.clearStencil = other.clearStencil;
		this.clearStencilBuffer = other.clearStencilBuffer;
		this.cullFaces = other.cullFaces;
		this.cullingMask = other.cullingMask;
		this.farClip = other.farClip;
		this.flipFaces = other.flipFaces;
		this.fov = other.fov;
		this.frustumCulling = other.frustumCulling;
		this.horizontalFov = other.horizontalFov;
		this.layers = other.layers;
		this.nearClip = other.nearClip;
		this.orthoHeight = other.orthoHeight;
		this.projection = other.projection;
		this.rect = other.rect;
		this.renderTarget = other.renderTarget;
		this.scissorRect = other.scissorRect;
		this.vrDisplay = other.vrDisplay;
		return this;
	}

	_updateViewProjMat() {
		if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
			this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);

			this._viewProjMatDirty = false;
		}
	}

	worldToScreen(worldCoord, cw, ch, screenCoord = new Vec3()) {
		this._updateViewProjMat();

		this._viewProjMat.transformPoint(worldCoord, screenCoord);

		const vpm = this._viewProjMat.data;
		const w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
		screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
		screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
		return screenCoord;
	}

	screenToWorld(x, y, z, cw, ch, worldCoord = new Vec3()) {
		const range = this._farClip - this._nearClip;

		_deviceCoord.set(x / cw, (ch - y) / ch, z / range);

		_deviceCoord.mulScalar(2);

		_deviceCoord.sub(Vec3.ONE);

		if (this._projection === PROJECTION_PERSPECTIVE) {
			Mat4._getPerspectiveHalfSize(_halfSize, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov);

			_halfSize.x *= _deviceCoord.x;
			_halfSize.y *= _deviceCoord.y;

			const invView = this._node.getWorldTransform();

			_halfSize.z = -this._nearClip;
			invView.transformPoint(_halfSize, _point);

			const cameraPos = this._node.getPosition();

			worldCoord.sub2(_point, cameraPos);
			worldCoord.normalize();
			worldCoord.mulScalar(z);
			worldCoord.add(cameraPos);
		} else {
			this._updateViewProjMat();

			_invViewProjMat.copy(this._viewProjMat).invert();

			_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
		}

		return worldCoord;
	}

	_evaluateProjectionMatrix() {
		if (this._projMatDirty) {
			if (this._projection === PROJECTION_PERSPECTIVE) {
				this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);

				this._projMatSkybox.copy(this._projMat);
			} else {
				const y = this._orthoHeight;
				const x = y * this._aspectRatio;

				this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);

				this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);
			}

			this._projMatDirty = false;
		}
	}

	getProjectionMatrixSkybox() {
		this._evaluateProjectionMatrix();

		return this._projMatSkybox;
	}

	getScreenSize(sphere) {
		if (this._projection === PROJECTION_PERSPECTIVE) {
			const distance = this._node.getPosition().distance(sphere.center);

			if (distance < sphere.radius) {
				return 1;
			}

			const viewAngle = Math.asin(sphere.radius / distance);
			const sphereViewHeight = Math.tan(viewAngle);
			const screenViewHeight = Math.tan(this._fov / 2 * math.DEG_TO_RAD);
			return Math.min(sphereViewHeight / screenViewHeight, 1);
		}

		return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
	}

}

const scaleCompensatePosTransform = new Mat4();
const scaleCompensatePos = new Vec3();
const scaleCompensateRot = new Quat();
const scaleCompensateRot2 = new Quat();
const scaleCompensateScale = new Vec3();
const scaleCompensateScaleForParent = new Vec3();
const tmpMat4 = new Mat4();
const tmpQuat = new Quat();
const position$1 = new Vec3();
const invParentWtm$1 = new Mat4();
const rotation = new Quat();
const invParentRot = new Quat();
const matrix = new Mat4();
const target = new Vec3();
const up = new Vec3();

class GraphNode extends EventHandler {
	constructor(name = 'Untitled') {
		super();
		this.name = name;
		this.tags = new Tags(this);
		this._labels = {};
		this.localPosition = new Vec3();
		this.localRotation = new Quat();
		this.localScale = new Vec3(1, 1, 1);
		this.localEulerAngles = new Vec3();
		this.position = new Vec3();
		this.rotation = new Quat();
		this.eulerAngles = new Vec3();
		this._scale = null;
		this.localTransform = new Mat4();
		this._dirtyLocal = false;
		this._aabbVer = 0;
		this._frozen = false;
		this.worldTransform = new Mat4();
		this._dirtyWorld = false;
		this.normalMatrix = new Mat3();
		this._dirtyNormal = true;
		this._right = null;
		this._up = null;
		this._forward = null;
		this._parent = null;
		this._children = [];
		this._graphDepth = 0;
		this._enabled = true;
		this._enabledInHierarchy = false;
		this.scaleCompensation = false;
	}

	get right() {
		if (!this._right) {
			this._right = new Vec3();
		}

		return this.getWorldTransform().getX(this._right).normalize();
	}

	get up() {
		if (!this._up) {
			this._up = new Vec3();
		}

		return this.getWorldTransform().getY(this._up).normalize();
	}

	get forward() {
		if (!this._forward) {
			this._forward = new Vec3();
		}

		return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
	}

	set enabled(enabled) {
		if (this._enabled !== enabled) {
			this._enabled = enabled;
			if (!this._parent || this._parent.enabled) this._notifyHierarchyStateChanged(this, enabled);
		}
	}

	get enabled() {
		return this._enabled && this._enabledInHierarchy;
	}

	get parent() {
		return this._parent;
	}

	get path() {
		let node = this._parent;

		if (!node) {
			return '';
		}

		let result = this.name;

		while (node && node._parent) {
			result = `${node.name}/${result}`;
			node = node._parent;
		}

		return result;
	}

	get root() {
		let result = this;

		while (result._parent) {
			result = result._parent;
		}

		return result;
	}

	get children() {
		return this._children;
	}

	get graphDepth() {
		return this._graphDepth;
	}

	_notifyHierarchyStateChanged(node, enabled) {
		node._onHierarchyStateChanged(enabled);

		const c = node._children;

		for (let i = 0, len = c.length; i < len; i++) {
			if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
		}
	}

	_onHierarchyStateChanged(enabled) {
		this._enabledInHierarchy = enabled;
		if (enabled && !this._frozen) this._unfreezeParentToRoot();
	}

	_cloneInternal(clone) {
		clone.name = this.name;
		const tags = this.tags._list;
		clone.tags.clear();

		for (let i = 0; i < tags.length; i++) clone.tags.add(tags[i]);

		clone._labels = Object.assign({}, this._labels);
		clone.localPosition.copy(this.localPosition);
		clone.localRotation.copy(this.localRotation);
		clone.localScale.copy(this.localScale);
		clone.localEulerAngles.copy(this.localEulerAngles);
		clone.position.copy(this.position);
		clone.rotation.copy(this.rotation);
		clone.eulerAngles.copy(this.eulerAngles);
		clone.localTransform.copy(this.localTransform);
		clone._dirtyLocal = this._dirtyLocal;
		clone.worldTransform.copy(this.worldTransform);
		clone._dirtyWorld = this._dirtyWorld;
		clone._dirtyNormal = this._dirtyNormal;
		clone._aabbVer = this._aabbVer + 1;
		clone._enabled = this._enabled;
		clone.scaleCompensation = this.scaleCompensation;
		clone._enabledInHierarchy = false;
	}

	clone() {
		const clone = new GraphNode();

		this._cloneInternal(clone);

		return clone;
	}

	copy(source) {
		source._cloneInternal(this);

		return this;
	}

	find(attr, value) {
		let result,
				results = [];
		const len = this._children.length;

		if (attr instanceof Function) {
			const fn = attr;
			result = fn(this);
			if (result) results.push(this);

			for (let i = 0; i < len; i++) {
				const descendants = this._children[i].find(fn);

				if (descendants.length) results = results.concat(descendants);
			}
		} else {
			let testValue;

			if (this[attr]) {
				if (this[attr] instanceof Function) {
					testValue = this[attr]();
				} else {
					testValue = this[attr];
				}

				if (testValue === value) results.push(this);
			}

			for (let i = 0; i < len; ++i) {
				const descendants = this._children[i].find(attr, value);

				if (descendants.length) results = results.concat(descendants);
			}
		}

		return results;
	}

	findOne(attr, value) {
		const len = this._children.length;
		let result = null;

		if (attr instanceof Function) {
			const fn = attr;
			result = fn(this);
			if (result) return this;

			for (let i = 0; i < len; i++) {
				result = this._children[i].findOne(fn);
				if (result) return result;
			}
		} else {
			let testValue;

			if (this[attr]) {
				if (this[attr] instanceof Function) {
					testValue = this[attr]();
				} else {
					testValue = this[attr];
				}

				if (testValue === value) {
					return this;
				}
			}

			for (let i = 0; i < len; i++) {
				result = this._children[i].findOne(attr, value);
				if (result !== null) return result;
			}
		}

		return null;
	}

	findByTag() {
		const query = arguments;
		const results = [];

		const queryNode = (node, checkNode) => {
			if (checkNode && node.tags.has(...query)) {
				results.push(node);
			}

			for (let i = 0; i < node._children.length; i++) {
				queryNode(node._children[i], true);
			}
		};

		queryNode(this, false);
		return results;
	}

	findByName(name) {
		if (this.name === name) return this;

		for (let i = 0; i < this._children.length; i++) {
			const found = this._children[i].findByName(name);

			if (found !== null) return found;
		}

		return null;
	}

	findByPath(path) {
		const parts = Array.isArray(path) ? path : path.split('/');
		let result = this;

		for (let i = 0, imax = parts.length; i < imax; ++i) {
			result = result.children.find(c => c.name === parts[i]);

			if (!result) {
				return null;
			}
		}

		return result;
	}

	forEach(callback, thisArg) {
		callback.call(thisArg, this);
		const children = this._children;

		for (let i = 0; i < children.length; i++) {
			children[i].forEach(callback, thisArg);
		}
	}

	isDescendantOf(node) {
		let parent = this._parent;

		while (parent) {
			if (parent === node) return true;
			parent = parent._parent;
		}

		return false;
	}

	isAncestorOf(node) {
		return node.isDescendantOf(this);
	}

	getEulerAngles() {
		this.getWorldTransform().getEulerAngles(this.eulerAngles);
		return this.eulerAngles;
	}

	getLocalEulerAngles() {
		this.localRotation.getEulerAngles(this.localEulerAngles);
		return this.localEulerAngles;
	}

	getLocalPosition() {
		return this.localPosition;
	}

	getLocalRotation() {
		return this.localRotation;
	}

	getLocalScale() {
		return this.localScale;
	}

	getLocalTransform() {
		if (this._dirtyLocal) {
			this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
			this._dirtyLocal = false;
		}

		return this.localTransform;
	}

	getPosition() {
		this.getWorldTransform().getTranslation(this.position);
		return this.position;
	}

	getRotation() {
		this.rotation.setFromMat4(this.getWorldTransform());
		return this.rotation;
	}

	getScale() {
		if (!this._scale) {
			this._scale = new Vec3();
		}

		return this.getWorldTransform().getScale(this._scale);
	}

	getWorldTransform() {
		if (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;
		if (this._parent) this._parent.getWorldTransform();

		this._sync();

		return this.worldTransform;
	}

	reparent(parent, index) {
		const current = this._parent;
		if (current) current.removeChild(this);

		if (parent) {
			if (index >= 0) {
				parent.insertChild(this, index);
			} else {
				parent.addChild(this);
			}
		}
	}

	setLocalEulerAngles(x, y, z) {
		if (x instanceof Vec3) {
			this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			this.localRotation.setFromEulerAngles(x, y, z);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setLocalPosition(x, y, z) {
		if (x instanceof Vec3) {
			this.localPosition.copy(x);
		} else {
			this.localPosition.set(x, y, z);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setLocalRotation(x, y, z, w) {
		if (x instanceof Quat) {
			this.localRotation.copy(x);
		} else {
			this.localRotation.set(x, y, z, w);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setLocalScale(x, y, z) {
		if (x instanceof Vec3) {
			this.localScale.copy(x);
		} else {
			this.localScale.set(x, y, z);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	_dirtifyLocal() {
		if (!this._dirtyLocal) {
			this._dirtyLocal = true;
			if (!this._dirtyWorld) this._dirtifyWorld();
		}
	}

	_unfreezeParentToRoot() {
		let p = this._parent;

		while (p) {
			p._frozen = false;
			p = p._parent;
		}
	}

	_dirtifyWorld() {
		if (!this._dirtyWorld) this._unfreezeParentToRoot();

		this._dirtifyWorldInternal();
	}

	_dirtifyWorldInternal() {
		if (!this._dirtyWorld) {
			this._frozen = false;
			this._dirtyWorld = true;

			for (let i = 0; i < this._children.length; i++) {
				if (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();
			}
		}

		this._dirtyNormal = true;
		this._aabbVer++;
	}

	setPosition(x, y, z) {
		if (x instanceof Vec3) {
			position$1.copy(x);
		} else {
			position$1.set(x, y, z);
		}

		if (this._parent === null) {
			this.localPosition.copy(position$1);
		} else {
			invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
			invParentWtm$1.transformPoint(position$1, this.localPosition);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setRotation(x, y, z, w) {
		if (x instanceof Quat) {
			rotation.copy(x);
		} else {
			rotation.set(x, y, z, w);
		}

		if (this._parent === null) {
			this.localRotation.copy(rotation);
		} else {
			const parentRot = this._parent.getRotation();

			invParentRot.copy(parentRot).invert();
			this.localRotation.copy(invParentRot).mul(rotation);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setEulerAngles(x, y, z) {
		if (x instanceof Vec3) {
			this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			this.localRotation.setFromEulerAngles(x, y, z);
		}

		if (this._parent !== null) {
			const parentRot = this._parent.getRotation();

			invParentRot.copy(parentRot).invert();
			this.localRotation.mul2(invParentRot, this.localRotation);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	addChild(node) {
		if (node._parent !== null) throw new Error("GraphNode is already parented");

		this._children.push(node);

		this._onInsertChild(node);
	}

	addChildAndSaveTransform(node) {
		const wPos = node.getPosition();
		const wRot = node.getRotation();
		const current = node._parent;
		if (current) current.removeChild(node);
		node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
		node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));

		this._children.push(node);

		this._onInsertChild(node);
	}

	insertChild(node, index) {
		if (node._parent !== null) throw new Error("GraphNode is already parented");

		this._children.splice(index, 0, node);

		this._onInsertChild(node);
	}

	_fireOnHierarchy(name, nameHierarchy, parent) {
		this.fire(name, parent);

		for (let i = 0; i < this._children.length; i++) {
			this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
		}
	}

	_onInsertChild(node) {
		node._parent = this;
		const enabledInHierarchy = node._enabled && this.enabled;

		if (node._enabledInHierarchy !== enabledInHierarchy) {
			node._enabledInHierarchy = enabledInHierarchy;

			node._notifyHierarchyStateChanged(node, enabledInHierarchy);
		}

		node._updateGraphDepth();

		node._dirtifyWorld();

		if (this._frozen) node._unfreezeParentToRoot();

		node._fireOnHierarchy('insert', 'inserthierarchy', this);

		if (this.fire) this.fire('childinsert', node);
	}

	_updateGraphDepth() {
		this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;

		for (let i = 0, len = this._children.length; i < len; i++) {
			this._children[i]._updateGraphDepth();
		}
	}

	removeChild(child) {
		const index = this._children.indexOf(child);

		if (index === -1) {
			return;
		}

		this._children.splice(index, 1);

		child._parent = null;

		child._fireOnHierarchy('remove', 'removehierarchy', this);

		this.fire('childremove', child);
	}

	_sync() {
		if (this._dirtyLocal) {
			this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
			this._dirtyLocal = false;
		}

		if (this._dirtyWorld) {
			if (this._parent === null) {
				this.worldTransform.copy(this.localTransform);
			} else {
				if (this.scaleCompensation) {
					let parentWorldScale;
					const parent = this._parent;
					let scale = this.localScale;
					let parentToUseScaleFrom = parent;

					if (parentToUseScaleFrom) {
						while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
							parentToUseScaleFrom = parentToUseScaleFrom._parent;
						}

						if (parentToUseScaleFrom) {
							parentToUseScaleFrom = parentToUseScaleFrom._parent;

							if (parentToUseScaleFrom) {
								parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
								scaleCompensateScale.mul2(parentWorldScale, this.localScale);
								scale = scaleCompensateScale;
							}
						}
					}

					scaleCompensateRot2.setFromMat4(parent.worldTransform);
					scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
					let tmatrix = parent.worldTransform;

					if (parent.scaleCompensation) {
						scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
						scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
						tmatrix = scaleCompensatePosTransform;
					}

					tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
					this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
				} else {
					this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
				}
			}

			this._dirtyWorld = false;
		}
	}

	syncHierarchy() {
		if (!this._enabled) return;
		if (this._frozen) return;
		this._frozen = true;

		if (this._dirtyLocal || this._dirtyWorld) {
			this._sync();
		}

		const children = this._children;

		for (let i = 0, len = children.length; i < len; i++) {
			children[i].syncHierarchy();
		}
	}

	lookAt(x, y, z, ux = 0, uy = 1, uz = 0) {
		if (x instanceof Vec3) {
			target.copy(x);

			if (y instanceof Vec3) {
				up.copy(y);
			} else {
				up.copy(Vec3.UP);
			}
		} else if (z === undefined) {
			return;
		} else {
			target.set(x, y, z);
			up.set(ux, uy, uz);
		}

		matrix.setLookAt(this.getPosition(), target, up);
		rotation.setFromMat4(matrix);
		this.setRotation(rotation);
	}

	translate(x, y, z) {
		if (x instanceof Vec3) {
			position$1.copy(x);
		} else {
			position$1.set(x, y, z);
		}

		position$1.add(this.getPosition());
		this.setPosition(position$1);
	}

	translateLocal(x, y, z) {
		if (x instanceof Vec3) {
			position$1.copy(x);
		} else {
			position$1.set(x, y, z);
		}

		this.localRotation.transformVector(position$1, position$1);
		this.localPosition.add(position$1);
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	rotate(x, y, z) {
		if (x instanceof Vec3) {
			rotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			rotation.setFromEulerAngles(x, y, z);
		}

		if (this._parent === null) {
			this.localRotation.mul2(rotation, this.localRotation);
		} else {
			const rot = this.getRotation();

			const parentRot = this._parent.getRotation();

			invParentRot.copy(parentRot).invert();
			rotation.mul2(invParentRot, rotation);
			this.localRotation.mul2(rotation, rot);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	rotateLocal(x, y, z) {
		if (x instanceof Vec3) {
			rotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			rotation.setFromEulerAngles(x, y, z);
		}

		this.localRotation.mul(rotation);
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

}

const _viewMat = new Mat4();

const _viewProjMat = new Mat4();

const _viewportMatrix = new Mat4();

class LightCamera {
	static create(name, lightType, face) {
		const camera = new Camera();
		camera.node = new GraphNode(name);
		camera.aspectRatio = 1;
		camera.aspectRatioMode = ASPECT_MANUAL;
		camera._scissorRectClear = true;

		switch (lightType) {
			case LIGHTTYPE_OMNI:
				camera.node.setRotation(LightCamera.pointLightRotations[face]);
				camera.fov = 90;
				camera.projection = PROJECTION_PERSPECTIVE;
				break;

			case LIGHTTYPE_SPOT:
				camera.projection = PROJECTION_PERSPECTIVE;
				break;

			case LIGHTTYPE_DIRECTIONAL:
				camera.projection = PROJECTION_ORTHOGRAPHIC;
				break;
		}

		return camera;
	}

	static evalSpotCookieMatrix(light) {
		let cookieCamera = LightCamera._spotCookieCamera;

		if (!cookieCamera) {
			cookieCamera = LightCamera.create("SpotCookieCamera", LIGHTTYPE_SPOT);
			LightCamera._spotCookieCamera = cookieCamera;
		}

		cookieCamera.fov = light._outerConeAngle * 2;
		const cookieNode = cookieCamera._node;
		cookieNode.setPosition(light._node.getPosition());
		cookieNode.setRotation(light._node.getRotation());
		cookieNode.rotateLocal(-90, 0, 0);

		_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();

		_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);

		const cookieMatrix = light.cookieMatrix;
		const rectViewport = light.atlasViewport;

		_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);

		cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
		return cookieMatrix;
	}

}

LightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];
LightCamera._spotCookieCamera = null;

const epsilon$1 = 0.000001;
const tempVec3$1 = new Vec3();
const tempAreaLightSizes = new Float32Array(6);
const areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
const areaHalfAxisHeight = new Vec3(0, 0, 0.5);
const TextureIndex8 = {
	FLAGS: 0,
	COLOR_A: 1,
	COLOR_B: 2,
	SPOT_ANGLES: 3,
	SHADOW_BIAS: 4,
	COOKIE_A: 5,
	COOKIE_B: 6,
	COUNT_ALWAYS: 7,
	POSITION_X: 7,
	POSITION_Y: 8,
	POSITION_Z: 9,
	RANGE: 10,
	SPOT_DIRECTION_X: 11,
	SPOT_DIRECTION_Y: 12,
	SPOT_DIRECTION_Z: 13,
	PROJ_MAT_00: 14,
	ATLAS_VIEWPORT_A: 14,
	PROJ_MAT_01: 15,
	ATLAS_VIEWPORT_B: 15,
	PROJ_MAT_02: 16,
	PROJ_MAT_03: 17,
	PROJ_MAT_10: 18,
	PROJ_MAT_11: 19,
	PROJ_MAT_12: 20,
	PROJ_MAT_13: 21,
	PROJ_MAT_20: 22,
	PROJ_MAT_21: 23,
	PROJ_MAT_22: 24,
	PROJ_MAT_23: 25,
	PROJ_MAT_30: 26,
	PROJ_MAT_31: 27,
	PROJ_MAT_32: 28,
	PROJ_MAT_33: 29,
	AREA_DATA_WIDTH_X: 30,
	AREA_DATA_WIDTH_Y: 31,
	AREA_DATA_WIDTH_Z: 32,
	AREA_DATA_HEIGHT_X: 33,
	AREA_DATA_HEIGHT_Y: 34,
	AREA_DATA_HEIGHT_Z: 35,
	COUNT: 36
};
const TextureIndexFloat = {
	POSITION_RANGE: 0,
	SPOT_DIRECTION: 1,
	PROJ_MAT_0: 2,
	ATLAS_VIEWPORT: 2,
	PROJ_MAT_1: 3,
	PROJ_MAT_2: 4,
	PROJ_MAT_3: 5,
	AREA_DATA_WIDTH: 6,
	AREA_DATA_HEIGHT: 7,
	COUNT: 8
};

class LightsBuffer {
	static initShaderDefines() {
		const clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? "FLOAT" : "8BIT";
		LightsBuffer.shaderDefines = `
						\n#define CLUSTER_TEXTURE_${clusterTextureFormat}
						${LightsBuffer.buildShaderDefines(TextureIndex8, "CLUSTER_TEXTURE_8_")}
						${LightsBuffer.buildShaderDefines(TextureIndexFloat, "CLUSTER_TEXTURE_F_")}
				`;
	}

	static buildShaderDefines(object, prefix) {
		let str = "";
		Object.keys(object).forEach(key => {
			str += `\n#define ${prefix}${key} ${object[key]}.5`;
		});
		return str;
	}

	static init(device) {
		LightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;
		LightsBuffer.initShaderDefines();
	}

	static createTexture(device, width, height, format, name) {
		const tex = new Texture(device, {
			name: name,
			width: width,
			height: height,
			mipmaps: false,
			format: format,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			type: TEXTURETYPE_DEFAULT,
			magFilter: FILTER_NEAREST,
			minFilter: FILTER_NEAREST,
			anisotropy: 1
		});
		return tex;
	}

	constructor(device) {
		this.device = device;
		this.cookiesEnabled = false;
		this.shadowsEnabled = false;
		this.areaLightsEnabled = false;
		this.maxLights = 255;
		let pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;
		let pixelsPerLightFloat = 0;

		if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
			pixelsPerLightFloat = TextureIndexFloat.COUNT;
		} else {
			pixelsPerLight8 = TextureIndex8.COUNT;
		}

		this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);
		this.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_R8_G8_B8_A8, "LightsTexture8");
		this._lightsTexture8Id = this.device.scope.resolve("lightsTexture8");

		if (pixelsPerLightFloat) {
			this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
			this.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, "LightsTextureFloat");
			this._lightsTextureFloatId = this.device.scope.resolve("lightsTextureFloat");
		} else {
			this.lightsFloat = null;
			this.lightsTextureFloat = null;
			this._lightsTextureFloatId = undefined;
		}

		this._lightsTextureInvSizeId = this.device.scope.resolve("lightsTextureInvSize");
		this._lightsTextureInvSizeData = new Float32Array(4);
		this._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;
		this._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;
		this._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;
		this._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;
		this.invMaxColorValue = 0;
		this.invMaxAttenuation = 0;
		this.boundsMin = new Vec3();
		this.boundsDelta = new Vec3();
	}

	destroy() {
		if (this.lightsTexture8) {
			this.lightsTexture8.destroy();
			this.lightsTexture8 = null;
		}

		if (this.lightsTextureFloat) {
			this.lightsTextureFloat.destroy();
			this.lightsTextureFloat = null;
		}
	}

	setCompressionRanges(maxAttenuation, maxColorValue) {
		this.invMaxColorValue = 1 / maxColorValue;
		this.invMaxAttenuation = 1 / maxAttenuation;
	}

	setBounds(min, delta) {
		this.boundsMin.copy(min);
		this.boundsDelta.copy(delta);
	}

	uploadTextures() {
		if (this.lightsTextureFloat) {
			this.lightsTextureFloat.lock().set(this.lightsFloat);
			this.lightsTextureFloat.unlock();
		}

		this.lightsTexture8.lock().set(this.lights8);
		this.lightsTexture8.unlock();
	}

	updateUniforms() {
		this._lightsTexture8Id.setValue(this.lightsTexture8);

		if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
			this._lightsTextureFloatId.setValue(this.lightsTextureFloat);
		}

		this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);
	}

	getSpotDirection(direction, spot) {
		const mat = spot._node.getWorldTransform();

		mat.getY(direction).mulScalar(-1);
		direction.normalize();
	}

	getLightAreaSizes(light) {
		const mat = light._node.getWorldTransform();

		mat.transformVector(areaHalfAxisWidth, tempVec3$1);
		tempAreaLightSizes[0] = tempVec3$1.x;
		tempAreaLightSizes[1] = tempVec3$1.y;
		tempAreaLightSizes[2] = tempVec3$1.z;
		mat.transformVector(areaHalfAxisHeight, tempVec3$1);
		tempAreaLightSizes[3] = tempVec3$1.x;
		tempAreaLightSizes[4] = tempVec3$1.y;
		tempAreaLightSizes[5] = tempVec3$1.z;
		return tempAreaLightSizes;
	}

	addLightDataFlags(data8, index, light, isSpot, castShadows) {
		data8[index + 0] = isSpot ? 255 : 0;
		data8[index + 1] = light._shape * 64;
		data8[index + 2] = light._falloffMode * 255;
		data8[index + 3] = castShadows ? 255 : 0;
	}

	addLightDataColor(data8, index, light, gammaCorrection, isCookie) {
		const invMaxColorValue = this.invMaxColorValue;
		const color = gammaCorrection ? light._linearFinalColor : light._finalColor;
		FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);
		FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);
		FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);
		data8[index + 6] = isCookie ? 255 : 0;
		const isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);
		const isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);
		data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;
	}

	addLightDataSpotAngles(data8, index, light) {
		FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);
		FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);
	}

	addLightDataShadowBias(data8, index, light) {
		const lightRenderData = light.getRenderData(null, 0);

		const biases = light._getUniformBiasValues(lightRenderData);

		FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);
		FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);
	}

	addLightDataPositionRange(data8, index, light, pos) {
		const normPos = tempVec3$1.sub2(pos, this.boundsMin).div(this.boundsDelta);
		FloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);
		FloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);
		FloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);
		FloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);
	}

	addLightDataSpotDirection(data8, index, light) {
		this.getSpotDirection(tempVec3$1, light);
		FloatPacking.float2Bytes(tempVec3$1.x * (0.5 - epsilon$1) + 0.5, data8, index + 0, 4);
		FloatPacking.float2Bytes(tempVec3$1.y * (0.5 - epsilon$1) + 0.5, data8, index + 4, 4);
		FloatPacking.float2Bytes(tempVec3$1.z * (0.5 - epsilon$1) + 0.5, data8, index + 8, 4);
	}

	addLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {
		const matData = lightProjectionMatrix.data;

		for (let m = 0; m < 12; m++) FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);

		for (let m = 12; m < 16; m++) {
			FloatPacking.float2MantissaExponent(matData[m], data8, index + 4 * m, 4);
		}
	}

	addLightDataCookies(data8, index, light) {
		const isRgb = light._cookieChannel === "rgb";
		data8[index + 0] = Math.floor(light.cookieIntensity * 255);
		data8[index + 1] = isRgb ? 255 : 0;

		if (!isRgb) {
			const channel = light._cookieChannel;
			data8[index + 4] = channel === "rrr" ? 255 : 0;
			data8[index + 5] = channel === "ggg" ? 255 : 0;
			data8[index + 6] = channel === "bbb" ? 255 : 0;
			data8[index + 7] = channel === "aaa" ? 255 : 0;
		}
	}

	addLightAtlasViewport(data8, index, atlasViewport) {
		FloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);
		FloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);
		FloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);
	}

	addLightAreaSizes(data8, index, light) {
		const areaSizes = this.getLightAreaSizes(light);

		for (let i = 0; i < 6; i++) {
			FloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);
		}
	}

	addLightData(light, lightIndex, gammaCorrection) {
		const isSpot = light._type === LIGHTTYPE_SPOT;
		const hasAtlasViewport = light.atlasViewportAllocated;
		const isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
		const isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
		const castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;

		const pos = light._node.getPosition();

		let lightProjectionMatrix = null;
		let atlasViewport = null;

		if (isSpot) {
			if (castShadows) {
				const lightRenderData = light.getRenderData(null, 0);
				lightProjectionMatrix = lightRenderData.shadowMatrix;
			} else if (isCookie) {
				lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
			}
		} else {
			if (castShadows || isCookie) {
				atlasViewport = light.atlasViewport;
			}
		}

		const data8 = this.lights8;
		const data8Start = lightIndex * this.lightsTexture8.width * 4;
		this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows);
		this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);

		if (isSpot) {
			this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);
		}

		if (light.castShadows) {
			this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);
		}

		if (isCookie) {
			this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);
		}

		if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
			const dataFloat = this.lightsFloat;
			const dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;

			if (isSpot) {
				this.getSpotDirection(tempVec3$1, light);
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;
			}

			if (lightProjectionMatrix) {
				const matData = lightProjectionMatrix.data;

				for (let m = 0; m < 16; m++) dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
			}

			if (atlasViewport) {
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
			}

			if (isArea) {
				const areaSizes = this.getLightAreaSizes(light);
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
			}
		} else {
			this.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);

			if (isSpot) {
				this.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);
			}

			if (lightProjectionMatrix) {
				this.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);
			}

			if (atlasViewport) {
				this.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);
			}

			if (isArea) {
				this.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);
			}
		}
	}

}

LightsBuffer.FORMAT_FLOAT = 0;
LightsBuffer.FORMAT_8BIT = 1;
LightsBuffer.lightTextureFormat = LightsBuffer.FORMAT_8BIT;
LightsBuffer.shaderDefines = "";

const _matTex2D = [];
const decodeTable = {
	'rgbm': 'decodeRGBM',
	'rgbe': 'decodeRGBE',
	'linear': 'decodeLinear'
};
const standard = {
	optionsContext: {},
	optionsContextMin: {},
	generateKey: function (options) {
		const buildPropertiesList = function buildPropertiesList(options) {
			const props = [];

			for (const prop in options) {
				if (options.hasOwnProperty(prop) && prop !== "chunks" && prop !== "lights") props.push(prop);
			}

			return props.sort();
		};

		let props;

		if (options === this.optionsContextMin) {
			if (!this.propsMin) this.propsMin = buildPropertiesList(options);
			props = this.propsMin;
		} else if (options === this.optionsContext) {
			if (!this.props) this.props = buildPropertiesList(options);
			props = this.props;
		} else {
			props = buildPropertiesList(options);
		}

		let key = "standard";

		for (let i = 0; i < props.length; i++) {
			if (options[props[i]]) key += props[i] + options[props[i]];
		}

		if (options.chunks) {
			const chunks = [];

			for (const p in options.chunks) {
				if (options.chunks.hasOwnProperty(p)) {
					chunks.push(p + options.chunks[p]);
				}
			}

			chunks.sort();
			key += chunks;
		}

		if (options.lights) {
			const isClustered = options.clusteredLightingEnabled;

			for (let i = 0; i < options.lights.length; i++) {
				const light = options.lights[i];

				if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
					key += light.key;
				}
			}
		}

		return hashCode(key);
	},
	_correctChannel: function (p, chan) {
		if (_matTex2D[p] > 0) {
			if (_matTex2D[p] < chan.length) {
				return chan.substring(0, _matTex2D[p]);
			} else if (_matTex2D[p] > chan.length) {
				let str = chan;
				const chr = str.charAt(str.length - 1);
				const addLen = _matTex2D[p] - str.length;

				for (let i = 0; i < addLen; i++) str += chr;

				return str;
			}

			return chan;
		}
	},
	_setMapTransform: function (codes, name, id, uv) {
		const varName = `texture_${name}MapTransform`;
		const checkId = id + uv * 100;
		codes[0] += `uniform vec3 ${varName}0;\n`;
		codes[0] += `uniform vec3 ${varName}1;\n`;

		if (!codes[3][checkId]) {
			codes[1] += `varying vec2 vUV${uv}_${id};\n`;
			codes[2] += `	 vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));\n`;
			codes[3][checkId] = true;
		}

		return codes;
	},
	_getUvSourceExpression: function (transformPropName, uVPropName, options) {
		const transformId = options[transformPropName];
		const uvChannel = options[uVPropName];
		const isMainPass = options.pass === SHADER_FORWARD || options.pass === SHADER_FORWARDHDR;
		let expression;

		if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
			expression = "nineSlicedUv";
		} else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			expression = "nineSlicedUv, -1000.0";
		} else {
			if (transformId === 0) {
				expression = "vUv" + uvChannel;
			} else {
				expression = "vUV" + uvChannel + "_" + transformId;
			}

			if (options.heightMap && transformPropName !== "heightMapTransform") {
				expression += " + dUvOffset";
			}
		}

		return expression;
	},
	_addMapDef: function (name, enabled) {
		let s = "\n#undef " + name + "\n";
		if (enabled) s += " #define " + name + "\n";
		return s;
	},
	_addMapDefs: function (float, color, vertex, map) {
		let s = "";
		s += this._addMapDef("MAPFLOAT", float);
		s += this._addMapDef("MAPCOLOR", color);
		s += this._addMapDef("MAPVERTEX", vertex);
		s += this._addMapDef("MAPTEXTURE", map);
		return s;
	},
	_addMap: function (propName, chunkName, options, chunks, samplerFormat) {
		const mapPropName = propName + "Map";
		const uVPropName = mapPropName + "Uv";
		const transformPropName = mapPropName + "Transform";
		const channelPropName = mapPropName + "Channel";
		const vertexColorChannelPropName = propName + "VertexColorChannel";
		const tintPropName = propName + "Tint";
		const vertexColorPropName = propName + "VertexColor";
		const detailModePropName = propName + "Mode";
		const tintOption = options[tintPropName];
		const vertexColorOption = options[vertexColorPropName];
		const textureOption = options[mapPropName];
		const detailModeOption = options[detailModePropName];
		let subCode = chunks[chunkName];

		if (textureOption) {
			const uv = this._getUvSourceExpression(transformPropName, uVPropName, options);

			subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);

			if (samplerFormat !== undefined) {
				const fmt = samplerFormat === 0 ? "texture2DSRGB" : samplerFormat === 1 ? "texture2DRGBM" : "texture2D";
				subCode = subCode.replace(/\$texture2DSAMPLE/g, fmt);
			}
		}

		if (vertexColorOption) {
			subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
		}

		if (detailModeOption) {
			subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
		}

		const isFloatTint = !!(tintOption & 1);
		const isVecTint = !!(tintOption & 2);
		subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;
		return subCode.replace(/\$/g, "");
	},
	_directionalShadowMapProjection: function (light, shadowCoordArgs, shadowParamArg, lightIndex, coordsFunctioName) {
		let code = "";

		if (light.numCascades > 1) {
			code += `getShadowCascadeMatrix(light${lightIndex}_shadowMatrixPalette, light${lightIndex}_shadowCascadeDistances, light${lightIndex}_shadowCascadeCount);\n`;
			shadowCoordArgs = `(cascadeShadowMat, ${shadowParamArg});\n`;
		}

		code += coordsFunctioName + shadowCoordArgs;
		code += `fadeShadow(light${lightIndex}_shadowCascadeDistances);\n`;
		return code;
	},
	_nonPointShadowMapProjection: function (device, light, shadowMatArg, shadowParamArg, lightIndex) {
		const shadowCoordArgs = `(${shadowMatArg}, ${shadowParamArg});\n`;

		if (!light._normalOffsetBias || light._isVsm) {
			if (light._type === LIGHTTYPE_SPOT) {
				if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
					return "			 getShadowCoordPerspZbuffer" + shadowCoordArgs;
				}

				return "			 getShadowCoordPersp" + shadowCoordArgs;
			}

			return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrtho");
		}

		if (light._type === LIGHTTYPE_SPOT) {
			if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
				return "			 getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
			}

			return "			 getShadowCoordPerspNormalOffset" + shadowCoordArgs;
		}

		return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrthoNormalOffset");
	},
	_addVaryingIfNeeded: function (code, type, name) {
		return code.indexOf(name) >= 0 ? "varying " + type + " " + name + ";\n" : "";
	},
	_getLightSourceShapeString: function (shape) {
		switch (shape) {
			case LIGHTSHAPE_RECT:
				return 'Rect';

			case LIGHTSHAPE_DISK:
				return 'Disk';

			case LIGHTSHAPE_SPHERE:
				return 'Sphere';

			default:
				return '';
		}
	},
	_getPassDefineString: function (pass) {
		if (pass === SHADER_PICK) {
			return '#define PICK_PASS\n';
		} else if (pass === SHADER_DEPTH) {
			return '#define DEPTH_PASS\n';
		} else if (pass >= SHADER_SHADOW && pass <= 17) {
			return '#define SHADOW_PASS\n';
		}

		return '';
	},
	_vsAddTransformCode: function (code, device, chunks, options) {
		code += chunks.transformVS;
		return code;
	},
	_vsAddBaseCode: function (code, device, chunks, options) {
		code += chunks.baseVS;

		if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			code += chunks.baseNineSlicedVS;
		}

		return code;
	},
	_fsAddBaseCode: function (code, device, chunks, options) {
		code += chunks.basePS;

		if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
			code += chunks.baseNineSlicedPS;
		} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			code += chunks.baseNineSlicedTiledPS;
		}

		return code;
	},
	_decodeFunc: function (textureFormat) {
		return decodeTable[textureFormat] || 'decodeGamma';
	},
	_fsAddStartCode: function (code, device, chunks, options) {
		code += chunks.startPS;

		if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
			code += chunks.startNineSlicedPS;
		} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			code += chunks.startNineSlicedTiledPS;
		}

		return code;
	},
	_buildShadowPassFragmentCode: function (code, device, chunks, options, varyings) {
		const smode = options.pass - SHADER_SHADOW;
		const numShadowModes = SHADOW_COUNT;
		const lightType = Math.floor(smode / numShadowModes);
		const shadowType = smode - lightType * numShadowModes;

		if (device.extStandardDerivatives && !device.webgl2) {
			code += 'uniform vec2 polygonOffset;\n';
		}

		if (shadowType === SHADOW_VSM32) {
			if (device.textureFloatHighPrecision) {
				code += '#define VSM_EXPONENT 15.0\n\n';
			} else {
				code += '#define VSM_EXPONENT 5.54\n\n';
			}
		} else if (shadowType === SHADOW_VSM16) {
			code += '#define VSM_EXPONENT 5.54\n\n';
		}

		if (lightType !== LIGHTTYPE_DIRECTIONAL) {
			code += 'uniform vec3 view_position;\n';
			code += 'uniform float light_radius;\n';
		}

		code += varyings;

		if (options.alphaTest) {
			code += "float dAlpha;\n";
			code += this._addMap("opacity", "opacityPS", options, chunks);
			code += chunks.alphaTestPS;
		}

		if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI)) {
			code += chunks.packDepthPS;
		} else if (shadowType === SHADOW_VSM8) {
			code += "vec2 encodeFloatRG( float v ) {\n";
			code += "		vec2 enc = vec2(1.0, 255.0) * v;\n";
			code += "		enc = fract(enc);\n";
			code += "		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
			code += "		return enc;\n";
			code += "}\n\n";
		}

		code += begin();

		if (options.alphaTest) {
			code += "	 getOpacity();\n";
			code += "	 alphaTest(dAlpha);\n";
		}

		const isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;

		if (lightType === LIGHTTYPE_OMNI || isVsm && lightType !== LIGHTTYPE_DIRECTIONAL) {
			code += "	 float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
		} else {
			code += "	 float depth = gl_FragCoord.z;\n";
		}

		if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI && !options.clusteredLightingEnabled)) {
			if (device.extStandardDerivatives && !device.webgl2) {
				code += "	 float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
				code += "	 depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
				code += "	 gl_FragColor = packFloat(depth);\n";
			} else {
				code += "	 gl_FragColor = packFloat(depth);\n";
			}
		} else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {
			code += "	 gl_FragColor = vec4(1.0);\n";

			if (options.clusteredLightingEnabled && lightType === LIGHTTYPE_OMNI && device.webgl2) {
				code += "	 gl_FragDepth = depth;\n";
			}
		} else if (shadowType === SHADOW_VSM8) {
			code += "	 gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
		} else {
			code += chunks.storeEVSMPS;
		}

		code += end();
		return code;
	},
	createShaderDefinition: function (device, options) {
		let lighting = options.lights.length > 0;

		if (options.dirLightMap) {
			lighting = true;
		}

		if (options.clusteredLightingEnabled) {
			lighting = true;
		}

		if (options.shadingModel === SPECULAR_PHONG) {
			options.fresnelModel = 0;
			options.specularAntialias = false;
			options.ambientSH = false;
		} else {
			options.fresnelModel = options.fresnelModel === 0 ? FRESNEL_SCHLICK : options.fresnelModel;
		}

		const reflections = !!options.reflectionSource;
		if (!options.useSpecular) options.specularMap = options.glossMap = null;
		const shadowPass = options.pass >= SHADER_SHADOW && options.pass <= 17;
		const needsNormal = lighting || reflections || options.ambientSH || options.heightMap || options.enableGGXSpecular || options.clusteredLightingEnabled && !shadowPass || options.clearCoatNormalMap;
		this.options = options;
		let code = '';
		let codeBody = '';
		let varyings = "";
		let chunks = shaderChunks;
		let shadowCoordArgs;
		let chunk;
		const attributes = {
			vertex_position: SEMANTIC_POSITION
		};

		if (options.chunks) {
			const customChunks = {};

			for (const p in chunks) {
				if (chunks.hasOwnProperty(p)) {
					if (!options.chunks[p]) {
						customChunks[p] = chunks[p];
					} else {
						chunk = options.chunks[p];

						if (chunk.indexOf("vertex_normal") >= 0) {
							attributes.vertex_normal = SEMANTIC_NORMAL;
						}

						if (chunk.indexOf("vertex_tangent") >= 0) {
							attributes.vertex_tangent = SEMANTIC_TANGENT;
						}

						if (chunk.indexOf("vertex_texCoord0") >= 0) {
							attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
						}

						if (chunk.indexOf("vertex_texCoord1") >= 0) {
							attributes.vertex_texCoord1 = SEMANTIC_TEXCOORD1;
						}

						if (chunk.indexOf("vertex_color") >= 0) {
							attributes.vertex_color = SEMANTIC_COLOR;
						}

						if (chunk.indexOf("vertex_boneWeights") >= 0) {
							attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
						}

						if (chunk.indexOf("vertex_boneIndices") >= 0) {
							attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
						}

						customChunks[p] = chunk;
					}
				}
			}

			chunks = customChunks;
		}

		code += this._getPassDefineString(options.pass);
		code = this._vsAddBaseCode(code, device, chunks, options);
		codeBody += "	 vPositionW		= getWorldPosition();\n";

		if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += '#ifndef VIEWMATRIX\n';
			code += '#define VIEWMATRIX\n';
			code += 'uniform mat4 matrix_view;\n';
			code += '#endif\n';
			code += '#ifndef CAMERAPLANES\n';
			code += '#define CAMERAPLANES\n';
			code += 'uniform vec4 camera_params;\n\n';
			code += '#endif\n';
			codeBody += "		vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
		}

		if (options.useInstancing) {
			attributes.instance_line1 = SEMANTIC_ATTR12;
			attributes.instance_line2 = SEMANTIC_ATTR13;
			attributes.instance_line3 = SEMANTIC_ATTR14;
			attributes.instance_line4 = SEMANTIC_ATTR15;
			code += chunks.instancingVS;
		}

		if (needsNormal) {
			attributes.vertex_normal = SEMANTIC_NORMAL;
			codeBody += "	 vNormalW = getNormal();\n";

			if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {
				code += chunks.viewNormalVS;
				codeBody += "	 vNormalV		= getViewNormal();\n";
			}

			if ((options.heightMap || options.normalMap || options.enableGGXSpecular) && options.hasTangents) {
				attributes.vertex_tangent = SEMANTIC_TANGENT;
				code += chunks.tangentBinormalVS;
				codeBody += "	 vTangentW	 = getTangent();\n";
				codeBody += "	 vBinormalW	= getBinormal();\n";
			} else if (options.enableGGXSpecular) {
				code += chunks.tangentBinormalVS;
				codeBody += "	 vObjectSpaceUpW	= getObjectSpaceUp();\n";
			}
		}

		const useUv = [];
		const useUnmodifiedUv = [];
		const maxUvSets = 2;

		for (const p in _matTex2D) {
			const mname = p + "Map";

			if (options[p + "VertexColor"]) {
				const cname = p + "VertexColorChannel";
				options[cname] = this._correctChannel(p, options[cname]);
			}

			if (options[mname]) {
				const cname = mname + "Channel";
				const tname = mname + "Transform";
				const uname = mname + "Uv";
				options[uname] = Math.min(options[uname], maxUvSets - 1);
				options[cname] = this._correctChannel(p, options[cname]);
				const uvSet = options[uname];
				useUv[uvSet] = true;
				useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];
			}
		}

		if (options.forceUv1) {
			useUv[1] = true;
			useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
		}

		for (let i = 0; i < maxUvSets; i++) {
			if (useUv[i]) {
				attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
				code += chunks["uv" + i + "VS"];
				codeBody += "	 vec2 uv" + i + " = getUv" + i + "();\n";
			}

			if (useUnmodifiedUv[i]) {
				codeBody += "	 vUv" + i + " = uv" + i + ";\n";
			}
		}

		const codes = [code, varyings, codeBody, []];

		for (const p in _matTex2D) {
			const mname = p + "Map";

			if (options[mname]) {
				const tname = mname + "Transform";

				if (options[tname]) {
					const uname = mname + "Uv";

					this._setMapTransform(codes, p, options[tname], options[uname]);
				}
			}
		}

		code = codes[0];
		varyings = codes[1];
		codeBody = codes[2];

		if (options.vertexColors) {
			attributes.vertex_color = SEMANTIC_COLOR;
			codeBody += "	 vVertexColor = vertex_color;\n";
		}

		if (options.useMorphPosition || options.useMorphNormal) {
			if (options.useMorphTextureBased) {
				code += "#define MORPHING_TEXTURE_BASED\n";

				if (options.useMorphPosition) {
					code += "#define MORPHING_TEXTURE_BASED_POSITION\n";
				}

				if (options.useMorphNormal) {
					code += "#define MORPHING_TEXTURE_BASED_NORMAL\n";
				}

				attributes.morph_vertex_id = SEMANTIC_ATTR15;
				code += "attribute float morph_vertex_id;\n";
			} else {
				code += "#define MORPHING\n";

				if (options.useMorphPosition) {
					attributes.morph_pos0 = SEMANTIC_ATTR8;
					attributes.morph_pos1 = SEMANTIC_ATTR9;
					attributes.morph_pos2 = SEMANTIC_ATTR10;
					attributes.morph_pos3 = SEMANTIC_ATTR11;
					code += "#define MORPHING_POS03\n";
					code += "attribute vec3 morph_pos0;\n";
					code += "attribute vec3 morph_pos1;\n";
					code += "attribute vec3 morph_pos2;\n";
					code += "attribute vec3 morph_pos3;\n";
				} else if (options.useMorphNormal) {
					attributes.morph_nrm0 = SEMANTIC_ATTR8;
					attributes.morph_nrm1 = SEMANTIC_ATTR9;
					attributes.morph_nrm2 = SEMANTIC_ATTR10;
					attributes.morph_nrm3 = SEMANTIC_ATTR11;
					code += "#define MORPHING_NRM03\n";
					code += "attribute vec3 morph_nrm0;\n";
					code += "attribute vec3 morph_nrm1;\n";
					code += "attribute vec3 morph_nrm2;\n";
					code += "attribute vec3 morph_nrm3;\n";
				}

				if (!options.useMorphNormal) {
					attributes.morph_pos4 = SEMANTIC_ATTR12;
					attributes.morph_pos5 = SEMANTIC_ATTR13;
					attributes.morph_pos6 = SEMANTIC_ATTR14;
					attributes.morph_pos7 = SEMANTIC_ATTR15;
					code += "#define MORPHING_POS47\n";
					code += "attribute vec3 morph_pos4;\n";
					code += "attribute vec3 morph_pos5;\n";
					code += "attribute vec3 morph_pos6;\n";
					code += "attribute vec3 morph_pos7;\n";
				} else {
					attributes.morph_nrm4 = SEMANTIC_ATTR12;
					attributes.morph_nrm5 = SEMANTIC_ATTR13;
					attributes.morph_nrm6 = SEMANTIC_ATTR14;
					attributes.morph_nrm7 = SEMANTIC_ATTR15;
					code += "#define MORPHING_NRM47\n";
					code += "attribute vec3 morph_nrm4;\n";
					code += "attribute vec3 morph_nrm5;\n";
					code += "attribute vec3 morph_nrm6;\n";
					code += "attribute vec3 morph_nrm7;\n";
				}
			}
		}

		if (options.skin) {
			attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
			attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
			code += skinCode(device, chunks);
			code += "#define SKIN\n";
		} else if (options.useInstancing) {
			code += "#define INSTANCING\n";
		}

		if (options.screenSpace) {
			code += "#define SCREENSPACE\n";
		}

		if (options.pixelSnap) {
			code += "#define PIXELSNAP\n";
		}

		code = this._vsAddTransformCode(code, device, chunks, options);
		if (needsNormal) code += chunks.normalVS;
		code += "\n";
		code += chunks.startVS;
		code += codeBody;
		code += chunks.endVS;
		code += "}";
		let vshader = code;
		const oldVars = varyings;
		varyings = "";
		varyings += this._addVaryingIfNeeded(code, "vec4", "vVertexColor");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vPositionW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalV");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vTangentW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vBinormalW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vObjectSpaceUpW");
		varyings += this._addVaryingIfNeeded(code, "vec2", "vUv0");
		varyings += this._addVaryingIfNeeded(code, "vec2", "vUv1");
		varyings += oldVars;
		vshader = varyings + vshader;
		let startCode = "";

		if (device.webgl2) {
			startCode = versionCode(device);

			if (chunks.extensionVS) {
				startCode += chunks.extensionVS + "\n";
			}

			vshader = startCode + chunks.gles3VS + vshader;
		} else {
			if (chunks.extensionVS) {
				startCode = chunks.extensionVS + "\n";
			}

			vshader = startCode + vshader;
		}

		if (options.forceFragmentPrecision && options.forceFragmentPrecision !== "highp" && options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp") options.forceFragmentPrecision = null;

		if (options.forceFragmentPrecision) {
			if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") options.forceFragmentPrecision = "mediump";
			if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") options.forceFragmentPrecision = "lowp";
		}

		let fshader;
		code = '';

		if (device.webgl2) {
			code += versionCode(device);
		}

		if (!device.webgl2) {
			if (device.extStandardDerivatives) {
				code += "#extension GL_OES_standard_derivatives : enable\n";
			}

			if (device.extTextureLod) {
				code += "#extension GL_EXT_shader_texture_lod : enable\n";
				code += "#define SUPPORTS_TEXLOD\n";
			}
		}

		if (chunks.extensionPS) {
			code += chunks.extensionPS + "\n";
		}

		if (device.webgl2) {
			code += chunks.gles3PS;
		}

		code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : precisionCode(device);
		code += this._getPassDefineString(options.pass);

		if (options.pass === SHADER_PICK) {
			code += "uniform vec4 uColor;\n";
			code += varyings;

			if (options.alphaTest) {
				code += "float dAlpha;\n";
				code += this._addMap("opacity", "opacityPS", options, chunks);
				code += chunks.alphaTestPS;
			}

			code += begin();

			if (options.alphaTest) {
				code += "	 getOpacity();\n";
				code += "	 alphaTest(dAlpha);\n";
			}

			code += "		gl_FragColor = uColor;\n";
			code += end();
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: code
			};
		} else if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += varyings;
			code += chunks.packDepthPS;

			if (options.alphaTest) {
				code += "float dAlpha;\n";
				code += this._addMap("opacity", "opacityPS", options, chunks);
				code += chunks.alphaTestPS;
			}

			code += begin();

			if (options.alphaTest) {
				code += "	 getOpacity();\n";
				code += "	 alphaTest(dAlpha);\n";
			}

			code += "		gl_FragColor = packFloat(vDepth);\n";
			code += end();
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: code
			};
		} else if (shadowPass) {
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: this._buildShadowPassFragmentCode(code, device, chunks, options, varyings)
			};
		}

		if (options.customFragmentShader) {
			fshader = code + options.customFragmentShader;
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader,
				tag: SHADERTAG_MATERIAL
			};
		}

		code += varyings;
		code = this._fsAddBaseCode(code, device, chunks, options);

		if (options.detailModes) {
			code += chunks.detailModesPS;
		}

		const codeBegin = code;
		code = "";

		if (options.clearCoat > 0) {
			code += '#define CLEARCOAT\n';
			code += "#define CLUSTER_CLEAR_COAT\n";
		}

		if (options.opacityFadesSpecular === false) {
			code += 'uniform float material_alphaFade;\n';
		}

		let numShadowLights = 0;
		const shadowTypeUsed = [];
		let shadowedDirectionalLightUsed = false;
		let useVsm = false;
		let usePerspZbufferShadow = false;
		let hasAreaLights = options.lights.some(function (light) {
			return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
		});

		if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {
			hasAreaLights = true;
		}

		if (device.areaLightLutFormat === PIXELFORMAT_R8_G8_B8_A8) {
			code += "#define AREA_R8_G8_B8_A8_LUTS\n";
			code += "#define AREA_LUTS_PRECISION lowp\n";
		} else {
			code += "#define AREA_LUTS_PRECISION highp\n";
		}

		if (hasAreaLights || options.clusteredLightingEnabled) {
			code += "#define AREA_LIGHTS\n";
			code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex1;\n";
			code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex2;\n";
		}

		for (let i = 0; i < options.lights.length; i++) {
			const light = options.lights[i];
			const lightType = light._type;
			if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) continue;
			const lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
			code += "uniform vec3 light" + i + "_color;\n";

			if (lightType === LIGHTTYPE_DIRECTIONAL) {
				code += "uniform vec3 light" + i + "_direction;\n";
			} else {
				code += "uniform vec3 light" + i + "_position;\n";
				code += "uniform float light" + i + "_radius;\n";

				if (lightType === LIGHTTYPE_SPOT) {
					code += "uniform vec3 light" + i + "_direction;\n";
					code += "uniform float light" + i + "_innerConeAngle;\n";
					code += "uniform float light" + i + "_outerConeAngle;\n";
				}
			}

			if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "uniform vec3 light" + i + "_position;\n";
				}

				code += "uniform vec3 light" + i + "_halfWidth;\n";
				code += "uniform vec3 light" + i + "_halfHeight;\n";
			}

			if (light.castShadows && !options.noShadow) {
				code += "uniform mat4 light" + i + "_shadowMatrix;\n";

				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "uniform mat4 light" + i + "_shadowMatrixPalette[4];\n";
					code += "uniform float light" + i + "_shadowCascadeDistances[4];\n";
					code += "uniform float light" + i + "_shadowCascadeCount;\n";
				}

				if (lightType !== LIGHTTYPE_DIRECTIONAL) {
					code += "uniform vec4 light" + i + "_shadowParams;\n";
				} else {
					shadowedDirectionalLightUsed = true;
					code += "uniform vec3 light" + i + "_shadowParams;\n";
				}

				if (lightType === LIGHTTYPE_OMNI) {
					code += "uniform samplerCube light" + i + "_shadowMap;\n";
				} else {
					if (light._isPcf && device.webgl2) {
						code += "uniform sampler2DShadow light" + i + "_shadowMap;\n";
					} else {
						code += "uniform sampler2D light" + i + "_shadowMap;\n";
					}
				}

				numShadowLights++;
				shadowTypeUsed[light._shadowType] = true;
				if (light._isVsm) useVsm = true;
				if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;
			}

			if (light._cookie) {
				if (light._cookie._cubemap) {
					if (lightType === LIGHTTYPE_OMNI) {
						code += "uniform samplerCube light" + i + "_cookie;\n";
						code += "uniform float light" + i + "_cookieIntensity;\n";
						if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";
					}
				} else {
					if (lightType === LIGHTTYPE_SPOT) {
						code += "uniform sampler2D light" + i + "_cookie;\n";
						code += "uniform float light" + i + "_cookieIntensity;\n";
						if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";

						if (light._cookieTransform) {
							code += "uniform vec4 light" + i + "_cookieMatrix;\n";
							code += "uniform vec2 light" + i + "_cookieOffset;\n";
						}
					}
				}
			}
		}

		code += "\n";
		let tbn;

		if (!options.hasTangents && device.extStandardDerivatives) {
			tbn = chunks.TBNderivativePS;
		} else if (options.fastTbn) {
			tbn = chunks.TBNfastPS;
		} else {
			tbn = chunks.TBNPS;
		}

		if (needsNormal) {
			if (options.normalMap || options.clearCoatNormalMap) {
				code += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;

				if (!options.hasTangents) {
					const baseName = options.normalMap ? "normalMap" : "clearCoatNormalMap";

					const uv = this._getUvSourceExpression(`${baseName}Transform`, `${baseName}Uv`, options);

					tbn = tbn.replace(/\$UV/g, uv);
				}

				code += tbn;
			} else if (options.enableGGXSpecular && !options.heightMap) {
				code += chunks.normalVertexPS;
				code += chunks.TBNObjectSpacePS;
			}
		}

		if (needsNormal) {
			if (options.normalMap) {
				if (options.normalDetail) {
					code += this._addMap("normalDetail", "normalDetailMapPS", options, chunks);
				}

				const transformedNormalMapUv = this._getUvSourceExpression("normalMapTransform", "normalMapUv", options);

				if (options.normalizeNormalMap) {
					code += chunks.normalMapPS.replace(/\$UV/g, transformedNormalMapUv);
				} else {
					code += chunks.normalMapFastPS.replace(/\$UV/g, transformedNormalMapUv);
				}
			} else if (!(options.enableGGXSpecular && !options.heightMap)) {
				code += chunks.normalVertexPS;
			}
		}

		code += gammaCode(options.gamma, chunks);
		code += tonemapCode(options.toneMap, chunks);
		code += fogCode(options.fog, chunks);
		code += chunks.decodePS;
		if (options.useRgbm) code += chunks.rgbmPS;

		if (options.useCubeMapRotation) {
			code += "#define CUBEMAP_ROTATION\n";
		}

		if (needsNormal) {
			code += chunks.cubeMapRotatePS;
			code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
			code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
		}

		if (options.diffuseDetail) {
			code += this._addMap("diffuseDetail", "diffuseDetailMapPS", options, chunks);
		}

		code += this._addMap("diffuse", "diffusePS", options, chunks);

		if (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
			code += this._addMap("opacity", "opacityPS", options, chunks);
		}

		code += this._addMap("emissive", "emissivePS", options, chunks, options.emissiveFormat);

		if (lighting && options.useSpecular || reflections) {
			if (options.specularAntialias && options.normalMap) {
				if (options.normalizeNormalMap && needsNormal) {
					code += chunks.specularAaToksvigPS;
				} else {
					code += chunks.specularAaToksvigFastPS;
				}
			} else {
				code += chunks.specularAaNonePS;
			}

			const specularPropName = options.useMetalness ? "metalness" : "specular";
			code += this._addMap(specularPropName, specularPropName + "PS", options, chunks);
			code += this._addMap("gloss", "glossPS", options, chunks);

			if (options.fresnelModel === FRESNEL_SCHLICK) {
				code += chunks.fresnelSchlickPS;
			}
		}

		if (options.clearCoat > 0) {
			code += this._addMap("clearCoat", "clearCoatPS", options, chunks);
			code += this._addMap("clearCoatGloss", "clearCoatGlossPS", options, chunks);
			code += this._addMap("clearCoatNormal", "clearCoatNormalPS", options, chunks);
		}

		if (options.heightMap) {
			if (!options.normalMap) {
				const transformedHeightMapUv = this._getUvSourceExpression("heightMapTransform", "heightMapUv", options);

				if (!options.hasTangents) tbn = tbn.replace(/\$UV/g, transformedHeightMapUv);
				code += tbn;
			}

			code += this._addMap("height", "parallaxPS", options, chunks);
		}

		const useAo = options.aoMap || options.aoVertexColor;

		if (useAo) {
			code += this._addMap("ao", "aoPS", options, chunks);

			if (options.occludeSpecular) {
				if (options.occludeSpecular === SPECOCC_AO) {
					code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
				} else {
					code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
				}
			}
		}

		if (options.reflectionSource === 'envAtlas') {
			code += chunks.reflectionEnvPS.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
		} else if (options.reflectionSource === 'cubeMap') {
			code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
			code += chunks.reflectionCubePS.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
		} else if (options.reflectionSource === 'sphereMap') {
			const scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
			code += scode.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
		}

		if (reflections) {
			if (options.clearCoat > 0) {
				code += chunks.reflectionCCPS;
			}

			if (options.refraction) {
				code += chunks.refractionPS;
			}
		}

		if (options.clusteredLightingEnabled) {
			code += chunks.clusteredLightUtilsPS;
			code += chunks.clusteredLightCookiesPS;
			shadowTypeUsed[SHADOW_PCF3] = true;
			shadowTypeUsed[SHADOW_PCF5] = true;
			usePerspZbufferShadow = true;
		}

		if (numShadowLights > 0 || options.clusteredLightingEnabled) {
			if (shadowedDirectionalLightUsed) {
				code += chunks.shadowCascadesPS;
			}

			if (shadowTypeUsed[SHADOW_PCF3]) {
				code += chunks.shadowStandardPS;
			}

			if (shadowTypeUsed[SHADOW_PCF5] && device.webgl2) {
				code += chunks.shadowStandardGL2PS;
			}

			if (useVsm) {
				code += chunks.shadowVSM_commonPS;

				if (shadowTypeUsed[SHADOW_VSM8]) {
					code += chunks.shadowVSM8PS;
				}

				if (shadowTypeUsed[SHADOW_VSM16]) {
					code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
				}

				if (shadowTypeUsed[SHADOW_VSM32]) {
					code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
				}
			}

			if (!(device.webgl2 || device.extStandardDerivatives)) {
				code += chunks.biasConstPS;
			}

			code += chunks.shadowCoordPS + chunks.shadowCommonPS;
			if (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;
		}

		if (options.enableGGXSpecular) code += "uniform float material_anisotropy;\n";

		if (lighting) {
			code += chunks.lightDiffuseLambertPS;
			if (hasAreaLights || options.clusteredLightingEnabled) code += chunks.ltc;
		}

		code += '\n';
		let useOldAmbient = false;

		if (options.useSpecular) {
			code += "#define CLUSTER_SPECULAR\n";

			if (options.conserveEnergy) {
				code += "#define CLUSTER_CONSERVE_ENERGY\n";
			}

			if (lighting) {
				code += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;
			}

			if (options.fresnelModel > 0) {
				if (options.conserveEnergy && !hasAreaLights) {
					code += chunks.combineDiffuseSpecularPS;
				} else {
					code += chunks.combineDiffuseSpecularNoConservePS;
				}
			} else if (reflections) {
				code += chunks.combineDiffuseSpecularOldPS;
			} else {
				if (options.diffuseMap) {
					code += chunks.combineDiffuseSpecularNoReflPS;
				} else {
					code += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;
					useOldAmbient = true;
				}
			}
		} else {
			code += chunks.combineDiffusePS;
		}

		if (options.clearCoat > 0) {
			code += chunks.combineClearCoatPS;
		}

		let addAmbient = true;

		if (options.lightMap || options.lightVertexColor) {
			const lightmapChunkPropName = options.dirLightMap && options.useSpecular ? 'lightmapDirPS' : 'lightmapSinglePS';
			code += this._addMap("light", lightmapChunkPropName, options, chunks, options.lightMapFormat);
			addAmbient = options.lightMapWithoutAmbient;
		}

		if (addAmbient) {
			if (options.ambientSource === 'ambientSH') {
				code += chunks.ambientSHPS;
			} else if (options.ambientSource === 'envAtlas') {
				code += chunks.ambientEnvPS.replace(/\$DECODE/g, this._decodeFunc(options.ambientEncoding));
			} else {
				code += chunks.ambientConstantPS;
			}
		}

		if (options.ambientTint && !useOldAmbient) {
			code += "uniform vec3 material_ambient;\n";
		}

		if (options.alphaTest) {
			code += chunks.alphaTestPS;
		}

		if (options.msdf) {
			code += chunks.msdfPS;
		}

		if (needsNormal) {
			code += chunks.viewDirPS;

			if (options.useSpecular) {
				code += options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS;
			}
		}

		let hasPointLights = false;
		let usesLinearFalloff = false;
		let usesInvSquaredFalloff = false;
		let usesSpot = false;
		let usesCookie = false;
		let usesCookieNow;

		if (options.clusteredLightingEnabled && lighting) {
			usesSpot = true;
			hasPointLights = true;
			usesLinearFalloff = true;
			usesCookie = true;
			code += chunks.floatUnpackingPS;
			if (options.lightMaskDynamic) code += "\n#define CLUSTER_MESH_DYNAMIC_LIGHTS";
			if (options.clusteredLightingCookiesEnabled) code += "\n#define CLUSTER_COOKIES";

			if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
				code += "\n#define CLUSTER_SHADOWS";
				code += "\n#define CLUSTER_SHADOW_TYPE_" + shadowTypeToString[options.clusteredLightingShadowType];
			}

			if (options.clusteredLightingAreaLightsEnabled) code += "\n#define CLUSTER_AREALIGHTS";
			code += LightsBuffer.shaderDefines;
			code += chunks.clusteredLightShadowsPS;
			code += chunks.clusteredLightPS;
		}

		if (options.twoSidedLighting) code += "uniform float twoSidedLightingNegScaleFactor;\n";
		code = this._fsAddStartCode(code, device, chunks, options);

		if (needsNormal) {
			if (!options.hasTangents && device.extStandardDerivatives && !options.fastTbn) {
				if (options.twoSidedLighting) {
					code += "	 dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n";
				} else {
					code += "	 dVertexNormalW = normalize(vNormalW);\n";
				}
			} else {
				if (options.twoSidedLighting) {
					code += "	 dVertexNormalW = gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor;\n";
				} else {
					code += "	 dVertexNormalW = vNormalW;\n";
				}
			}

			if ((options.heightMap || options.normalMap) && options.hasTangents) {
				if (options.twoSidedLighting) {
					code += "	 dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n";
					code += "	 dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n";
				} else {
					code += "	 dTangentW = vTangentW;\n";
					code += "	 dBinormalW = vBinormalW;\n";
				}
			}
		}

		let opacityParallax = false;

		if (options.blendType === BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {
			code += "	 dAlpha = 1.0;\n";
		} else {
			if (options.heightMap && options.opacityMap) {
				opacityParallax = true;
			} else {
				code += "	 getOpacity();\n";

				if (options.alphaTest) {
					code += "	 alphaTest(dAlpha);\n";
				}
			}
		}

		let getGlossinessCalled = false;

		if (needsNormal) {
			code += "	 getViewDir();\n";

			if (options.heightMap || options.normalMap || options.clearCoatNormalMap || options.enableGGXSpecular) {
				code += "	 getTBN();\n";
			}

			if (options.heightMap) {
				code += "	 getParallax();\n";
			}

			if (opacityParallax) {
				code += "	 getOpacity();\n";

				if (options.alphaTest) {
					code += "	 alphaTest(dAlpha);\n";
				}
			}

			code += "	 getNormal();\n";

			if (options.useSpecular) {
				if (lighting && options.enableGGXSpecular) {
					code += "	 getGlossiness();\n";
					getGlossinessCalled = true;
				}

				code += "	 getReflDir();\n";
			}
		}

		code += "	 getAlbedo();\n";

		if (options.clearCoat > 0) {
			code += "	 getClearCoat();\n";
			code += "	 getClearCoatGlossiness();\n";
			code += "	 getClearCoatNormal();\n";
		}

		if (lighting && options.useSpecular || reflections) {
			code += "	 getSpecularity();\n";
			if (!getGlossinessCalled) code += "	 getGlossiness();\n";

			if (hasAreaLights) {
				code += "	 #ifdef AREA_LIGHTS\n";
				code += "	 dSpecularityNoFres = dSpecularity;\n";
				code += "	 #ifdef CLEARCOAT\n";
				code += "	 ccSpecularityNoFres = ccSpecularity;\n";
				code += "	 #endif\n";
				code += "	 #endif\n";
			}

			if (options.fresnelModel > 0) code += "	 getFresnel();\n";
		}

		if (addAmbient) {
			code += "	 addAmbient();\n";

			if (options.separateAmbient) {
				code += `
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`;
			}
		}

		if (options.ambientTint && !useOldAmbient) {
			code += "	 dDiffuseLight *= material_ambient;\n";
		}

		if (useAo && !options.occludeDirect) {
			code += "		applyAO();\n";
		}

		if (options.lightMap || options.lightVertexColor) {
			code += "	 addLightMap();\n";
		}

		if (lighting || reflections) {
			if (reflections) {
				if (options.clearCoat > 0) {
					code += "	 addReflectionCC();\n";
				}

				code += "	 addReflection();\n";
			}

			if (hasAreaLights) {
				code += "	 ccReflection.rgb *= ccSpecularity;\n";
				code += "	 dReflection.rgb *= dSpecularity;\n";
				code += "	 dSpecularLight *= dSpecularity;\n";
				code += "	 float roughness = max((1.0 - dGlossiness) * (1.0 - dGlossiness), 0.001);\n";
				code += "	 calcLTCLightValues();\n";
			}

			for (let i = 0; i < options.lights.length; i++) {
				const light = options.lights[i];
				const lightType = light._type;

				if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
					continue;
				}

				usesCookieNow = false;
				const lightShape = hasAreaLights && light._shape ? light.shape : LIGHTSHAPE_PUNCTUAL;
				const shapeString = hasAreaLights && light._shape ? this._getLightSourceShapeString(lightShape) : '';

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					code += "	 calc" + shapeString + "LightValues(light" + i + "_position, light" + i + "_halfWidth, light" + i + "_halfHeight);\n";
				}

				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "	 dLightDirNormW = light" + i + "_direction;\n";
					code += "	 dAtten = 1.0;\n";
				} else {
					if (light._cookie) {
						if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {
							usesCookie = true;
							usesCookieNow = true;
						} else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {
							usesCookie = true;
							usesCookieNow = true;
						}
					}

					code += "	 getLightDirPoint(light" + i + "_position);\n";
					hasPointLights = true;

					if (usesCookieNow) {
						if (lightType === LIGHTTYPE_SPOT) {
							code += "	 dAtten3 = getCookie2D" + (light._cookieFalloff ? "" : "Clip") + (light._cookieTransform ? "Xform" : "") + "(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity" + (light._cookieTransform ? ", light" + i + "_cookieMatrix, light" + i + "_cookieOffset" : "") + ")." + light._cookieChannel + ";\n";
						} else {
							code += "	 dAtten3 = getCookieCube(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity)." + light._cookieChannel + ";\n";
						}
					}

					if (lightShape === LIGHTSHAPE_PUNCTUAL) {
						if (light._falloffMode === LIGHTFALLOFF_LINEAR) {
							code += "	 dAtten = getFalloffLinear(light" + i + "_radius);\n";
							usesLinearFalloff = true;
						} else {
							code += "	 dAtten = getFalloffInvSquared(light" + i + "_radius);\n";
							usesInvSquaredFalloff = true;
						}
					} else {
						code += "	 dAtten = getFalloffWindow(light" + i + "_radius);\n";
						usesInvSquaredFalloff = true;
					}

					code += "	 if (dAtten > 0.00001) {\n";

					if (lightType === LIGHTTYPE_SPOT) {
						if (!(usesCookieNow && !light._cookieFalloff)) {
							code += "			 dAtten *= getSpotEffect(light" + i + "_direction, light" + i + "_innerConeAngle, light" + i + "_outerConeAngle);\n";
							usesSpot = true;
						}
					}
				}

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						code += "			 dAttenD = getLightDiffuse();\n";
					} else {
						code += "			 dAttenD = get" + shapeString + "LightDiffuse() * 16.0;\n";
					}
				} else {
					code += "			 dAtten *= getLightDiffuse();\n";
				}

				if (light.castShadows && !options.noShadow) {
					let shadowReadMode = null;
					let evsmExp;

					if (light._shadowType === SHADOW_VSM8) {
						shadowReadMode = "VSM8";
						evsmExp = "0.0";
					} else if (light._shadowType === SHADOW_VSM16) {
						shadowReadMode = "VSM16";
						evsmExp = "5.54";
					} else if (light._shadowType === SHADOW_VSM32) {
						shadowReadMode = "VSM32";

						if (device.textureFloatHighPrecision) {
							evsmExp = "15.0";
						} else {
							evsmExp = "5.54";
						}
					} else if (light._shadowType === SHADOW_PCF5) {
						shadowReadMode = "PCF5x5";
					} else {
						shadowReadMode = "PCF3x3";
					}

					if (shadowReadMode !== null) {
						if (lightType === LIGHTTYPE_OMNI) {
							shadowCoordArgs = "(light" + i + "_shadowMap, light" + i + "_shadowParams);\n";

							if (light._normalOffsetBias) {
								code += "			 normalOffsetPointShadow(light" + i + "_shadowParams);\n";
							}

							code += "			 dAtten *= getShadowPoint" + shadowReadMode + shadowCoordArgs;
						} else {
							const shadowMatArg = `light${i}_shadowMatrix`;
							const shadowParamArg = `light${i}_shadowParams`;
							code += this._nonPointShadowMapProjection(device, options.lights[i], shadowMatArg, shadowParamArg, i);
							if (lightType === LIGHTTYPE_SPOT) shadowReadMode = "Spot" + shadowReadMode;
							code += "			 dAtten *= getShadow" + shadowReadMode + "(light" + i + "_shadowMap, light" + i + "_shadowParams" + (light._isVsm ? ", " + evsmExp : "") + ");\n";
						}
					}
				}

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (options.conserveEnergy && options.useSpecular) {
						code += "			 dDiffuseLight += mix((dAttenD * dAtten) * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dLTCSpecFres);\n";
					} else {
						code += "			 dDiffuseLight += (dAttenD * dAtten) * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
				} else {
					if (hasAreaLights && options.conserveEnergy && options.useSpecular) {
						code += "			 dDiffuseLight += mix(dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dSpecularity);\n";
					} else {
						code += "			 dDiffuseLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
				}

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (options.clearCoat > 0) code += "			 ccSpecularLight += ccLTCSpecFres * get" + shapeString + "LightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					if (options.useSpecular) code += "			 dSpecularLight += dLTCSpecFres * get" + shapeString + "LightSpecular() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
				} else {
					if (hasAreaLights) {
						if (options.clearCoat > 0) code += "			 ccSpecularLight += ccSpecularity * getLightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						if (options.useSpecular) code += "			 dSpecularLight += dSpecularity * getLightSpecular() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					} else {
						if (options.clearCoat > 0) code += "			 ccSpecularLight += getLightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						if (options.useSpecular) code += "			 dSpecularLight += getLightSpecular() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
				}

				if (lightType !== LIGHTTYPE_DIRECTIONAL) {
					code += "	 }\n";
				}

				code += "\n";
			}

			if (options.clusteredLightingEnabled && lighting) {
				usesLinearFalloff = true;
				usesInvSquaredFalloff = true;
				hasPointLights = true;
				code += '	 addClusteredLights();\n';
			}

			if (hasAreaLights) {
				if (options.clearCoat > 0) {
					code += "	 ccSpecularity = 1.0;\n";
				}

				if (options.useSpecular) {
					code += "	 dSpecularity = vec3(1);\n";
				}
			}

			if (reflections && options.refraction) {
				code += "	 addRefraction();\n";
			}
		}

		code += "\n";

		if (useAo) {
			if (options.occludeDirect) {
				code += "		applyAO();\n";
			}

			if (options.occludeSpecular) {
				code += "		occludeSpecular();\n";
			}
		}

		if (options.opacityFadesSpecular === false) {
			if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {
				code += "float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n";
				code += "#ifdef CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n";
				code += "dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n";
			}

			code += "dAlpha *= material_alphaFade;\n";
		}

		code += chunks.endPS;

		if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
			code += chunks.outputAlphaPS;
		} else if (options.blendType === BLEND_PREMULTIPLIED) {
			code += chunks.outputAlphaPremulPS;
		} else {
			code += chunks.outputAlphaOpaquePS;
		}

		if (options.msdf) {
			code += "	 gl_FragColor = applyMsdf(gl_FragColor);\n";
		}

		code += "\n";
		code += end();

		if (hasPointLights) {
			code = chunks.lightDirPointPS + code;
		}

		if (usesLinearFalloff) {
			code = chunks.falloffLinearPS + code;
		}

		if (usesInvSquaredFalloff) {
			code = chunks.falloffInvSquaredPS + code;
		}

		if (usesSpot) {
			code = chunks.spotPS + code;
		}

		if (usesCookie) {
			code = chunks.cookiePS + code;
		}

		let structCode = "";
		if (code.includes("dReflection")) structCode += "vec4 dReflection;\n";
		if (code.includes("dTBN")) structCode += "mat3 dTBN;\n";
		if (code.includes("dAlbedo")) structCode += "vec3 dAlbedo;\n";
		if (code.includes("dEmission")) structCode += "vec3 dEmission;\n";
		if (code.includes("dNormalW")) structCode += "vec3 dNormalW;\n";
		if (code.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
		if (code.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
		if (code.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
		if (code.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
		if (code.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
		if (code.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
		if (code.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
		if (code.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
		if (code.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
		if (code.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
		if (code.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
		if (code.includes("dNormalMap")) structCode += "vec3 dNormalMap;\n";
		if (code.includes("dSpecularity")) structCode += "vec3 dSpecularity;\n";
		if (code.includes("dSpecularityNoFres")) structCode += "vec3 dSpecularityNoFres;\n";
		if (code.includes("dUvOffset")) structCode += "vec2 dUvOffset;\n";
		if (code.includes("dGlossiness")) structCode += "float dGlossiness;\n";
		if (code.includes("dAlpha")) structCode += "float dAlpha;\n";
		if (code.includes("dAtten")) structCode += "float dAtten;\n";
		if (code.includes("dAttenD")) structCode += "float dAttenD;\n";
		if (code.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
		if (code.includes("dAo")) structCode += "float dAo;\n";
		if (code.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
		if (code.includes("ccReflection")) structCode += "vec4 ccReflection;\n";
		if (code.includes("ccNormalW")) structCode += "vec3 ccNormalW;\n";
		if (code.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
		if (code.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
		if (code.includes("ccSpecularity")) structCode += "float ccSpecularity;\n";
		if (code.includes("ccSpecularityNoFres")) structCode += "float ccSpecularityNoFres;\n";
		if (code.includes("ccGlossiness")) structCode += "float ccGlossiness;\n";
		code = codeBegin + structCode + code;
		fshader = code;
		return {
			attributes: attributes,
			vshader: vshader,
			fshader: fshader,
			tag: SHADERTAG_MATERIAL
		};
	}
};

const programlib = {
	begin: begin,
	dummyFragmentCode: dummyFragmentCode,
	end: end,
	fogCode: fogCode,
	gammaCode: gammaCode,
	precisionCode: precisionCode,
	skinCode: skinCode,
	tonemapCode: tonemapCode,
	versionCode: versionCode,
	basic: basic,
	particle: particle,
	skybox: skybox,
	standard: standard
};

const _goldenAngle = 2.399963229728653;
const random = {
	circlePoint: function (point) {
		const r = Math.sqrt(Math.random());
		const theta = Math.random() * 2 * Math.PI;
		point.x = r * Math.cos(theta);
		point.y = r * Math.sin(theta);
	},
	circlePointDeterministic: function (point, index, numPoints) {
		const theta = index * _goldenAngle;
		const r = Math.sqrt(index) / Math.sqrt(numPoints);
		point.x = r * Math.cos(theta);
		point.y = r * Math.sin(theta);
	},
	spherePointDeterministic: function (point, index, numPoints, start = 0, end = 1) {
		start = 1 - 2 * start;
		end = 1 - 2 * end;
		const y = math.lerp(start, end, index / numPoints);
		const radius = Math.sqrt(1 - y * y);
		const theta = _goldenAngle * index;
		point.x = Math.cos(theta) * radius;
		point.y = y;
		point.z = Math.sin(theta) * radius;
	},
	radicalInverse: function (i) {
		let bits = (i << 16 | i >>> 16) >>> 0;
		bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
		bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
		bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
		bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
		return bits * 2.3283064365386963e-10;
	}
};

const getCoding = texture => {
	switch (texture.type) {
		case TEXTURETYPE_RGBM:
			return "RGBM";

		case TEXTURETYPE_RGBE:
			return "RGBE";

		default:
			switch (texture.format) {
				case PIXELFORMAT_RGB16F:
				case PIXELFORMAT_RGB32F:
				case PIXELFORMAT_RGBA16F:
				case PIXELFORMAT_RGBA32F:
					return "Linear";

				default:
					return "Gamma";
			}

	}
};

const getProjectionName = projection => {
	if (projection === TEXTUREPROJECTION_NONE) {
		projection = TEXTUREPROJECTION_EQUIRECT;
	}

	switch (projection) {
		case TEXTUREPROJECTION_CUBE:
			return "Cubemap";

		case TEXTUREPROJECTION_EQUIRECT:
			return "Equirect";

		case TEXTUREPROJECTION_OCTAHEDRAL:
			return "Octahedral";
	}
};

const packFloat32ToRGBA8 = (value, array, offset) => {
	if (value <= 0) {
		array[offset + 0] = 0;
		array[offset + 1] = 0;
		array[offset + 2] = 0;
		array[offset + 3] = 0;
	} else if (value >= 1.0) {
		array[offset + 0] = 255;
		array[offset + 1] = 0;
		array[offset + 2] = 0;
		array[offset + 3] = 0;
	} else {
		let encX = 1 * value % 1;
		let encY = 255 * value % 1;
		let encZ = 65025 * value % 1;
		const encW = 16581375.0 * value % 1;
		encX -= encY / 255;
		encY -= encZ / 255;
		encZ -= encW / 255;
		array[offset + 0] = Math.min(255, Math.floor(encX * 256));
		array[offset + 1] = Math.min(255, Math.floor(encY * 256));
		array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
		array[offset + 3] = Math.min(255, Math.floor(encW * 256));
	}
};

const packSamples = samples => {
	const numSamples = samples.length;
	const w = Math.min(numSamples, 512);
	const h = Math.ceil(numSamples / w);
	const data = new Uint8Array(w * h * 4);
	let off = 0;

	for (let i = 0; i < numSamples; ++i) {
		packFloat32ToRGBA8(samples[i * 4 + 0] * 0.5 + 0.5, data, off + 0);
		packFloat32ToRGBA8(samples[i * 4 + 1] * 0.5 + 0.5, data, off + 4);
		packFloat32ToRGBA8(samples[i * 4 + 2] * 0.5 + 0.5, data, off + 8);
		packFloat32ToRGBA8(samples[i * 4 + 3] / 8, data, off + 12);
		off += 16;
	}

	return {
		width: w,
		height: h,
		data: data
	};
};

const hemisphereSamplePhong = (dstVec, x, y, specularPower) => {
	const phi = y * 2 * Math.PI;
	const cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
	const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
	dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};

const hemisphereSampleLambert = (dstVec, x, y) => {
	const phi = y * 2 * Math.PI;
	const cosTheta = Math.sqrt(1 - x);
	const sinTheta = Math.sqrt(x);
	dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};

const hemisphereSampleGGX = (dstVec, x, y, a) => {
	const phi = y * 2 * Math.PI;
	const cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
	const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
	dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};

const D_GGX = (NoH, linearRoughness) => {
	const a = NoH * linearRoughness;
	const k = linearRoughness / (1.0 - NoH * NoH + a * a);
	return k * k * (1 / Math.PI);
};

const generatePhongSamples = (numSamples, specularPower) => {
	const H = new Vec3();
	const result = [];

	for (let i = 0; i < numSamples; ++i) {
		hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
		result.push(H.x, H.y, H.z, 0);
	}

	return result;
};

const generateLambertSamples = (numSamples, sourceTotalPixels) => {
	const pixelsPerSample = sourceTotalPixels / numSamples;
	const H = new Vec3();
	const result = [];

	for (let i = 0; i < numSamples; ++i) {
		hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
		const pdf = H.z / Math.PI;
		const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
		result.push(H.x, H.y, H.z, mipLevel);
	}

	return result;
};

const requiredSamplesGGX = {
	"16": {
		"2": 26,
		"8": 20,
		"32": 17,
		"128": 16,
		"512": 16
	},
	"32": {
		"2": 53,
		"8": 40,
		"32": 34,
		"128": 32,
		"512": 32
	},
	"128": {
		"2": 214,
		"8": 163,
		"32": 139,
		"128": 130,
		"512": 128
	},
	"1024": {
		"2": 1722,
		"8": 1310,
		"32": 1114,
		"128": 1041,
		"512": 1025
	}
};

const getRequiredSamplesGGX = (numSamples, specularPower) => {
	const table = requiredSamplesGGX[numSamples];
	return table && table[specularPower] || numSamples;
};

const generateGGXSamples = (numSamples, specularPower, sourceTotalPixels) => {
	const pixelsPerSample = sourceTotalPixels / numSamples;
	const roughness = 1 - Math.log2(specularPower) / 11.0;
	const a = roughness * roughness;
	const H = new Vec3();
	const L = new Vec3();
	const N = new Vec3(0, 0, 1);
	const result = [];
	const requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);

	for (let i = 0; i < requiredSamples; ++i) {
		hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
		const NoH = H.z;
		L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);

		if (L.z > 0) {
			const pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
			const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
			result.push(L.x, L.y, L.z, mipLevel);
		}
	}

	while (result.length < numSamples * 4) {
		result.push(0, 0, 0, 0);
	}

	return result;
};

const createSamplesTex = (device, name, samples) => {
	const packedSamples = packSamples(samples);
	return new Texture(device, {
		name: name,
		width: packedSamples.width,
		height: packedSamples.height,
		mipmaps: false,
		minFilter: FILTER_NEAREST,
		magFilter: FILTER_NEAREST,
		levels: [packedSamples.data]
	});
};

class SimpleCache {
	constructor() {
		this.map = new Map();
	}

	get(key, missFunc) {
		if (!this.map.has(key)) {
			const result = missFunc();
			this.map.set(key, result);
			return result;
		}

		return this.map.get(key);
	}

	clear() {
		this.map.clear();
	}

}

class DeviceCache {
	constructor() {
		this.cache = new SimpleCache();
	}

	get(device, key, missFunc) {
		return this.cache.get(device, () => {
			const cache = new SimpleCache();
			device.on('destroy', () => {
				cache.map.forEach((value, key) => {
					value.destroy();
				});
				this.cache.map.delete(device);
			});
			return cache;
		}).get(key, missFunc);
	}

	clear() {
		this.cache.clear();
	}

}

const samplesCache = new SimpleCache();
const samplesTexCache = new DeviceCache();

const generateLambertSamplesTex = (device, numSamples, sourceTotalPixels) => {
	const key = `lambert-samples-${numSamples}-${sourceTotalPixels}`;
	return samplesTexCache.get(device, key, () => {
		return createSamplesTex(device, key, samplesCache.get(key, () => {
			return generateLambertSamples(numSamples, sourceTotalPixels);
		}));
	});
};

const generatePhongSamplesTex = (device, numSamples, specularPower) => {
	const key = `phong-samples-${numSamples}-${specularPower}`;
	return samplesTexCache.get(device, key, () => {
		return createSamplesTex(device, key, samplesCache.get(key, () => {
			return generatePhongSamples(numSamples, specularPower);
		}));
	});
};

const generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels) => {
	const key = `ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;
	return samplesTexCache.get(device, key, () => {
		return createSamplesTex(device, key, samplesCache.get(key, () => {
			return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
		}));
	});
};

const vsCode = `
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;
}
`;

function reprojectTexture(source, target, options = {}) {
	var _options;

	if (source instanceof GraphicsDevice) {
		source = arguments[1];
		target = arguments[2];
		options = {};

		if (arguments[3] !== undefined) {
			options.specularPower = arguments[3];
		}

		if (arguments[4] !== undefined) {
			options.numSamples = arguments[4];
		}
	}

	const funcNames = {
		'none': 'reproject',
		'lambert': 'prefilterSamplesUnweighted',
		'phong': 'prefilterSamplesUnweighted',
		'ggx': 'prefilterSamples'
	};
	const specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
	const face = options.hasOwnProperty('face') ? options.face : null;
	const distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
	const processFunc = funcNames[distribution] || 'reproject';
	const decodeFunc = `decode${getCoding(source)}`;
	const encodeFunc = `encode${getCoding(target)}`;
	const sourceFunc = `sample${getProjectionName(source.projection)}`;
	const targetFunc = `getDirection${getProjectionName(target.projection)}`;
	const numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
	const shaderKey = `${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;
	const device = source.device;
	let shader = device.programLib._cache[shaderKey];

	if (!shader) {
		const defines = `#define PROCESS_FUNC ${processFunc}\n` + `#define DECODE_FUNC ${decodeFunc}\n` + `#define ENCODE_FUNC ${encodeFunc}\n` + `#define SOURCE_FUNC ${sourceFunc}\n` + `#define TARGET_FUNC ${targetFunc}\n` + `#define NUM_SAMPLES ${numSamples}\n` + (device.extTextureLod ? `#define SUPPORTS_TEXLOD\n` : '');
		let extensions = '';

		if (!device.webgl2) {
			extensions = '#extension GL_OES_standard_derivatives: enable\n';

			if (device.extTextureLod) {
				extensions += '#extension GL_EXT_shader_texture_lod: enable\n\n';
			}
		}

		shader = createShaderFromCode(device, vsCode, `${defines}\n${shaderChunks.reprojectPS}`, shaderKey, false, extensions);
	}

	const constantSource = device.scope.resolve(source.cubemap ? "sourceCube" : "sourceTex");
	constantSource.setValue(source);
	const constantParams = device.scope.resolve("params");
	const constantParams2 = device.scope.resolve("params2");
	const uvModParam = device.scope.resolve("uvMod");

	if ((_options = options) != null && _options.seamPixels) {
		const p = options.seamPixels;
		const w = options.rect ? options.rect.z : target.width;
		const h = options.rect ? options.rect.w : target.height;
		const innerWidth = w - p * 2;
		const innerHeight = h - p * 2;
		uvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);
	} else {
		uvModParam.setValue([1, 1, 0, 0]);
	}

	const params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];
	const params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];

	if (processFunc.startsWith('prefilterSamples')) {
		const sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
		const samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
		device.scope.resolve("samplesTex").setValue(samplesTex);
		device.scope.resolve("samplesTexInverseSize").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);
	}

	for (let f = 0; f < (target.cubemap ? 6 : 1); f++) {
		if (face === null || f === face) {
			var _options2;

			const renderTarget = new RenderTarget({
				colorBuffer: target,
				face: f,
				depth: false
			});
			params[0] = f;
			constantParams.setValue(params);
			constantParams2.setValue(params2);
			drawQuadWithShader(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);
			renderTarget.destroy();
		}
	}
}

const fixCubemapSeams = true;

const calcLevels = (width, height) => {
	return 1 + Math.floor(Math.log2(Math.max(width, height)));
};

const supportsFloat16 = device => {
	return device.extTextureHalfFloat && device.textureHalfFloatRenderable;
};

const supportsFloat32 = device => {
	return device.extTextureFloat && device.textureFloatRenderable;
};

const lightingSourcePixelFormat = device => {
	return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_R8_G8_B8_A8;
};

const lightingPixelFormat = device => {
	return PIXELFORMAT_R8_G8_B8_A8;
};

const createCubemap = (device, size, format, mipmaps) => {
	return new Texture(device, {
		name: `lighting-${size}`,
		cubemap: true,
		width: size,
		height: size,
		format: format,
		type: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
		addressU: ADDRESS_CLAMP_TO_EDGE,
		addressV: ADDRESS_CLAMP_TO_EDGE,
		fixCubemapSeams: fixCubemapSeams,
		mipmaps: !!mipmaps
	});
};

class EnvLighting {
	static generateSkyboxCubemap(source, size) {
		const device = source.device;
		const result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_R8_G8_B8_A8, false);
		reprojectTexture(source, result, {
			numSamples: 1024
		});
		return result;
	}

	static generateLightingSource(source) {
		const device = source.device;
		const format = lightingSourcePixelFormat(device);
		const result = new Texture(device, {
			name: `lighting-source`,
			cubemap: true,
			width: 128,
			height: 128,
			format: format,
			type: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			fixCubemapSeams: false,
			mipmaps: true
		});
		reprojectTexture(source, result, {
			numSamples: source.mipmaps ? 1 : 1024
		});
		return result;
	}

	static generateAtlas(source, options) {
		const device = source.device;
		const format = lightingPixelFormat();
		const result = (options == null ? void 0 : options.target) || new Texture(device, {
			width: 512,
			height: 512,
			format: format,
			type: TEXTURETYPE_RGBM ,
			projection: TEXTUREPROJECTION_EQUIRECT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			mipmaps: false
		});
		const rect = new Vec4(0, 0, 512, 256);
		const levels = calcLevels(result.width, result.height);

		for (let i = 0; i < levels; ++i) {
			reprojectTexture(source, result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
			rect.x += rect.w;
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(0, 256, 256, 128);

		for (let i = 1; i < 7; ++i) {
			reprojectTexture(source, result, {
				numSamples: (options == null ? void 0 : options.numSamples) || 1024,
				distribution: (options == null ? void 0 : options.distribution) || 'ggx',
				specularPower: Math.max(1, 2048 >> i * 2),
				rect: rect,
				seamPixels: 1
			});
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(128, 256 + 128, 64, 32);
		reprojectTexture(source, result, {
			numSamples: (options == null ? void 0 : options.numSamples) || 2048,
			distribution: 'lambert',
			rect: rect,
			seamPixels: 1
		});
		return result;
	}

	static generatePrefilteredAtlas(sources, options) {
		const device = sources[0].device;
		const format = lightingPixelFormat();
		const result = (options == null ? void 0 : options.target) || new Texture(device, {
			width: 512,
			height: 512,
			format: format,
			type: TEXTURETYPE_RGBM ,
			projection: TEXTUREPROJECTION_EQUIRECT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			mipmaps: false
		});
		const rect = new Vec4(0, 0, 512, 256);
		const levels = calcLevels(result.width, result.height);

		for (let i = 0; i < levels; ++i) {
			reprojectTexture(sources[0], result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
			rect.x += rect.w;
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(0, 256, 256, 128);

		for (let i = 1; i < sources.length; ++i) {
			reprojectTexture(sources[i], result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(128, 256 + 128, 64, 32);

		if (options != null && options.legacyAmbient) {
			reprojectTexture(sources[5], result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
		} else {
			reprojectTexture(sources[0], result, {
				numSamples: (options == null ? void 0 : options.numSamples) || 2048,
				distribution: 'lambert',
				rect: rect,
				seamPixels: 1
			});
		}

		return result;
	}

}

class DefaultMaterial {
	static get(device) {
		const material = this.cache.get(device);
		return material;
	}

	static add(device, material) {
		this.cache.set(device, material);
	}

	static remove(device) {
		this.cache.delete(device);
	}

}

DefaultMaterial.cache = new Map();

let id$2 = 0;

class Material$1 {
	constructor() {
		this.name = "Untitled";
		this.id = id$2++;
		this._shader = null;
		this.variants = {};
		this.parameters = {};
		this.alphaTest = 0;
		this.alphaToCoverage = false;
		this.blend = false;
		this.blendSrc = BLENDMODE_ONE;
		this.blendDst = BLENDMODE_ZERO;
		this.blendEquation = BLENDEQUATION_ADD;
		this.separateAlphaBlend = false;
		this.blendSrcAlpha = BLENDMODE_ONE;
		this.blendDstAlpha = BLENDMODE_ZERO;
		this.blendAlphaEquation = BLENDEQUATION_ADD;
		this.cull = CULLFACE_BACK;
		this.depthTest = true;
		this.depthWrite = true;
		this.stencilFront = null;
		this.stencilBack = null;
		this.depthBias = 0;
		this.slopeDepthBias = 0;
		this.redWrite = true;
		this.greenWrite = true;
		this.blueWrite = true;
		this.alphaWrite = true;
		this.meshInstances = [];
		this._shaderVersion = 0;
		this._scene = null;
		this._dirtyBlend = false;
		this.dirty = true;
	}

	set shader(shader) {
		this._shader = shader;
	}

	get shader() {
		return this._shader;
	}

	get transparent() {
		return this.blend || this.blendSrc !== BLENDMODE_ONE || this.blendDst !== BLENDMODE_ZERO || this.blendEquation !== BLENDEQUATION_ADD;
	}

	set blendType(type) {
		const prevBlend = this.blend;

		switch (type) {
			case BLEND_NONE:
				this.blend = false;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ZERO;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_NORMAL:
				this.blend = true;
				this.blendSrc = BLENDMODE_SRC_ALPHA;
				this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_PREMULTIPLIED:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_ADDITIVE:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_ADDITIVEALPHA:
				this.blend = true;
				this.blendSrc = BLENDMODE_SRC_ALPHA;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_MULTIPLICATIVE2X:
				this.blend = true;
				this.blendSrc = BLENDMODE_DST_COLOR;
				this.blendDst = BLENDMODE_SRC_COLOR;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_SCREEN:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_MULTIPLICATIVE:
				this.blend = true;
				this.blendSrc = BLENDMODE_DST_COLOR;
				this.blendDst = BLENDMODE_ZERO;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_MIN:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_MIN;
				break;

			case BLEND_MAX:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_MAX;
				break;
		}

		if (prevBlend !== this.blend) {
			if (this._scene) {
				this._scene.layers._dirtyBlend = true;
			} else {
				this._dirtyBlend = true;
			}
		}

		this._updateMeshInstanceKeys();
	}

	get blendType() {
		if (!this.transparent) {
			return BLEND_NONE;
		} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_NORMAL;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_ADDITIVE;
		} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_ADDITIVEALPHA;
		} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_SRC_COLOR && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_MULTIPLICATIVE2X;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_SCREEN;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MIN) {
			return BLEND_MIN;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MAX) {
			return BLEND_MAX;
		} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_ZERO && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_MULTIPLICATIVE;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_PREMULTIPLIED;
		}

		return BLEND_NORMAL;
	}

	copy(source) {
		this.name = source.name;
		this.shader = source.shader;
		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.blend = source.blend;
		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.separateAlphaBlend = source.separateAlphaBlend;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendAlphaEquation = source.blendAlphaEquation;
		this.cull = source.cull;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;
		this.depthBias = source.depthBias;
		this.slopeDepthBias = source.slopeDepthBias;
		if (source.stencilFront) this.stencilFront = source.stencilFront.clone();

		if (source.stencilBack) {
			if (source.stencilFront === source.stencilBack) {
				this.stencilBack = this.stencilFront;
			} else {
				this.stencilBack = source.stencilBack.clone();
			}
		}

		this.redWrite = source.redWrite;
		this.greenWrite = source.greenWrite;
		this.blueWrite = source.blueWrite;
		this.alphaWrite = source.alphaWrite;
		return this;
	}

	clone() {
		const clone = new this.constructor();
		return clone.copy(this);
	}

	_updateMeshInstanceKeys() {
		const meshInstances = this.meshInstances;

		for (let i = 0; i < meshInstances.length; i++) {
			meshInstances[i].updateKey();
		}
	}

	updateUniforms(device, scene) {}

	updateShader(device, scene, objDefs) {}

	update() {
		this.dirty = true;
		if (this._shader) this._shader.failed = false;
	}

	clearParameters() {
		this.parameters = {};
	}

	getParameters() {
		return this.parameters;
	}

	clearVariants() {
		this.variants = {};

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];

			for (let j = 0; j < meshInstance._shader.length; j++) {
				meshInstance._shader[j] = null;
			}
		}
	}

	getParameter(name) {
		return this.parameters[name];
	}

	setParameter(name, data) {
		if (data === undefined && typeof name === 'object') {
			const uniformObject = name;

			if (uniformObject.length) {
				for (let i = 0; i < uniformObject.length; i++) {
					this.setParameter(uniformObject[i]);
				}

				return;
			}

			name = uniformObject.name;
			data = uniformObject.value;
		}

		const param = this.parameters[name];

		if (param) {
			param.data = data;
		} else {
			this.parameters[name] = {
				scopeId: null,
				data: data
			};
		}
	}

	deleteParameter(name) {
		if (this.parameters[name]) {
			delete this.parameters[name];
		}
	}

	setParameters(device, names) {
		const parameters = this.parameters;
		if (names === undefined) names = parameters;

		for (const paramName in names) {
			const parameter = parameters[paramName];

			if (parameter) {
				if (!parameter.scopeId) {
					parameter.scopeId = device.scope.resolve(paramName);
				}

				parameter.scopeId.setValue(parameter.data);
			}
		}
	}

	destroy() {
		this.variants = {};
		this.shader = null;

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];

			for (let j = 0; j < meshInstance._shader.length; j++) {
				meshInstance._shader[j] = null;
			}

			meshInstance._material = null;

			if (meshInstance.mesh) {
				const defaultMaterial = DefaultMaterial.get(meshInstance.mesh.device);

				if (this !== defaultMaterial) {
					meshInstance.material = defaultMaterial;
				}
			}
		}
	}

	addMeshInstanceRef(meshInstance) {
		this.meshInstances.push(meshInstance);
	}

	removeMeshInstanceRef(meshInstance) {
		const meshInstances = this.meshInstances;
		const i = meshInstances.indexOf(meshInstance);

		if (i !== -1) {
			meshInstances.splice(i, 1);
		}
	}

}

const arraysEqual = (a, b) => {
	if (a.length !== b.length) {
		return false;
	}

	for (let i = 0; i < a.length; ++i) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
};

const notWhite = color => {
	return color.r !== 1 || color.g !== 1 || color.b !== 1;
};

const notBlack = color => {
	return color.r !== 0 || color.g !== 0 || color.b !== 0;
};

class StandardMaterialOptionsBuilder {
	constructor() {
		this._mapXForms = null;
	}

	updateMinRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
		this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

		this._updateMinOptions(options, stdMat);

		this._updateUVOptions(options, stdMat, objDefs, true);
	}

	updateRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
		this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

		this._updateEnvOptions(options, device, stdMat, scene);

		this._updateMaterialOptions(options, stdMat);

		if (pass === SHADER_FORWARDHDR) {
			if (options.gamma) options.gamma = GAMMA_SRGBHDR;
			options.toneMap = TONEMAP_LINEAR;
		}

		options.hasTangents = objDefs && stdMat.normalMap && (objDefs & SHADERDEF_TANGENTS) !== 0;

		this._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);

		this._updateUVOptions(options, stdMat, objDefs, false);
	}

	_updateSharedOptions(options, scene, stdMat, objDefs, pass) {
		options.pass = pass;
		options.alphaTest = stdMat.alphaTest > 0;
		options.forceFragmentPrecision = stdMat.forceFragmentPrecision || "";
		options.chunks = stdMat.chunks || "";
		options.blendType = stdMat.blendType;
		options.forceUv1 = stdMat.forceUv1;
		options.separateAmbient = false;
		options.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
		options.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
		options.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
		options.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
		options.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
		options.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;
		options.nineSlicedMode = stdMat.nineSlicedMode || 0;

		if (scene.clusteredLightingEnabled) {
			options.clusteredLightingEnabled = true;
			options.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
			options.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
			options.clusteredLightingShadowType = scene.lighting.shadowType;
			options.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
		}
	}

	_updateUVOptions(options, stdMat, objDefs, minimalOptions) {
		let hasUv0 = false;
		let hasUv1 = false;
		let hasVcolor = false;

		if (objDefs) {
			hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
			hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
			hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
		}

		options.vertexColors = false;
		this._mapXForms = [];

		for (const p in _matTex2D) {
			this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);
		}

		this._mapXForms = null;
	}

	_updateMinOptions(options, stdMat) {
		options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;
		options.lights = [];
	}

	_updateMaterialOptions(options, stdMat) {
		const diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);
		const useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
		const specularTint = useSpecular && !stdMat.useMetalness && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
		const emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;
		const emissiveTintIntensity = stdMat.emissiveIntensity !== 1;
		const isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
		options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE ? 1 : 0;
		options.blendMapsWithColors = true;
		options.ambientTint = stdMat.ambientTint;
		options.diffuseTint = diffuseTint ? 2 : 0;
		options.specularTint = specularTint ? 2 : 0;
		options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
		options.glossTint = 1;
		options.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);
		options.alphaToCoverage = stdMat.alphaToCoverage;
		options.normalizeNormalMap = stdMat.normalizeNormalMap;
		options.ambientSH = !!stdMat.ambientSH;
		options.useSpecular = useSpecular;
		options.emissiveFormat = stdMat.emissiveMap ? stdMat.emissiveMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.emissiveMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;
		options.lightMapFormat = stdMat.lightMap ? stdMat.lightMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.lightMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;
		options.specularAntialias = stdMat.specularAntialias && !!stdMat.normalMap && !!stdMat.normalMap.mipmaps && !isPackedNormalMap;
		options.conserveEnergy = stdMat.conserveEnergy;
		options.opacityFadesSpecular = stdMat.opacityFadesSpecular;
		options.alphaFade = stdMat.alphaFade;
		options.occludeSpecular = stdMat.occludeSpecular;
		options.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
		options.occludeDirect = stdMat.occludeDirect;
		options.shadingModel = stdMat.shadingModel;
		options.fresnelModel = stdMat.fresnelModel;
		options.packedNormal = isPackedNormalMap;
		options.fastTbn = stdMat.fastTbn;
		options.cubeMapProjection = stdMat.cubeMapProjection;
		options.customFragmentShader = stdMat.customFragmentShader;
		options.refraction = !!stdMat.refraction;
		options.useMetalness = stdMat.useMetalness;
		options.enableGGXSpecular = stdMat.enableGGXSpecular;
		options.msdf = !!stdMat.msdfMap;
		options.twoSidedLighting = stdMat.twoSidedLighting;
		options.pixelSnap = stdMat.pixelSnap;
		options.aoMapUv = stdMat.aoUvSet;
		options.diffuseDetail = !!stdMat.diffuseMap;
		options.normalDetail = !!stdMat.normalMap;
		options.diffuseDetailMode = stdMat.diffuseDetailMode;
		options.detailModes = !!options.diffuseDetail;
		options.clearCoat = !!stdMat.clearCoat;
		options.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;
		options.clearCoatGlossiness = !!stdMat.clearCoatGlossiness;
		options.clearCoatGlossTint = stdMat.clearCoatGlossiness !== 1.0 ? 1 : 0;
	}

	_updateEnvOptions(options, device, stdMat, scene) {
		options.fog = stdMat.useFog ? scene.fog : "none";
		options.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
		options.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
		options.useRgbm = stdMat.emissiveMap && stdMat.emissiveMap.type === TEXTURETYPE_RGBM || stdMat.lightMap && stdMat.lightMap.type === TEXTURETYPE_RGBM;
		options.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;
		options.skyboxIntensity = scene.skyboxIntensity !== 1;
		const isPhong = stdMat.shadingModel === SPECULAR_PHONG;
		let usingSceneEnv = false;

		if (stdMat.envAtlas && !isPhong) {
			options.reflectionSource = 'envAtlas';
			options.reflectionEncoding = stdMat.envAtlas.encoding;
		} else if (stdMat.cubeMap) {
			options.reflectionSource = 'cubeMap';
			options.reflectionEncoding = stdMat.cubeMap.encoding;
		} else if (stdMat.sphereMap) {
			options.reflectionSource = 'sphereMap';
			options.reflectionEncoding = stdMat.sphereMap.encoding;
		} else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {
			options.reflectionSource = 'envAtlas';
			options.reflectionEncoding = scene.envAtlas.encoding;
			usingSceneEnv = true;
		} else {
			options.reflectionSource = null;
			options.reflectionEncoding = null;
		}

		if (stdMat.ambientSH && !isPhong) {
			options.ambientSource = 'ambientSH';
			options.ambientEncoding = null;
		} else {
			const envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);

			if (envAtlas && !isPhong) {
				options.ambientSource = 'envAtlas';
				options.ambientEncoding = envAtlas.encoding;
			} else {
				options.ambientSource = 'constant';
				options.ambientEncoding = null;
			}
		}

		options.useCubeMapRotation = usingSceneEnv && scene.skyboxRotation && !scene.skyboxRotation.equals(Quat.IDENTITY);
	}

	_updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList) {
		options.lightMap = false;
		options.lightMapChannel = "";
		options.lightMapUv = 0;
		options.lightMapTransform = 0;
		options.lightMapWithoutAmbient = false;
		options.dirLightMap = false;

		if (objDefs) {
			options.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;

			if ((objDefs & SHADERDEF_LM) !== 0) {
				options.lightMapFormat = 1;
				options.lightMap = true;
				options.lightMapChannel = "rgb";
				options.lightMapUv = 1;
				options.lightMapTransform = 0;
				options.lightMapWithoutAmbient = !stdMat.lightMap;
				options.useRgbm = true;

				if ((objDefs & SHADERDEF_DIRLM) !== 0) {
					options.dirLightMap = true;
				}

				if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
					options.lightMapWithoutAmbient = false;
				}
			}
		}

		if (stdMat.useLighting) {
			const lightsFiltered = [];
			const mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
			options.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);

			if (sortedLights) {
				this._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);

				this._collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask, staticLightList);

				this._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
			}

			options.lights = lightsFiltered;
		} else {
			options.lights = [];
		}

		if (options.lights.length === 0) {
			options.noShadow = true;
		}
	}

	_updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {
		const mname = p + "Map";
		const vname = p + "VertexColor";
		const vcname = p + "VertexColorChannel";
		const cname = mname + "Channel";
		const tname = mname + "Transform";
		const uname = mname + "Uv";

		if (p !== "light") {
			options[mname] = false;
			options[cname] = "";
			options[tname] = 0;
			options[uname] = 0;
		}

		options[vname] = false;
		options[vcname] = "";
		const isOpacity = p === "opacity";
		if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) return options;

		if (!minimalOptions || isOpacity) {
			if (p !== "height" && stdMat[vname]) {
				if (hasVcolor) {
					options[vname] = stdMat[vname];
					options[vcname] = stdMat[vcname];
					options.vertexColors = true;
				}
			}

			if (stdMat[mname]) {
				let allow = true;
				if (stdMat[uname] === 0 && !hasUv0) allow = false;
				if (stdMat[uname] === 1 && !hasUv1) allow = false;

				if (allow) {
					options[mname] = !!stdMat[mname];
					options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
					options[cname] = stdMat[cname];
					options[uname] = stdMat[uname];
				}
			}
		}
	}

	_collectLights(lType, lights, lightsFiltered, mask, staticLightList) {
		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (light.enabled) {
				if (light.mask & mask) {
					if (lType !== LIGHTTYPE_DIRECTIONAL) {
						if (light.isStatic) {
							continue;
						}
					}

					lightsFiltered.push(light);
				}
			}
		}

		if (staticLightList) {
			for (let i = 0; i < staticLightList.length; i++) {
				const light = staticLightList[i];

				if (light._type === lType) {
					lightsFiltered.push(light);
				}
			}
		}
	}

	_getMapTransformID(xform, uv) {
		if (!xform) return 0;
		let xforms = this._mapXForms[uv];

		if (!xforms) {
			xforms = [];
			this._mapXForms[uv] = xforms;
		}

		for (let i = 0; i < xforms.length; i++) {
			if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
				return i + 1;
			}
		}

		return xforms.push(xform);
	}

}

const standardMaterialParameterTypes = {
	name: 'string',
	chunks: 'chunks',
	mappingFormat: 'string',
	_engine: 'boolean',
	ambient: 'rgb',
	ambientTint: 'boolean',
	aoVertexColor: 'boolean',
	aoVertexColorChannel: 'string',
	aoMap: 'texture',
	aoMapChannel: 'string',
	aoMapUv: 'number',
	aoMapTiling: 'vec2',
	aoMapOffset: 'vec2',
	aoMapRotation: 'number',
	diffuse: 'rgb',
	diffuseTint: 'boolean',
	diffuseVertexColor: 'boolean',
	diffuseVertexColorChannel: 'string',
	diffuseMap: 'texture',
	diffuseMapChannel: 'string',
	diffuseMapUv: 'number',
	diffuseMapTiling: 'vec2',
	diffuseMapOffset: 'vec2',
	diffuseMapRotation: 'number',
	diffuseDetailMap: 'texture',
	diffuseDetailMapChannel: 'string',
	diffuseDetailMapUv: 'number',
	diffuseDetailMapTiling: 'vec2',
	diffuseDetailMapOffset: 'vec2',
	diffuseDetailMapRotation: 'number',
	diffuseDetailMode: 'string',
	specular: 'rgb',
	specularTint: 'boolean',
	specularVertexColor: 'boolean',
	specularVertexColorChannel: 'string',
	specularMap: 'texture',
	specularMapChannel: 'string',
	specularMapUv: 'number',
	specularMapTiling: 'vec2',
	specularMapOffset: 'vec2',
	specularMapRotation: 'number',
	specularAntialias: 'boolean',
	occludeSpecular: 'enum:occludeSpecular',
	useMetalness: 'boolean',
	metalness: 'number',
	enableGGXSpecular: 'boolean',
	anisotropy: 'number',
	metalnessTint: 'boolean',
	metalnessVertexColor: 'boolean',
	metalnessVertexColorChannel: 'string',
	metalnessMap: 'texture',
	metalnessMapChannel: 'string',
	metalnessMapUv: 'number',
	metalnessMapTiling: 'vec2',
	metalnessMapOffset: 'vec2',
	netalnessMapRotation: 'number',
	conserveEnergy: 'boolean',
	shininess: 'number',
	glossVertexColor: 'boolean',
	glossVertexColorChannel: 'string',
	glossMap: 'texture',
	glossMapChannel: 'string',
	glossMapUv: 'number',
	glossMapTiling: 'vec2',
	glossMapOffset: 'vec2',
	glossMapRotation: 'number',
	clearCoat: 'number',
	clearCoatVertexColor: 'boolean',
	clearCoatVertexColorChannel: 'string',
	clearCoatMap: 'texture',
	clearCoatMapChannel: 'string',
	clearCoatMapUv: 'number',
	clearCoatMapTiling: 'vec2',
	clearCoatMapOffset: 'vec2',
	clearCoatMapRotation: 'number',
	clearCoatGlossiness: 'number',
	clearCoatGlossVertexColor: 'boolean',
	clearCoatGlossVertexColorChannel: 'string',
	clearCoatGlossMap: 'texture',
	clearCoatGlossMapChannel: 'string',
	clearCoatGlossMapUv: 'number',
	clearCoatGlossMapTiling: 'vec2',
	clearCoatGlossMapOffset: 'vec2',
	clearCoatGlossMapRotation: 'number',
	clearCoatBumpiness: 'number',
	clearCoatNormalMap: 'texture',
	clearCoatNormalMapUv: 'number',
	clearCoatNormalMapTiling: 'vec2',
	clearCoatNormalMapOffset: 'vec2',
	clearCoatNormalMapRotation: 'number',
	fresnelModel: 'number',
	emissive: 'rgb',
	emissiveTint: 'boolean',
	emissiveVertexColor: 'boolean',
	emissiveVertexColorChannel: 'string',
	emissiveMap: 'texture',
	emissiveMapChannel: 'string',
	emissiveMapUv: 'number',
	emissiveMapTiling: 'vec2',
	emissiveMapOffset: 'vec2',
	emissiveMapMapRotation: 'number',
	emissiveIntensity: 'number',
	normalMap: 'texture',
	normalMapTiling: 'vec2',
	normalMapOffset: 'vec2',
	normalMapRotation: 'number',
	normalMapUv: 'number',
	bumpiness: 'number',
	normalDetailMap: 'texture',
	normalDetailMapTiling: 'vec2',
	normalDetailMapOffset: 'vec2',
	normalDetailMapRotation: 'number',
	normalDetailMapUv: 'number',
	normalDetailMapBumpiness: 'number',
	heightMap: 'texture',
	heightMapChannel: 'string',
	heightMapUv: 'number',
	heightMapTiling: 'vec2',
	heightMapOffset: 'vec2',
	heightMapRotation: 'number',
	heightMapFactor: 'number',
	alphaToCoverage: 'boolean',
	alphaTest: 'number',
	alphaFade: 'number',
	opacity: 'number',
	opacityVertexColor: 'boolean',
	opacityVertexColorChannel: 'string',
	opacityMap: 'texture',
	opacityMapChannel: 'string',
	opacityMapUv: 'number',
	opacityMapTiling: 'vec2',
	opacityMapOffset: 'vec2',
	opacityMapRotation: 'number',
	opacityFadesSpecular: 'boolean',
	reflectivity: 'number',
	refraction: 'number',
	refractionIndex: 'number',
	sphereMap: 'texture',
	cubeMap: 'cubemap',
	cubeMapProjection: 'number',
	cubeMapProjectionBox: 'boundingbox',
	lightVertexColor: 'boolean',
	lightVertexColorChannel: 'string',
	lightMap: 'texture',
	lightMapChannel: 'string',
	lightMapUv: 'number',
	lightMapTiling: 'vec2',
	lightMapOffset: 'vec2',
	lightMapRotation: 'number',
	depthTest: 'boolean',
	depthWrite: 'boolean',
	depthBias: 'number',
	slopeDepthBias: 'number',
	cull: 'enum:cull',
	blendType: 'enum:blendType',
	shadingModel: 'enum:shadingModel',
	useFog: 'boolean',
	useLighting: 'boolean',
	useSkybox: 'boolean',
	useGammaTonemap: 'boolean',
	envAtlas: 'texture'
};
const standardMaterialTextureParameters = [];

for (const key in standardMaterialParameterTypes) {
	const type = standardMaterialParameterTypes[key];

	if (type === 'texture') {
		standardMaterialTextureParameters.push(key);
	}
}

const standardMaterialCubemapParameters = [];

for (const key in standardMaterialParameterTypes) {
	const type = standardMaterialParameterTypes[key];

	if (type === 'cubemap') {
		standardMaterialCubemapParameters.push(key);
	}
}

const _props = {};
const _uniforms = {};

let _params = new Set();

class StandardMaterial extends Material$1 {
	constructor() {
		super();
		this._dirtyShader = true;
		this._assetReferences = {};
		this._activeParams = new Set();
		this._activeLightingParams = new Set();
		this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
		this.reset();
	}

	reset() {
		Object.keys(_props).forEach(name => {
			this[`_${name}`] = _props[name].value();
		});
		this._chunks = {};
		this._uniformCache = {};
	}

	set chunks(value) {
		this._dirtyShader = true;
		this._chunks = value;
	}

	get chunks() {
		this._dirtyShader = true;
		return this._chunks;
	}

	copy(source) {
		super.copy(source);
		Object.keys(_props).forEach(k => {
			this[k] = source[k];
		});

		for (const p in source._chunks) {
			if (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];
		}

		return this;
	}

	_setParameter(name, value) {
		_params.add(name);

		this.setParameter(name, value);
	}

	_setParameters(parameters) {
		parameters.forEach(v => {
			this._setParameter(v.name, v.value);
		});
	}

	_processParameters(paramsName) {
		const prevParams = this[paramsName];
		prevParams.forEach(param => {
			if (!_params.has(param)) {
				delete this.parameters[param];
			}
		});
		this[paramsName] = _params;
		_params = prevParams;

		_params.clear();
	}

	_updateMap(p) {
		const mname = p + "Map";
		const map = this[mname];

		if (map) {
			this._setParameter("texture_" + mname, map);

			const tname = mname + "Transform";
			const uniform = this.getUniform(tname);

			if (uniform) {
				this._setParameters(uniform);
			}
		}
	}

	_allocUniform(name, allocFunc) {
		let uniform = this._uniformCache[name];

		if (!uniform) {
			uniform = allocFunc();
			this._uniformCache[name] = uniform;
		}

		return uniform;
	}

	getUniform(name, device, scene) {
		return _uniforms[name](this, device, scene);
	}

	updateUniforms(device, scene) {
		const getUniform = name => {
			return this.getUniform(name, device, scene);
		};

		this._setParameter('material_ambient', getUniform('ambient'));

		if (!this.diffuseMap || this.diffuseTint) {
			this._setParameter('material_diffuse', getUniform('diffuse'));
		}

		if (!this.useMetalness) {
			if (!this.specularMap || this.specularTint) {
				this._setParameter('material_specular', getUniform('specular'));
			}
		} else {
			if (!this.metalnessMap || this.metalness < 1) {
				this._setParameter('material_metalness', this.metalness);
			}
		}

		if (this.enableGGXSpecular) {
			this._setParameter('material_anisotropy', this.anisotropy);
		}

		if (this.clearCoat > 0) {
			this._setParameter('material_clearCoat', this.clearCoat);

			this._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);

			this._setParameter('material_clearCoatReflectivity', this.clearCoat);

			this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
		}

		this._setParameter("material_shininess", getUniform('shininess'));

		if (!this.emissiveMap || this.emissiveTint) {
			this._setParameter('material_emissive', getUniform('emissive'));
		}

		if (this.emissiveIntensity !== 1) {
			this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
		}

		if (this.refraction > 0) {
			this._setParameter('material_refraction', this.refraction);

			this._setParameter('material_refractionIndex', this.refractionIndex);
		}

		this._setParameter('material_opacity', this.opacity);

		if (this.opacityFadesSpecular === false) {
			this._setParameter('material_alphaFade', this.alphaFade);
		}

		if (this.occludeSpecular) {
			this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
		}

		if (this.cubeMapProjection === CUBEPROJ_BOX) {
			this._setParameter(getUniform("cubeMapProjectionBox"));
		}

		for (const p in _matTex2D) {
			this._updateMap(p);
		}

		if (this.ambientSH) {
			this._setParameter('ambientSH[0]', this.ambientSH);
		}

		if (this.normalMap) {
			this._setParameter('material_bumpiness', this.bumpiness);
		}

		if (this.normalMap && this.normalDetailMap) {
			this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
		}

		if (this.heightMap) {
			this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
		}

		if (this.cubeMap) {
			this._setParameter('texture_cubeMap', this.cubeMap);
		}

		if (this.sphereMap) {
			this._setParameter('texture_sphereMap', this.sphereMap);
		}

		this._setParameter('material_reflectivity', this.reflectivity);

		this._processParameters('_activeParams');

		if (this._dirtyShader) {
			this.shader = null;
			this.clearVariants();
		}
	}

	updateEnvUniforms(device, scene) {
		const envAtlas = this.envAtlas || (this.useSkybox ? scene.envAtlas : null);

		if (envAtlas) {
			this._setParameter('texture_envAtlas', envAtlas);

			if (this.useSkybox && !scene.skyboxRotation.equals(Quat.IDENTITY) && scene._skyboxRotationMat3) {
				this._setParameter('cubeMapRotationMatrix', scene._skyboxRotationMat3.data);
			}
		}

		this._processParameters('_activeLightingParams');
	}

	updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {
		this.updateEnvUniforms(device, scene);
		const minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;
		let options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
		if (minimalOptions) this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);

		if (this.onUpdateShader) {
			options = this.onUpdateShader(options);
		}

		const library = device.getProgramLibrary();
		this.shader = library.getProgram('standard', options);

		if (!objDefs) {
			this.clearVariants();
			this.variants[0] = this.shader;
		}

		this._dirtyShader = false;
	}

	destroy() {
		for (const asset in this._assetReferences) {
			this._assetReferences[asset]._unbind();
		}

		this._assetReferences = null;
		super.destroy();
	}

}

StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;

const defineUniform = (name, getUniformFunc) => {
	_uniforms[name] = getUniformFunc;
};

const definePropInternal = (name, constructorFunc, setterFunc, getterFunc) => {
	Object.defineProperty(StandardMaterial.prototype, name, {
		get: getterFunc || function () {
			return this[`_${name}`];
		},
		set: setterFunc
	});
	_props[name] = {
		value: constructorFunc
	};
};

const defineValueProp = prop => {
	const internalName = `_${prop.name}`;

	const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);

	const setterFunc = function setterFunc(value) {
		const oldValue = this[internalName];

		if (oldValue !== value) {
			this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
			this[internalName] = value;
		}
	};

	definePropInternal(prop.name, () => prop.defaultValue, setterFunc, prop.getterFunc);
};

const defineAggProp = prop => {
	const internalName = `_${prop.name}`;

	const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);

	const setterFunc = function setterFunc(value) {
		const oldValue = this[internalName];

		if (!oldValue.equals(value)) {
			this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
			this[internalName] = oldValue.copy(value);
		}
	};

	definePropInternal(prop.name, () => prop.defaultValue.clone(), setterFunc, prop.getterFunc);
};

const defineProp = prop => {
	return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
};

function _defineTex2D(name, uv, channels, defChannel, vertexColor, detailMode) {
	_matTex2D[name] = channels;
	defineProp({
		name: `${name}Map`,
		defaultValue: null,
		dirtyShaderFunc: (oldValue, newValue) => {
			return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);
		}
	});
	defineProp({
		name: `${name}MapTiling`,
		defaultValue: new Vec2(1, 1)
	});
	defineProp({
		name: `${name}MapOffset`,
		defaultValue: new Vec2(0, 0)
	});
	defineProp({
		name: `${name}MapRotation`,
		defaultValue: 0
	});
	defineProp({
		name: `${name}MapUv`,
		defaultValue: uv
	});

	if (channels > 0) {
		defineProp({
			name: `${name}MapChannel`,
			defaultValue: defChannel ? defChannel : channels > 1 ? "rgb" : "g"
		});
	}

	if (vertexColor) {
		defineProp({
			name: `${name}VertexColor`,
			defaultValue: false
		});

		if (channels > 0) {
			defineProp({
				name: `${name}VertexColorChannel`,
				defaultValue: defChannel ? defChannel : channels > 1 ? "rgb" : "g"
			});
		}
	}

	if (detailMode) {
		defineProp({
			name: `${name}Mode`,
			defaultValue: DETAILMODE_MUL
		});
	}

	const mapTiling = `${name}MapTiling`;
	const mapOffset = `${name}MapOffset`;
	const mapRotation = `${name}MapRotation`;
	const mapTransform = `${name}MapTransform`;
	defineUniform(mapTransform, (material, device, scene) => {
		const tiling = material[mapTiling];
		const offset = material[mapOffset];
		const rotation = material[mapRotation];

		if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
			return null;
		}

		const uniform = material._allocUniform(mapTransform, () => {
			return [{
				name: `texture_${mapTransform}0`,
				value: new Float32Array(3)
			}, {
				name: `texture_${mapTransform}1`,
				value: new Float32Array(3)
			}];
		});

		const cr = Math.cos(rotation * math.DEG_TO_RAD);
		const sr = Math.sin(rotation * math.DEG_TO_RAD);
		const uniform0 = uniform[0].value;
		uniform0[0] = cr * tiling.x;
		uniform0[1] = -sr * tiling.y;
		uniform0[2] = offset.x;
		const uniform1 = uniform[1].value;
		uniform1[0] = sr * tiling.x;
		uniform1[1] = cr * tiling.y;
		uniform1[2] = 1.0 - tiling.y - offset.y;
		return uniform;
	});
}

function _defineColor(name, defaultValue) {
	defineProp({
		name: name,
		defaultValue: defaultValue,
		getterFunc: function () {
			this._dirtyShader = true;
			return this[`_${name}`];
		}
	});
	defineUniform(name, (material, device, scene) => {
		const uniform = material._allocUniform(name, () => new Float32Array(3));

		const color = material[name];
		const gamma = material.useGammaTonemap && scene.gammaCorrection;

		if (gamma) {
			uniform[0] = Math.pow(color.r, 2.2);
			uniform[1] = Math.pow(color.g, 2.2);
			uniform[2] = Math.pow(color.b, 2.2);
		} else {
			uniform[0] = color.r;
			uniform[1] = color.g;
			uniform[2] = color.b;
		}

		return uniform;
	});
}

function _defineFloat(name, defaultValue, getUniformFunc) {
	defineProp({
		name: name,
		defaultValue: defaultValue,
		dirtyShaderFunc: (oldValue, newValue) => {
			return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
		}
	});
	defineUniform(name, getUniformFunc);
}

function _defineObject(name, getUniformFunc) {
	defineProp({
		name: name,
		defaultValue: null,
		dirtyShaderFunc: (oldValue, newValue) => {
			return !!oldValue === !!newValue;
		}
	});
	defineUniform(name, getUniformFunc);
}

function _defineFlag(name, defaultValue) {
	defineProp({
		name: name,
		defaultValue: defaultValue
	});
}

function _defineMaterialProps() {
	_defineColor("ambient", new Color(0.7, 0.7, 0.7));

	_defineColor("diffuse", new Color(1, 1, 1));

	_defineColor("specular", new Color(0, 0, 0));

	_defineColor("emissive", new Color(0, 0, 0));

	_defineFloat("emissiveIntensity", 1);

	_defineFloat("shininess", 25, (material, device, scene) => {
		return material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.shininess * 0.01 * 11) : material.shininess * 0.01;
	});

	_defineFloat("heightMapFactor", 1, (material, device, scene) => {
		return material.heightMapFactor * 0.025;
	});

	_defineFloat("opacity", 1);

	_defineFloat("alphaFade", 1);

	_defineFloat("alphaTest", 0);

	_defineFloat("bumpiness", 1);

	_defineFloat("normalDetailMapBumpiness", 1);

	_defineFloat("reflectivity", 1);

	_defineFloat("occludeSpecularIntensity", 1);

	_defineFloat("refraction", 0);

	_defineFloat("refractionIndex", 1.0 / 1.5);

	_defineFloat("metalness", 1);

	_defineFloat("anisotropy", 0);

	_defineFloat("clearCoat", 0);

	_defineFloat("clearCoatGlossiness", 1);

	_defineFloat("clearCoatBumpiness", 1);

	_defineFloat("aoUvSet", 0, null);

	_defineObject("ambientSH");

	_defineObject("cubeMapProjectionBox", (material, device, scene) => {
		const uniform = material._allocUniform('cubeMapProjectionBox', () => {
			return [{
				name: 'envBoxMin',
				value: new Float32Array(3)
			}, {
				name: 'envBoxMax',
				value: new Float32Array(3)
			}];
		});

		const bboxMin = material.cubeMapProjectionBox.getMin();
		const minUniform = uniform[0].value;
		minUniform[0] = bboxMin.x;
		minUniform[1] = bboxMin.y;
		minUniform[2] = bboxMin.z;
		const bboxMax = material.cubeMapProjectionBox.getMax();
		const maxUniform = uniform[1].value;
		maxUniform[0] = bboxMax.x;
		maxUniform[1] = bboxMax.y;
		maxUniform[2] = bboxMax.z;
		return uniform;
	});

	_defineFlag("ambientTint", false);

	_defineFlag("diffuseTint", false);

	_defineFlag("specularTint", false);

	_defineFlag("emissiveTint", false);

	_defineFlag("fastTbn", false);

	_defineFlag("specularAntialias", false);

	_defineFlag("useMetalness", false);

	_defineFlag("enableGGXSpecular", false);

	_defineFlag("occludeDirect", false);

	_defineFlag("normalizeNormalMap", true);

	_defineFlag("conserveEnergy", true);

	_defineFlag("opacityFadesSpecular", true);

	_defineFlag("occludeSpecular", SPECOCC_AO);

	_defineFlag("shadingModel", SPECULAR_BLINN);

	_defineFlag("fresnelModel", FRESNEL_SCHLICK);

	_defineFlag("cubeMapProjection", CUBEPROJ_NONE);

	_defineFlag("customFragmentShader", null);

	_defineFlag("forceFragmentPrecision", null);

	_defineFlag("useFog", true);

	_defineFlag("useLighting", true);

	_defineFlag("useGammaTonemap", true);

	_defineFlag("useSkybox", true);

	_defineFlag("forceUv1", false);

	_defineFlag("pixelSnap", false);

	_defineFlag("twoSidedLighting", false);

	_defineFlag("nineSlicedMode", undefined);

	_defineTex2D("diffuse", 0, 3, "", true);

	_defineTex2D("specular", 0, 3, "", true);

	_defineTex2D("emissive", 0, 3, "", true);

	_defineTex2D("normal", 0, -1, "", false);

	_defineTex2D("metalness", 0, 1, "", true);

	_defineTex2D("gloss", 0, 1, "", true);

	_defineTex2D("opacity", 0, 1, "a", true);

	_defineTex2D("height", 0, 1, "", false);

	_defineTex2D("ao", 0, 1, "", true);

	_defineTex2D("light", 1, 3, "", true);

	_defineTex2D("msdf", 0, 3, "", false);

	_defineTex2D("diffuseDetail", 0, 3, "", false, true);

	_defineTex2D("normalDetail", 0, -1, "", false);

	_defineTex2D("clearCoat", 0, 1, "", true);

	_defineTex2D("clearCoatGloss", 0, 1, "", true);

	_defineTex2D("clearCoatNormal", 0, -1, "", false);

	_defineObject("cubeMap");

	_defineObject("sphereMap");

	_defineObject("envAtlas");

	const getterFunc = function getterFunc() {
		return this._prefilteredCubemaps;
	};

	const setterFunc = function setterFunc(value) {
		const cubemaps = this._prefilteredCubemaps;
		value = value || [];
		let changed = false;
		let complete = true;

		for (let i = 0; i < 6; ++i) {
			const v = value[i] || null;

			if (cubemaps[i] !== v) {
				cubemaps[i] = v;
				changed = true;
			}

			complete = complete && !!cubemaps[i];
		}

		if (changed) {
			if (complete) {
				this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
					target: this.envAtlas
				});
			} else {
				if (this.envAtlas) {
					this.envAtlas.destroy();
					this.envAtlas = null;
				}
			}

			this._dirtyShader = true;
		}
	};

	const empty = [null, null, null, null, null, null];
	definePropInternal("prefilteredCubemaps", () => empty.slice(), setterFunc, getterFunc);
}

_defineMaterialProps();

class ProgramLibrary {
	constructor(device) {
		this._device = device;
		this._cache = {};
		this._generators = {};
		this._isClearingCache = false;
		this._precached = false;
		this._programsCollection = [];
		this._defaultStdMatOption = {};
		this._defaultStdMatOptionMin = {};
		const m = new StandardMaterial();
		m.shaderOptBuilder.updateRef(this._defaultStdMatOption, device, {}, m, null, [], SHADER_FORWARD, null, null);
		m.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, device, {}, m, null, [], SHADER_SHADOW, null, null);
	}

	register(name, generator) {
		if (!this.isRegistered(name)) {
			this._generators[name] = generator;
		}
	}

	unregister(name) {
		if (this.isRegistered(name)) {
			delete this._generators[name];
		}
	}

	isRegistered(name) {
		const generator = this._generators[name];
		return generator !== undefined;
	}

	getProgram(name, options) {
		const generator = this._generators[name];

		if (generator === undefined) {
			return null;
		}

		const gd = this._device;
		const key = generator.generateKey(options);
		let shader = this._cache[key];

		if (!shader) {
			let lights;

			if (options.lights) {
				lights = options.lights;
				options.lights = lights.map(function (l) {
					const lcopy = l.clone ? l.clone() : l;
					lcopy.key = l.key;
					return lcopy;
				});
			}

			this.storeNewProgram(name, options);
			if (options.lights) options.lights = lights;
			if (this._precached) console.warn(`ProgramLibrary#getProgram: Cache miss for shader ${name} key ${key} after shaders precaching`);
			const shaderDefinition = generator.createShaderDefinition(gd, options);
			shader = this._cache[key] = new Shader(gd, shaderDefinition);
		}

		return shader;
	}

	storeNewProgram(name, options) {
		let opt = {};

		if (name === "standard") {
			const defaultMat = this._getDefaultStdMatOptions(options.pass);

			for (const p in options) {
				if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === "pass") opt[p] = options[p];
			}
		} else {
			opt = options;
		}

		this._programsCollection.push(JSON.stringify({
			name: name,
			options: opt
		}));
	}

	dumpPrograms() {
		let text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
		text += 'let shaders = [';
		if (this._programsCollection[0]) text += '\n\t' + this._programsCollection[0];

		for (let i = 1; i < this._programsCollection.length; ++i) {
			text += ',\n\t' + this._programsCollection[i];
		}

		text += '\n];\n';
		text += 'device.programLib.precompile(shaders);\n';
		text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
		text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
		const element = document.createElement('a');
		element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
		element.setAttribute('download', 'precompile-shaders.js');
		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
	}

	clearCache() {
		const cache = this._cache;
		this._isClearingCache = true;

		for (const key in cache) {
			if (cache.hasOwnProperty(key)) {
				cache[key].destroy();
			}
		}

		this._cache = {};
		this._isClearingCache = false;
	}

	removeFromCache(shader) {
		if (this._isClearingCache) return;
		const cache = this._cache;

		for (const key in cache) {
			if (cache.hasOwnProperty(key)) {
				if (cache[key] === shader) {
					delete cache[key];
					break;
				}
			}
		}
	}

	_getDefaultStdMatOptions(pass) {
		return pass > SHADER_FORWARDHDR && pass <= SHADER_PICK ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
	}

	precompile(cache) {
		if (cache) {
			const shaders = new Array(cache.length);

			for (let i = 0; i < cache.length; i++) {
				if (cache[i].name === "standard") {
					const opt = cache[i].options;

					const defaultMat = this._getDefaultStdMatOptions(opt.pass);

					for (const p in defaultMat) {
						if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];
					}
				}

				shaders[i] = this.getProgram(cache[i].name, cache[i].options);
			}
		}

		this._precached = true;
	}

}

class Version {
	constructor() {
		this.globalId = 0;
		this.revision = 0;
	}

	equals(other) {
		return this.globalId === other.globalId && this.revision === other.revision;
	}

	copy(other) {
		this.globalId = other.globalId;
		this.revision = other.revision;
	}

	reset() {
		this.globalId = 0;
		this.revision = 0;
	}

}

let idCounter = 0;

class VersionedObject {
	constructor() {
		idCounter++;
		this.version = new Version();
		this.version.globalId = idCounter;
	}

	increment() {
		this.version.revision++;
	}

}

class ScopeId {
	constructor(name) {
		this.name = name;
		this.value = null;
		this.versionObject = new VersionedObject();
	}

	setValue(value) {
		this.value = value;
		this.versionObject.increment();
	}

	getValue() {
		return this.value;
	}

}

class ScopeSpace {
	constructor(name) {
		this.name = name;
		this.variables = new Map();
	}

	resolve(name) {
		if (!this.variables.has(name)) {
			this.variables.set(name, new ScopeId(name));
		}

		return this.variables.get(name);
	}

	removeValue(value) {
		for (const uniformName in this.variables) {
			const uniform = this.variables[uniformName];

			if (uniform.value === value) {
				uniform.value = null;
			}
		}
	}

}

class ShaderInput {
	constructor(graphicsDevice, name, type, locationId) {
		this.locationId = locationId;
		this.scopeId = graphicsDevice.scope.resolve(name);
		this.version = new Version();

		if (name.substr(name.length - 3) === "[0]") {
			switch (type) {
				case UNIFORMTYPE_FLOAT:
					type = UNIFORMTYPE_FLOATARRAY;
					break;

				case UNIFORMTYPE_VEC2:
					type = UNIFORMTYPE_VEC2ARRAY;
					break;

				case UNIFORMTYPE_VEC3:
					type = UNIFORMTYPE_VEC3ARRAY;
					break;

				case UNIFORMTYPE_VEC4:
					type = UNIFORMTYPE_VEC4ARRAY;
					break;
			}
		}

		this.dataType = type;
		this.value = [null, null, null, null];
		this.array = [];
	}

}

class GrabPass {
	constructor(device, useAlpha) {
		this.device = device;
		this.useAlpha = useAlpha;
		this.useMipmaps = device.webgl2;
		this.texture = null;
		this.renderTarget = null;
		this.textureId = null;
	}

	destroy() {
		this.textureId = null;

		if (this.renderTarget) {
			this.renderTarget.destroy();
			this.renderTarget = null;
		}

		if (this.texture) {
			this.texture.destroy();
			this.texture = null;
		}
	}

	create() {
		if (!this.texture) {
			const texture = new Texture(this.device, {
				name: 'texture_grabPass',
				format: this.useAlpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8,
				minFilter: this.useMipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: this.useMipmaps
			});
			this.texture = texture;
			this.renderTarget = new RenderTarget({
				colorBuffer: texture,
				depth: false
			});
			this.textureId = this.device.scope.resolve(texture.name);
			this.textureId.setValue(texture);
		}
	}

	update() {
		const device = this.device;
		const gl = device.gl;

		if (!device.grabPassAvailable) {
			return false;
		}

		const renderTarget = device.renderTarget;
		const resolveRenderTarget = renderTarget && renderTarget._glResolveFrameBuffer;
		const texture = this.texture;
		const width = device.width;
		const height = device.height;

		if (device.webgl2 && !device._tempMacChromeBlitFramebufferWorkaround && width === texture._width && height === texture._height) {
			if (resolveRenderTarget) {
				renderTarget.resolve(true);
			}

			const currentFrameBuffer = renderTarget ? renderTarget._glFrameBuffer : null;
			const resolvedFrameBuffer = renderTarget ? renderTarget._glResolveFrameBuffer || renderTarget._glFrameBuffer : null;
			device.initRenderTarget(this.renderTarget);
			const grabPassFrameBuffer = this.renderTarget._glFrameBuffer;
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, resolvedFrameBuffer);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, grabPassFrameBuffer);
			gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, currentFrameBuffer);
		} else {
			if (resolveRenderTarget) {
				renderTarget.resolve(true);
				gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glResolveFrameBuffer);
			}

			const format = texture._glFormat;
			gl.copyTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, width, height, 0);
			texture._width = width;
			texture._height = height;

			if (resolveRenderTarget) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glFrameBuffer);
			}
		}

		return true;
	}

	generateMipmaps() {
		if (this.useMipmaps) {
			this.device.gl.generateMipmap(this.texture._glTarget);
		}
	}

	prepareTexture() {
		const updated = this.update();

		if (updated) {
			this.generateMipmaps();
		}

		return updated;
	}

}

const EVENT_RESIZE = 'resizecanvas';

function downsampleImage(image, size) {
	const srcW = image.width;
	const srcH = image.height;

	if (srcW > size || srcH > size) {
		const scale = size / Math.max(srcW, srcH);
		const dstW = Math.floor(srcW * scale);
		const dstH = Math.floor(srcH * scale);
		const canvas = document.createElement('canvas');
		canvas.width = dstW;
		canvas.height = dstH;
		const context = canvas.getContext('2d');
		context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
		return canvas;
	}

	return image;
}

function testRenderable(gl, pixelFormat) {
	let result = true;
	const texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);
	const framebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
		result = false;
	}

	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.deleteTexture(texture);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	gl.deleteFramebuffer(framebuffer);
	return result;
}

function testTextureHalfFloatUpdatable(gl, pixelFormat) {
	let result = true;
	const texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	const data = new Uint16Array(4 * 2 * 2);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);

	if (gl.getError() !== gl.NO_ERROR) {
		result = false;
		console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support");
	}

	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.deleteTexture(texture);
	return result;
}

function testTextureFloatHighPrecision(device) {
	if (!device.textureFloatRenderable) return false;
	const test1 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTestPS, "ptest1");
	const test2 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTest2PS, "ptest2");
	const textureOptions = {
		format: PIXELFORMAT_RGBA32F,
		width: 1,
		height: 1,
		mipmaps: false,
		minFilter: FILTER_NEAREST,
		magFilter: FILTER_NEAREST
	};
	const tex1 = new Texture(device, textureOptions);
	tex1.name = 'testFHP';
	const targ1 = new RenderTarget({
		colorBuffer: tex1,
		depth: false
	});
	drawQuadWithShader(device, targ1, test1);
	textureOptions.format = PIXELFORMAT_R8_G8_B8_A8;
	const tex2 = new Texture(device, textureOptions);
	tex2.name = 'testFHP';
	const targ2 = new RenderTarget({
		colorBuffer: tex2,
		depth: false
	});
	device.constantTexSource.setValue(tex1);
	drawQuadWithShader(device, targ2, test2);
	const prevFramebuffer = device.activeFramebuffer;
	device.setFramebuffer(targ2._glFrameBuffer);
	const pixels = new Uint8Array(4);
	device.readPixels(0, 0, 1, 1, pixels);
	device.setFramebuffer(prevFramebuffer);
	const x = pixels[0] / 255;
	const y = pixels[1] / 255;
	const z = pixels[2] / 255;
	const w = pixels[3] / 255;
	const f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;
	tex1.destroy();
	targ1.destroy();
	tex2.destroy();
	targ2.destroy();
	return f === 0;
}

class GraphicsDevice extends EventHandler {
	constructor(canvas, options = {}) {
		super();
		this.canvas = void 0;
		this.gl = void 0;
		this.maxAnisotropy = void 0;
		this.maxCubeMapSize = void 0;
		this.maxTextureSize = void 0;
		this.maxVolumeSize = void 0;
		this.precision = void 0;
		this.scope = void 0;
		this.supportsInstancing = void 0;
		this.textureFloatRenderable = void 0;
		this.textureHalfFloatRenderable = void 0;
		this.webgl2 = void 0;
		this.canvas = canvas;
		this._enableAutoInstancing = false;
		this.autoInstancingMaxObjects = 16384;
		this.defaultFramebuffer = null;
		this._maxPixelRatio = 1;
		this._width = 0;
		this._height = 0;
		this.updateClientRect();
		this.shaders = [];
		this.buffers = [];
		this.textures = [];
		this.targets = [];
		this.contextLost = false;

		this._contextLostHandler = event => {
			event.preventDefault();
			this.contextLost = true;
			this.loseContext();
			this.fire('devicelost');
		};

		this._contextRestoredHandler = () => {
			this.restoreContext();
			this.contextLost = false;
			this.fire('devicerestored');
		};

		options.stencil = true;

		if (!options.powerPreference) {
			options.powerPreference = 'high-performance';
		}

		const preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;
		const names = preferWebGl2 ? ["webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
		let gl = null;

		for (let i = 0; i < names.length; i++) {
			gl = canvas.getContext(names[i], options);

			if (gl) {
				this.webgl2 = names[i] === 'webgl2';
				break;
			}
		}

		if (!gl) {
			throw new Error("WebGL not supported");
		}

		const isChrome = platform.browser && !!window.chrome;
		const isMac = platform.browser && navigator.appVersion.indexOf("Mac") !== -1;
		this.gl = gl;
		this._tempEnableSafariTextureUnitWorkaround = platform.browser && !!window.safari;
		this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;

		if (!this.webgl2) {
			setupVertexArrayObject(gl);
		}

		canvas.addEventListener("webglcontextlost", this._contextLostHandler, false);
		canvas.addEventListener("webglcontextrestored", this._contextRestoredHandler, false);
		this.initializeExtensions();
		this.initializeCapabilities();
		this.initializeRenderState();
		this.initializeContextCaches();
		this.defaultClearOptions = {
			color: [0, 0, 0, 1],
			depth: 1,
			stencil: 0,
			flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
		};
		this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
		this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];
		this.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA];
		this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
		this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
		this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
		this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
		this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
		this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
		this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];
		this.pcUniformType = {};
		this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
		this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
		this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
		this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
		this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
		this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
		this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
		this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
		this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
		this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
		this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
		this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
		this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
		this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
		this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
		this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
		this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;

		if (this.webgl2) {
			this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
			this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
			this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
		}

		this.targetToSlot = {};
		this.targetToSlot[gl.TEXTURE_2D] = 0;
		this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
		this.targetToSlot[gl.TEXTURE_3D] = 2;
		let scopeX, scopeY, scopeZ, scopeW;
		let uniformValue;
		this.commitFunction = [];

		this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
			if (uniform.value !== value) {
				gl.uniform1i(uniform.locationId, value);
				uniform.value = value;
			}
		};

		this.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];

		this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
			if (uniform.value !== value) {
				gl.uniform1f(uniform.locationId, value);
				uniform.value = value;
			}
		};

		this.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
				gl.uniform2fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
			}
		};

		this.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
				gl.uniform3fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
			}
		};

		this.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			scopeW = value[3];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
				gl.uniform4fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
				uniformValue[3] = scopeW;
			}
		};

		this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
				gl.uniform2iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
			}
		};

		this.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];

		this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
				gl.uniform3iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
			}
		};

		this.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];

		this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			scopeW = value[3];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
				gl.uniform4iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
				uniformValue[3] = scopeW;
			}
		};

		this.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];

		this.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {
			gl.uniformMatrix2fv(uniform.locationId, false, value);
		};

		this.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {
			gl.uniformMatrix3fv(uniform.locationId, false, value);
		};

		this.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {
			gl.uniformMatrix4fv(uniform.locationId, false, value);
		};

		this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
			gl.uniform1fv(uniform.locationId, value);
		};

		this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {
			gl.uniform2fv(uniform.locationId, value);
		};

		this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {
			gl.uniform3fv(uniform.locationId, value);
		};

		this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {
			gl.uniform4fv(uniform.locationId, value);
		};

		this.scope = new ScopeSpace("Device");
		this.programLib = new ProgramLibrary(this);

		for (const generator in programlib) this.programLib.register(generator, programlib[generator]);

		this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
		let numUniforms = this.vertexUniformsCount;
		numUniforms -= 4 * 4;
		numUniforms -= 8;
		numUniforms -= 1;
		numUniforms -= 4 * 4;
		this.boneLimit = Math.floor(numUniforms / 3);
		this.boneLimit = Math.min(this.boneLimit, 128);

		if (this.unmaskedRenderer === 'Mali-450 MP') {
			this.boneLimit = 34;
		}

		this._drawCallsPerFrame = 0;
		this._shaderSwitchesPerFrame = 0;
		this._primsPerFrame = [];

		for (let i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
			this._primsPerFrame[i] = 0;
		}

		this._renderTargetCreationTime = 0;
		this._vram = {
			tex: 0,
			vb: 0,
			ib: 0
		};
		this._shaderStats = {
			vsCompiled: 0,
			fsCompiled: 0,
			linked: 0,
			materialShaders: 0,
			compileTime: 0
		};
		this.constantTexSource = this.scope.resolve("source");

		if (this.extTextureFloat) {
			if (this.webgl2) {
				this.textureFloatRenderable = !!this.extColorBufferFloat;
			} else {
				this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
			}
		} else {
			this.textureFloatRenderable = false;
		}

		if (this.extColorBufferHalfFloat) {
			this.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat;
		} else if (this.extTextureHalfFloat) {
			if (this.webgl2) {
				this.textureHalfFloatRenderable = !!this.extColorBufferFloat;
			} else {
				this.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
			}
		} else {
			this.textureHalfFloatRenderable = false;
		}

		this.supportsMorphTargetTexturesCore = this.maxPrecision === "highp" && this.maxVertexTextures >= 2;
		this._textureFloatHighPrecision = undefined;
		this._textureHalfFloatUpdatable = undefined;
		this.grabPassAvailable = true;
		this.grabPass = new GrabPass(this, options.alpha);
		this.grabPass.create();
		VertexFormat.init(this);
		this.areaLightLutFormat = PIXELFORMAT_R8_G8_B8_A8;

		if (this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear) {
			this.areaLightLutFormat = PIXELFORMAT_RGBA16F;
		} else if (this.extTextureFloat && this.extTextureFloatLinear) {
			this.areaLightLutFormat = PIXELFORMAT_RGBA32F;
		}
	}

	destroy() {
		const gl = this.gl;
		this.fire('destroy');
		this.grabPass.destroy();

		if (this.webgl2 && this.feedback) {
			gl.deleteTransformFeedback(this.feedback);
		}

		this.clearShaderCache();
		this.clearVertexArrayObjectCache();
		this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
		this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
		this._contextLostHandler = null;
		this._contextRestoredHandler = null;
		this.scope = null;
		this.canvas = null;
		this.gl = null;
	}

	toJSON(key) {
		return undefined;
	}

	getPrecision() {
		const gl = this.gl;
		let precision = "highp";

		if (gl.getShaderPrecisionFormat) {
			const vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
			const vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
			const fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
			const fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
			const highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
			const mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;

			if (!highpAvailable) {
				if (mediumpAvailable) {
					precision = "mediump";
				} else {
					precision = "lowp";
				}
			}
		}

		return precision;
	}

	initializeExtensions() {
		const gl = this.gl;
		const supportedExtensions = gl.getSupportedExtensions();

		const getExtension = function getExtension() {
			for (let i = 0; i < arguments.length; i++) {
				if (supportedExtensions.indexOf(arguments[i]) !== -1) {
					return gl.getExtension(arguments[i]);
				}
			}

			return null;
		};

		if (this.webgl2) {
			this.extBlendMinmax = true;
			this.extDrawBuffers = true;
			this.extInstancing = true;
			this.extStandardDerivatives = true;
			this.extTextureFloat = true;
			this.extTextureHalfFloat = true;
			this.extTextureLod = true;
			this.extUintElement = true;
			this.extVertexArrayObject = true;
			this.extColorBufferFloat = getExtension('EXT_color_buffer_float');
			this.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
		} else {
			this.extBlendMinmax = getExtension("EXT_blend_minmax");
			this.extDrawBuffers = getExtension('EXT_draw_buffers');
			this.extInstancing = getExtension("ANGLE_instanced_arrays");

			if (this.extInstancing) {
				const ext = this.extInstancing;
				gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
				gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
				gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
			}

			this.extStandardDerivatives = getExtension("OES_standard_derivatives");
			this.extTextureFloat = getExtension("OES_texture_float");
			this.extTextureHalfFloat = getExtension("OES_texture_half_float");
			this.extTextureLod = getExtension('EXT_shader_texture_lod');
			this.extUintElement = getExtension("OES_element_index_uint");
			this.extVertexArrayObject = getExtension("OES_vertex_array_object");

			if (this.extVertexArrayObject) {
				const ext = this.extVertexArrayObject;
				gl.createVertexArray = ext.createVertexArrayOES.bind(ext);
				gl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);
				gl.isVertexArray = ext.isVertexArrayOES.bind(ext);
				gl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);
			}

			this.extColorBufferFloat = null;
			this.extDisjointTimerQuery = null;
		}

		this.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');
		this.extTextureFloatLinear = getExtension("OES_texture_float_linear");
		this.extTextureHalfFloatLinear = getExtension("OES_texture_half_float_linear");
		this.extFloatBlend = getExtension("EXT_float_blend");
		this.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
		this.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');
		this.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');
		this.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
		this.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
		this.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');
		this.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');
		this.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');
		this.extColorBufferHalfFloat = getExtension("EXT_color_buffer_half_float");
		this.supportsInstancing = !!this.extInstancing;
	}

	initializeCapabilities() {
		const gl = this.gl;
		let ext;
		this.maxPrecision = this.precision = this.getPrecision();
		const contextAttribs = gl.getContextAttributes();
		this.supportsMsaa = contextAttribs.antialias;
		this.supportsStencil = contextAttribs.stencil;
		this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
		this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

		if (this.webgl2) {
			this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
			this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
			this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
		} else {
			ext = this.extDrawBuffers;
			this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;
			this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;
			this.maxVolumeSize = 1;
		}

		ext = this.extDebugRendererInfo;
		this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
		this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
		ext = this.extTextureFilterAnisotropic;
		this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
		this.samples = gl.getParameter(gl.SAMPLES);
		this.maxSamples = this.webgl2 ? gl.getParameter(gl.MAX_SAMPLES) : 1;
		this.supportsAreaLights = this.webgl2 || !platform.android;

		if (this.maxTextures <= 8) {
			this.supportsAreaLights = false;
		}
	}

	initializeRenderState() {
		const gl = this.gl;
		this.blending = false;
		gl.disable(gl.BLEND);
		this.blendSrc = BLENDMODE_ONE;
		this.blendDst = BLENDMODE_ZERO;
		this.blendSrcAlpha = BLENDMODE_ONE;
		this.blendDstAlpha = BLENDMODE_ZERO;
		this.separateAlphaBlend = false;
		this.blendEquation = BLENDEQUATION_ADD;
		this.blendAlphaEquation = BLENDEQUATION_ADD;
		this.separateAlphaEquation = false;
		gl.blendFunc(gl.ONE, gl.ZERO);
		gl.blendEquation(gl.FUNC_ADD);
		this.writeRed = true;
		this.writeGreen = true;
		this.writeBlue = true;
		this.writeAlpha = true;
		gl.colorMask(true, true, true, true);
		this.cullMode = CULLFACE_BACK;
		gl.enable(gl.CULL_FACE);
		gl.cullFace(gl.BACK);
		this.depthTest = true;
		gl.enable(gl.DEPTH_TEST);
		this.depthFunc = FUNC_LESSEQUAL;
		gl.depthFunc(gl.LEQUAL);
		this.depthWrite = true;
		gl.depthMask(true);
		this.stencil = false;
		gl.disable(gl.STENCIL_TEST);
		this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
		this.stencilRefFront = this.stencilRefBack = 0;
		this.stencilMaskFront = this.stencilMaskBack = 0xFF;
		gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
		this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
		this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
		this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
		this.stencilWriteMaskFront = 0xFF;
		this.stencilWriteMaskBack = 0xFF;
		gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
		gl.stencilMask(0xFF);
		this.alphaToCoverage = false;
		this.raster = true;

		if (this.webgl2) {
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.disable(gl.RASTERIZER_DISCARD);
		}

		this.depthBiasEnabled = false;
		gl.disable(gl.POLYGON_OFFSET_FILL);
		this.clearDepth = 1;
		gl.clearDepth(1);
		this.clearRed = 0;
		this.clearBlue = 0;
		this.clearGreen = 0;
		this.clearAlpha = 0;
		gl.clearColor(0, 0, 0, 0);
		this.clearStencil = 0;
		gl.clearStencil(0);
		this.vx = this.vy = this.vw = this.vh = 0;
		this.sx = this.sy = this.sw = this.sh = 0;

		if (this.webgl2) {
			gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
		} else {
			if (this.extStandardDerivatives) {
				gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
			}
		}

		gl.enable(gl.SCISSOR_TEST);
		gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
		this.unpackFlipY = false;
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
		this.unpackPremultiplyAlpha = false;
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
	}

	initializeContextCaches() {
		this.vertexShaderCache = {};
		this.fragmentShaderCache = {};
		this._vaoMap = new Map();
		this.boundVao = null;
		this.indexBuffer = null;
		this.vertexBuffers = [];
		this.shader = null;
		this.renderTarget = null;
		this.activeFramebuffer = null;
		this.feedback = null;
		this.transformFeedbackBuffer = null;
		this.textureUnit = 0;
		this.textureUnits = [];

		for (let i = 0; i < this.maxCombinedTextures; i++) {
			this.textureUnits.push([null, null, null]);
		}
	}

	loseContext() {
		for (const shader of this.shaders) {
			shader.loseContext();
		}

		this.grabPass.destroy();

		while (this.textures.length > 0) {
			const texture = this.textures[0];
			this.destroyTexture(texture);
			texture.dirtyAll();
		}

		for (const buffer of this.buffers) {
			buffer.loseContext();
		}

		for (const target of this.targets) {
			target.loseContext();
		}
	}

	restoreContext() {
		this.initializeExtensions();
		this.initializeCapabilities();
		this.initializeRenderState();
		this.initializeContextCaches();

		for (const shader of this.shaders) {
			this.compileAndLinkShader(shader);
		}

		for (const buffer of this.buffers) {
			buffer.unlock();
		}

		this.grabPass.create();
	}

	updateClientRect() {
		this.clientRect = this.canvas.getBoundingClientRect();
	}

	setViewport(x, y, w, h) {
		if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
			this.gl.viewport(x, y, w, h);
			this.vx = x;
			this.vy = y;
			this.vw = w;
			this.vh = h;
		}
	}

	setScissor(x, y, w, h) {
		if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
			this.gl.scissor(x, y, w, h);
			this.sx = x;
			this.sy = y;
			this.sw = w;
			this.sh = h;
		}
	}

	getProgramLibrary() {
		return this.programLib;
	}

	setProgramLibrary(programLib) {
		this.programLib = programLib;
	}

	setFramebuffer(fb) {
		if (this.activeFramebuffer !== fb) {
			const gl = this.gl;
			gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
			this.activeFramebuffer = fb;
		}
	}

	_checkFbo() {
		const gl = this.gl;
		const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

		switch (status) {
			case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
				console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
				break;

			case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
				console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
				break;

			case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
				console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
				break;

			case gl.FRAMEBUFFER_UNSUPPORTED:
				console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
				break;

			case gl.FRAMEBUFFER_COMPLETE:
				break;
		}
	}

	copyRenderTarget(source, dest, color, depth) {
		const gl = this.gl;

		if (!this.webgl2 && depth) {
			return false;
		}

		if (color) {
			if (!dest) {
				if (!source._colorBuffer) {
					return false;
				}
			} else {
				if (!source._colorBuffer || !dest._colorBuffer) {
					return false;
				}

				if (source._colorBuffer._format !== dest._colorBuffer._format) {
					return false;
				}
			}
		}

		if (depth) {
			if (!source._depthBuffer || !dest._depthBuffer) {
				return false;
			}

			if (source._depthBuffer._format !== dest._depthBuffer._format) {
				return false;
			}
		}

		if (this.webgl2 && dest) {
			const prevRt = this.renderTarget;
			this.renderTarget = dest;
			this.updateBegin();
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);
			const w = source ? source.width : dest.width;
			const h = source ? source.height : dest.height;
			gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
			this.renderTarget = prevRt;
			gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);
		} else {
			const shader = this.getCopyShader();
			this.constantTexSource.setValue(source._colorBuffer);
			drawQuadWithShader(this, dest, shader);
		}

		return true;
	}

	initRenderTarget(target) {
		if (target._glFrameBuffer) return;
		const gl = this.gl;
		target._glFrameBuffer = gl.createFramebuffer();
		this.setFramebuffer(target._glFrameBuffer);
		const colorBuffer = target._colorBuffer;

		if (colorBuffer) {
			if (!colorBuffer._glTexture) {
				colorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);
				colorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);
				this.setTexture(colorBuffer, 0);
			}

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer._glTexture, 0);
		}

		const depthBuffer = target._depthBuffer;

		if (depthBuffer && this.webgl2) {
			if (!depthBuffer._glTexture) {
				depthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);
				depthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);
				this.setTexture(depthBuffer, 0);
			}

			if (target._stencil) {
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);
			} else {
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);
			}
		} else if (target._depth) {
			const willRenderMsaa = target._samples > 1 && this.webgl2;

			if (!willRenderMsaa) {
				if (!target._glDepthBuffer) {
					target._glDepthBuffer = gl.createRenderbuffer();
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);

				if (target._stencil) {
					gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
				} else {
					gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			}
		}

		if (this.webgl2 && target._samples > 1) {
			target._glResolveFrameBuffer = target._glFrameBuffer;
			target._glFrameBuffer = gl.createFramebuffer();
			this.setFramebuffer(target._glFrameBuffer);

			if (colorBuffer) {
				if (!target._glMsaaColorBuffer) {
					target._glMsaaColorBuffer = gl.createRenderbuffer();
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);
				gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer._glInternalFormat, target.width, target.height);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);
			}

			if (target._depth) {
				if (!target._glMsaaDepthBuffer) {
					target._glMsaaDepthBuffer = gl.createRenderbuffer();
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);

				if (target._stencil) {
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
				} else {
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
				}
			}
		}

		this.targets.push(target);
	}

	getCopyShader() {
		if (!this._copyShader) {
			const vs = shaderChunks.fullscreenQuadVS;
			const fs = shaderChunks.outputTex2DPS;
			this._copyShader = createShaderFromCode(this, vs, fs, "outputTex2D");
		}

		return this._copyShader;
	}

	updateBegin() {
		this.boundVao = null;

		if (this._tempEnableSafariTextureUnitWorkaround) {
			for (let unit = 0; unit < this.textureUnits.length; ++unit) {
				for (let slot = 0; slot < 3; ++slot) {
					this.textureUnits[unit][slot] = null;
				}
			}
		}

		const target = this.renderTarget;

		if (target) {
			if (!target._glFrameBuffer) {
				this.initRenderTarget(target);
			} else {
				this.setFramebuffer(target._glFrameBuffer);
			}
		} else {
			this.setFramebuffer(this.defaultFramebuffer);
		}
	}

	updateEnd() {
		const gl = this.gl;

		if (this.boundVao) {
			this.boundVao = null;
			this.gl.bindVertexArray(null);
		}

		const target = this.renderTarget;

		if (target) {
			const colorBuffer = target._colorBuffer;

			if (colorBuffer && colorBuffer._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {
				this.activeTexture(this.maxCombinedTextures - 1);
				this.bindTexture(colorBuffer);
				gl.generateMipmap(colorBuffer._glTarget);
			}

			if (this.webgl2 && target._samples > 1 && target.autoResolve) {
				target.resolve();
			}
		}
	}

	initializeTexture(texture) {
		const gl = this.gl;
		let ext;
		texture._glTexture = gl.createTexture();
		texture._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;

		switch (texture._format) {
			case PIXELFORMAT_A8:
				texture._glFormat = gl.ALPHA;
				texture._glInternalFormat = gl.ALPHA;
				texture._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_L8:
				texture._glFormat = gl.LUMINANCE;
				texture._glInternalFormat = gl.LUMINANCE;
				texture._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_L8_A8:
				texture._glFormat = gl.LUMINANCE_ALPHA;
				texture._glInternalFormat = gl.LUMINANCE_ALPHA;
				texture._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_R5_G6_B5:
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = gl.RGB;
				texture._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
				break;

			case PIXELFORMAT_R5_G5_B5_A1:
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = gl.RGBA;
				texture._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
				break;

			case PIXELFORMAT_R4_G4_B4_A4:
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = gl.RGBA;
				texture._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
				break;

			case PIXELFORMAT_R8_G8_B8:
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = this.webgl2 ? gl.RGB8 : gl.RGB;
				texture._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_R8_G8_B8_A8:
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = this.webgl2 ? gl.RGBA8 : gl.RGBA;
				texture._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_DXT1:
				ext = this.extCompressedTextureS3TC;
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
				break;

			case PIXELFORMAT_DXT3:
				ext = this.extCompressedTextureS3TC;
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				break;

			case PIXELFORMAT_DXT5:
				ext = this.extCompressedTextureS3TC;
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				break;

			case PIXELFORMAT_ETC1:
				ext = this.extCompressedTextureETC1;
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;
				break;

			case PIXELFORMAT_PVRTC_2BPP_RGB_1:
				ext = this.extCompressedTexturePVRTC;
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				break;

			case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
				ext = this.extCompressedTexturePVRTC;
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				break;

			case PIXELFORMAT_PVRTC_4BPP_RGB_1:
				ext = this.extCompressedTexturePVRTC;
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				break;

			case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
				ext = this.extCompressedTexturePVRTC;
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				break;

			case PIXELFORMAT_ETC2_RGB:
				ext = this.extCompressedTextureETC;
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;
				break;

			case PIXELFORMAT_ETC2_RGBA:
				ext = this.extCompressedTextureETC;
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;
				break;

			case PIXELFORMAT_ASTC_4x4:
				ext = this.extCompressedTextureASTC;
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = ext.COMPRESSED_RGBA_ASTC_4x4_KHR;
				break;

			case PIXELFORMAT_ATC_RGB:
				ext = this.extCompressedTextureATC;
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = ext.COMPRESSED_RGB_ATC_WEBGL;
				break;

			case PIXELFORMAT_ATC_RGBA:
				ext = this.extCompressedTextureATC;
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
				break;

			case PIXELFORMAT_RGB16F:
				ext = this.extTextureHalfFloat;
				texture._glFormat = gl.RGB;

				if (this.webgl2) {
					texture._glInternalFormat = gl.RGB16F;
					texture._glPixelType = gl.HALF_FLOAT;
				} else {
					texture._glInternalFormat = gl.RGB;
					texture._glPixelType = ext.HALF_FLOAT_OES;
				}

				break;

			case PIXELFORMAT_RGBA16F:
				ext = this.extTextureHalfFloat;
				texture._glFormat = gl.RGBA;

				if (this.webgl2) {
					texture._glInternalFormat = gl.RGBA16F;
					texture._glPixelType = gl.HALF_FLOAT;
				} else {
					texture._glInternalFormat = gl.RGBA;
					texture._glPixelType = ext.HALF_FLOAT_OES;
				}

				break;

			case PIXELFORMAT_RGB32F:
				texture._glFormat = gl.RGB;

				if (this.webgl2) {
					texture._glInternalFormat = gl.RGB32F;
				} else {
					texture._glInternalFormat = gl.RGB;
				}

				texture._glPixelType = gl.FLOAT;
				break;

			case PIXELFORMAT_RGBA32F:
				texture._glFormat = gl.RGBA;

				if (this.webgl2) {
					texture._glInternalFormat = gl.RGBA32F;
				} else {
					texture._glInternalFormat = gl.RGBA;
				}

				texture._glPixelType = gl.FLOAT;
				break;

			case PIXELFORMAT_R32F:
				texture._glFormat = gl.RED;
				texture._glInternalFormat = gl.R32F;
				texture._glPixelType = gl.FLOAT;
				break;

			case PIXELFORMAT_DEPTH:
				if (this.webgl2) {
					texture._glFormat = gl.DEPTH_COMPONENT;
					texture._glInternalFormat = gl.DEPTH_COMPONENT32F;
					texture._glPixelType = gl.FLOAT;
				} else {
					texture._glFormat = gl.DEPTH_COMPONENT;
					texture._glInternalFormat = gl.DEPTH_COMPONENT;
					texture._glPixelType = gl.UNSIGNED_SHORT;
				}

				break;

			case PIXELFORMAT_DEPTHSTENCIL:
				texture._glFormat = gl.DEPTH_STENCIL;
				texture._glInternalFormat = gl.DEPTH24_STENCIL8;
				texture._glPixelType = gl.UNSIGNED_INT_24_8;
				break;

			case PIXELFORMAT_111110F:
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = gl.R11F_G11F_B10F;
				texture._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
				break;

			case PIXELFORMAT_SRGB:
				texture._glFormat = gl.RGB;
				texture._glInternalFormat = gl.SRGB8;
				texture._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_SRGBA:
				texture._glFormat = gl.RGBA;
				texture._glInternalFormat = gl.SRGB8_ALPHA8;
				texture._glPixelType = gl.UNSIGNED_BYTE;
				break;
		}

		this.textures.push(texture);
	}

	destroyTexture(texture) {
		if (texture._glTexture) {
			const idx = this.textures.indexOf(texture);

			if (idx !== -1) {
				this.textures.splice(idx, 1);
			}

			this.scope.removeValue(texture);

			for (let i = 0; i < this.textureUnits.length; i++) {
				const textureUnit = this.textureUnits[i];

				for (let j = 0; j < textureUnit.length; j++) {
					if (textureUnit[j] === texture._glTexture) {
						textureUnit[j] = null;
					}
				}
			}

			const gl = this.gl;
			gl.deleteTexture(texture._glTexture);
			delete texture._glTexture;
			delete texture._glTarget;
			delete texture._glFormat;
			delete texture._glInternalFormat;
			delete texture._glPixelType;
			this._vram.tex -= texture._gpuSize;
		}
	}

	setUnpackFlipY(flipY) {
		if (this.unpackFlipY !== flipY) {
			this.unpackFlipY = flipY;
			const gl = this.gl;
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
		}
	}

	setUnpackPremultiplyAlpha(premultiplyAlpha) {
		if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
			this.unpackPremultiplyAlpha = premultiplyAlpha;
			const gl = this.gl;
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
		}
	}

	_isBrowserInterface(texture) {
		return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement || typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap;
	}

	uploadTexture(texture) {
		const gl = this.gl;
		if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;
		let mipLevel = 0;
		let mipObject;
		let resMult;
		const requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

		while (texture._levels[mipLevel] || mipLevel === 0) {
			if (!texture._needsUpload && mipLevel === 0) {
				mipLevel++;
				continue;
			} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
				break;
			}

			mipObject = texture._levels[mipLevel];

			if (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {
				gl.generateMipmap(texture._glTarget);
				texture._mipmapsUploaded = true;
			}

			if (texture._cubemap) {
				let face;

				if (this._isBrowserInterface(mipObject[0])) {
					for (face = 0; face < 6; face++) {
						if (!texture._levelsUpdated[0][face]) continue;
						let src = mipObject[face];

						if (src instanceof HTMLImageElement) {
							if (src.width > this.maxCubeMapSize || src.height > this.maxCubeMapSize) {
								src = downsampleImage(src, this.maxCubeMapSize);

								if (mipLevel === 0) {
									texture._width = src.width;
									texture._height = src.height;
								}
							}
						}

						this.setUnpackFlipY(false);
						this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, src);
					}
				} else {
					resMult = 1 / Math.pow(2, mipLevel);

					for (face = 0; face < 6; face++) {
						if (!texture._levelsUpdated[0][face]) continue;
						const texData = mipObject[face];

						if (texture._compressed) {
							gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
						} else {
							this.setUnpackFlipY(false);
							this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, texData);
						}
					}
				}
			} else if (texture._volume) {
				resMult = 1 / Math.pow(2, mipLevel);

				if (texture._compressed) {
					gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
				} else {
					this.setUnpackFlipY(false);
					this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
					gl.texImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);
				}
			} else {
				if (this._isBrowserInterface(mipObject)) {
					if (mipObject instanceof HTMLImageElement) {
						if (mipObject.width > this.maxTextureSize || mipObject.height > this.maxTextureSize) {
							mipObject = downsampleImage(mipObject, this.maxTextureSize);

							if (mipLevel === 0) {
								texture._width = mipObject.width;
								texture._height = mipObject.height;
							}
						}
					}

					this.setUnpackFlipY(texture._flipY);
					this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
					gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, mipObject);
				} else {
					resMult = 1 / Math.pow(2, mipLevel);

					if (texture._compressed) {
						gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
					} else {
						this.setUnpackFlipY(false);
						this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);
					}
				}

				if (mipLevel === 0) {
					texture._mipmapsUploaded = false;
				} else {
					texture._mipmapsUploaded = true;
				}
			}

			mipLevel++;
		}

		if (texture._needsUpload) {
			if (texture._cubemap) {
				for (let i = 0; i < 6; i++) texture._levelsUpdated[0][i] = false;
			} else {
				texture._levelsUpdated[0] = false;
			}
		}

		if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || this.webgl2) && texture._levels.length === 1) {
			gl.generateMipmap(texture._glTarget);
			texture._mipmapsUploaded = true;
		}

		if (texture._gpuSize) {
			this._vram.tex -= texture._gpuSize;
		}

		texture._gpuSize = texture.gpuSize;
		this._vram.tex += texture._gpuSize;
	}

	activeTexture(textureUnit) {
		if (this.textureUnit !== textureUnit) {
			this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
			this.textureUnit = textureUnit;
		}
	}

	bindTexture(texture) {
		const textureTarget = texture._glTarget;
		const textureObject = texture._glTexture;
		const textureUnit = this.textureUnit;
		const slot = this.targetToSlot[textureTarget];

		if (this.textureUnits[textureUnit][slot] !== textureObject) {
			this.gl.bindTexture(textureTarget, textureObject);
			this.textureUnits[textureUnit][slot] = textureObject;
		}
	}

	bindTextureOnUnit(texture, textureUnit) {
		const textureTarget = texture._glTarget;
		const textureObject = texture._glTexture;
		const slot = this.targetToSlot[textureTarget];

		if (this.textureUnits[textureUnit][slot] !== textureObject) {
			this.activeTexture(textureUnit);
			this.gl.bindTexture(textureTarget, textureObject);
			this.textureUnits[textureUnit][slot] = textureObject;
		}
	}

	setTextureParameters(texture) {
		const gl = this.gl;
		const flags = texture._parameterFlags;
		const target = texture._glTarget;

		if (flags & 1) {
			let filter = texture._minFilter;

			if (!texture.pot && !this.webgl2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {
				if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
					filter = FILTER_NEAREST;
				} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
					filter = FILTER_LINEAR;
				}
			}

			gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
		}

		if (flags & 2) {
			gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
		}

		if (flags & 4) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
			} else {
				gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);
			}
		}

		if (flags & 8) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
			} else {
				gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);
			}
		}

		if (flags & 16) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
			}
		}

		if (flags & 32) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
			}
		}

		if (flags & 64) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
			}
		}

		if (flags & 128) {
			const ext = this.extTextureFilterAnisotropic;

			if (ext) {
				gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
			}
		}
	}

	setTexture(texture, textureUnit) {
		if (!texture._glTexture) this.initializeTexture(texture);

		if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload || texture === this.grabPass.texture) {
			this.activeTexture(textureUnit);
			this.bindTexture(texture);

			if (texture._parameterFlags) {
				this.setTextureParameters(texture);
				texture._parameterFlags = 0;
			}

			const processed = texture === this.grabPass.texture && this.grabPass.prepareTexture();

			if (!processed && (texture._needsUpload || texture._needsMipmapsUpload)) {
				this.uploadTexture(texture);
				texture._needsUpload = false;
				texture._needsMipmapsUpload = false;
			}
		} else {
			this.bindTextureOnUnit(texture, textureUnit);
		}
	}

	createVertexArray(vertexBuffers) {
		let key, vao;
		const useCache = vertexBuffers.length > 1;

		if (useCache) {
			key = "";

			for (let i = 0; i < vertexBuffers.length; i++) {
				const vertexBuffer = vertexBuffers[i];
				key += vertexBuffer.id + vertexBuffer.format.renderingingHash;
			}

			vao = this._vaoMap.get(key);
		}

		if (!vao) {
			const gl = this.gl;
			vao = gl.createVertexArray();
			gl.bindVertexArray(vao);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

			for (let i = 0; i < vertexBuffers.length; i++) {
				const vertexBuffer = vertexBuffers[i];
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.bufferId);
				const elements = vertexBuffer.format.elements;

				for (let j = 0; j < elements.length; j++) {
					const e = elements[j];
					const loc = semanticToLocation[e.name];

					gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
					gl.enableVertexAttribArray(loc);

					if (vertexBuffer.instancing) {
						gl.vertexAttribDivisor(loc, 1);
					}
				}
			}

			gl.bindVertexArray(null);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);

			if (useCache) {
				this._vaoMap.set(key, vao);
			}
		}

		return vao;
	}

	setBuffers() {
		const gl = this.gl;
		let vao;

		if (this.vertexBuffers.length === 1) {
			const vertexBuffer = this.vertexBuffers[0];

			if (!vertexBuffer._vao) {
				vertexBuffer._vao = this.createVertexArray(this.vertexBuffers);
			}

			vao = vertexBuffer._vao;
		} else {
			vao = this.createVertexArray(this.vertexBuffers);
		}

		if (this.boundVao !== vao) {
			this.boundVao = vao;
			gl.bindVertexArray(vao);
		}

		this.vertexBuffers.length = 0;
		const bufferId = this.indexBuffer ? this.indexBuffer.bufferId : null;
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
	}

	draw(primitive, numInstances, keepBuffers) {
		const gl = this.gl;
		let sampler, samplerValue, texture, numTextures;
		let uniform, scopeId, uniformVersion, programVersion;
		const shader = this.shader;
		if (!shader) return;
		const samplers = shader.samplers;
		const uniforms = shader.uniforms;

		if (!keepBuffers) {
			this.setBuffers();
		}

		let textureUnit = 0;

		for (let i = 0, len = samplers.length; i < len; i++) {
			sampler = samplers[i];
			samplerValue = sampler.scopeId.value;

			if (!samplerValue) {
				continue;
			}

			if (samplerValue instanceof Texture) {
				texture = samplerValue;
				this.setTexture(texture, textureUnit);

				if (sampler.slot !== textureUnit) {
					gl.uniform1i(sampler.locationId, textureUnit);
					sampler.slot = textureUnit;
				}

				textureUnit++;
			} else {
				sampler.array.length = 0;
				numTextures = samplerValue.length;

				for (let j = 0; j < numTextures; j++) {
					texture = samplerValue[j];
					this.setTexture(texture, textureUnit);
					sampler.array[j] = textureUnit;
					textureUnit++;
				}

				gl.uniform1iv(sampler.locationId, sampler.array);
			}
		}

		for (let i = 0, len = uniforms.length; i < len; i++) {
			uniform = uniforms[i];
			scopeId = uniform.scopeId;
			uniformVersion = uniform.version;
			programVersion = scopeId.versionObject.version;

			if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
				uniformVersion.globalId = programVersion.globalId;
				uniformVersion.revision = programVersion.revision;

				if (scopeId.value !== null) {
					this.commitFunction[uniform.dataType](uniform, scopeId.value);
				}
			}
		}

		if (this.webgl2 && this.transformFeedbackBuffer) {
			gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId);
			gl.beginTransformFeedback(gl.POINTS);
		}

		const mode = this.glPrimitive[primitive.type];
		const count = primitive.count;

		if (primitive.indexed) {
			const indexBuffer = this.indexBuffer;
			const format = indexBuffer.glFormat;
			const offset = primitive.base * indexBuffer.bytesPerIndex;

			if (numInstances > 0) {
				gl.drawElementsInstanced(mode, count, format, offset, numInstances);
			} else {
				gl.drawElements(mode, count, format, offset);
			}
		} else {
			const first = primitive.base;

			if (numInstances > 0) {
				gl.drawArraysInstanced(mode, first, count, numInstances);
			} else {
				gl.drawArrays(mode, first, count);
			}
		}

		if (this.webgl2 && this.transformFeedbackBuffer) {
			gl.endTransformFeedback();
			gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
		}

		this._drawCallsPerFrame++;
	}

	clear(options) {
		const defaultOptions = this.defaultClearOptions;
		options = options || defaultOptions;
		const flags = options.flags == undefined ? defaultOptions.flags : options.flags;

		if (flags !== 0) {
			const gl = this.gl;

			if (flags & CLEARFLAG_COLOR) {
				const color = options.color == undefined ? defaultOptions.color : options.color;
				this.setClearColor(color[0], color[1], color[2], color[3]);
			}

			if (flags & CLEARFLAG_DEPTH) {
				const depth = options.depth == undefined ? defaultOptions.depth : options.depth;
				this.setClearDepth(depth);

				if (!this.depthWrite) {
					gl.depthMask(true);
				}
			}

			if (flags & CLEARFLAG_STENCIL) {
				const stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;
				this.setClearStencil(stencil);
			}

			gl.clear(this.glClearFlag[flags]);

			if (flags & CLEARFLAG_DEPTH) {
				if (!this.depthWrite) {
					gl.depthMask(false);
				}
			}
		}
	}

	readPixels(x, y, w, h, pixels) {
		const gl = this.gl;
		gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	}

	setClearDepth(depth) {
		if (depth !== this.clearDepth) {
			this.gl.clearDepth(depth);
			this.clearDepth = depth;
		}
	}

	setClearColor(r, g, b, a) {
		if (r !== this.clearRed || g !== this.clearGreen || b !== this.clearBlue || a !== this.clearAlpha) {
			this.gl.clearColor(r, g, b, a);
			this.clearRed = r;
			this.clearGreen = g;
			this.clearBlue = b;
			this.clearAlpha = a;
		}
	}

	setClearStencil(value) {
		if (value !== this.clearStencil) {
			this.gl.clearStencil(value);
			this.clearStencil = value;
		}
	}

	setRenderTarget(renderTarget) {
		this.renderTarget = renderTarget;
	}

	getRenderTarget() {
		return this.renderTarget;
	}

	getDepthTest() {
		return this.depthTest;
	}

	setDepthTest(depthTest) {
		if (this.depthTest !== depthTest) {
			const gl = this.gl;

			if (depthTest) {
				gl.enable(gl.DEPTH_TEST);
			} else {
				gl.disable(gl.DEPTH_TEST);
			}

			this.depthTest = depthTest;
		}
	}

	setDepthFunc(func) {
		if (this.depthFunc === func) return;
		this.gl.depthFunc(this.glComparison[func]);
		this.depthFunc = func;
	}

	getDepthWrite() {
		return this.depthWrite;
	}

	setDepthWrite(writeDepth) {
		if (this.depthWrite !== writeDepth) {
			this.gl.depthMask(writeDepth);
			this.depthWrite = writeDepth;
		}
	}

	setColorWrite(writeRed, writeGreen, writeBlue, writeAlpha) {
		if (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {
			this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
			this.writeRed = writeRed;
			this.writeGreen = writeGreen;
			this.writeBlue = writeBlue;
			this.writeAlpha = writeAlpha;
		}
	}

	setAlphaToCoverage(state) {
		if (!this.webgl2) return;
		if (this.alphaToCoverage === state) return;
		this.alphaToCoverage = state;

		if (state) {
			this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
		} else {
			this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
		}
	}

	setTransformFeedbackBuffer(tf) {
		if (this.transformFeedbackBuffer === tf) return;
		this.transformFeedbackBuffer = tf;

		if (this.webgl2) {
			const gl = this.gl;

			if (tf) {
				if (!this.feedback) {
					this.feedback = gl.createTransformFeedback();
				}

				gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
			} else {
				gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
			}
		}
	}

	setRaster(on) {
		if (this.raster === on) return;
		this.raster = on;

		if (this.webgl2) {
			if (on) {
				this.gl.disable(this.gl.RASTERIZER_DISCARD);
			} else {
				this.gl.enable(this.gl.RASTERIZER_DISCARD);
			}
		}
	}

	setDepthBias(on) {
		if (this.depthBiasEnabled === on) return;
		this.depthBiasEnabled = on;

		if (on) {
			this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
		} else {
			this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
		}
	}

	setDepthBiasValues(constBias, slopeBias) {
		this.gl.polygonOffset(slopeBias, constBias);
	}

	getBlending() {
		return this.blending;
	}

	setBlending(blending) {
		if (this.blending !== blending) {
			const gl = this.gl;

			if (blending) {
				gl.enable(gl.BLEND);
			} else {
				gl.disable(gl.BLEND);
			}

			this.blending = blending;
		}
	}

	setStencilTest(enable) {
		if (this.stencil !== enable) {
			const gl = this.gl;

			if (enable) {
				gl.enable(gl.STENCIL_TEST);
			} else {
				gl.disable(gl.STENCIL_TEST);
			}

			this.stencil = enable;
		}
	}

	setStencilFunc(func, ref, mask) {
		if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
			const gl = this.gl;
			gl.stencilFunc(this.glComparison[func], ref, mask);
			this.stencilFuncFront = this.stencilFuncBack = func;
			this.stencilRefFront = this.stencilRefBack = ref;
			this.stencilMaskFront = this.stencilMaskBack = mask;
		}
	}

	setStencilFuncFront(func, ref, mask) {
		if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
			const gl = this.gl;
			gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
			this.stencilFuncFront = func;
			this.stencilRefFront = ref;
			this.stencilMaskFront = mask;
		}
	}

	setStencilFuncBack(func, ref, mask) {
		if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
			const gl = this.gl;
			gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
			this.stencilFuncBack = func;
			this.stencilRefBack = ref;
			this.stencilMaskBack = mask;
		}
	}

	setStencilOperation(fail, zfail, zpass, writeMask) {
		if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
			this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
			this.stencilFailFront = this.stencilFailBack = fail;
			this.stencilZfailFront = this.stencilZfailBack = zfail;
			this.stencilZpassFront = this.stencilZpassBack = zpass;
		}

		if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
			this.gl.stencilMask(writeMask);
			this.stencilWriteMaskFront = writeMask;
			this.stencilWriteMaskBack = writeMask;
		}
	}

	setStencilOperationFront(fail, zfail, zpass, writeMask) {
		if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
			this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
			this.stencilFailFront = fail;
			this.stencilZfailFront = zfail;
			this.stencilZpassFront = zpass;
		}

		if (this.stencilWriteMaskFront !== writeMask) {
			this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
			this.stencilWriteMaskFront = writeMask;
		}
	}

	setStencilOperationBack(fail, zfail, zpass, writeMask) {
		if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
			this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
			this.stencilFailBack = fail;
			this.stencilZfailBack = zfail;
			this.stencilZpassBack = zpass;
		}

		if (this.stencilWriteMaskBack !== writeMask) {
			this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
			this.stencilWriteMaskBack = writeMask;
		}
	}

	setBlendFunction(blendSrc, blendDst) {
		if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
			this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
			this.blendSrc = blendSrc;
			this.blendDst = blendDst;
			this.separateAlphaBlend = false;
		}
	}

	setBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
		if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
			this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
			this.blendSrc = blendSrc;
			this.blendDst = blendDst;
			this.blendSrcAlpha = blendSrcAlpha;
			this.blendDstAlpha = blendDstAlpha;
			this.separateAlphaBlend = true;
		}
	}

	setBlendEquation(blendEquation) {
		if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
			this.gl.blendEquation(this.glBlendEquation[blendEquation]);
			this.blendEquation = blendEquation;
			this.separateAlphaEquation = false;
		}
	}

	setBlendEquationSeparate(blendEquation, blendAlphaEquation) {
		if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
			this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
			this.blendEquation = blendEquation;
			this.blendAlphaEquation = blendAlphaEquation;
			this.separateAlphaEquation = true;
		}
	}

	setCullMode(cullMode) {
		if (this.cullMode !== cullMode) {
			if (cullMode === CULLFACE_NONE) {
				this.gl.disable(this.gl.CULL_FACE);
			} else {
				if (this.cullMode === CULLFACE_NONE) {
					this.gl.enable(this.gl.CULL_FACE);
				}

				const mode = this.glCull[cullMode];

				if (this.cullFace !== mode) {
					this.gl.cullFace(mode);
					this.cullFace = mode;
				}
			}

			this.cullMode = cullMode;
		}
	}

	getCullMode() {
		return this.cullMode;
	}

	setIndexBuffer(indexBuffer) {
		this.indexBuffer = indexBuffer;
	}

	setVertexBuffer(vertexBuffer) {
		if (vertexBuffer) {
			this.vertexBuffers.push(vertexBuffer);
		}
	}

	compileShaderSource(src, isVertexShader) {
		const gl = this.gl;
		let glShader = isVertexShader ? this.vertexShaderCache[src] : this.fragmentShaderCache[src];

		if (!glShader) {
			glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
			gl.shaderSource(glShader, src);
			gl.compileShader(glShader);

			if (isVertexShader) {
				this.vertexShaderCache[src] = glShader;
			} else {
				this.fragmentShaderCache[src] = glShader;
			}
		}

		return glShader;
	}

	compileAndLinkShader(shader) {
		const definition = shader.definition;
		const glVertexShader = this.compileShaderSource(definition.vshader, true);
		const glFragmentShader = this.compileShaderSource(definition.fshader, false);
		const gl = this.gl;
		const glProgram = gl.createProgram();
		gl.attachShader(glProgram, glVertexShader);
		gl.attachShader(glProgram, glFragmentShader);
		const attrs = definition.attributes;

		if (this.webgl2 && definition.useTransformFeedback) {
			const outNames = [];

			for (const attr in attrs) {
				if (attrs.hasOwnProperty(attr)) {
					outNames.push("out_" + attr);
				}
			}

			gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
		}

		const locations = {};

		for (const attr in attrs) {
			if (attrs.hasOwnProperty(attr)) {
				const semantic = attrs[attr];
				const loc = semanticToLocation[semantic];
				locations[loc] = attr;
				gl.bindAttribLocation(glProgram, loc, attr);
			}
		}

		gl.linkProgram(glProgram);
		shader._glVertexShader = glVertexShader;
		shader._glFragmentShader = glFragmentShader;
		shader._glProgram = glProgram;
	}

	createShader(shader) {
		this.compileAndLinkShader(shader);
		this.shaders.push(shader);
	}

	destroyShader(shader) {
		const idx = this.shaders.indexOf(shader);

		if (idx !== -1) {
			this.shaders.splice(idx, 1);
		}

		if (shader._glProgram) {
			this.gl.deleteProgram(shader._glProgram);
			shader._glProgram = null;
			this.removeShaderFromCache(shader);
		}
	}

	_processError(src, infoLog) {
		if (!src) return "";
		const lines = src.split('\n');
		const error = {};
		let code = '';
		let from = 0;
		let to = lines.length;

		if (infoLog && infoLog.startsWith('ERROR:')) {
			const match = infoLog.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);

			if (match) {
				error.message = match[3];
				error.line = parseInt(match[2], 10);
				from = Math.max(0, error.line - 6);
				to = Math.min(lines.length, error.line + 5);
			}
		}

		for (let i = from; i < to; i++) {
			code += i + 1 + ":\t" + lines[i] + '\n';
		}

		error.source = src;
		return [code, error];
	}

	_isShaderCompiled(shader, glShader, source, shaderType) {
		const gl = this.gl;

		if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
			const infoLog = gl.getShaderInfoLog(glShader);

			const [code, error] = this._processError(source, infoLog);

			const message = `Failed to compile ${shaderType} shader:\n\n${infoLog}\n${code}`;
			console.error(message);
			return false;
		}

		return true;
	}

	postLink(shader) {
		const gl = this.gl;
		const glProgram = shader._glProgram;
		const definition = shader.definition;
		if (!this._isShaderCompiled(shader, shader._glVertexShader, definition.vshader, "vertex")) return false;
		if (!this._isShaderCompiled(shader, shader._glFragmentShader, definition.fshader, "fragment")) return false;

		if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
			const message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
			console.error(message);
			return false;
		}

		let i, info, location, shaderInput;
		i = 0;
		const numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);

		while (i < numAttributes) {
			info = gl.getActiveAttrib(glProgram, i++);
			location = gl.getAttribLocation(glProgram, info.name);

			if (definition.attributes[info.name] === undefined) {
				console.error(`Vertex shader attribute "${info.name}" is not mapped to a semantic in shader definition.`);
			}

			shaderInput = new ShaderInput(this, definition.attributes[info.name], this.pcUniformType[info.type], location);
			shader.attributes.push(shaderInput);
		}

		i = 0;
		const numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);

		while (i < numUniforms) {
			info = gl.getActiveUniform(glProgram, i++);
			location = gl.getUniformLocation(glProgram, info.name);
			shaderInput = new ShaderInput(this, info.name, this.pcUniformType[info.type], location);

			if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || this.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {
				shader.samplers.push(shaderInput);
			} else {
				shader.uniforms.push(shaderInput);
			}
		}

		shader.ready = true;
		return true;
	}

	setShader(shader) {
		if (shader !== this.shader) {
			if (!shader.ready) {
				if (!this.postLink(shader)) {
					return false;
				}
			}

			this.shader = shader;
			this.gl.useProgram(shader._glProgram);
			this.attributesInvalidated = true;
		}

		return true;
	}

	getHdrFormat() {
		if (this.textureHalfFloatRenderable) {
			return PIXELFORMAT_RGBA16F;
		} else if (this.textureFloatRenderable) {
			return PIXELFORMAT_RGBA32F;
		}

		return PIXELFORMAT_R8_G8_B8_A8;
	}

	getBoneLimit() {
		return this.boneLimit;
	}

	setBoneLimit(maxBones) {
		this.boneLimit = maxBones;
	}

	resizeCanvas(width, height) {
		this._width = width;
		this._height = height;
		const ratio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
		width = Math.floor(width * ratio);
		height = Math.floor(height * ratio);

		if (this.canvas.width !== width || this.canvas.height !== height) {
			this.canvas.width = width;
			this.canvas.height = height;
			this.fire(EVENT_RESIZE, width, height);
		}
	}

	setResolution(width, height) {
		this._width = width;
		this._height = height;
		this.canvas.width = width;
		this.canvas.height = height;
		this.fire(EVENT_RESIZE, width, height);
	}

	clearShaderCache() {
		const gl = this.gl;

		for (const shaderSrc in this.fragmentShaderCache) {
			gl.deleteShader(this.fragmentShaderCache[shaderSrc]);
			delete this.fragmentShaderCache[shaderSrc];
		}

		for (const shaderSrc in this.vertexShaderCache) {
			gl.deleteShader(this.vertexShaderCache[shaderSrc]);
			delete this.vertexShaderCache[shaderSrc];
		}

		this.programLib.clearCache();
	}

	clearVertexArrayObjectCache() {
		const gl = this.gl;

		this._vaoMap.forEach((item, key, mapObj) => {
			gl.deleteVertexArray(item);
		});

		this._vaoMap.clear();
	}

	removeShaderFromCache(shader) {
		this.programLib.removeFromCache(shader);
	}

	get width() {
		return this.gl.drawingBufferWidth || this.canvas.width;
	}

	get height() {
		return this.gl.drawingBufferHeight || this.canvas.height;
	}

	set fullscreen(fullscreen) {
		if (fullscreen) {
			const canvas = this.gl.canvas;
			canvas.requestFullscreen();
		} else {
			document.exitFullscreen();
		}
	}

	get fullscreen() {
		return !!document.fullscreenElement;
	}

	set enableAutoInstancing(value) {
		this._enableAutoInstancing = value && this.extInstancing;
	}

	get enableAutoInstancing() {
		return this._enableAutoInstancing;
	}

	set maxPixelRatio(ratio) {
		this._maxPixelRatio = ratio;
		this.resizeCanvas(this._width, this._height);
	}

	get maxPixelRatio() {
		return this._maxPixelRatio;
	}

	get textureFloatHighPrecision() {
		if (this._textureFloatHighPrecision === undefined) {
			this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
		}

		return this._textureFloatHighPrecision;
	}

	get textureHalfFloatUpdatable() {
		if (this._textureHalfFloatUpdatable === undefined) {
			if (this.webgl2) {
				this._textureHalfFloatUpdatable = true;
			} else {
				this._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
			}
		}

		return this._textureHalfFloatUpdatable;
	}

}

const defaultOptions = {
	depth: true,
	face: 0
};

class RenderTarget {
	constructor(options) {
		var _this$_colorBuffer, _this$_depthBuffer;

		const _arg2 = arguments[1];
		const _arg3 = arguments[2];

		if (options instanceof GraphicsDevice) {
			this._colorBuffer = _arg2;
			options = _arg3;
		} else {
			this._colorBuffer = options.colorBuffer;
		}

		if (this._colorBuffer) {
			this._colorBuffer._isRenderTarget = true;
		}

		this._glFrameBuffer = null;
		this._glDepthBuffer = null;
		options = options !== undefined ? options : defaultOptions;
		this._depthBuffer = options.depthBuffer;
		this._face = options.face !== undefined ? options.face : 0;

		if (this._depthBuffer) {
			const format = this._depthBuffer._format;

			if (format === PIXELFORMAT_DEPTH) {
				this._depth = true;
				this._stencil = false;
			} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
				this._depth = true;
				this._stencil = true;
			} else {
				this._depth = false;
				this._stencil = false;
			}
		} else {
			this._depth = options.depth !== undefined ? options.depth : true;
			this._stencil = options.stencil !== undefined ? options.stencil : false;
		}

		this._device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device);
		this._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;
		this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;
		this._glResolveFrameBuffer = null;
		this._glMsaaColorBuffer = null;
		this._glMsaaDepthBuffer = null;
		this.name = options.name;

		if (!this.name) {
			var _this$_colorBuffer2;

			this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;
		}

		if (!this.name) {
			var _this$_depthBuffer2;

			this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;
		}

		if (!this.name) {
			this.name = "Untitled";
		}

		this.flipY = !!options.flipY;
	}

	destroy() {
		const device = this._device;

		if (device) {
			const idx = device.targets.indexOf(this);

			if (idx !== -1) {
				device.targets.splice(idx, 1);
			}

			this.destroyFrameBuffers();
		}
	}

	destroyFrameBuffers() {
		const device = this._device;

		if (device) {
			const gl = device.gl;

			if (this._glFrameBuffer) {
				gl.deleteFramebuffer(this._glFrameBuffer);
				this._glFrameBuffer = null;
			}

			if (this._glDepthBuffer) {
				gl.deleteRenderbuffer(this._glDepthBuffer);
				this._glDepthBuffer = null;
			}

			if (this._glResolveFrameBuffer) {
				gl.deleteFramebuffer(this._glResolveFrameBuffer);
				this._glResolveFrameBuffer = null;
			}

			if (this._glMsaaColorBuffer) {
				gl.deleteRenderbuffer(this._glMsaaColorBuffer);
				this._glMsaaColorBuffer = null;
			}

			if (this._glMsaaDepthBuffer) {
				gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
				this._glMsaaDepthBuffer = null;
			}
		}
	}

	destroyTextureBuffers() {
		if (this._depthBuffer) {
			this._depthBuffer.destroy();

			this._depthBuffer = null;
		}

		if (this._colorBuffer) {
			this._colorBuffer.destroy();

			this._colorBuffer = null;
		}
	}

	loseContext() {
		this._glFrameBuffer = undefined;
		this._glDepthBuffer = undefined;
		this._glResolveFrameBuffer = undefined;
		this._glMsaaColorBuffer = undefined;
		this._glMsaaDepthBuffer = undefined;
	}

	resolve(color = true, depth = !!this._depthBuffer) {
		if (!this._device) return;
		if (!this._device.webgl2) return;
		const gl = this._device.gl;
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
		gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
		gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
		gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
	}

	copy(source, color, depth) {
		if (!this._device) {
			if (source._device) {
				this._device = source._device;
			} else {
				return false;
			}
		}

		return this._device.copyRenderTarget(source, this, color, depth);
	}

	get colorBuffer() {
		return this._colorBuffer;
	}

	get depthBuffer() {
		return this._depthBuffer;
	}

	get face() {
		return this._face;
	}

	get width() {
		return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;
	}

	get height() {
		return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;
	}

}

class IndexBuffer {
	constructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData) {
		this.device = graphicsDevice;
		this.format = format;
		this.numIndices = numIndices;
		this.usage = usage;
		const gl = this.device.gl;
		let bytesPerIndex;

		if (format === INDEXFORMAT_UINT8) {
			bytesPerIndex = 1;
			this.glFormat = gl.UNSIGNED_BYTE;
		} else if (format === INDEXFORMAT_UINT16) {
			bytesPerIndex = 2;
			this.glFormat = gl.UNSIGNED_SHORT;
		} else if (format === INDEXFORMAT_UINT32) {
			bytesPerIndex = 4;
			this.glFormat = gl.UNSIGNED_INT;
		}

		this.bytesPerIndex = bytesPerIndex;
		this.numBytes = this.numIndices * bytesPerIndex;

		if (initialData) {
			this.setData(initialData);
		} else {
			this.storage = new ArrayBuffer(this.numBytes);
		}

		graphicsDevice._vram.ib += this.numBytes;
		this.device.buffers.push(this);
	}

	destroy() {
		const device = this.device;
		const idx = device.buffers.indexOf(this);

		if (idx !== -1) {
			device.buffers.splice(idx, 1);
		}

		if (this.bufferId) {
			const gl = this.device.gl;
			gl.deleteBuffer(this.bufferId);
			this.device._vram.ib -= this.storage.byteLength;
			this.bufferId = null;

			if (this.device.indexBuffer === this) {
				this.device.indexBuffer = null;
			}
		}
	}

	loseContext() {
		this.bufferId = undefined;
	}

	getFormat() {
		return this.format;
	}

	getNumIndices() {
		return this.numIndices;
	}

	lock() {
		return this.storage;
	}

	unlock() {
		const gl = this.device.gl;

		if (!this.bufferId) {
			this.bufferId = gl.createBuffer();
		}

		let glUsage;

		switch (this.usage) {
			case BUFFER_STATIC:
				glUsage = gl.STATIC_DRAW;
				break;

			case BUFFER_DYNAMIC:
				glUsage = gl.DYNAMIC_DRAW;
				break;

			case BUFFER_STREAM:
				glUsage = gl.STREAM_DRAW;
				break;

			case BUFFER_GPUDYNAMIC:
				if (this.device.webgl2) {
					glUsage = gl.DYNAMIC_COPY;
				} else {
					glUsage = gl.STATIC_DRAW;
				}

				break;
		}

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferId);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.storage, glUsage);
	}

	setData(data) {
		if (data.byteLength !== this.numBytes) {
			return false;
		}

		this.storage = data;
		this.unlock();
		return true;
	}

	_lockTypedArray() {
		const lock = this.lock();
		const indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
		return indices;
	}

	writeData(data, count) {
		const indices = this._lockTypedArray();

		if (data.length > count) {
			if (ArrayBuffer.isView(data)) {
				data = data.subarray(0, count);
				indices.set(data);
			} else {
				for (let i = 0; i < count; i++) indices[i] = data[i];
			}
		} else {
			indices.set(data);
		}

		this.unlock();
	}

	readData(data) {
		const indices = this._lockTypedArray();

		const count = this.numIndices;

		if (ArrayBuffer.isView(data)) {
			data.set(indices);
		} else {
			data.length = 0;

			for (let i = 0; i < count; i++) data[i] = indices[i];
		}

		return count;
	}

}

function set1(a) {
	this.array[this.index] = a;
}

function set2(a, b) {
	this.array[this.index] = a;
	this.array[this.index + 1] = b;
}

function set3(a, b, c) {
	this.array[this.index] = a;
	this.array[this.index + 1] = b;
	this.array[this.index + 2] = c;
}

function set4(a, b, c, d) {
	this.array[this.index] = a;
	this.array[this.index + 1] = b;
	this.array[this.index + 2] = c;
	this.array[this.index + 3] = d;
}

function arraySet1(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
}

function arraySet2(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
	this.array[index + 1] = inputArray[inputIndex + 1];
}

function arraySet3(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
	this.array[index + 1] = inputArray[inputIndex + 1];
	this.array[index + 2] = inputArray[inputIndex + 2];
}

function arraySet4(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
	this.array[index + 1] = inputArray[inputIndex + 1];
	this.array[index + 2] = inputArray[inputIndex + 2];
	this.array[index + 3] = inputArray[inputIndex + 3];
}

function arrayGet1(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
}

function arrayGet2(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
	outputArray[outputIndex + 1] = this.array[offset + 1];
}

function arrayGet3(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
	outputArray[outputIndex + 1] = this.array[offset + 1];
	outputArray[outputIndex + 2] = this.array[offset + 2];
}

function arrayGet4(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
	outputArray[outputIndex + 1] = this.array[offset + 1];
	outputArray[outputIndex + 2] = this.array[offset + 2];
	outputArray[outputIndex + 3] = this.array[offset + 3];
}

class VertexIteratorAccessor {
	constructor(buffer, vertexElement, vertexFormat) {
		this.index = 0;
		this.numComponents = vertexElement.numComponents;

		if (vertexFormat.interleaved) {
			this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
		} else {
			this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
		}

		this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;

		switch (vertexElement.numComponents) {
			case 1:
				this.set = set1;
				this.getToArray = arrayGet1;
				this.setFromArray = arraySet1;
				break;

			case 2:
				this.set = set2;
				this.getToArray = arrayGet2;
				this.setFromArray = arraySet2;
				break;

			case 3:
				this.set = set3;
				this.getToArray = arrayGet3;
				this.setFromArray = arraySet3;
				break;

			case 4:
				this.set = set4;
				this.getToArray = arrayGet4;
				this.setFromArray = arraySet4;
				break;
		}
	}

	get(offset) {
		return this.array[this.index + offset];
	}

	set(a, b, c, d) {}

	getToArray(offset, outputArray, outputIndex) {}

	setFromArray(index, inputArray, inputIndex) {}

}

class VertexIterator {
	constructor(vertexBuffer) {
		this.vertexBuffer = vertexBuffer;
		this.vertexFormatSize = vertexBuffer.getFormat().size;
		this.buffer = this.vertexBuffer.lock();
		this.accessors = [];
		this.element = {};
		const vertexFormat = this.vertexBuffer.getFormat();

		for (let i = 0; i < vertexFormat.elements.length; i++) {
			const vertexElement = vertexFormat.elements[i];
			this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
			this.element[vertexElement.name] = this.accessors[i];
		}
	}

	next(count = 1) {
		let i = 0;
		const accessors = this.accessors;
		const numAccessors = this.accessors.length;

		while (i < numAccessors) {
			const accessor = accessors[i++];
			accessor.index += count * accessor.stride;
		}
	}

	end() {
		this.vertexBuffer.unlock();
	}

	writeData(semantic, data, numVertices) {
		const element = this.element[semantic];

		if (element) {
			if (numVertices > this.vertexBuffer.numVertices) {
				numVertices = this.vertexBuffer.numVertices;
			}

			const numComponents = element.numComponents;

			if (this.vertexBuffer.getFormat().interleaved) {
				let index = 0;

				for (let i = 0; i < numVertices; i++) {
					element.setFromArray(index, data, i * numComponents);
					index += element.stride;
				}
			} else {
				if (data.length > numVertices * numComponents) {
					const copyCount = numVertices * numComponents;

					if (ArrayBuffer.isView(data)) {
						data = data.subarray(0, copyCount);
						element.array.set(data);
					} else {
						for (let i = 0; i < copyCount; i++) element.array[i] = data[i];
					}
				} else {
					element.array.set(data);
				}
			}
		}
	}

	readData(semantic, data) {
		const element = this.element[semantic];
		let count = 0;

		if (element) {
			count = this.vertexBuffer.numVertices;
			let i;
			const numComponents = element.numComponents;

			if (this.vertexBuffer.getFormat().interleaved) {
				if (Array.isArray(data)) data.length = 0;
				element.index = 0;
				let offset = 0;

				for (i = 0; i < count; i++) {
					element.getToArray(offset, data, i * numComponents);
					offset += element.stride;
				}
			} else {
				if (ArrayBuffer.isView(data)) {
					data.set(element.array);
				} else {
					data.length = 0;
					const copyCount = count * numComponents;

					for (i = 0; i < copyCount; i++) data[i] = element.array[i];
				}
			}
		}

		return count;
	}

}

class RefCountedObject {
	constructor() {
		this._refCount = 0;
	}

	incRefCount() {
		this._refCount++;
	}

	decRefCount() {
		this._refCount--;
	}

	get refCount() {
		return this._refCount;
	}

}

let currentApplication;

function getApplication() {
	return currentApplication;
}

function setApplication(app) {
	currentApplication = app;
}

let id$1 = 0;

class GeometryData {
	constructor() {
		this.initDefaults();
	}

	initDefaults() {
		this.recreate = false;
		this.verticesUsage = BUFFER_STATIC;
		this.indicesUsage = BUFFER_STATIC;
		this.maxVertices = 0;
		this.maxIndices = 0;
		this.vertexCount = 0;
		this.indexCount = 0;
		this.vertexStreamsUpdated = false;
		this.indexStreamUpdated = false;
		this.vertexStreamDictionary = {};
		this.indices = null;
	}

	_changeVertexCount(count, semantic) {
		if (!this.vertexCount) {
			this.vertexCount = count;
		}
	}

}

GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
GeometryData.DEFAULT_COMPONENTS_UV = 2;
GeometryData.DEFAULT_COMPONENTS_COLORS = 4;

class GeometryVertexStream {
	constructor(data, componentCount, dataType, dataTypeNormalize) {
		this.data = data;
		this.componentCount = componentCount;
		this.dataType = dataType;
		this.dataTypeNormalize = dataTypeNormalize;
	}

}

class Mesh extends RefCountedObject {
	constructor(graphicsDevice) {
		super();
		this.id = id$1++;
		this.device = graphicsDevice || getApplication().graphicsDevice;
		this.vertexBuffer = null;
		this.indexBuffer = [null];
		this.primitive = [{
			type: 0,
			base: 0,
			count: 0
		}];
		this.skin = null;
		this._morph = null;
		this._geometryData = null;
		this._aabb = new BoundingBox();
		this.boneAabb = null;
	}

	set morph(morph) {
		if (morph !== this._morph) {
			if (this._morph) {
				this._morph.decRefCount();
			}

			this._morph = morph;

			if (morph) {
				morph.incRefCount();
			}
		}
	}

	get morph() {
		return this._morph;
	}

	set aabb(aabb) {
		this._aabb = aabb;
	}

	get aabb() {
		return this._aabb;
	}

	destroy() {
		const morph = this.morph;

		if (morph) {
			this.morph = null;

			if (morph.refCount < 1) {
				morph.destroy();
			}
		}

		if (this.vertexBuffer) {
			this.vertexBuffer.destroy();
			this.vertexBuffer = null;
		}

		for (let j = 0; j < this.indexBuffer.length; j++) {
			this._destroyIndexBuffer(j);
		}

		this.indexBuffer.length = 0;
		this._geometryData = null;
	}

	_destroyIndexBuffer(index) {
		if (this.indexBuffer[index]) {
			this.indexBuffer[index].destroy();
			this.indexBuffer[index] = null;
		}
	}

	_initBoneAabbs(morphTargets) {
		this.boneAabb = [];
		this.boneUsed = [];
		let x, y, z;
		let bMax, bMin;
		const boneMin = [];
		const boneMax = [];
		const boneUsed = this.boneUsed;
		const numBones = this.skin.boneNames.length;
		let maxMorphX, maxMorphY, maxMorphZ;

		for (let i = 0; i < numBones; i++) {
			boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
			boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
		}

		const iterator = new VertexIterator(this.vertexBuffer);
		const posElement = iterator.element[SEMANTIC_POSITION];
		const weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
		const indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
		const numVerts = this.vertexBuffer.numVertices;

		for (let j = 0; j < numVerts; j++) {
			for (let k = 0; k < 4; k++) {
				const boneWeight = weightsElement.array[weightsElement.index + k];

				if (boneWeight > 0) {
					const boneIndex = indicesElement.array[indicesElement.index + k];
					boneUsed[boneIndex] = true;
					x = posElement.array[posElement.index];
					y = posElement.array[posElement.index + 1];
					z = posElement.array[posElement.index + 2];
					bMax = boneMax[boneIndex];
					bMin = boneMin[boneIndex];
					if (bMin.x > x) bMin.x = x;
					if (bMin.y > y) bMin.y = y;
					if (bMin.z > z) bMin.z = z;
					if (bMax.x < x) bMax.x = x;
					if (bMax.y < y) bMax.y = y;
					if (bMax.z < z) bMax.z = z;

					if (morphTargets) {
						let minMorphX = maxMorphX = x;
						let minMorphY = maxMorphY = y;
						let minMorphZ = maxMorphZ = z;

						for (let l = 0; l < morphTargets.length; l++) {
							const target = morphTargets[l];
							const dx = target.deltaPositions[j * 3];
							const dy = target.deltaPositions[j * 3 + 1];
							const dz = target.deltaPositions[j * 3 + 2];

							if (dx < 0) {
								minMorphX += dx;
							} else {
								maxMorphX += dx;
							}

							if (dy < 0) {
								minMorphY += dy;
							} else {
								maxMorphY += dy;
							}

							if (dz < 0) {
								minMorphZ += dz;
							} else {
								maxMorphZ += dz;
							}
						}

						if (bMin.x > minMorphX) bMin.x = minMorphX;
						if (bMin.y > minMorphY) bMin.y = minMorphY;
						if (bMin.z > minMorphZ) bMin.z = minMorphZ;
						if (bMax.x < maxMorphX) bMax.x = maxMorphX;
						if (bMax.y < maxMorphY) bMax.y = maxMorphY;
						if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
					}
				}
			}

			iterator.next();
		}

		const positionElement = this.vertexBuffer.getFormat().elements.find(e => e.name === SEMANTIC_POSITION);

		if (positionElement && positionElement.normalize) {
			const func = (() => {
				switch (positionElement.dataType) {
					case TYPE_INT8:
						return x => Math.max(x / 127.0, -1.0);

					case TYPE_UINT8:
						return x => x / 255.0;

					case TYPE_INT16:
						return x => Math.max(x / 32767.0, -1.0);

					case TYPE_UINT16:
						return x => x / 65535.0;

					default:
						return x => x;
				}
			})();

			for (let i = 0; i < numBones; i++) {
				if (boneUsed[i]) {
					const min = boneMin[i];
					const max = boneMax[i];
					min.set(func(min.x), func(min.y), func(min.z));
					max.set(func(max.x), func(max.y), func(max.z));
				}
			}
		}

		for (let i = 0; i < numBones; i++) {
			const aabb = new BoundingBox();
			aabb.setMinMax(boneMin[i], boneMax[i]);
			this.boneAabb.push(aabb);
		}
	}

	_initGeometryData() {
		if (!this._geometryData) {
			this._geometryData = new GeometryData();

			if (this.vertexBuffer) {
				this._geometryData.vertexCount = this.vertexBuffer.numVertices;
				this._geometryData.maxVertices = this.vertexBuffer.numVertices;
			}

			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				this._geometryData.indexCount = this.indexBuffer[0].numIndices;
				this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
			}
		}
	}

	clear(verticesDynamic, indicesDynamic, maxVertices = 0, maxIndices = 0) {
		this._initGeometryData();

		this._geometryData.initDefaults();

		this._geometryData.recreate = true;
		this._geometryData.maxVertices = maxVertices;
		this._geometryData.maxIndices = maxIndices;
		this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
		this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
	}

	setVertexStream(semantic, data, componentCount, numVertices, dataType = TYPE_FLOAT32, dataTypeNormalize = false) {
		this._initGeometryData();

		const vertexCount = numVertices || data.length / componentCount;

		this._geometryData._changeVertexCount(vertexCount, semantic);

		this._geometryData.vertexStreamsUpdated = true;
		this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);
	}

	getVertexStream(semantic, data) {
		let count = 0;
		let done = false;

		if (this._geometryData) {
			const stream = this._geometryData.vertexStreamDictionary[semantic];

			if (stream) {
				done = true;
				count = this._geometryData.vertexCount;

				if (ArrayBuffer.isView(data)) {
					data.set(stream.data);
				} else {
					data.length = 0;
					data.push(stream.data);
				}
			}
		}

		if (!done) {
			if (this.vertexBuffer) {
				const iterator = new VertexIterator(this.vertexBuffer);
				count = iterator.readData(semantic, data);
			}
		}

		return count;
	}

	setPositions(positions, componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices) {
		this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setNormals(normals, componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices) {
		this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setUvs(channel, uvs, componentCount = GeometryData.DEFAULT_COMPONENTS_UV, numVertices) {
		this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setColors(colors, componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices) {
		this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setColors32(colors, numVertices) {
		this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
	}

	setIndices(indices, numIndices) {
		this._initGeometryData();

		this._geometryData.indexStreamUpdated = true;
		this._geometryData.indices = indices;
		this._geometryData.indexCount = numIndices || indices.length;
	}

	getPositions(positions) {
		return this.getVertexStream(SEMANTIC_POSITION, positions);
	}

	getNormals(normals) {
		return this.getVertexStream(SEMANTIC_NORMAL, normals);
	}

	getUvs(channel, uvs) {
		return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
	}

	getColors(colors) {
		return this.getVertexStream(SEMANTIC_COLOR, colors);
	}

	getIndices(indices) {
		let count = 0;

		if (this._geometryData && this._geometryData.indices) {
			const streamIndices = this._geometryData.indices;
			count = this._geometryData.indexCount;

			if (ArrayBuffer.isView(indices)) {
				indices.set(streamIndices);
			} else {
				indices.length = 0;
				indices.push(streamIndices);
			}
		} else {
			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				const indexBuffer = this.indexBuffer[0];
				count = indexBuffer.readData(indices);
			}
		}

		return count;
	}

	update(primitiveType = PRIMITIVE_TRIANGLES, updateBoundingBox = true) {
		if (this._geometryData) {
			if (updateBoundingBox) {
				const stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];

				if (stream) {
					if (stream.componentCount === 3) {
						this._aabb.compute(stream.data, this._geometryData.vertexCount);
					}
				}
			}

			let destroyVB = this._geometryData.recreate;

			if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
				destroyVB = true;
				this._geometryData.maxVertices = this._geometryData.vertexCount;
			}

			if (destroyVB) {
				if (this.vertexBuffer) {
					this.vertexBuffer.destroy();
					this.vertexBuffer = null;
				}
			}

			let destroyIB = this._geometryData.recreate;

			if (this._geometryData.indexCount > this._geometryData.maxIndices) {
				destroyIB = true;
				this._geometryData.maxIndices = this._geometryData.indexCount;
			}

			if (destroyIB) {
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					this.indexBuffer[0].destroy();
					this.indexBuffer[0] = null;
				}
			}

			if (this._geometryData.vertexStreamsUpdated) {
				this._updateVertexBuffer();
			}

			if (this._geometryData.indexStreamUpdated) {
				this._updateIndexBuffer();
			}

			this.primitive[0].type = primitiveType;

			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				if (this._geometryData.indexStreamUpdated) {
					this.primitive[0].count = this._geometryData.indexCount;
					this.primitive[0].indexed = true;
				}
			} else {
				if (this._geometryData.vertexStreamsUpdated) {
					this.primitive[0].count = this._geometryData.vertexCount;
					this.primitive[0].indexed = false;
				}
			}

			this._geometryData.vertexCount = 0;
			this._geometryData.indexCount = 0;
			this._geometryData.vertexStreamsUpdated = false;
			this._geometryData.indexStreamUpdated = false;
			this._geometryData.recreate = false;
			this.updateRenderStates();
		}
	}

	_buildVertexFormat(vertexCount) {
		const vertexDesc = [];

		for (const semantic in this._geometryData.vertexStreamDictionary) {
			const stream = this._geometryData.vertexStreamDictionary[semantic];
			vertexDesc.push({
				semantic: semantic,
				components: stream.componentCount,
				type: stream.dataType,
				normalize: stream.dataTypeNormalize
			});
		}

		return new VertexFormat(this.device, vertexDesc, vertexCount);
	}

	_updateVertexBuffer() {
		if (!this.vertexBuffer) {
			const allocateVertexCount = this._geometryData.maxVertices;

			const format = this._buildVertexFormat(allocateVertexCount);

			this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);
		}

		const iterator = new VertexIterator(this.vertexBuffer);
		const numVertices = this._geometryData.vertexCount;

		for (const semantic in this._geometryData.vertexStreamDictionary) {
			const stream = this._geometryData.vertexStreamDictionary[semantic];
			iterator.writeData(semantic, stream.data, numVertices);
			delete this._geometryData.vertexStreamDictionary[semantic];
		}

		iterator.end();
	}

	_updateIndexBuffer() {
		if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
			const createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
			this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);
		}

		const srcIndices = this._geometryData.indices;

		if (srcIndices) {
			const indexBuffer = this.indexBuffer[0];
			indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
			this._geometryData.indices = null;
		}
	}

	prepareRenderState(renderStyle) {
		if (renderStyle === RENDERSTYLE_WIREFRAME) {
			this.generateWireframe();
		} else if (renderStyle === RENDERSTYLE_POINTS) {
			this.primitive[RENDERSTYLE_POINTS] = {
				type: PRIMITIVE_POINTS,
				base: 0,
				count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
				indexed: false
			};
		}
	}

	updateRenderStates() {
		if (this.primitive[RENDERSTYLE_POINTS]) {
			this.prepareRenderState(RENDERSTYLE_POINTS);
		}

		if (this.primitive[RENDERSTYLE_WIREFRAME]) {
			this.prepareRenderState(RENDERSTYLE_WIREFRAME);
		}
	}

	generateWireframe() {
		this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);

		const lines = [];
		let format;

		if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
			const offsets = [[0, 1], [1, 2], [2, 0]];
			const base = this.primitive[RENDERSTYLE_SOLID].base;
			const count = this.primitive[RENDERSTYLE_SOLID].count;
			const indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
			const srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
			const uniqueLineIndices = {};

			for (let j = base; j < base + count; j += 3) {
				for (let k = 0; k < 3; k++) {
					const i1 = srcIndices[j + offsets[k][0]];
					const i2 = srcIndices[j + offsets[k][1]];
					const line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

					if (uniqueLineIndices[line] === undefined) {
						uniqueLineIndices[line] = 0;
						lines.push(i1, i2);
					}
				}
			}

			format = indexBuffer.format;
		} else {
			for (let i = 0; i < this.vertexBuffer.numVertices; i += 3) {
				lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
			}

			format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
		}

		const wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
		const dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
		dstIndices.set(lines);
		wireBuffer.unlock();
		this.primitive[RENDERSTYLE_WIREFRAME] = {
			type: PRIMITIVE_LINES,
			base: 0,
			count: lines.length,
			indexed: true
		};
		this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
	}

}

const primitiveUv1Padding = 4.0 / 64;
const primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
const shapePrimitives = [];

function calculateNormals(positions, indices) {
	const triangleCount = indices.length / 3;
	const vertexCount = positions.length / 3;
	const p1 = new Vec3();
	const p2 = new Vec3();
	const p3 = new Vec3();
	const p1p2 = new Vec3();
	const p1p3 = new Vec3();
	const faceNormal = new Vec3();
	const normals = [];

	for (let i = 0; i < positions.length; i++) {
		normals[i] = 0;
	}

	for (let i = 0; i < triangleCount; i++) {
		const i1 = indices[i * 3];
		const i2 = indices[i * 3 + 1];
		const i3 = indices[i * 3 + 2];
		p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
		p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
		p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
		p1p2.sub2(p2, p1);
		p1p3.sub2(p3, p1);
		faceNormal.cross(p1p2, p1p3).normalize();
		normals[i1 * 3] += faceNormal.x;
		normals[i1 * 3 + 1] += faceNormal.y;
		normals[i1 * 3 + 2] += faceNormal.z;
		normals[i2 * 3] += faceNormal.x;
		normals[i2 * 3 + 1] += faceNormal.y;
		normals[i2 * 3 + 2] += faceNormal.z;
		normals[i3 * 3] += faceNormal.x;
		normals[i3 * 3 + 1] += faceNormal.y;
		normals[i3 * 3 + 2] += faceNormal.z;
	}

	for (let i = 0; i < vertexCount; i++) {
		const nx = normals[i * 3];
		const ny = normals[i * 3 + 1];
		const nz = normals[i * 3 + 2];
		const invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
		normals[i * 3] *= invLen;
		normals[i * 3 + 1] *= invLen;
		normals[i * 3 + 2] *= invLen;
	}

	return normals;
}

function calculateTangents(positions, normals, uvs, indices) {
	const triangleCount = indices.length / 3;
	const vertexCount = positions.length / 3;
	const v1 = new Vec3();
	const v2 = new Vec3();
	const v3 = new Vec3();
	const w1 = new Vec2();
	const w2 = new Vec2();
	const w3 = new Vec2();
	const sdir = new Vec3();
	const tdir = new Vec3();
	const tan1 = new Float32Array(vertexCount * 3);
	const tan2 = new Float32Array(vertexCount * 3);
	const tangents = [];

	for (let i = 0; i < triangleCount; i++) {
		const i1 = indices[i * 3];
		const i2 = indices[i * 3 + 1];
		const i3 = indices[i * 3 + 2];
		v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
		v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
		v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
		w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
		w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
		w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
		const x1 = v2.x - v1.x;
		const x2 = v3.x - v1.x;
		const y1 = v2.y - v1.y;
		const y2 = v3.y - v1.y;
		const z1 = v2.z - v1.z;
		const z2 = v3.z - v1.z;
		const s1 = w2.x - w1.x;
		const s2 = w3.x - w1.x;

		const _t = w2.y - w1.y;

		const _t2 = w3.y - w1.y;

		const area = s1 * _t2 - s2 * _t;

		if (area === 0) {
			sdir.set(0, 1, 0);
			tdir.set(1, 0, 0);
		} else {
			const r = 1 / area;
			sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);
			tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
		}

		tan1[i1 * 3 + 0] += sdir.x;
		tan1[i1 * 3 + 1] += sdir.y;
		tan1[i1 * 3 + 2] += sdir.z;
		tan1[i2 * 3 + 0] += sdir.x;
		tan1[i2 * 3 + 1] += sdir.y;
		tan1[i2 * 3 + 2] += sdir.z;
		tan1[i3 * 3 + 0] += sdir.x;
		tan1[i3 * 3 + 1] += sdir.y;
		tan1[i3 * 3 + 2] += sdir.z;
		tan2[i1 * 3 + 0] += tdir.x;
		tan2[i1 * 3 + 1] += tdir.y;
		tan2[i1 * 3 + 2] += tdir.z;
		tan2[i2 * 3 + 0] += tdir.x;
		tan2[i2 * 3 + 1] += tdir.y;
		tan2[i2 * 3 + 2] += tdir.z;
		tan2[i3 * 3 + 0] += tdir.x;
		tan2[i3 * 3 + 1] += tdir.y;
		tan2[i3 * 3 + 2] += tdir.z;
	}

	const t1 = new Vec3();
	const t2 = new Vec3();
	const n = new Vec3();
	const temp = new Vec3();

	for (let i = 0; i < vertexCount; i++) {
		n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
		t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
		t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);
		const ndott = n.dot(t1);
		temp.copy(n).mulScalar(ndott);
		temp.sub2(t1, temp).normalize();
		tangents[i * 4] = temp.x;
		tangents[i * 4 + 1] = temp.y;
		tangents[i * 4 + 2] = temp.z;
		temp.cross(n, t1);
		tangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
	}

	return tangents;
}

function createMesh$1(device, positions, opts) {
	const mesh = new Mesh(device);
	mesh.setPositions(positions);

	if (opts) {
		if (opts.normals) {
			mesh.setNormals(opts.normals);
		}

		if (opts.tangents) {
			mesh.setVertexStream(SEMANTIC_TANGENT, opts.tangents, 4);
		}

		if (opts.colors) {
			mesh.setColors32(opts.colors);
		}

		if (opts.uvs) {
			mesh.setUvs(0, opts.uvs);
		}

		if (opts.uvs1) {
			mesh.setUvs(1, opts.uvs1);
		}

		if (opts.blendIndices) {
			mesh.setVertexStream(SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, TYPE_UINT8);
		}

		if (opts.blendWeights) {
			mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);
		}

		if (opts.indices) {
			mesh.setIndices(opts.indices);
		}
	}

	mesh.update();
	return mesh;
}

function _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
	const pos = new Vec3();
	const bottomToTop = new Vec3();
	const norm = new Vec3();
	const top = new Vec3();
	const bottom = new Vec3();
	const tangent = new Vec3();
	const positions = [];
	const normals = [];
	const uvs = [];
	const uvs1 = [];
	const indices = [];
	let offset;

	if (height > 0) {
		for (let i = 0; i <= heightSegments; i++) {
			for (let j = 0; j <= capSegments; j++) {
				const theta = j / capSegments * 2 * Math.PI - Math.PI;
				const sinTheta = Math.sin(theta);
				const cosTheta = Math.cos(theta);
				bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
				top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
				pos.lerp(bottom, top, i / heightSegments);
				bottomToTop.sub2(top, bottom).normalize();
				tangent.set(cosTheta, 0, -sinTheta);
				norm.cross(tangent, bottomToTop).normalize();
				positions.push(pos.x, pos.y, pos.z);
				normals.push(norm.x, norm.y, norm.z);
				let u = j / capSegments;
				let v = i / heightSegments;
				uvs.push(u, 1 - v);
				const _v = v;
				v = u;
				u = _v;
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				uvs1.push(u, 1 - v);

				if (i < heightSegments && j < capSegments) {
					const first = i * (capSegments + 1) + j;
					const second = i * (capSegments + 1) + (j + 1);
					const third = (i + 1) * (capSegments + 1) + j;
					const fourth = (i + 1) * (capSegments + 1) + (j + 1);
					indices.push(first, second, third);
					indices.push(second, fourth, third);
				}
			}
		}
	}

	if (roundedCaps) {
		const latitudeBands = Math.floor(capSegments / 2);
		const longitudeBands = capSegments;
		const capOffset = height / 2;

		for (let lat = 0; lat <= latitudeBands; lat++) {
			const theta = lat * Math.PI * 0.5 / latitudeBands;
			const sinTheta = Math.sin(theta);
			const cosTheta = Math.cos(theta);

			for (let lon = 0; lon <= longitudeBands; lon++) {
				const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
				const sinPhi = Math.sin(phi);
				const cosPhi = Math.cos(phi);
				const x = cosPhi * sinTheta;
				const y = cosTheta;
				const z = sinPhi * sinTheta;
				let u = 1 - lon / longitudeBands;
				let v = 1 - lat / latitudeBands;
				positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
				normals.push(x, y, z);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 1.0 / 3;
				uvs1.push(u, 1 - v);
			}
		}

		offset = (heightSegments + 1) * (capSegments + 1);

		for (let lat = 0; lat < latitudeBands; ++lat) {
			for (let lon = 0; lon < longitudeBands; ++lon) {
				const first = lat * (longitudeBands + 1) + lon;
				const second = first + longitudeBands + 1;
				indices.push(offset + first + 1, offset + second, offset + first);
				indices.push(offset + first + 1, offset + second + 1, offset + second);
			}
		}

		for (let lat = 0; lat <= latitudeBands; lat++) {
			const theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;
			const sinTheta = Math.sin(theta);
			const cosTheta = Math.cos(theta);

			for (let lon = 0; lon <= longitudeBands; lon++) {
				const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
				const sinPhi = Math.sin(phi);
				const cosPhi = Math.cos(phi);
				const x = cosPhi * sinTheta;
				const y = cosTheta;
				const z = sinPhi * sinTheta;
				let u = 1 - lon / longitudeBands;
				let v = 1 - lat / latitudeBands;
				positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);
				normals.push(x, y, z);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 2.0 / 3;
				uvs1.push(u, 1 - v);
			}
		}

		offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);

		for (let lat = 0; lat < latitudeBands; ++lat) {
			for (let lon = 0; lon < longitudeBands; ++lon) {
				const first = lat * (longitudeBands + 1) + lon;
				const second = first + longitudeBands + 1;
				indices.push(offset + first + 1, offset + second, offset + first);
				indices.push(offset + first + 1, offset + second + 1, offset + second);
			}
		}
	} else {
		offset = (heightSegments + 1) * (capSegments + 1);

		if (baseRadius > 0) {
			for (let i = 0; i < capSegments; i++) {
				const theta = i / capSegments * 2 * Math.PI;
				const x = Math.sin(theta);
				const y = -height / 2;
				const z = Math.cos(theta);
				let u = 1 - (x + 1) / 2;
				let v = (z + 1) / 2;
				positions.push(x * baseRadius, y, z * baseRadius);
				normals.push(0, -1, 0);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 1 / 3;
				uvs1.push(u, 1 - v);

				if (i > 1) {
					indices.push(offset, offset + i, offset + i - 1);
				}
			}
		}

		offset += capSegments;

		if (peakRadius > 0) {
			for (let i = 0; i < capSegments; i++) {
				const theta = i / capSegments * 2 * Math.PI;
				const x = Math.sin(theta);
				const y = height / 2;
				const z = Math.cos(theta);
				let u = 1 - (x + 1) / 2;
				let v = (z + 1) / 2;
				positions.push(x * peakRadius, y, z * peakRadius);
				normals.push(0, 1, 0);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 2 / 3;
				uvs1.push(u, 1 - v);

				if (i > 1) {
					indices.push(offset, offset + i - 1, offset + i);
				}
			}
		}
	}

	return {
		positions: positions,
		normals: normals,
		uvs: uvs,
		uvs1: uvs1,
		indices: indices
	};
}

function createCylinder(device, opts) {
	let radius = opts && (opts.radius || opts.baseRadius);
	radius = radius !== undefined ? radius : 0.5;
	const height = opts && opts.height !== undefined ? opts.height : 1.0;
	const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
	const capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	const options = _createConeData(radius, radius, height, heightSegments, capSegments, false);

	if (calcTangents) {
		options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	}

	return createMesh$1(device, options.positions, options);
}

function createCapsule(device, opts) {
	const radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
	const height = opts && opts.height !== undefined ? opts.height : 1.0;
	const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
	const sides = opts && opts.sides !== undefined ? opts.sides : 20;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	const options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);

	if (calcTangents) {
		options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	}

	return createMesh$1(device, options.positions, options);
}

function createCone(device, opts) {
	const baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
	const peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
	const height = opts && opts.height !== undefined ? opts.height : 1.0;
	const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
	const capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	const options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);

	if (calcTangents) {
		options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	}

	return createMesh$1(device, options.positions, options);
}

function createSphere(device, opts) {
	const radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
	const latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
	const longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	const positions = [];
	const normals = [];
	const uvs = [];
	const indices = [];

	for (let lat = 0; lat <= latitudeBands; lat++) {
		const theta = lat * Math.PI / latitudeBands;
		const sinTheta = Math.sin(theta);
		const cosTheta = Math.cos(theta);

		for (let lon = 0; lon <= longitudeBands; lon++) {
			const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
			const sinPhi = Math.sin(phi);
			const cosPhi = Math.cos(phi);
			const x = cosPhi * sinTheta;
			const y = cosTheta;
			const z = sinPhi * sinTheta;
			const u = 1 - lon / longitudeBands;
			const v = 1 - lat / latitudeBands;
			positions.push(x * radius, y * radius, z * radius);
			normals.push(x, y, z);
			uvs.push(u, 1 - v);
		}
	}

	for (let lat = 0; lat < latitudeBands; ++lat) {
		for (let lon = 0; lon < longitudeBands; ++lon) {
			const first = lat * (longitudeBands + 1) + lon;
			const second = first + longitudeBands + 1;
			indices.push(first + 1, second, first);
			indices.push(first + 1, second + 1, second);
		}
	}

	const options = {
		normals: normals,
		uvs: uvs,
		uvs1: uvs,
		indices: indices
	};

	if (calcTangents) {
		options.tangents = calculateTangents(positions, normals, uvs, indices);
	}

	return createMesh$1(device, positions, options);
}

function createPlane(device, opts) {
	const he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);
	const ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
	const ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	const positions = [];
	const normals = [];
	const uvs = [];
	const indices = [];
	let vcounter = 0;

	for (let i = 0; i <= ws; i++) {
		for (let j = 0; j <= ls; j++) {
			const x = -he.x + 2 * he.x * i / ws;
			const y = 0.0;
			const z = -(-he.y + 2 * he.y * j / ls);
			const u = i / ws;
			const v = j / ls;
			positions.push(x, y, z);
			normals.push(0, 1, 0);
			uvs.push(u, 1 - v);

			if (i < ws && j < ls) {
				indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
				indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
			}

			vcounter++;
		}
	}

	const options = {
		normals: normals,
		uvs: uvs,
		uvs1: uvs,
		indices: indices
	};

	if (calcTangents) {
		options.tangents = calculateTangents(positions, normals, uvs, indices);
	}

	return createMesh$1(device, positions, options);
}

function createBox(device, opts) {
	const he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);
	const ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
	const ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
	const hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	const corners = [new Vec3(-he.x, -he.y, he.z), new Vec3(he.x, -he.y, he.z), new Vec3(he.x, he.y, he.z), new Vec3(-he.x, he.y, he.z), new Vec3(he.x, -he.y, -he.z), new Vec3(-he.x, -he.y, -he.z), new Vec3(-he.x, he.y, -he.z), new Vec3(he.x, he.y, -he.z)];
	const faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
	const faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
	const sides = {
		FRONT: 0,
		BACK: 1,
		TOP: 2,
		BOTTOM: 3,
		RIGHT: 4,
		LEFT: 5
	};
	const positions = [];
	const normals = [];
	const uvs = [];
	const uvs1 = [];
	const indices = [];
	let vcounter = 0;

	const generateFace = (side, uSegments, vSegments) => {
		const temp1 = new Vec3();
		const temp2 = new Vec3();
		const temp3 = new Vec3();
		const r = new Vec3();

		for (let i = 0; i <= uSegments; i++) {
			for (let j = 0; j <= vSegments; j++) {
				temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
				temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
				temp3.sub2(temp2, corners[faceAxes[side][0]]);
				r.add2(temp1, temp3);
				let u = i / uSegments;
				let v = j / vSegments;
				positions.push(r.x, r.y, r.z);
				normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += side % 3 / 3;
				v += Math.floor(side / 3) / 3;
				uvs1.push(u, 1 - v);

				if (i < uSegments && j < vSegments) {
					indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
					indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
				}

				vcounter++;
			}
		}
	};

	generateFace(sides.FRONT, ws, hs);
	generateFace(sides.BACK, ws, hs);
	generateFace(sides.TOP, ws, ls);
	generateFace(sides.BOTTOM, ws, ls);
	generateFace(sides.RIGHT, ls, hs);
	generateFace(sides.LEFT, ls, hs);
	const options = {
		normals: normals,
		uvs: uvs,
		uvs1: uvs1,
		indices: indices
	};

	if (calcTangents) {
		options.tangents = calculateTangents(positions, normals, uvs, indices);
	}

	return createMesh$1(device, positions, options);
}

function getShapePrimitive(device, type) {
	let primData = null;

	for (let i = 0; i < shapePrimitives.length; i++) {
		if (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {
			primData = shapePrimitives[i].primData;
		}
	}

	if (!primData) {
		let mesh, area;

		switch (type) {
			case 'box':
				mesh = createBox(device, {
					halfExtents: new Vec3(0.5, 0.5, 0.5)
				});
				area = {
					x: 2,
					y: 2,
					z: 2,
					uv: 2.0 / 3
				};
				break;

			case 'capsule':
				mesh = createCapsule(device, {
					radius: 0.5,
					height: 2
				});
				area = {
					x: Math.PI * 2,
					y: Math.PI,
					z: Math.PI * 2,
					uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
				};
				break;

			case 'cone':
				mesh = createCone(device, {
					baseRadius: 0.5,
					peakRadius: 0,
					height: 1
				});
				area = {
					x: 2.54,
					y: 2.54,
					z: 2.54,
					uv: 1.0 / 3 + 1.0 / 3 / 3
				};
				break;

			case 'cylinder':
				mesh = createCylinder(device, {
					radius: 0.5,
					height: 1
				});
				area = {
					x: Math.PI,
					y: 0.79 * 2,
					z: Math.PI,
					uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
				};
				break;

			case 'plane':
				mesh = createPlane(device, {
					halfExtents: new Vec2(0.5, 0.5),
					widthSegments: 1,
					lengthSegments: 1
				});
				area = {
					x: 0,
					y: 1,
					z: 0,
					uv: 1
				};
				break;

			case 'sphere':
				mesh = createSphere(device, {
					radius: 0.5
				});
				area = {
					x: Math.PI,
					y: Math.PI,
					z: Math.PI,
					uv: 1
				};
				break;

			default:
				throw new Error("Invalid primitive type: " + type);
		}

		mesh.incRefCount();
		primData = {
			mesh: mesh,
			area: area
		};
		shapePrimitives.push({
			type: type,
			device: device,
			primData: primData
		});
	}

	return primData;
}

class BasicMaterial extends Material$1 {
	constructor() {
		super();
		this.color = new Color(1, 1, 1, 1);
		this.colorUniform = new Float32Array(4);
		this.colorMap = null;
		this.vertexColors = false;
	}

	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.colorMap = source.colorMap;
		this.vertexColors = source.vertexColors;
		return this;
	}

	updateUniforms(device, scene) {
		this.clearParameters();
		this.colorUniform[0] = this.color.r;
		this.colorUniform[1] = this.color.g;
		this.colorUniform[2] = this.color.b;
		this.colorUniform[3] = this.color.a;
		this.setParameter('uColor', this.colorUniform);

		if (this.colorMap) {
			this.setParameter('texture_diffuseMap', this.colorMap);
		}
	}

	updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {
		const options = {
			skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
			screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
			useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
			useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
			useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
			useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
			vertexColors: this.vertexColors,
			diffuseMap: !!this.colorMap,
			pass: pass
		};
		const library = device.getProgramLibrary();
		this.shader = library.getProgram('basic', options);
	}

}

class Batch {
	constructor(meshInstances, dynamic, batchGroupId) {
		this.origMeshInstances = meshInstances;
		this._aabb = new BoundingBox();
		this.meshInstance = null;
		this.dynamic = dynamic;
		this.batchGroupId = batchGroupId;
	}

	destroy(scene, layers) {
		if (this.meshInstance) {
			this.removeFromLayers(scene, layers);
			this.meshInstance.destroy();
		}
	}

	addToLayers(scene, layers) {
		for (let i = 0; i < layers.length; i++) {
			const layer = scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.addMeshInstances([this.meshInstance]);
			}
		}
	}

	removeFromLayers(scene, layers) {
		for (let i = 0; i < layers.length; i++) {
			const layer = scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.removeMeshInstances([this.meshInstance]);
			}
		}
	}

	updateBoundingBox() {
		this._aabb.copy(this.origMeshInstances[0].aabb);

		for (let i = 1; i < this.origMeshInstances.length; i++) {
			this._aabb.add(this.origMeshInstances[i].aabb);
		}

		this.meshInstance.aabb = this._aabb;
		this.meshInstance._aabbVer = 0;
	}

}

class BatchGroup {
	constructor(id, name, dynamic, maxAabbSize, layers = [LAYERID_WORLD]) {
		this.dynamic = dynamic;
		this.maxAabbSize = maxAabbSize;
		this.id = id;
		this.name = name;
		this.layers = layers;
		this._ui = false;
		this._sprite = false;
		this._obj = {
			model: [],
			element: [],
			sprite: [],
			render: []
		};
	}

}

BatchGroup.MODEL = 'model';
BatchGroup.ELEMENT = 'element';
BatchGroup.SPRITE = 'sprite';
BatchGroup.RENDER = 'render';

const _invMatrix = new Mat4();

class SkinInstance {
	constructor(skin) {
		this.bones = void 0;
		this._dirty = true;
		this._rootBone = null;
		this._skinUpdateIndex = -1;
		this._updateBeforeCull = true;

		if (skin) {
			this.initSkin(skin);
		}
	}

	set rootBone(rootBone) {
		this._rootBone = rootBone;
	}

	get rootBone() {
		return this._rootBone;
	}

	init(device, numBones) {
		if (device.supportsBoneTextures) {
			const numPixels = numBones * 3;
			let width = Math.ceil(Math.sqrt(numPixels));
			width = math.roundUp(width, 3);
			const height = Math.ceil(numPixels / width);
			this.boneTexture = new Texture(device, {
				width: width,
				height: height,
				format: PIXELFORMAT_RGBA32F,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST
			});
			this.boneTexture.name = 'skin';
			this.matrixPalette = this.boneTexture.lock();
		} else {
			this.matrixPalette = new Float32Array(numBones * 12);
		}
	}

	destroy() {
		if (this.boneTexture) {
			this.boneTexture.destroy();
			this.boneTexture = null;
		}
	}

	resolve(rootBone, entity) {
		this.rootBone = rootBone;
		const skin = this.skin;
		const bones = [];

		for (let j = 0; j < skin.boneNames.length; j++) {
			const boneName = skin.boneNames[j];
			let bone = rootBone.findByName(boneName);

			if (!bone) {
				bone = entity;
			}

			bones.push(bone);
		}

		this.bones = bones;
	}

	initSkin(skin) {
		this.skin = skin;
		this.bones = [];
		const numBones = skin.inverseBindPose.length;
		this.init(skin.device, numBones);
		this.matrices = [];

		for (let i = 0; i < numBones; i++) {
			this.matrices[i] = new Mat4();
		}
	}

	uploadBones(device) {
		if (device.supportsBoneTextures) {
			this.boneTexture.lock();
			this.boneTexture.unlock();
		}
	}

	_updateMatrices(rootNode, skinUpdateIndex) {
		if (this._skinUpdateIndex !== skinUpdateIndex) {
			this._skinUpdateIndex = skinUpdateIndex;

			_invMatrix.copy(rootNode.getWorldTransform()).invert();

			for (let i = this.bones.length - 1; i >= 0; i--) {
				this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
				this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
			}
		}
	}

	updateMatrices(rootNode, skinUpdateIndex) {
		if (this._updateBeforeCull) {
			this._updateMatrices(rootNode, skinUpdateIndex);
		}
	}

	updateMatrixPalette(rootNode, skinUpdateIndex) {
		this._updateMatrices(rootNode, skinUpdateIndex);

		const mp = this.matrixPalette;
		const count = this.bones.length;

		for (let i = 0; i < count; i++) {
			const pe = this.matrices[i].data;
			const base = i * 12;
			mp[base] = pe[0];
			mp[base + 1] = pe[4];
			mp[base + 2] = pe[8];
			mp[base + 3] = pe[12];
			mp[base + 4] = pe[1];
			mp[base + 5] = pe[5];
			mp[base + 6] = pe[9];
			mp[base + 7] = pe[13];
			mp[base + 8] = pe[2];
			mp[base + 9] = pe[6];
			mp[base + 10] = pe[10];
			mp[base + 11] = pe[14];
		}

		this.uploadBones(this.skin.device);
	}

}

class SkinBatchInstance extends SkinInstance {
	constructor(device, nodes, rootNode) {
		super();
		const numBones = nodes.length;
		this.init(device, numBones);
		this.device = device;
		this.rootNode = rootNode;
		this.bones = nodes;
	}

	updateMatrices(rootNode, skinUpdateIndex) {}

	updateMatrixPalette(rootNode, skinUpdateIndex) {
		const mp = this.matrixPalette;
		const count = this.bones.length;

		for (let i = 0; i < count; i++) {
			const pe = this.bones[i].getWorldTransform().data;
			const base = i * 12;
			mp[base] = pe[0];
			mp[base + 1] = pe[4];
			mp[base + 2] = pe[8];
			mp[base + 3] = pe[12];
			mp[base + 4] = pe[1];
			mp[base + 5] = pe[5];
			mp[base + 6] = pe[9];
			mp[base + 7] = pe[13];
			mp[base + 8] = pe[2];
			mp[base + 9] = pe[6];
			mp[base + 10] = pe[10];
			mp[base + 11] = pe[14];
		}

		this.uploadBones(this.device);
	}

}

class RefCountedCache {
	constructor() {
		this.cache = new Map();
	}

	destroy() {
		this.cache.forEach((refCount, object) => {
			object.destroy();
		});
		this.cache.clear();
	}

	incRef(object) {
		const refCount = (this.cache.get(object) || 0) + 1;
		this.cache.set(object, refCount);
	}

	decRef(object) {
		if (object) {
			let refCount = this.cache.get(object);

			if (refCount) {
				refCount--;

				if (refCount === 0) {
					this.cache.delete(object);
					object.destroy();
				} else {
					this.cache.set(object, refCount);
				}
			}
		}
	}

}

class LightmapCache {
	static incRef(texture) {
		this.cache.incRef(texture);
	}

	static decRef(texture) {
		this.cache.decRef(texture);
	}

	static destroy() {
		this.cache.destroy();
	}

}

LightmapCache.cache = new RefCountedCache();

const _tmpAabb = new BoundingBox();

const _tempBoneAabb = new BoundingBox();

const _tempSphere = new BoundingSphere();

const _meshSet = new Set();

class InstancingData {
	constructor(numObjects) {
		this.count = numObjects;
		this.vertexBuffer = null;
	}

}

class MeshInstance {
	constructor(mesh, material, node = null) {
		if (mesh instanceof GraphNode) {
			const temp = mesh;
			mesh = material;
			material = node;
			node = temp;
		}

		this._key = [0, 0];
		this._shader = [null, null, null];
		this.isStatic = false;
		this._staticLightList = null;
		this._staticSource = null;
		this.node = node;
		this._mesh = mesh;
		mesh.incRefCount();
		this.material = material;
		this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
		this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;
		this._lightHash = 0;
		this.visible = true;
		this.layer = LAYER_WORLD;
		this._renderStyle = RENDERSTYLE_SOLID;
		this.castShadow = false;
		this._receiveShadow = true;
		this._screenSpace = false;
		this._noDepthDrawGl1 = false;
		this.cull = true;
		this.pick = true;
		this._updateAabb = true;
		this._updateAabbFunc = null;
		this._calculateSortDistance = null;
		this.updateKey();
		this._skinInstance = null;
		this._morphInstance = null;
		this.instancingData = null;
		this._customAabb = null;
		this.aabb = new BoundingBox();
		this._aabbVer = -1;
		this.drawOrder = 0;
		this.visibleThisFrame = 0;
		this.isVisibleFunc = null;
		this.parameters = {};
		this.stencilFront = null;
		this.stencilBack = null;
		this.flipFaces = false;
	}

	set renderStyle(renderStyle) {
		this._renderStyle = renderStyle;
		this.mesh.prepareRenderState(renderStyle);
	}

	get renderStyle() {
		return this._renderStyle;
	}

	set mesh(mesh) {
		if (mesh === this._mesh) return;

		if (this._mesh) {
			this._mesh.decRefCount();
		}

		this._mesh = mesh;

		if (mesh) {
			mesh.incRefCount();
		}
	}

	get mesh() {
		return this._mesh;
	}

	set aabb(aabb) {
		this._aabb = aabb;
	}

	get aabb() {
		if (!this._updateAabb) {
			return this._aabb;
		}

		if (this._updateAabbFunc) {
			return this._updateAabbFunc(this._aabb);
		}

		let localAabb = this._customAabb;
		let toWorldSpace = !!localAabb;

		if (!localAabb) {
			localAabb = _tmpAabb;

			if (this.skinInstance) {
				if (!this.mesh.boneAabb) {
					const morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;

					this.mesh._initBoneAabbs(morphTargets);
				}

				const boneUsed = this.mesh.boneUsed;
				let first = true;

				for (let i = 0; i < this.mesh.boneAabb.length; i++) {
					if (boneUsed[i]) {
						_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);

						if (first) {
							first = false;
							localAabb.center.copy(_tempBoneAabb.center);
							localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
						} else {
							localAabb.add(_tempBoneAabb);
						}
					}
				}

				toWorldSpace = true;
			} else if (this.node._aabbVer !== this._aabbVer) {
				if (this.mesh) {
					localAabb.center.copy(this.mesh.aabb.center);
					localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
				} else {
					localAabb.center.set(0, 0, 0);
					localAabb.halfExtents.set(0, 0, 0);
				}

				if (this.mesh && this.mesh.morph) {
					localAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());
				}

				toWorldSpace = true;
				this._aabbVer = this.node._aabbVer;
			}
		}

		if (toWorldSpace) {
			this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
		}

		return this._aabb;
	}

	set material(material) {
		for (let i = 0; i < this._shader.length; i++) {
			this._shader[i] = null;
		}

		const prevMat = this._material;

		if (prevMat) {
			prevMat.removeMeshInstanceRef(this);
		}

		this._material = material;

		if (this._material) {
			this._material.addMeshInstanceRef(this);

			this.updateKey();
			const prevBlend = prevMat && prevMat.blendType !== BLEND_NONE;
			const thisBlend = this._material.blendType !== BLEND_NONE;

			if (prevBlend !== thisBlend) {
				let scene = this._material._scene;
				if (!scene && prevMat && prevMat._scene) scene = prevMat._scene;

				if (scene) {
					scene.layers._dirtyBlend = true;
				} else {
					this._material._dirtyBlend = true;
				}
			}
		}
	}

	get material() {
		return this._material;
	}

	set layer(layer) {
		this._layer = layer;
		this.updateKey();
	}

	get layer() {
		return this._layer;
	}

	set calculateSortDistance(calculateSortDistance) {
		this._calculateSortDistance = calculateSortDistance;
	}

	get calculateSortDistance() {
		return this._calculateSortDistance;
	}

	set receiveShadow(val) {
		this._receiveShadow = val;
		this._shaderDefs = val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW;
		this._shader[SHADER_FORWARD] = null;
		this._shader[SHADER_FORWARDHDR] = null;
	}

	get receiveShadow() {
		return this._receiveShadow;
	}

	set skinInstance(val) {
		this._skinInstance = val;
		this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN;

		for (let i = 0; i < this._shader.length; i++) {
			this._shader[i] = null;
		}

		this._setupSkinUpdate();
	}

	get skinInstance() {
		return this._skinInstance;
	}

	set morphInstance(val) {
		this._morphInstance = val;

		if (this._morphInstance) {
			this._morphInstance.meshInstance = this;
		}

		this._shaderDefs = val && val.morph.useTextureMorph ? this._shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : this._shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;
		this._shaderDefs = val && val.morph.morphPositions ? this._shaderDefs | SHADERDEF_MORPH_POSITION : this._shaderDefs & ~SHADERDEF_MORPH_POSITION;
		this._shaderDefs = val && val.morph.morphNormals ? this._shaderDefs | SHADERDEF_MORPH_NORMAL : this._shaderDefs & ~SHADERDEF_MORPH_NORMAL;

		for (let i = 0; i < this._shader.length; i++) {
			this._shader[i] = null;
		}
	}

	get morphInstance() {
		return this._morphInstance;
	}

	set screenSpace(val) {
		this._screenSpace = val;
		this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE;
		this._shader[SHADER_FORWARD] = null;
	}

	get screenSpace() {
		return this._screenSpace;
	}

	set key(val) {
		this._key[SORTKEY_FORWARD] = val;
	}

	get key() {
		return this._key[SORTKEY_FORWARD];
	}

	set mask(val) {
		const toggles = this._shaderDefs & 0x0000FFFF;
		this._shaderDefs = toggles | val << 16;
		this._shader[SHADER_FORWARD] = null;
		this._shader[SHADER_FORWARDHDR] = null;
	}

	get mask() {
		return this._shaderDefs >> 16;
	}

	set instancingCount(value) {
		if (this.instancingData) this.instancingData.count = value;
	}

	get instancingCount() {
		return this.instancingData ? this.instancingData.count : 0;
	}

	destroy() {
		const mesh = this.mesh;

		if (mesh) {
			this.mesh = null;

			if (mesh.refCount < 1) {
				mesh.destroy();
			}
		}

		this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
		this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);

		if (this._skinInstance) {
			this._skinInstance.destroy();

			this._skinInstance = null;
		}

		if (this.morphInstance) {
			this.morphInstance.destroy();
			this.morphInstance = null;
		}

		this.material = null;
	}

	static _prepareRenderStyleForArray(meshInstances, renderStyle) {
		if (meshInstances) {
			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i]._renderStyle = renderStyle;
				const mesh = meshInstances[i].mesh;

				if (!_meshSet.has(mesh)) {
					_meshSet.add(mesh);

					mesh.prepareRenderState(renderStyle);
				}
			}

			_meshSet.clear();
		}
	}

	_isVisible(camera) {
		if (this.visible) {
			if (this.isVisibleFunc) {
				return this.isVisibleFunc(camera);
			}

			_tempSphere.center = this.aabb.center;
			_tempSphere.radius = this._aabb.halfExtents.length();
			return camera.frustum.containsSphere(_tempSphere);
		}

		return false;
	}

	updateKey() {
		const material = this.material;
		this._key[SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType, false, material.id);
	}

	setInstancing(vertexBuffer) {
		if (vertexBuffer) {
			this.instancingData = new InstancingData(vertexBuffer.numVertices);
			this.instancingData.vertexBuffer = vertexBuffer;
			vertexBuffer.instancing = true;
			this.cull = false;
		} else {
			this.instancingData = null;
			this.cull = true;
		}
	}

	clearParameters() {
		this.parameters = {};
	}

	getParameters() {
		return this.parameters;
	}

	getParameter(name) {
		return this.parameters[name];
	}

	setParameter(name, data, passFlags = -262141) {
		if (data === undefined && typeof name === 'object') {
			const uniformObject = name;

			if (uniformObject.length) {
				for (let i = 0; i < uniformObject.length; i++) {
					this.setParameter(uniformObject[i]);
				}

				return;
			}

			name = uniformObject.name;
			data = uniformObject.value;
		}

		const param = this.parameters[name];

		if (param) {
			param.data = data;
			param.passFlags = passFlags;
		} else {
			this.parameters[name] = {
				scopeId: null,
				data: data,
				passFlags: passFlags
			};
		}
	}

	setRealtimeLightmap(name, texture) {
		const old = this.getParameter(name);
		if (old === texture) return;

		if (old) {
			LightmapCache.decRef(old.data);
		}

		if (texture) {
			LightmapCache.incRef(texture);
			this.setParameter(name, texture);
		} else {
			this.deleteParameter(name);
		}
	}

	deleteParameter(name) {
		if (this.parameters[name]) {
			delete this.parameters[name];
		}
	}

	setParameters(device, passFlag) {
		const parameters = this.parameters;

		for (const paramName in parameters) {
			const parameter = parameters[paramName];

			if (parameter.passFlags & passFlag) {
				if (!parameter.scopeId) {
					parameter.scopeId = device.scope.resolve(paramName);
				}

				parameter.scopeId.setValue(parameter.data);
			}
		}
	}

	setLightmapped(value) {
		if (value) {
			this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);
		} else {
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
			this._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);
			this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);
		}
	}

	setCustomAabb(aabb) {
		if (aabb) {
			if (this._customAabb) {
				this._customAabb.copy(aabb);
			} else {
				this._customAabb = aabb.clone();
			}
		} else {
			this._customAabb = null;
			this._aabbVer = -1;
		}

		this._setupSkinUpdate();
	}

	_setupSkinUpdate() {
		if (this._skinInstance) {
			this._skinInstance._updateBeforeCull = !this._customAabb;
		}
	}

}

MeshInstance.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];

function getKey(layer, blendType, isCommand, materialId) {
	return (layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 0x1ffffff) << 0;
}

function paramsIdentical(a, b) {
	if (a && !b) return false;
	if (!a && b) return false;
	a = a.data;
	b = b.data;
	if (a === b) return true;

	if (a instanceof Float32Array && b instanceof Float32Array) {
		if (a.length !== b.length) return false;

		for (let i = 0; i < a.length; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	return false;
}

function equalParamSets(params1, params2) {
	for (const param in params1) {
		if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;
	}

	for (const param in params2) {
		if (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) return false;
	}

	return true;
}

function equalLightLists(lightList1, lightList2) {
	for (let k = 0; k < lightList1.length; k++) {
		if (lightList2.indexOf(lightList1[k]) < 0) return false;
	}

	for (let k = 0; k < lightList2.length; k++) {
		if (lightList1.indexOf(lightList2[k]) < 0) return false;
	}

	return true;
}

const mat3 = new Mat3();
const worldMatX$1 = new Vec3();
const worldMatY$1 = new Vec3();
const worldMatZ$1 = new Vec3();

function getScaleSign(mi) {
	const wt = mi.node.worldTransform;
	wt.getX(worldMatX$1);
	wt.getY(worldMatY$1);
	wt.getZ(worldMatZ$1);
	worldMatX$1.cross(worldMatX$1, worldMatY$1);
	return worldMatX$1.dot(worldMatZ$1) >= 0 ? 1 : -1;
}

class BatchManager {
	constructor(device, root, scene) {
		this.device = device;
		this.rootNode = root;
		this.scene = scene;
		this._init = false;
		this._batchGroups = {};
		this._batchGroupCounter = 0;
		this._batchList = [];
		this._dirtyGroups = [];
	}

	destroy() {
		this.device = null;
		this.rootNode = null;
		this.scene = null;
		this._batchGroups = {};
		this._batchList = [];
		this._dirtyGroups = [];
	}

	addGroup(name, dynamic, maxAabbSize, id, layers) {
		if (id === undefined) {
			id = this._batchGroupCounter;
			this._batchGroupCounter++;
		}

		if (this._batchGroups[id]) {
			return;
		}

		const group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
		this._batchGroups[id] = group;
		return group;
	}

	removeGroup(id) {
		if (!this._batchGroups[id]) {
			return;
		}

		const newBatchList = [];

		for (let i = 0; i < this._batchList.length; i++) {
			if (this._batchList[i].batchGroupId === id) {
				this.destroyBatch(this._batchList[i]);
			} else {
				newBatchList.push(this._batchList[i]);
			}
		}

		this._batchList = newBatchList;

		this._removeModelsFromBatchGroup(this.rootNode, id);

		delete this._batchGroups[id];
	}

	markGroupDirty(id) {
		if (this._dirtyGroups.indexOf(id) < 0) {
			this._dirtyGroups.push(id);
		}
	}

	getGroupByName(name) {
		const groups = this._batchGroups;

		for (const group in groups) {
			if (!groups.hasOwnProperty(group)) continue;

			if (groups[group].name === name) {
				return groups[group];
			}
		}

		return null;
	}

	getBatches(batchGroupId) {
		const results = [];
		const len = this._batchList.length;

		for (let i = 0; i < len; i++) {
			const batch = this._batchList[i];

			if (batch.batchGroupId === batchGroupId) {
				results.push(batch);
			}
		}

		return results;
	}

	_removeModelsFromBatchGroup(node, id) {
		if (!node.enabled) return;

		if (node.model && node.model.batchGroupId === id) {
			node.model.batchGroupId = -1;
		}

		if (node.render && node.render.batchGroupId === id) {
			node.render.batchGroupId = -1;
		}

		if (node.element && node.element.batchGroupId === id) {
			node.element.batchGroupId = -1;
		}

		if (node.sprite && node.sprite.batchGroupId === id) {
			node.sprite.batchGroupId = -1;
		}

		for (let i = 0; i < node._children.length; i++) {
			this._removeModelsFromBatchGroup(node._children[i], id);
		}
	}

	insert(type, groupId, node) {
		const group = this._batchGroups[groupId];

		if (group) {
			if (group._obj[type].indexOf(node) < 0) {
				group._obj[type].push(node);

				this.markGroupDirty(groupId);
			}
		}
	}

	remove(type, groupId, node) {
		const group = this._batchGroups[groupId];

		if (group) {
			const idx = group._obj[type].indexOf(node);

			if (idx >= 0) {
				group._obj[type].splice(idx, 1);

				this.markGroupDirty(groupId);
			}
		}
	}

	_extractRender(node, arr, group, groupMeshInstances) {
		if (node.render) {
			if (node.render.isStatic) {
				const drawCalls = this.scene.drawCalls;
				const nodeMeshInstances = node.render.meshInstances;

				for (let i = 0; i < drawCalls.length; i++) {
					if (!drawCalls[i]._staticSource) continue;
					if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
					arr.push(drawCalls[i]);
				}

				for (let i = 0; i < nodeMeshInstances.length; i++) {
					if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
						arr.push(nodeMeshInstances[i]);
					}
				}
			} else {
				arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
			}

			node.render.removeFromLayers();
		}

		return arr;
	}

	_extractModel(node, arr, group, groupMeshInstances) {
		if (node.model && node.model.model) {
			if (node.model.isStatic) {
				const drawCalls = this.scene.drawCalls;
				const nodeMeshInstances = node.model.meshInstances;

				for (let i = 0; i < drawCalls.length; i++) {
					if (!drawCalls[i]._staticSource) continue;
					if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
					arr.push(drawCalls[i]);
				}

				for (let i = 0; i < nodeMeshInstances.length; i++) {
					if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
						arr.push(nodeMeshInstances[i]);
					}
				}
			} else {
				arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
			}

			node.model.removeModelFromLayers();
		}

		return arr;
	}

	_extractElement(node, arr, group) {
		if (!node.element) return;
		let valid = false;

		if (node.element._text && node.element._text._model.meshInstances.length > 0) {
			arr.push(node.element._text._model.meshInstances[0]);
			node.element.removeModelFromLayers(node.element._text._model);
			valid = true;
		} else if (node.element._image) {
			arr.push(node.element._image._renderable.meshInstance);
			node.element.removeModelFromLayers(node.element._image._renderable.model);

			if (node.element._image._renderable.unmaskMeshInstance) {
				arr.push(node.element._image._renderable.unmaskMeshInstance);

				if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
					node.element._dirtifyMask();

					node.element._onPrerender();
				}
			}

			valid = true;
		}

		if (valid) {
			group._ui = true;
		}
	}

	_collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
		for (let g = 0; g < groupIds.length; g++) {
			const id = groupIds[g];
			const group = this._batchGroups[id];
			if (!group) continue;
			let arr = groupMeshInstances[id];
			if (!arr) arr = groupMeshInstances[id] = [];

			for (let m = 0; m < group._obj.model.length; m++) {
				arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
			}

			for (let r = 0; r < group._obj.render.length; r++) {
				arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
			}

			for (let e = 0; e < group._obj.element.length; e++) {
				this._extractElement(group._obj.element[e], arr, group);
			}

			for (let s = 0; s < group._obj.sprite.length; s++) {
				const node = group._obj.sprite[s];

				if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
					arr.push(node.sprite._meshInstance);
					node.sprite.removeModelFromLayers();
					group._sprite = true;
					node.sprite._batchGroup = group;
				}
			}
		}
	}

	generate(groupIds) {
		const groupMeshInstances = {};

		if (!groupIds) {
			groupIds = Object.keys(this._batchGroups);
		}

		const newBatchList = [];

		for (let i = 0; i < this._batchList.length; i++) {
			if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
				newBatchList.push(this._batchList[i]);
				continue;
			}

			this.destroyBatch(this._batchList[i]);
		}

		this._batchList = newBatchList;

		this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);

		if (groupIds === this._dirtyGroups) {
			this._dirtyGroups.length = 0;
		} else {
			const newDirtyGroups = [];

			for (let i = 0; i < this._dirtyGroups.length; i++) {
				if (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);
			}

			this._dirtyGroups = newDirtyGroups;
		}

		let group, lists, groupData, batch;

		for (const groupId in groupMeshInstances) {
			if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
			group = groupMeshInstances[groupId];
			groupData = this._batchGroups[groupId];

			if (!groupData) {
				continue;
			}

			lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);

			for (let i = 0; i < lists.length; i++) {
				batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));

				if (batch) {
					batch.addToLayers(this.scene, groupData.layers);
				}
			}
		}
	}

	prepare(meshInstances, dynamic, maxAabbSize = Number.POSITIVE_INFINITY, translucent) {
		if (meshInstances.length === 0) return [];
		const halfMaxAabbSize = maxAabbSize * 0.5;
		const maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
		const maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;
		const aabb = new BoundingBox();
		const testAabb = new BoundingBox();
		let skipTranslucentAabb = null;
		let sf;
		const lists = [];
		let j = 0;

		if (translucent) {
			meshInstances.sort(function (a, b) {
				return a.drawOrder - b.drawOrder;
			});
		}

		let meshInstancesLeftA = meshInstances;
		let meshInstancesLeftB;
		const skipMesh = translucent ? function (mi) {
			if (skipTranslucentAabb) {
				skipTranslucentAabb.add(mi.aabb);
			} else {
				skipTranslucentAabb = mi.aabb.clone();
			}

			meshInstancesLeftB.push(mi);
		} : function (mi) {
			meshInstancesLeftB.push(mi);
		};

		while (meshInstancesLeftA.length > 0) {
			lists[j] = [meshInstancesLeftA[0]];
			meshInstancesLeftB = [];
			const material = meshInstancesLeftA[0].material;
			const layer = meshInstancesLeftA[0].layer;
			const defs = meshInstancesLeftA[0]._shaderDefs;
			const params = meshInstancesLeftA[0].parameters;
			const stencil = meshInstancesLeftA[0].stencilFront;
			const lightList = meshInstancesLeftA[0]._staticLightList;
			let vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
			const drawOrder = meshInstancesLeftA[0].drawOrder;
			aabb.copy(meshInstancesLeftA[0].aabb);
			const scaleSign = getScaleSign(meshInstancesLeftA[0]);
			const vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
			const indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
			skipTranslucentAabb = null;

			for (let i = 1; i < meshInstancesLeftA.length; i++) {
				const mi = meshInstancesLeftA[i];

				if (dynamic && lists[j].length >= maxInstanceCount) {
					meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
					break;
				}

				if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
					skipMesh(mi);
					continue;
				}

				testAabb.copy(aabb);
				testAabb.add(mi.aabb);

				if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
					skipMesh(mi);
					continue;
				}

				if (stencil) {
					if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
						skipMesh(mi);
						continue;
					}
				}

				if (scaleSign !== getScaleSign(mi)) {
					skipMesh(mi);
					continue;
				}

				if (!equalParamSets(params, mi.parameters)) {
					skipMesh(mi);
					continue;
				}

				const staticLights = mi._staticLightList;

				if (lightList && staticLights) {
					if (!equalLightLists(lightList, staticLights)) {
						skipMesh(mi);
						continue;
					}
				} else if (lightList || staticLights) {
					skipMesh(mi);
					continue;
				}

				if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
					skipMesh(mi);
					continue;
				}

				aabb.add(mi.aabb);
				vertCount += mi.mesh.vertexBuffer.getNumVertices();
				lists[j].push(mi);
			}

			j++;
			meshInstancesLeftA = meshInstancesLeftB;
		}

		return lists;
	}

	collectBatchedMeshData(meshInstances, dynamic) {
		let streams = null;
		let batchNumVerts = 0;
		let batchNumIndices = 0;
		let material = null;

		for (let i = 0; i < meshInstances.length; i++) {
			if (meshInstances[i].visible) {
				const mesh = meshInstances[i].mesh;
				const numVerts = mesh.vertexBuffer.numVertices;
				batchNumVerts += numVerts;
				batchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count : mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0;

				if (!streams) {
					material = meshInstances[i].material;
					streams = {};
					const elems = mesh.vertexBuffer.format.elements;

					for (let j = 0; j < elems.length; j++) {
						const semantic = elems[j].name;
						streams[semantic] = {
							numComponents: elems[j].numComponents,
							dataType: elems[j].dataType,
							normalize: elems[j].normalize,
							count: 0
						};
					}

					if (dynamic) {
						streams[SEMANTIC_BLENDINDICES] = {
							numComponents: 1,
							dataType: TYPE_FLOAT32,
							normalize: false,
							count: 0
						};
					}
				}
			}
		}

		return {
			streams: streams,
			batchNumVerts: batchNumVerts,
			batchNumIndices: batchNumIndices,
			material: material
		};
	}

	create(meshInstances, dynamic, batchGroupId) {
		if (!this._init) {
			const boneLimit = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n";
			this.transformVS = boneLimit + "#define DYNAMICBATCH\n" + shaderChunks.transformVS;
			this.skinTexVS = shaderChunks.skinBatchTexVS;
			this.skinConstVS = shaderChunks.skinBatchConstVS;
			this.vertexFormats = {};
			this._init = true;
		}

		let stream = null;
		let semantic;
		let mesh, numVerts;
		let batch = null;
		const batchData = this.collectBatchedMeshData(meshInstances, dynamic);

		if (batchData.streams) {
			const streams = batchData.streams;
			let material = batchData.material;
			const batchNumVerts = batchData.batchNumVerts;
			const batchNumIndices = batchData.batchNumIndices;
			batch = new Batch(meshInstances, dynamic, batchGroupId);

			this._batchList.push(batch);

			let indexBase, numIndices, indexData;
			let verticesOffset = 0;
			let indexOffset = 0;
			let transform;
			const vec = new Vec3();
			const indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
			const indices = new indexArrayType(batchNumIndices);

			for (semantic in streams) {
				stream = streams[semantic];
				stream.typeArrayType = typedArrayTypes[stream.dataType];
				stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
				stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
			}

			for (let i = 0; i < meshInstances.length; i++) {
				if (!meshInstances[i].visible) continue;
				mesh = meshInstances[i].mesh;
				numVerts = mesh.vertexBuffer.numVertices;

				if (!dynamic) {
					transform = meshInstances[i].node.getWorldTransform();
				}

				for (semantic in streams) {
					if (semantic !== SEMANTIC_BLENDINDICES) {
						stream = streams[semantic];
						const subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
						const totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
						stream.count += totalComponents;

						if (!dynamic && stream.numComponents >= 3) {
							if (semantic === SEMANTIC_POSITION) {
								for (let j = 0; j < totalComponents; j += stream.numComponents) {
									vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
									transform.transformPoint(vec, vec);
									subarray[j] = vec.x;
									subarray[j + 1] = vec.y;
									subarray[j + 2] = vec.z;
								}
							} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
								transform.invertTo3x3(mat3);
								mat3.transpose();

								for (let j = 0; j < totalComponents; j += stream.numComponents) {
									vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
									mat3.transformVector(vec, vec);
									subarray[j] = vec.x;
									subarray[j + 1] = vec.y;
									subarray[j + 2] = vec.z;
								}
							}
						}
					}
				}

				if (dynamic) {
					stream = streams[SEMANTIC_BLENDINDICES];

					for (let j = 0; j < numVerts; j++) stream.buffer[stream.count++] = i;
				}

				if (mesh.primitive[0].indexed) {
					indexBase = mesh.primitive[0].base;
					numIndices = mesh.primitive[0].count;
					const srcFormat = mesh.indexBuffer[0].getFormat();
					indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
				} else if (mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {
					indexBase = 0;
					numIndices = 6;
					indexData = [0, 1, 3, 2, 3, 1];
				} else {
					numIndices = 0;
					continue;
				}

				for (let j = 0; j < numIndices; j++) {
					indices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;
				}

				indexOffset += numIndices;
				verticesOffset += numVerts;
			}

			mesh = new Mesh(this.device);

			for (semantic in streams) {
				stream = streams[semantic];
				mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
			}

			if (indices.length > 0) mesh.setIndices(indices);
			mesh.update(PRIMITIVE_TRIANGLES, false);

			if (dynamic) {
				material = material.clone();
				material.chunks.transformVS = this.transformVS;
				material.chunks.skinTexVS = this.skinTexVS;
				material.chunks.skinConstVS = this.skinConstVS;
				material.update();
			}

			const meshInstance = new MeshInstance(mesh, material, this.rootNode);
			meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
			meshInstance.parameters = batch.origMeshInstances[0].parameters;
			meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
			meshInstance.layer = batch.origMeshInstances[0].layer;
			meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
			meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
			meshInstance.cull = batch.origMeshInstances[0].cull;
			const batchGroup = this._batchGroups[batchGroupId];
			if (batchGroup && batchGroup._ui) meshInstance.cull = false;

			if (dynamic) {
				const nodes = [];

				for (let i = 0; i < batch.origMeshInstances.length; i++) {
					nodes.push(batch.origMeshInstances[i].node);
				}

				meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
			}

			meshInstance._updateAabb = false;
			meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
			meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
			meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
			meshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;
			meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
			batch.meshInstance = meshInstance;
			batch.updateBoundingBox();
		}

		return batch;
	}

	updateAll() {
		if (this._dirtyGroups.length > 0) {
			this.generate(this._dirtyGroups);
		}

		for (let i = 0; i < this._batchList.length; i++) {
			if (!this._batchList[i].dynamic) continue;

			this._batchList[i].updateBoundingBox();
		}
	}

	clone(batch, clonedMeshInstances) {
		const batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);

		this._batchList.push(batch2);

		const nodes = [];

		for (let i = 0; i < clonedMeshInstances.length; i++) {
			nodes.push(clonedMeshInstances[i].node);
		}

		batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
		batch2.meshInstance._updateAabb = false;
		batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
		batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
		batch2.meshInstance.cull = clonedMeshInstances[0].cull;
		batch2.meshInstance.layer = clonedMeshInstances[0].layer;
		batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;

		if (batch.dynamic) {
			batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
		}

		batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
		batch2.meshInstance._shader = batch.meshInstance._shader;
		batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
		return batch2;
	}

	destroyBatch(batch) {
		batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
	}

}

const tempVec3 = new Vec3();
const tempMin3 = new Vec3();
const tempMax3 = new Vec3();
const tempBox = new BoundingBox();
const epsilon = 0.000001;

class ClusterLight {
	constructor() {
		this.light = null;
		this.min = new Vec3();
		this.max = new Vec3();
	}

}

class WorldClusters {
	constructor(device) {
		this.device = device;
		this.name = "Untitled";
		this.reportCount = 0;
		this.boundsMin = new Vec3();
		this.boundsMax = new Vec3();
		this.boundsDelta = new Vec3();
		this._cells = new Vec3(1, 1, 1);
		this._cellsLimit = new Vec3();
		this.cells = this._cells;
		this._maxCellLightCount = 0;
		this._pixelsPerCellCount = 0;
		this.maxCellLightCount = 4;
		this._maxAttenuation = 0;
		this._maxColorValue = 0;
		this._usedLights = [];

		this._usedLights.push(new ClusterLight());

		this.lightsBuffer = new LightsBuffer(device);
		this.registerUniforms(device);
	}

	set maxCellLightCount(count) {
		const maxCellLightCount = math.roundUp(count, 4);

		if (maxCellLightCount !== this._maxCellLightCount) {
			this._maxCellLightCount = maxCellLightCount;
			this._pixelsPerCellCount = this._maxCellLightCount / 4;
			this._cellsDirty = true;
		}
	}

	get maxCellLightCount() {
		return this._maxCellLightCount;
	}

	set cells(value) {
		tempVec3.copy(value).floor();

		if (!this._cells.equals(tempVec3)) {
			this._cells.copy(tempVec3);

			this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);

			this._cellsDirty = true;
		}
	}

	get cells() {
		return this._cells;
	}

	destroy() {
		this.lightsBuffer.destroy();
		this.releaseClusterTexture();
	}

	releaseClusterTexture() {
		if (this.clusterTexture) {
			this.clusterTexture.destroy();
			this.clusterTexture = null;
		}
	}

	registerUniforms(device) {
		this._clusterWorldTextureId = device.scope.resolve("clusterWorldTexture");
		this._clusterPixelsPerCellId = device.scope.resolve("clusterPixelsPerCell");
		this._clusterTextureSizeId = device.scope.resolve("clusterTextureSize");
		this._clusterTextureSizeData = new Float32Array(3);
		this._clusterBoundsMinId = device.scope.resolve("clusterBoundsMin");
		this._clusterBoundsMinData = new Float32Array(3);
		this._clusterBoundsDeltaId = device.scope.resolve("clusterBoundsDelta");
		this._clusterBoundsDeltaData = new Float32Array(3);
		this._clusterCellsCountByBoundsSizeId = device.scope.resolve("clusterCellsCountByBoundsSize");
		this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
		this._clusterCellsDotId = device.scope.resolve("clusterCellsDot");
		this._clusterCellsDotData = new Float32Array(3);
		this._clusterCellsMaxId = device.scope.resolve("clusterCellsMax");
		this._clusterCellsMaxData = new Float32Array(3);
		this._clusterCompressionLimit0Id = device.scope.resolve("clusterCompressionLimit0");
		this._clusterCompressionLimit0Data = new Float32Array(2);
	}

	updateParams(lightingParams) {
		if (lightingParams) {
			this.cells = lightingParams.cells;
			this.maxCellLightCount = lightingParams.maxLightsPerCell;
			this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
			this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
			this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
		}
	}

	updateCells() {
		if (this._cellsDirty) {
			this._cellsDirty = false;
			const cx = this._cells.x;
			const cy = this._cells.y;
			const cz = this._cells.z;
			const numCells = cx * cy * cz;
			const totalPixels = this._pixelsPerCellCount * numCells;
			let width = Math.ceil(Math.sqrt(totalPixels));
			width = math.roundUp(width, this._pixelsPerCellCount);
			const height = Math.ceil(totalPixels / width);
			this._clusterCellsMaxData[0] = cx;
			this._clusterCellsMaxData[1] = cy;
			this._clusterCellsMaxData[2] = cz;
			this._clusterCellsDotData[0] = this._pixelsPerCellCount;
			this._clusterCellsDotData[1] = cx * cz * this._pixelsPerCellCount;
			this._clusterCellsDotData[2] = cx * this._pixelsPerCellCount;
			this.clusters = new Uint8ClampedArray(4 * totalPixels);
			this.counts = new Int32Array(numCells);
			this._clusterTextureSizeData[0] = width;
			this._clusterTextureSizeData[1] = 1.0 / width;
			this._clusterTextureSizeData[2] = 1.0 / height;
			this.releaseClusterTexture();
			this.clusterTexture = LightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8_G8_B8_A8, "ClusterTexture");
		}
	}

	uploadTextures() {
		this.clusterTexture.lock().set(this.clusters);
		this.clusterTexture.unlock();
		this.lightsBuffer.uploadTextures();
	}

	updateUniforms() {
		this.lightsBuffer.updateUniforms();

		this._clusterWorldTextureId.setValue(this.clusterTexture);

		const boundsDelta = this.boundsDelta;
		this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
		this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
		this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;

		this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);

		this._clusterBoundsMinData[0] = this.boundsMin.x;
		this._clusterBoundsMinData[1] = this.boundsMin.y;
		this._clusterBoundsMinData[2] = this.boundsMin.z;
		this._clusterBoundsDeltaData[0] = boundsDelta.x;
		this._clusterBoundsDeltaData[1] = boundsDelta.y;
		this._clusterBoundsDeltaData[2] = boundsDelta.z;
		this._clusterCompressionLimit0Data[0] = this._maxAttenuation;
		this._clusterCompressionLimit0Data[1] = this._maxColorValue;

		this._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount);

		this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);

		this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);

		this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);

		this._clusterCellsDotId.setValue(this._clusterCellsDotData);

		this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);

		this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
	}

	evalLightCellMinMax(clusteredLight, min, max) {
		min.copy(clusteredLight.min);
		min.sub(this.boundsMin);
		min.div(this.boundsDelta);
		min.mul2(min, this.cells);
		min.floor();
		max.copy(clusteredLight.max);
		max.sub(this.boundsMin);
		max.div(this.boundsDelta);
		max.mul2(max, this.cells);
		max.ceil();
		min.max(Vec3.ZERO);
		max.min(this._cellsLimit);
	}

	collectLights(lights) {
		const maxLights = this.lightsBuffer.maxLights;
		const usedLights = this._usedLights;
		let lightIndex = 1;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];
			const runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));

			if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight) {
				if (lightIndex < maxLights) {
					let clusteredLight;

					if (lightIndex < usedLights.length) {
						clusteredLight = usedLights[lightIndex];
					} else {
						clusteredLight = new ClusterLight();
						usedLights.push(clusteredLight);
					}

					clusteredLight.light = light;
					light.getBoundingBox(tempBox);
					clusteredLight.min.copy(tempBox.getMin());
					clusteredLight.max.copy(tempBox.getMax());
					lightIndex++;
				} else {
					console.warn(`Clustered lighting: more than ${maxLights - 1} lights in the frame, ignoring some.`);
					break;
				}
			}
		}

		usedLights.length = lightIndex;
	}

	evaluateBounds() {
		const usedLights = this._usedLights;
		const min = this.boundsMin;
		const max = this.boundsMax;

		if (usedLights.length > 1) {
			min.copy(usedLights[1].min);
			max.copy(usedLights[1].max);

			for (let i = 2; i < usedLights.length; i++) {
				min.min(usedLights[i].min);
				max.max(usedLights[i].max);
			}
		} else {
			min.set(0, 0, 0);
			max.set(1, 1, 1);
		}

		this.boundsDelta.sub2(max, min);
		this.lightsBuffer.setBounds(min, this.boundsDelta);
	}

	evaluateCompressionLimits(gammaCorrection) {
		let maxAttenuation = 0;
		let maxColorValue = 0;
		const usedLights = this._usedLights;

		for (let i = 1; i < usedLights.length; i++) {
			const light = usedLights[i].light;
			maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);
			const color = gammaCorrection ? light._linearFinalColor : light._finalColor;
			maxColorValue = Math.max(color[0], maxColorValue);
			maxColorValue = Math.max(color[1], maxColorValue);
			maxColorValue = Math.max(color[2], maxColorValue);
		}

		this._maxAttenuation = maxAttenuation + epsilon;
		this._maxColorValue = maxColorValue + epsilon;
		this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
	}

	updateClusters(gammaCorrection) {
		this.counts.fill(0);
		this.clusters.fill(0);
		const divX = this._cells.x;
		const divZ = this._cells.z;
		const counts = this.counts;
		const limit = this._maxCellLightCount;
		const clusters = this.clusters;
		const pixelsPerCellCount = this._pixelsPerCellCount;
		const usedLights = this._usedLights;

		for (let i = 1; i < usedLights.length; i++) {
			const clusteredLight = usedLights[i];
			const light = clusteredLight.light;
			this.lightsBuffer.addLightData(light, i, gammaCorrection);
			this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
			const xStart = tempMin3.x;
			const xEnd = tempMax3.x;
			const yStart = tempMin3.y;
			const yEnd = tempMax3.y;
			const zStart = tempMin3.z;
			const zEnd = tempMax3.z;

			for (let x = xStart; x <= xEnd; x++) {
				for (let z = zStart; z <= zEnd; z++) {
					for (let y = yStart; y <= yEnd; y++) {
						const clusterIndex = x + divX * (z + y * divZ);
						const count = counts[clusterIndex];

						if (count < limit) {
							clusters[pixelsPerCellCount * clusterIndex * 4 + count] = i;
							counts[clusterIndex] = count + 1;
						}
					}
				}
			}
		}
	}

	update(lights, gammaCorrection, lightingParams) {
		this.updateParams(lightingParams);
		this.updateCells();
		this.collectLights(lights);
		this.evaluateBounds();
		this.evaluateCompressionLimits(gammaCorrection);
		this.updateClusters(gammaCorrection);
		this.uploadTextures();
	}

	activate() {
		this.updateUniforms();
	}

}

const textureBlitVertexShader = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}`;
const textureBlitFragmentShader = `
		varying vec2 uv0;
		uniform sampler2D blitTexture;
		void main(void) {
				gl_FragColor = texture2D(blitTexture, uv0);
		}`;
const textureCubeBlitFragmentShader = `
		varying vec2 uv0;
		uniform samplerCube blitTexture;
		uniform mat4 invViewProj;
		void main(void) {
				vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
				vec4 worldPos = invViewProj * projPos;
				gl_FragColor = textureCube(blitTexture, worldPos.xyz);
		}`;

const _viewport$1 = new Vec4();

class CookieRenderer {
	constructor(device, lightTextureAtlas) {
		this.device = device;
		this.lightTextureAtlas = lightTextureAtlas;
		this.blitShader2d = null;
		this.blitShaderCube = null;
		this.blitTextureId = null;
		this.invViewProjId = null;
	}

	destroy() {}

	getShader(shader, fragment) {
		if (!this[shader]) this[shader] = createShaderFromCode(this.device, textureBlitVertexShader, fragment, `cookie_renderer_${shader}`);
		if (!this.blitTextureId) this.blitTextureId = this.device.scope.resolve("blitTexture");
		if (!this.invViewProjId) this.invViewProjId = this.device.scope.resolve("invViewProj");
		return this[shader];
	}

	get shader2d() {
		return this.getShader("blitShader2d", textureBlitFragmentShader);
	}

	get shaderCube() {
		return this.getShader("blitShaderCube", textureCubeBlitFragmentShader);
	}

	static createTexture(device, resolution) {
		const texture = new Texture(device, {
			name: "CookieAtlas",
			width: resolution,
			height: resolution,
			format: PIXELFORMAT_R8_G8_B8_A8,
			cubemap: false,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		return texture;
	}

	initInvViewProjMatrices() {
		if (!CookieRenderer._invViewProjMatrices) {
			CookieRenderer._invViewProjMatrices = [];

			for (let face = 0; face < 6; face++) {
				const camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
				const projMat = camera.projectionMatrix;
				const viewMat = camera.node.getLocalTransform().clone().invert();
				CookieRenderer._invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
			}
		}
	}

	render(light, renderTarget) {
		if (light.enabled && light.cookie && light.visibleThisFrame) {
			const faceCount = light.numShadowFaces;
			const shader = faceCount > 1 ? this.shaderCube : this.shader2d;
			const device = this.device;

			if (faceCount > 1) {
				this.initInvViewProjMatrices();
			}

			this.blitTextureId.setValue(light.cookie);

			for (let face = 0; face < faceCount; face++) {
				_viewport$1.copy(light.atlasViewport);

				if (faceCount > 1) {
					const smallSize = _viewport$1.z / 3;
					const offset = this.lightTextureAtlas.cubeSlotsOffsets[face];
					_viewport$1.x += smallSize * offset.x;
					_viewport$1.y += smallSize * offset.y;
					_viewport$1.z = smallSize;
					_viewport$1.w = smallSize;
					this.invViewProjId.setValue(CookieRenderer._invViewProjMatrices[face].data);
				}

				_viewport$1.mulScalar(renderTarget.colorBuffer.width);

				drawQuadWithShader(device, renderTarget, shader, _viewport$1);
			}
		}
	}

}

CookieRenderer._invViewProjMatrices = null;

class ShadowMap {
	constructor(texture, targets) {
		this.texture = texture;
		this.cached = false;
		this.renderTargets = targets;
	}

	destroy() {
		if (this.texture) {
			this.texture.destroy();
			this.texture = null;
		}

		const targets = this.renderTargets;

		for (let i = 0; i < targets.length; i++) {
			targets[i].destroy();
		}

		this.renderTargets.length = 0;
	}

	static getShadowFormat(device, shadowType) {
		if (shadowType === SHADOW_VSM32) {
			return PIXELFORMAT_RGBA32F;
		} else if (shadowType === SHADOW_VSM16) {
			return PIXELFORMAT_RGBA16F;
		} else if (shadowType === SHADOW_PCF5) {
			return PIXELFORMAT_DEPTH;
		} else if (shadowType === SHADOW_PCF3 && device.webgl2) {
			return PIXELFORMAT_DEPTH;
		}

		return PIXELFORMAT_R8_G8_B8_A8;
	}

	static getShadowFiltering(device, shadowType) {
		if (shadowType === SHADOW_PCF3 && !device.webgl2) {
			return FILTER_NEAREST;
		} else if (shadowType === SHADOW_VSM32) {
			return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
		} else if (shadowType === SHADOW_VSM16) {
			return device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
		}

		return FILTER_LINEAR;
	}

	static create(device, light) {
		let shadowMap = null;

		if (light._type === LIGHTTYPE_OMNI) {
			shadowMap = this.createCubemap(device, light._shadowResolution);
		} else {
			shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
		}

		return shadowMap;
	}

	static createAtlas(device, resolution, shadowType) {
		const shadowMap = this.create2dMap(device, resolution, shadowType);
		const targets = shadowMap.renderTargets;
		const rt = targets[0];

		for (let i = 0; i < 5; i++) {
			targets.push(rt);
		}

		return shadowMap;
	}

	static create2dMap(device, size, shadowType) {
		const format = this.getShadowFormat(device, shadowType);
		const filter = this.getShadowFiltering(device, shadowType);
		const texture = new Texture(device, {
			format: format,
			width: size,
			height: size,
			mipmaps: false,
			minFilter: filter,
			magFilter: filter,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = 'ShadowMap2D';
		let target = null;

		if (shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2) {
			texture.compareOnRead = true;
			texture.compareFunc = FUNC_LESS;
			target = new RenderTarget({
				depthBuffer: texture
			});
		} else {
			target = new RenderTarget({
				colorBuffer: texture,
				depth: true
			});
		}

		return new ShadowMap(texture, [target]);
	}

	static createCubemap(device, size) {
		const cubemap = new Texture(device, {
			format: PIXELFORMAT_R8_G8_B8_A8,
			width: size,
			height: size,
			cubemap: true,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		cubemap.name = 'ShadowMapCube';
		const targets = [];

		for (let i = 0; i < 6; i++) {
			const target = new RenderTarget({
				colorBuffer: cubemap,
				face: i,
				depth: true
			});
			targets.push(target);
		}

		return new ShadowMap(cubemap, targets);
	}

}

const _tempArray = [];
const _tempArray2 = [];

const _viewport = new Vec4();

const _scissor = new Vec4();

class Slot {
	constructor(rect) {
		this.size = Math.floor(rect.w * 1024);
		this.used = false;
		this.lightId = -1;
		this.rect = rect;
	}

}

class LightTextureAtlas {
	constructor(device) {
		this.device = device;
		this.version = 1;
		this.shadowAtlasResolution = 2048;
		this.shadowAtlas = null;
		this.shadowEdgePixels = 3;
		this.cookieAtlasResolution = 2048;
		this.cookieAtlas = null;
		this.cookieRenderTarget = null;
		this.slots = [];
		this.atlasSplit = [];
		this.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];
		this.scissorVec = new Vec4();
		this.allocateShadowAtlas(1);
		this.allocateCookieAtlas(1);
		this.allocateUniforms();
	}

	destroy() {
		this.destroyShadowAtlas();
		this.destroyCookieAtlas();
	}

	destroyShadowAtlas() {
		if (this.shadowAtlas) {
			this.shadowAtlas.destroy();
			this.shadowAtlas = null;
		}
	}

	destroyCookieAtlas() {
		if (this.cookieAtlas) {
			this.cookieAtlas.destroy();
			this.cookieAtlas = null;
		}

		if (this.cookieRenderTarget) {
			this.cookieRenderTarget.destroy();
			this.cookieRenderTarget = null;
		}
	}

	allocateShadowAtlas(resolution) {
		if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {
			this.version++;
			this.destroyShadowAtlas();
			this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);
			this.shadowAtlas.cached = true;
			const scissorOffset = 4 / this.shadowAtlasResolution;
			this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
		}
	}

	allocateCookieAtlas(resolution) {
		if (!this.cookieAtlas || this.cookieAtlas.width !== resolution) {
			this.version++;
			this.destroyCookieAtlas();
			this.cookieAtlas = CookieRenderer.createTexture(this.device, resolution);
			this.cookieRenderTarget = new RenderTarget({
				colorBuffer: this.cookieAtlas,
				depth: false,
				flipY: true
			});
		}
	}

	allocateUniforms() {
		this._shadowAtlasTextureId = this.device.scope.resolve("shadowAtlasTexture");
		this._shadowAtlasParamsId = this.device.scope.resolve("shadowAtlasParams");
		this._shadowAtlasParams = new Float32Array(2);
		this._cookieAtlasTextureId = this.device.scope.resolve("cookieAtlasTexture");
	}

	updateUniforms() {
		const isShadowFilterPcf = true;
		const rt = this.shadowAtlas.renderTargets[0];
		const shadowBuffer = this.device.webgl2 && isShadowFilterPcf ? rt.depthBuffer : rt.colorBuffer;

		this._shadowAtlasTextureId.setValue(shadowBuffer);

		this._shadowAtlasParams[0] = this.shadowAtlasResolution;
		this._shadowAtlasParams[1] = this.shadowEdgePixels;

		this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);

		this._cookieAtlasTextureId.setValue(this.cookieAtlas);
	}

	subdivide(numLights, lightingParams) {
		let atlasSplit = lightingParams.atlasSplit;

		if (!atlasSplit) {
			const gridSize = Math.ceil(Math.sqrt(numLights));
			atlasSplit = _tempArray2;
			atlasSplit[0] = gridSize;
			atlasSplit.length = 1;
		}

		const arraysEqual = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);

		if (!arraysEqual(atlasSplit, this.atlasSplit)) {
			this.version++;
			this.slots.length = 0;
			this.atlasSplit.length = 0;
			this.atlasSplit.push(...atlasSplit);
			const splitCount = this.atlasSplit[0];

			if (splitCount > 1) {
				const invSize = 1 / splitCount;

				for (let i = 0; i < splitCount; i++) {
					for (let j = 0; j < splitCount; j++) {
						const rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
						const nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];

						if (nextLevelSplit > 1) {
							for (let x = 0; x < nextLevelSplit; x++) {
								for (let y = 0; y < nextLevelSplit; y++) {
									const invSizeNext = invSize / nextLevelSplit;
									const rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
									this.slots.push(new Slot(rectNext));
								}
							}
						} else {
							this.slots.push(new Slot(rect));
						}
					}
				}
			} else {
				this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
			}

			this.slots.sort((a, b) => {
				return b.size - a.size;
			});
		}
	}

	collectLights(spotLights, omniLights, lightingParams) {
		const cookiesEnabled = lightingParams.cookiesEnabled;
		const shadowsEnabled = lightingParams.shadowsEnabled;
		let needsShadowAtlas = false;
		let needsCookieAtlas = false;
		const lights = _tempArray;
		lights.length = 0;

		const processLights = list => {
			for (let i = 0; i < list.length; i++) {
				const light = list[i];

				if (light.visibleThisFrame) {
					const lightShadow = shadowsEnabled && light.castShadows;
					const lightCookie = cookiesEnabled && !!light.cookie;
					needsShadowAtlas || (needsShadowAtlas = lightShadow);
					needsCookieAtlas || (needsCookieAtlas = lightCookie);

					if (lightShadow || lightCookie) {
						lights.push(light);
					}
				}
			}
		};

		if (cookiesEnabled || shadowsEnabled) {
			processLights(spotLights);
			processLights(omniLights);
		}

		lights.sort((a, b) => {
			return b.maxScreenSize - a.maxScreenSize;
		});

		if (needsShadowAtlas) {
			this.allocateShadowAtlas(this.shadowAtlasResolution);
		}

		if (needsCookieAtlas) {
			this.allocateCookieAtlas(this.cookieAtlasResolution);
		}

		if (needsShadowAtlas || needsCookieAtlas) {
			this.subdivide(lights.length, lightingParams);
		}

		return lights;
	}

	setupSlot(light, rect) {
		light.atlasViewport.copy(rect);
		const faceCount = light.numShadowFaces;

		for (let face = 0; face < faceCount; face++) {
			if (light.castShadows || light._cookie) {
				_viewport.copy(rect);

				_scissor.copy(rect);

				if (light._type === LIGHTTYPE_SPOT) {
					_viewport.add(this.scissorVec);
				}

				if (light._type === LIGHTTYPE_OMNI) {
					const smallSize = _viewport.z / 3;
					const offset = this.cubeSlotsOffsets[face];
					_viewport.x += smallSize * offset.x;
					_viewport.y += smallSize * offset.y;
					_viewport.z = smallSize;
					_viewport.w = smallSize;

					_scissor.copy(_viewport);
				}

				if (light.castShadows) {
					const lightRenderData = light.getRenderData(null, face);
					lightRenderData.shadowViewport.copy(_viewport);
					lightRenderData.shadowScissor.copy(_scissor);
				}
			}
		}
	}

	assignSlot(light, slotIndex, slotReassigned) {
		light.atlasViewportAllocated = true;
		const slot = this.slots[slotIndex];
		slot.lightId = light.id;
		slot.used = true;

		if (slotReassigned) {
			light.atlasSlotUpdated = true;
			light.atlasVersion = this.version;
			light.atlasSlotIndex = slotIndex;
		}
	}

	update(spotLights, omniLights, lightingParams) {
		this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
		this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
		const lights = this.collectLights(spotLights, omniLights, lightingParams);

		if (lights.length > 0) {
			const slots = this.slots;

			for (let i = 0; i < slots.length; i++) {
				slots[i].used = false;
			}

			const assignCount = Math.min(lights.length, slots.length);

			for (let i = 0; i < assignCount; i++) {
				const light = lights[i];
				if (light.castShadows) light._shadowMap = this.shadowAtlas;
				const previousSlot = slots[light.atlasSlotIndex];

				if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
					const _previousSlot = slots[light.atlasSlotIndex];

					if (_previousSlot.size === slots[i].size && !_previousSlot.used) {
						this.assignSlot(light, light.atlasSlotIndex, false);
					}
				}
			}

			let usedCount = 0;

			for (let i = 0; i < assignCount; i++) {
				while (usedCount < slots.length && slots[usedCount].used) usedCount++;

				const light = lights[i];

				if (!light.atlasViewportAllocated) {
					this.assignSlot(light, usedCount, true);
				}

				const slot = slots[light.atlasSlotIndex];
				this.setupSlot(light, slot.rect);
			}
		}

		this.updateUniforms();
	}

}

class ShadowMapCache {
	constructor() {
		this.shadowMapCache = new Map();
	}

	destroy() {
		this.clear();
		this.shadowMapCache = null;
	}

	clear() {
		this.shadowMapCache.forEach(shadowMaps => {
			shadowMaps.forEach(shadowMap => {
				shadowMap.destroy();
			});
		});
		this.shadowMapCache.clear();
	}

	getKey(light) {
		const isCubeMap = light._type === LIGHTTYPE_OMNI;
		const shadowType = light._shadowType;
		const resolution = light._shadowResolution;
		return `${isCubeMap}-${shadowType}-${resolution}`;
	}

	get(device, light) {
		const key = this.getKey(light);
		const shadowMaps = this.shadowMapCache.get(key);

		if (shadowMaps && shadowMaps.length) {
			return shadowMaps.pop();
		}

		const shadowMap = ShadowMap.create(device, light);
		shadowMap.cached = true;
		return shadowMap;
	}

	add(light, shadowMap) {
		const key = this.getKey(light);
		const shadowMaps = this.shadowMapCache.get(key);

		if (shadowMaps) {
			shadowMaps.push(shadowMap);
		} else {
			this.shadowMapCache.set(key, [shadowMap]);
		}
	}

}

const aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
const _depthRange = {
	min: 0,
	max: 0
};

function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
	aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
	aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
	aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
	aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
	aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
	aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
	let minz = 9999999999;
	let maxz = -9999999999;

	for (let i = 0; i < 8; ++i) {
		cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
		const z = aabbPoints[i].z;
		if (z < minz) minz = z;
		if (z > maxz) maxz = z;
	}

	_depthRange.min = minz;
	_depthRange.max = maxz;
	return _depthRange;
}

function gauss(x, sigma) {
	return Math.exp(-(x * x) / (2.0 * sigma * sigma));
}

const maxBlurSize = 25;

function gaussWeights(kernelSize) {
	if (kernelSize > maxBlurSize) {
		kernelSize = maxBlurSize;
	}

	const sigma = (kernelSize - 1) / (2 * 3);
	const halfWidth = (kernelSize - 1) * 0.5;
	const values = new Array(kernelSize);
	let sum = 0.0;

	for (let i = 0; i < kernelSize; ++i) {
		values[i] = gauss(i - halfWidth, sigma);
		sum += values[i];
	}

	for (let i = 0; i < kernelSize; ++i) {
		values[i] /= sum;
	}

	return values;
}

const visibleSceneAabb = new BoundingBox();
const shadowCamView = new Mat4();
const shadowCamViewProj = new Mat4();
const pixelOffset = new Float32Array(2);
const blurScissorRect = {
	x: 1,
	y: 1,
	z: 0,
	w: 0
};
const opChanId = {
	r: 1,
	g: 2,
	b: 3,
	a: 4
};
const center = new Vec3();
const viewportMatrix = new Mat4();

function getDepthKey(meshInstance) {
	const material = meshInstance.material;
	const x = meshInstance.skinInstance ? 10 : 0;
	let y = 0;

	if (material.opacityMap) {
		const opChan = material.opacityMapChannel;

		if (opChan) {
			y = opChanId[opChan];
		}
	}

	return x + y;
}

class ShadowRenderer {
	constructor(forwardRenderer, lightTextureAtlas) {
		this.device = forwardRenderer.device;
		this.forwardRenderer = forwardRenderer;
		this.lightTextureAtlas = lightTextureAtlas;
		const scope = this.device.scope;
		this.polygonOffsetId = scope.resolve("polygonOffset");
		this.polygonOffset = new Float32Array(2);
		this.sourceId = scope.resolve("source");
		this.pixelOffsetId = scope.resolve("pixelOffset");
		this.weightId = scope.resolve("weight[0]");
		this.blurVsmShaderCode = [shaderChunks.blurVSMPS, "#define GAUSS\n" + shaderChunks.blurVSMPS];
		const packed = "#define PACKED\n";
		this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
		this.blurVsmShader = [{}, {}];
		this.blurPackedVsmShader = [{}, {}];
		this.blurVsmWeights = {};
		this.shadowMapLightRadiusId = scope.resolve('light_radius');
		this.shadowMapCache = new ShadowMapCache();
	}

	destroy() {
		this.shadowMapCache.destroy();
		this.shadowMapCache = null;
	}

	static createShadowCamera(device, shadowType, type, face) {
		const shadowCam = LightCamera.create("ShadowCamera", type, face);

		if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
			shadowCam.clearColor = new Color(0, 0, 0, 0);
		} else {
			shadowCam.clearColor = new Color(1, 1, 1, 1);
		}

		shadowCam.clearDepthBuffer = true;
		shadowCam.clearStencilBuffer = false;
		return shadowCam;
	}

	static setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {
		let hwPcf = shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2;

		if (type === LIGHTTYPE_OMNI && !isClustered) {
			hwPcf = false;
		}

		shadowCam.clearColorBuffer = !hwPcf;
	}

	cullShadowCasters(meshInstances, visible, camera) {
		let count = 0;
		const numInstances = meshInstances.length;

		for (let i = 0; i < numInstances; i++) {
			const meshInstance = meshInstances[i];

			if (!meshInstance.cull || meshInstance._isVisible(camera)) {
				meshInstance.visibleThisFrame = true;
				visible[count] = meshInstance;
				count++;
			}
		}

		visible.length = count;
		visible.sort(this.forwardRenderer.depthSortCompare);
	}

	cullLocal(light, drawCalls) {
		const isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;
		light.visibleThisFrame = true;

		if (!isClustered) {
			if (!light._shadowMap) {
				light._shadowMap = ShadowMap.create(this.device, light);
			}
		}

		const type = light._type;
		const faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;

		for (let face = 0; face < faceCount; face++) {
			const lightRenderData = light.getRenderData(null, face);
			const shadowCam = lightRenderData.shadowCamera;
			shadowCam.nearClip = light.attenuationEnd / 1000;
			shadowCam.farClip = light.attenuationEnd;
			const shadowCamNode = shadowCam._node;
			const lightNode = light._node;
			shadowCamNode.setPosition(lightNode.getPosition());

			if (type === LIGHTTYPE_SPOT) {
				shadowCam.fov = light._outerConeAngle * 2;
				shadowCamNode.setRotation(lightNode.getRotation());
				shadowCamNode.rotateLocal(-90, 0, 0);
			} else if (type === LIGHTTYPE_OMNI) {
				if (isClustered) {
					const tileSize = this.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
					const texelSize = 2 / tileSize;
					const filterSize = texelSize * this.lightTextureAtlas.shadowEdgePixels;
					shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
				} else {
					shadowCam.fov = 90;
				}
			}

			this.forwardRenderer.updateCameraFrustum(shadowCam);
			this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
		}
	}

	generateSplitDistances(light, nearDist, farDist) {
		light._shadowCascadeDistances.fill(farDist);

		for (let i = 1; i < light.numCascades; i++) {
			const fraction = i / light.numCascades;
			const linearDist = nearDist + (farDist - nearDist) * fraction;
			const logDist = nearDist * (farDist / nearDist) ** fraction;
			const dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
			light._shadowCascadeDistances[i - 1] = dist;
		}
	}

	cullDirectional(light, drawCalls, camera) {
		light.visibleThisFrame = true;

		if (!light._shadowMap) {
			light._shadowMap = ShadowMap.create(this.device, light);
		}

		const nearDist = camera._nearClip;
		this.generateSplitDistances(light, nearDist, light.shadowDistance);

		for (let cascade = 0; cascade < light.numCascades; cascade++) {
			const lightRenderData = light.getRenderData(camera, cascade);
			const shadowCam = lightRenderData.shadowCamera;
			shadowCam.renderTarget = light._shadowMap.renderTargets[0];
			lightRenderData.shadowViewport.copy(light.cascades[cascade]);
			lightRenderData.shadowScissor.copy(light.cascades[cascade]);
			const shadowCamNode = shadowCam._node;
			const lightNode = light._node;
			shadowCamNode.setPosition(lightNode.getPosition());
			shadowCamNode.setRotation(lightNode.getRotation());
			shadowCamNode.rotateLocal(-90, 0, 0);
			const frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
			const frustumFarDist = light._shadowCascadeDistances[cascade];
			const frustumPoints = Frustum.getPoints(camera, frustumNearDist, frustumFarDist);
			center.set(0, 0, 0);
			const cameraWorldMat = camera.node.getWorldTransform();

			for (let i = 0; i < 8; i++) {
				cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
				center.add(frustumPoints[i]);
			}

			center.mulScalar(1 / 8);
			let radius = 0;

			for (let i = 0; i < 8; i++) {
				const dist = frustumPoints[i].sub(center).length();
				if (dist > radius) radius = dist;
			}

			const right = shadowCamNode.right;
			const up = shadowCamNode.up;
			const lightDir = shadowCamNode.forward;
			const sizeRatio = 0.25 * light._shadowResolution / radius;
			const x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
			const y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
			const scaledUp = up.mulScalar(x);
			const scaledRight = right.mulScalar(y);
			const dot = center.dot(lightDir);
			const scaledDir = lightDir.mulScalar(dot);
			center.add2(scaledUp, scaledRight).add(scaledDir);
			shadowCamNode.setPosition(center);
			shadowCamNode.translateLocal(0, 0, 1000000);
			shadowCam.nearClip = 0;
			shadowCam.farClip = 2000000;
			shadowCam.orthoHeight = radius;
			this.forwardRenderer.updateCameraFrustum(shadowCam);
			this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
			let emptyAabb = true;
			const visibleCasters = lightRenderData.visibleCasters;

			for (let i = 0; i < visibleCasters.length; i++) {
				const meshInstance = visibleCasters[i];

				if (emptyAabb) {
					emptyAabb = false;
					visibleSceneAabb.copy(meshInstance.aabb);
				} else {
					visibleSceneAabb.add(meshInstance.aabb);
				}
			}

			shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();
			const depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
			shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
			shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
		}
	}

	setupRenderState(device, light) {
		const isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

		if (device.webgl2) {
			if (light._type === LIGHTTYPE_OMNI && !isClustered) {
				device.setDepthBias(false);
			} else {
				device.setDepthBias(true);
				device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
			}
		} else if (device.extStandardDerivatives) {
			if (light._type === LIGHTTYPE_OMNI) {
				this.polygonOffset[0] = 0;
				this.polygonOffset[1] = 0;
				this.polygonOffsetId.setValue(this.polygonOffset);
			} else {
				this.polygonOffset[0] = light.shadowBias * -1000.0;
				this.polygonOffset[1] = light.shadowBias * -1000.0;
				this.polygonOffsetId.setValue(this.polygonOffset);
			}
		}

		device.setBlending(false);
		device.setDepthWrite(true);
		device.setDepthTest(true);
		device.setDepthFunc(FUNC_LESSEQUAL);
		const useShadowSampler = isClustered ? light._isPcf && device.webgl2 : light._isPcf && device.webgl2 && light._type !== LIGHTTYPE_OMNI;

		if (useShadowSampler) {
			device.setColorWrite(false, false, false, false);
		} else {
			device.setColorWrite(true, true, true, true);
		}
	}

	restoreRenderState(device) {
		if (device.webgl2) {
			device.setDepthBias(false);
		} else if (device.extStandardDerivatives) {
			this.polygonOffset[0] = 0;
			this.polygonOffset[1] = 0;
			this.polygonOffsetId.setValue(this.polygonOffset);
		}
	}

	dispatchUniforms(light, shadowCam, lightRenderData, face) {
		const shadowCamNode = shadowCam._node;

		if (light._type !== LIGHTTYPE_DIRECTIONAL) {
			this.forwardRenderer.dispatchViewPos(shadowCamNode.getPosition());
			this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
		}

		shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
		shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
		const rectViewport = lightRenderData.shadowViewport;
		shadowCam.rect = rectViewport;
		shadowCam.scissorRect = lightRenderData.shadowScissor;
		viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
		lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);

		if (light._type === LIGHTTYPE_DIRECTIONAL) {
			light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
		}
	}

	submitCasters(visibleCasters, light) {
		const device = this.device;
		const forwardRenderer = this.forwardRenderer;
		const shadowPass = 1 << SHADER_SHADOW;
		const shadowType = light._shadowType;
		const smode = shadowType + light._type * SHADOW_COUNT;
		const count = visibleCasters.length;

		for (let i = 0; i < count; i++) {
			const meshInstance = visibleCasters[i];
			const mesh = meshInstance.mesh;
			const material = meshInstance.material;
			forwardRenderer.setBaseConstants(device, material);
			forwardRenderer.setSkinning(device, meshInstance, material);

			if (material.dirty) {
				material.updateUniforms(device, forwardRenderer.scene);
				material.dirty = false;
			}

			if (material.chunks) {
				forwardRenderer.setCullMode(true, false, meshInstance);
				material.setParameters(device);
				meshInstance.setParameters(device, shadowPass);
			}

			let shadowShader = meshInstance._shader[SHADER_SHADOW + smode];

			if (!shadowShader) {
				forwardRenderer.updateShader(meshInstance, meshInstance._shaderDefs, null, SHADER_SHADOW + smode);
				shadowShader = meshInstance._shader[SHADER_SHADOW + smode];
				meshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);
			}

			device.setShader(shadowShader);
			forwardRenderer.setVertexBuffers(device, mesh);
			forwardRenderer.setMorphing(device, meshInstance.morphInstance);
			const style = meshInstance.renderStyle;
			device.setIndexBuffer(mesh.indexBuffer[style]);
			i += forwardRenderer.drawInstance(device, meshInstance, mesh, style);
			forwardRenderer._shadowDrawCalls++;
		}
	}

	render(light, camera) {
		if (light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {
			const device = this.device;

			if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
				light.shadowUpdateMode = SHADOWUPDATE_NONE;
			}

			const type = light._type;
			const shadowType = light._shadowType;
			const faceCount = light.numShadowFaces;
			const forwardRenderer = this.forwardRenderer;
			forwardRenderer._shadowMapUpdates += faceCount;
			const isClustered = forwardRenderer.scene.clusteredLightingEnabled;
			this.setupRenderState(device, light);

			for (let face = 0; face < faceCount; face++) {
				const lightRenderData = light.getRenderData(type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
				const shadowCam = lightRenderData.shadowCamera;
				ShadowRenderer.setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered);
				const renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
				shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
				this.dispatchUniforms(light, shadowCam, lightRenderData, face);
				forwardRenderer.setCamera(shadowCam, shadowCam.renderTarget, true);
				this.submitCasters(lightRenderData.visibleCasters, light);
			}

			if (light._isVsm && light._vsmBlurSize > 1) {
				const _isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

				if (!_isClustered || type === LIGHTTYPE_DIRECTIONAL) {
					this.applyVsmBlur(light, camera);
				}
			}

			this.restoreRenderState(device);
		}
	}

	getVsmBlurShader(isVsm8, blurMode, filterSize) {
		let blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];

		if (!blurShader) {
			this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
			const blurVS = shaderChunks.fullscreenQuadVS;
			let blurFS = "#define SAMPLES " + filterSize + "\n";

			if (isVsm8) {
				blurFS += this.blurPackedVsmShaderCode[blurMode];
			} else {
				blurFS += this.blurVsmShaderCode[blurMode];
			}

			const blurShaderName = "blurVsm" + blurMode + "" + filterSize + "" + isVsm8;
			blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);

			if (isVsm8) {
				this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
			} else {
				this.blurVsmShader[blurMode][filterSize] = blurShader;
			}
		}

		return blurShader;
	}

	applyVsmBlur(light, camera) {
		const device = this.device;
		const lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
		const shadowCam = lightRenderData.shadowCamera;
		const origShadowMap = shadowCam.renderTarget;
		const tempShadowMap = this.shadowMapCache.get(device, light);
		const tempRt = tempShadowMap.renderTargets[0];
		const isVsm8 = light._shadowType === SHADOW_VSM8;
		const blurMode = light.vsmBlurMode;
		const filterSize = light._vsmBlurSize;
		const blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);
		blurScissorRect.z = light._shadowResolution - 2;
		blurScissorRect.w = blurScissorRect.z;
		this.sourceId.setValue(origShadowMap.colorBuffer);
		pixelOffset[0] = 1 / light._shadowResolution;
		pixelOffset[1] = 0;
		this.pixelOffsetId.setValue(pixelOffset);
		if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
		drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
		this.sourceId.setValue(tempRt.colorBuffer);
		pixelOffset[1] = pixelOffset[0];
		pixelOffset[0] = 0;
		this.pixelOffsetId.setValue(pixelOffset);
		drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
		this.shadowMapCache.add(light, tempShadowMap);
	}

}

const tempSphere$2 = new BoundingSphere();

class StaticMeshes {
	static lightCompare(lightA, lightB) {
		return lightA.key - lightB.key;
	}

	static prepare(device, scene, meshInstances, lights) {
		const drawCalls = meshInstances;
		const drawCallsCount = drawCalls.length;
		const newDrawCalls = [];
		const minVec = new Vec3();
		const maxVec = new Vec3();
		const localLightBounds = new BoundingBox();
		const invMatrix = new Mat4();
		const triLightComb = [];
		const lightAabb = [];
		const triBounds = [];
		const staticLights = [];

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];

			if (!drawCall.isStatic) {
				newDrawCalls.push(drawCall);
			} else {
				const aabb = drawCall.aabb;
				staticLights.length = 0;

				for (let lightTypePass = LIGHTTYPE_OMNI; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {
					for (let j = 0; j < lights.length; j++) {
						const light = lights[j];
						if (light._type !== lightTypePass) continue;

						if (light.enabled) {
							if (light.mask & drawCall.mask) {
								if (light.isStatic) {
									if (!lightAabb[j]) {
										lightAabb[j] = new BoundingBox();

										light._node.getWorldTransform();

										light.getBoundingSphere(tempSphere$2);
										lightAabb[j].center.copy(tempSphere$2.center);
										lightAabb[j].halfExtents.set(tempSphere$2.radius, tempSphere$2.radius, tempSphere$2.radius);
									}

									if (!lightAabb[j].intersects(aabb)) continue;
									staticLights.push(j);
								}
							}
						}
					}
				}

				if (staticLights.length === 0) {
					newDrawCalls.push(drawCall);
					continue;
				}

				const mesh = drawCall.mesh;
				const vertexBuffer = mesh.vertexBuffer;
				const indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
				const indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
				const numTris = mesh.primitive[drawCall.renderStyle].count / 3;
				const baseIndex = mesh.primitive[drawCall.renderStyle].base;
				const elems = vertexBuffer.format.elements;
				const vertSize = vertexBuffer.format.size / 4;
				const verts = new Float32Array(vertexBuffer.storage);
				let offsetP;

				for (let k = 0; k < elems.length; k++) {
					if (elems[k].name === SEMANTIC_POSITION) {
						offsetP = elems[k].offset / 4;
					}
				}

				triLightComb.length = numTris;

				for (let k = 0; k < numTris; k++) {
					triLightComb[k] = 0;
				}

				let triLightCombUsed = false;
				triBounds.length = numTris * 6;

				for (let k = 0; k < numTris; k++) {
					let minx = Number.MAX_VALUE;
					let miny = Number.MAX_VALUE;
					let minz = Number.MAX_VALUE;
					let maxx = -Number.MAX_VALUE;
					let maxy = -Number.MAX_VALUE;
					let maxz = -Number.MAX_VALUE;

					for (let v = 0; v < 3; v++) {
						let _index = indices[k * 3 + v + baseIndex];
						_index = _index * vertSize + offsetP;
						const _x = verts[_index];
						const _y = verts[_index + 1];
						const _z = verts[_index + 2];
						if (_x < minx) minx = _x;
						if (_y < miny) miny = _y;
						if (_z < minz) minz = _z;
						if (_x > maxx) maxx = _x;
						if (_y > maxy) maxy = _y;
						if (_z > maxz) maxz = _z;
					}

					const index = k * 6;
					triBounds[index] = minx;
					triBounds[index + 1] = miny;
					triBounds[index + 2] = minz;
					triBounds[index + 3] = maxx;
					triBounds[index + 4] = maxy;
					triBounds[index + 5] = maxz;
				}

				for (let s = 0; s < staticLights.length; s++) {
					const j = staticLights[s];
					invMatrix.copy(drawCall.node.worldTransform).invert();
					localLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);
					const minv = localLightBounds.getMin();
					const maxv = localLightBounds.getMax();
					const bit = 1 << s;

					for (let k = 0; k < numTris; k++) {
						const index = k * 6;

						if (triBounds[index] <= maxv.x && triBounds[index + 3] >= minv.x && triBounds[index + 1] <= maxv.y && triBounds[index + 4] >= minv.y && triBounds[index + 2] <= maxv.z && triBounds[index + 5] >= minv.z) {
							triLightComb[k] |= bit;
							triLightCombUsed = true;
						}
					}
				}

				if (triLightCombUsed) {
					const combIndices = {};

					for (let k = 0; k < numTris; k++) {
						const j = k * 3 + baseIndex;
						const combIbName = triLightComb[k];
						if (!combIndices[combIbName]) combIndices[combIbName] = [];
						const combIb = combIndices[combIbName];
						combIb.push(indices[j]);
						combIb.push(indices[j + 1]);
						combIb.push(indices[j + 2]);
					}

					for (const combIbName in combIndices) {
						const combIb = combIndices[combIbName];
						const ib = new IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);
						const ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
						ib2.set(combIb);
						ib.unlock();
						let minx = Number.MAX_VALUE;
						let miny = Number.MAX_VALUE;
						let minz = Number.MAX_VALUE;
						let maxx = -Number.MAX_VALUE;
						let maxy = -Number.MAX_VALUE;
						let maxz = -Number.MAX_VALUE;

						for (let k = 0; k < combIb.length; k++) {
							const index = combIb[k];
							const _x = verts[index * vertSize + offsetP];
							const _y = verts[index * vertSize + offsetP + 1];
							const _z = verts[index * vertSize + offsetP + 2];
							if (_x < minx) minx = _x;
							if (_y < miny) miny = _y;
							if (_z < minz) minz = _z;
							if (_x > maxx) maxx = _x;
							if (_y > maxy) maxy = _y;
							if (_z > maxz) maxz = _z;
						}

						minVec.set(minx, miny, minz);
						maxVec.set(maxx, maxy, maxz);
						const chunkAabb = new BoundingBox();
						chunkAabb.setMinMax(minVec, maxVec);
						const mesh2 = new Mesh(device);
						mesh2.vertexBuffer = vertexBuffer;
						mesh2.indexBuffer[0] = ib;
						mesh2.primitive[0].type = PRIMITIVE_TRIANGLES;
						mesh2.primitive[0].base = 0;
						mesh2.primitive[0].count = combIb.length;
						mesh2.primitive[0].indexed = true;
						mesh2.aabb = chunkAabb;
						const instance = new MeshInstance(mesh2, drawCall.material, drawCall.node);
						instance.isStatic = drawCall.isStatic;
						instance.visible = drawCall.visible;
						instance.layer = drawCall.layer;
						instance.castShadow = drawCall.castShadow;
						instance._receiveShadow = drawCall._receiveShadow;
						instance.cull = drawCall.cull;
						instance.pick = drawCall.pick;
						instance.mask = drawCall.mask;
						instance.parameters = drawCall.parameters;
						instance._shaderDefs = drawCall._shaderDefs;
						instance._staticSource = drawCall;

						if (drawCall._staticLightList) {
							instance._staticLightList = drawCall._staticLightList;
						} else {
							instance._staticLightList = [];
						}

						for (let k = 0; k < staticLights.length; k++) {
							const bit = 1 << k;

							if (combIbName & bit) {
								const lht = lights[staticLights[k]];

								if (instance._staticLightList.indexOf(lht) < 0) {
									instance._staticLightList.push(lht);
								}
							}
						}

						instance._staticLightList.sort(StaticMeshes.lightCompare);

						newDrawCalls.push(instance);
					}
				} else {
					newDrawCalls.push(drawCall);
				}
			}
		}

		meshInstances.length = newDrawCalls.length;

		for (let i = 0; i < newDrawCalls.length; i++) {
			meshInstances[i] = newDrawCalls[i];
		}
	}

	static revert(meshInstances) {
		const drawCalls = meshInstances;
		const drawCallsCount = drawCalls.length;
		const newDrawCalls = [];
		let prevStaticSource;

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];

			if (drawCall._staticSource) {
				if (drawCall._staticSource !== prevStaticSource) {
					newDrawCalls.push(drawCall._staticSource);
					prevStaticSource = drawCall._staticSource;
				}
			} else {
				newDrawCalls.push(drawCall);
			}
		}

		meshInstances.length = newDrawCalls.length;

		for (let i = 0; i < newDrawCalls.length; i++) {
			meshInstances[i] = newDrawCalls[i];
		}
	}

}

new Vec3(1, 1, 1);
new Vec3(40, 0, 0);

const viewInvMat = new Mat4();
const viewMat = new Mat4();
const viewMat3 = new Mat3();
const viewProjMat = new Mat4();
let projMat;
const flipYMat = new Mat4().setScale(1, -1, 1);
const flippedViewProjMat = new Mat4();
const flippedSkyboxProjMat = new Mat4();
const viewInvL = new Mat4();
const viewInvR = new Mat4();
const viewL = new Mat4();
const viewR = new Mat4();
const viewPosL = new Vec3();
const viewPosR = new Vec3();
let projL, projR;
const viewMat3L = new Mat3();
const viewMat3R = new Mat3();
const viewProjMatL = new Mat4();
const viewProjMatR = new Mat4();
const worldMatX = new Vec3();
const worldMatY = new Vec3();
const worldMatZ = new Vec3();
const tempSphere$1 = new BoundingSphere();
const boneTextureSize = [0, 0, 0, 0];
let boneTexture, instancingData, modelMatrix, normalMatrix;
let keyA$1, keyB$1;
let _autoInstanceBuffer = null;
let _skinUpdateIndex = 0;
const _drawCallList = {
	drawCalls: [],
	isNewMaterial: [],
	lightMaskChanged: []
};

const _tempMaterialSet = new Set();

class ForwardRenderer {
	constructor(graphicsDevice) {
		this.device = graphicsDevice;
		this.scene = null;
		this._shadowDrawCalls = 0;
		this._forwardDrawCalls = 0;
		this._skinDrawCalls = 0;
		this._numDrawCallsCulled = 0;
		this._instancedDrawCalls = 0;
		this._camerasRendered = 0;
		this._materialSwitches = 0;
		this._shadowMapUpdates = 0;
		this._shadowMapTime = 0;
		this._depthMapTime = 0;
		this._forwardTime = 0;
		this._cullTime = 0;
		this._sortTime = 0;
		this._skinTime = 0;
		this._morphTime = 0;
		this._instancingTime = 0;
		this._removedByInstancing = 0;
		this._layerCompositionUpdateTime = 0;
		this._lightClustersTime = 0;
		this._lightClusters = 0;
		const device = this.device;
		const library = device.getProgramLibrary();
		this.library = library;
		this.lightTextureAtlas = new LightTextureAtlas(device);
		this._shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
		this._cookieRenderer = new CookieRenderer(device, this.lightTextureAtlas);
		const scope = device.scope;
		this.projId = scope.resolve('matrix_projection');
		this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
		this.viewId = scope.resolve('matrix_view');
		this.viewId3 = scope.resolve('matrix_view3');
		this.viewInvId = scope.resolve('matrix_viewInverse');
		this.viewProjId = scope.resolve('matrix_viewProjection');
		this.viewPos = new Float32Array(3);
		this.viewPosId = scope.resolve('view_position');
		this.nearClipId = scope.resolve('camera_near');
		this.farClipId = scope.resolve('camera_far');
		this.cameraParamsId = scope.resolve('camera_params');
		this.tbnBasis = scope.resolve('tbnBasis');
		this.fogColorId = scope.resolve('fog_color');
		this.fogStartId = scope.resolve('fog_start');
		this.fogEndId = scope.resolve('fog_end');
		this.fogDensityId = scope.resolve('fog_density');
		this.modelMatrixId = scope.resolve('matrix_model');
		this.normalMatrixId = scope.resolve('matrix_normal');
		this.poseMatrixId = scope.resolve('matrix_pose[0]');
		this.boneTextureId = scope.resolve('texture_poseMap');
		this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
		this.morphWeightsA = scope.resolve('morph_weights_a');
		this.morphWeightsB = scope.resolve('morph_weights_b');
		this.morphPositionTex = scope.resolve('morphPositionTex');
		this.morphNormalTex = scope.resolve('morphNormalTex');
		this.morphTexParams = scope.resolve('morph_tex_params');
		this.alphaTestId = scope.resolve('alpha_ref');
		this.opacityMapId = scope.resolve('texture_opacityMap');
		this.ambientId = scope.resolve("light_globalAmbient");
		this.exposureId = scope.resolve("exposure");
		this.skyboxIntensityId = scope.resolve("skyboxIntensity");
		this.lightColorId = [];
		this.lightDir = [];
		this.lightDirId = [];
		this.lightShadowMapId = [];
		this.lightShadowMatrixId = [];
		this.lightShadowParamsId = [];
		this.lightRadiusId = [];
		this.lightPos = [];
		this.lightPosId = [];
		this.lightWidth = [];
		this.lightWidthId = [];
		this.lightHeight = [];
		this.lightHeightId = [];
		this.lightInAngleId = [];
		this.lightOutAngleId = [];
		this.lightCookieId = [];
		this.lightCookieIntId = [];
		this.lightCookieMatrixId = [];
		this.lightCookieOffsetId = [];
		this.shadowMatrixPaletteId = [];
		this.shadowCascadeDistancesId = [];
		this.shadowCascadeCountId = [];
		this.depthMapId = scope.resolve('uDepthMap');
		this.screenSizeId = scope.resolve('uScreenSize');
		this._screenSize = new Float32Array(4);
		this.twoSidedLightingNegScaleFactorId = scope.resolve("twoSidedLightingNegScaleFactor");
		this.fogColor = new Float32Array(3);
		this.ambientColor = new Float32Array(3);
		this.cameraParams = new Float32Array(4);
	}

	destroy() {
		this._shadowRenderer.destroy();

		this._shadowRenderer = null;

		this._cookieRenderer.destroy();

		this._cookieRenderer = null;
		this.lightTextureAtlas.destroy();
		this.lightTextureAtlas = null;
	}

	sortCompare(drawCallA, drawCallB) {
		if (drawCallA.layer === drawCallB.layer) {
			if (drawCallA.drawOrder && drawCallB.drawOrder) {
				return drawCallA.drawOrder - drawCallB.drawOrder;
			} else if (drawCallA.zdist && drawCallB.zdist) {
				return drawCallB.zdist - drawCallA.zdist;
			} else if (drawCallA.zdist2 && drawCallB.zdist2) {
				return drawCallA.zdist2 - drawCallB.zdist2;
			}
		}

		return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
	}

	sortCompareMesh(drawCallA, drawCallB) {
		if (drawCallA.layer === drawCallB.layer) {
			if (drawCallA.drawOrder && drawCallB.drawOrder) {
				return drawCallA.drawOrder - drawCallB.drawOrder;
			} else if (drawCallA.zdist && drawCallB.zdist) {
				return drawCallB.zdist - drawCallA.zdist;
			}
		}

		keyA$1 = drawCallA._key[SORTKEY_FORWARD];
		keyB$1 = drawCallB._key[SORTKEY_FORWARD];

		if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}

		return keyB$1 - keyA$1;
	}

	depthSortCompare(drawCallA, drawCallB) {
		keyA$1 = drawCallA._key[SORTKEY_DEPTH];
		keyB$1 = drawCallB._key[SORTKEY_DEPTH];

		if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}

		return keyB$1 - keyA$1;
	}

	updateCameraFrustum(camera) {
		if (camera.vrDisplay && camera.vrDisplay.presenting) {
			projMat = camera.vrDisplay.combinedProj;
			const parent = camera._node.parent;

			if (parent) {
				viewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();
			} else {
				viewMat.copy(camera.vrDisplay.combinedView);
			}

			viewInvMat.copy(viewMat).invert();
			this.viewInvId.setValue(viewInvMat.data);
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		} else if (camera.xr && camera.xr.views.length) {
			const view = camera.xr.views[0];
			viewProjMat.mul2(view.projMat, view.viewOffMat);
			camera.frustum.setFromMat4(viewProjMat);
			return;
		}

		projMat = camera.projectionMatrix;

		if (camera.calculateProjection) {
			camera.calculateProjection(projMat, VIEW_CENTER);
		}

		if (camera.calculateTransform) {
			camera.calculateTransform(viewInvMat, VIEW_CENTER);
		} else {
			const pos = camera._node.getPosition();

			const rot = camera._node.getRotation();

			viewInvMat.setTRS(pos, rot, Vec3.ONE);
			this.viewInvId.setValue(viewInvMat.data);
		}

		viewMat.copy(viewInvMat).invert();
		viewProjMat.mul2(projMat, viewMat);
		camera.frustum.setFromMat4(viewProjMat);
	}

	setCamera(camera, target, clear) {
		const vrDisplay = camera.vrDisplay;
		let transform;

		if (vrDisplay && vrDisplay.presenting) {
			projL = vrDisplay.leftProj;
			projR = vrDisplay.rightProj;
			projMat = vrDisplay.combinedProj;

			if (camera.calculateProjection) {
				camera.calculateProjection(projL, VIEW_LEFT);
				camera.calculateProjection(projR, VIEW_RIGHT);
				camera.calculateProjection(projMat, VIEW_CENTER);
			}

			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvL, VIEW_LEFT);
				camera.calculateTransform(viewInvR, VIEW_RIGHT);
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
				viewL.copy(viewInvL).invert();
				viewR.copy(viewInvR).invert();
				viewMat.copy(viewInvMat).invert();
			} else {
				const parent = camera._node.parent;

				if (parent) {
					transform = parent.getWorldTransform();
					viewInvL.mul2(transform, vrDisplay.leftViewInv);
					viewInvR.mul2(transform, vrDisplay.rightViewInv);
					viewL.copy(viewInvL).invert();
					viewR.copy(viewInvR).invert();
					viewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();
				} else {
					viewInvL.copy(vrDisplay.leftViewInv);
					viewInvR.copy(vrDisplay.rightViewInv);
					viewL.copy(vrDisplay.leftView);
					viewR.copy(vrDisplay.rightView);
					viewMat.copy(vrDisplay.combinedView);
				}
			}

			viewMat3L.setFromMat4(viewL);
			viewMat3R.setFromMat4(viewR);
			viewProjMatL.mul2(projL, viewL);
			viewProjMatR.mul2(projR, viewR);
			viewPosL.x = viewInvL.data[12];
			viewPosL.y = viewInvL.data[13];
			viewPosL.z = viewInvL.data[14];
			viewPosR.x = viewInvR.data[12];
			viewPosR.y = viewInvR.data[13];
			viewPosR.z = viewInvR.data[14];
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		} else if (camera.xr && camera.xr.session) {
			const parent = camera._node.parent;
			if (parent) transform = parent.getWorldTransform();
			const views = camera.xr.views;

			for (let v = 0; v < views.length; v++) {
				const view = views[v];

				if (parent) {
					view.viewInvOffMat.mul2(transform, view.viewInvMat);
					view.viewOffMat.copy(view.viewInvOffMat).invert();
				} else {
					view.viewInvOffMat.copy(view.viewInvMat);
					view.viewOffMat.copy(view.viewMat);
				}

				view.viewMat3.setFromMat4(view.viewOffMat);
				view.projViewOffMat.mul2(view.projMat, view.viewOffMat);
				view.position[0] = view.viewInvOffMat.data[12];
				view.position[1] = view.viewInvOffMat.data[13];
				view.position[2] = view.viewInvOffMat.data[14];
				camera.frustum.setFromMat4(view.projViewOffMat);
			}
		} else {
			projMat = camera.projectionMatrix;

			if (camera.calculateProjection) {
				camera.calculateProjection(projMat, VIEW_CENTER);
			}

			this.projId.setValue(projMat.data);
			this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);

			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
			} else {
				const pos = camera._node.getPosition();

				const rot = camera._node.getRotation();

				viewInvMat.setTRS(pos, rot, Vec3.ONE);
			}

			this.viewInvId.setValue(viewInvMat.data);
			viewMat.copy(viewInvMat).invert();
			this.viewId.setValue(viewMat.data);
			viewMat3.setFromMat4(viewMat);
			this.viewId3.setValue(viewMat3.data);
			viewProjMat.mul2(projMat, viewMat);

			if (target && target.flipY) {
				flippedViewProjMat.mul2(flipYMat, viewProjMat);
				flippedSkyboxProjMat.mul2(flipYMat, camera.getProjectionMatrixSkybox());
				this.viewProjId.setValue(flippedViewProjMat.data);
				this.projSkyboxId.setValue(flippedSkyboxProjMat.data);
			} else {
				this.viewProjId.setValue(viewProjMat.data);
				this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);
			}

			this.dispatchViewPos(camera._node.getPosition());
			camera.frustum.setFromMat4(viewProjMat);
		}

		this.tbnBasis.setValue(target && target.flipY ? -1 : 1);
		this.nearClipId.setValue(camera._nearClip);
		this.farClipId.setValue(camera._farClip);
		const n = camera._nearClip;
		const f = camera._farClip;
		this.cameraParams[0] = 1 / f;
		this.cameraParams[1] = f;
		this.cameraParams[2] = (1 - f / n) * 0.5;
		this.cameraParams[3] = (1 + f / n) * 0.5;
		this.cameraParamsId.setValue(this.cameraParams);
		this.clearView(camera, target, clear, false);
	}

	clearView(camera, target, clear, forceWrite, options) {
		const device = this.device;
		device.setRenderTarget(target);
		device.updateBegin();

		if (forceWrite) {
			device.setColorWrite(true, true, true, true);
			device.setDepthWrite(true);
		}

		const pixelWidth = target ? target.width : device.width;
		const pixelHeight = target ? target.height : device.height;
		const rect = camera.rect;
		let x = Math.floor(rect.x * pixelWidth);
		let y = Math.floor(rect.y * pixelHeight);
		let w = Math.floor(rect.z * pixelWidth);
		let h = Math.floor(rect.w * pixelHeight);
		device.setViewport(x, y, w, h);

		if (camera._scissorRectClear) {
			const scissorRect = camera.scissorRect;
			x = Math.floor(scissorRect.x * pixelWidth);
			y = Math.floor(scissorRect.y * pixelHeight);
			w = Math.floor(scissorRect.z * pixelWidth);
			h = Math.floor(scissorRect.w * pixelHeight);
		}

		device.setScissor(x, y, w, h);

		if (clear) {
			if (!options) options = camera._clearOptions;
			device.clear(options ? options : {
				color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
				depth: camera._clearDepth,
				flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
				stencil: camera._clearStencil
			});
		}
	}

	dispatchGlobalLights(scene) {
		this.ambientColor[0] = scene.ambientLight.r;
		this.ambientColor[1] = scene.ambientLight.g;
		this.ambientColor[2] = scene.ambientLight.b;

		if (scene.gammaCorrection) {
			for (let i = 0; i < 3; i++) {
				this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
			}
		}

		this.ambientId.setValue(this.ambientColor);
		this.exposureId.setValue(scene.exposure);
		if (scene.skyboxModel) this.skyboxIntensityId.setValue(scene.skyboxIntensity);
	}

	_resolveLight(scope, i) {
		const light = "light" + i;
		this.lightColorId[i] = scope.resolve(light + "_color");
		this.lightDir[i] = new Float32Array(3);
		this.lightDirId[i] = scope.resolve(light + "_direction");
		this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
		this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
		this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
		this.lightRadiusId[i] = scope.resolve(light + "_radius");
		this.lightPos[i] = new Float32Array(3);
		this.lightPosId[i] = scope.resolve(light + "_position");
		this.lightWidth[i] = new Float32Array(3);
		this.lightWidthId[i] = scope.resolve(light + "_halfWidth");
		this.lightHeight[i] = new Float32Array(3);
		this.lightHeightId[i] = scope.resolve(light + "_halfHeight");
		this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
		this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
		this.lightCookieId[i] = scope.resolve(light + "_cookie");
		this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
		this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
		this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
		this.shadowMatrixPaletteId[i] = scope.resolve(light + "_shadowMatrixPalette[0]");
		this.shadowCascadeDistancesId[i] = scope.resolve(light + "_shadowCascadeDistances[0]");
		this.shadowCascadeCountId[i] = scope.resolve(light + "_shadowCascadeCount");
	}

	setLTCDirectionallLight(wtm, cnt, dir, campos, far) {
		this.lightPos[cnt][0] = campos.x - dir.x * far;
		this.lightPos[cnt][1] = campos.y - dir.y * far;
		this.lightPos[cnt][2] = campos.z - dir.z * far;
		this.lightPosId[cnt].setValue(this.lightPos[cnt]);
		const hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
		this.lightWidth[cnt][0] = hWidth.x * far;
		this.lightWidth[cnt][1] = hWidth.y * far;
		this.lightWidth[cnt][2] = hWidth.z * far;
		this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
		const hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
		this.lightHeight[cnt][0] = hHeight.x * far;
		this.lightHeight[cnt][1] = hHeight.y * far;
		this.lightHeight[cnt][2] = hHeight.z * far;
		this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
	}

	dispatchDirectLights(dirs, scene, mask, camera) {
		let cnt = 0;
		const scope = this.device.scope;

		for (let i = 0; i < dirs.length; i++) {
			if (!(dirs[i].mask & mask)) continue;
			const directional = dirs[i];

			const wtm = directional._node.getWorldTransform();

			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}

			this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);
			wtm.getY(directional._direction).mulScalar(-1);

			directional._direction.normalize();

			this.lightDir[cnt][0] = directional._direction.x;
			this.lightDir[cnt][1] = directional._direction.y;
			this.lightDir[cnt][2] = directional._direction.z;
			this.lightDirId[cnt].setValue(this.lightDir[cnt]);

			if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCDirectionallLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
			}

			if (directional.castShadows) {
				const lightRenderData = directional.getRenderData(camera, 0);

				const biases = directional._getUniformBiasValues(lightRenderData);

				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
				this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
				this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
				this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
				this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
				const params = directional._shadowRenderParams;
				params.length = 3;
				params[0] = directional._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				this.lightShadowParamsId[cnt].setValue(params);
			}

			cnt++;
		}

		return cnt;
	}

	setLTCPositionalLight(wtm, cnt) {
		const hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
		this.lightWidth[cnt][0] = hWidth.x;
		this.lightWidth[cnt][1] = hWidth.y;
		this.lightWidth[cnt][2] = hWidth.z;
		this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
		const hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
		this.lightHeight[cnt][0] = hHeight.x;
		this.lightHeight[cnt][1] = hHeight.y;
		this.lightHeight[cnt][2] = hHeight.z;
		this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
	}

	dispatchOmniLight(scene, scope, omni, cnt) {
		const wtm = omni._node.getWorldTransform();

		if (!this.lightColorId[cnt]) {
			this._resolveLight(scope, cnt);
		}

		this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
		this.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);
		wtm.getTranslation(omni._position);
		this.lightPos[cnt][0] = omni._position.x;
		this.lightPos[cnt][1] = omni._position.y;
		this.lightPos[cnt][2] = omni._position.z;
		this.lightPosId[cnt].setValue(this.lightPos[cnt]);

		if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
			this.setLTCPositionalLight(wtm, cnt);
		}

		if (omni.castShadows) {
			const lightRenderData = omni.getRenderData(null, 0);
			this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);

			const biases = omni._getUniformBiasValues(lightRenderData);

			const params = omni._shadowRenderParams;
			params.length = 4;
			params[0] = omni._shadowResolution;
			params[1] = biases.normalBias;
			params[2] = biases.bias;
			params[3] = 1.0 / omni.attenuationEnd;
			this.lightShadowParamsId[cnt].setValue(params);
		}

		if (omni._cookie) {
			this.lightCookieId[cnt].setValue(omni._cookie);
			this.lightShadowMatrixId[cnt].setValue(wtm.data);
			this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
		}
	}

	dispatchSpotLight(scene, scope, spot, cnt) {
		const wtm = spot._node.getWorldTransform();

		if (!this.lightColorId[cnt]) {
			this._resolveLight(scope, cnt);
		}

		this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
		this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
		this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
		this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
		wtm.getTranslation(spot._position);
		this.lightPos[cnt][0] = spot._position.x;
		this.lightPos[cnt][1] = spot._position.y;
		this.lightPos[cnt][2] = spot._position.z;
		this.lightPosId[cnt].setValue(this.lightPos[cnt]);

		if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
			this.setLTCPositionalLight(wtm, cnt);
		}

		wtm.getY(spot._direction).mulScalar(-1);

		spot._direction.normalize();

		this.lightDir[cnt][0] = spot._direction.x;
		this.lightDir[cnt][1] = spot._direction.y;
		this.lightDir[cnt][2] = spot._direction.z;
		this.lightDirId[cnt].setValue(this.lightDir[cnt]);

		if (spot.castShadows) {
			const lightRenderData = spot.getRenderData(null, 0);
			this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
			this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);

			const biases = spot._getUniformBiasValues(lightRenderData);

			const params = spot._shadowRenderParams;
			params.length = 4;
			params[0] = spot._shadowResolution;
			params[1] = biases.normalBias;
			params[2] = biases.bias;
			params[3] = 1.0 / spot.attenuationEnd;
			this.lightShadowParamsId[cnt].setValue(params);
		}

		if (spot._cookie) {
			if (!spot.castShadows) {
				const cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
				this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
			}

			this.lightCookieId[cnt].setValue(spot._cookie);
			this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);

			if (spot._cookieTransform) {
				spot._cookieTransformUniform[0] = spot._cookieTransform.x;
				spot._cookieTransformUniform[1] = spot._cookieTransform.y;
				spot._cookieTransformUniform[2] = spot._cookieTransform.z;
				spot._cookieTransformUniform[3] = spot._cookieTransform.w;
				this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
				spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
				spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
				this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
			}
		}
	}

	dispatchLocalLights(sortedLights, scene, mask, usedDirLights, staticLightList) {
		let cnt = usedDirLights;
		const scope = this.device.scope;
		const omnis = sortedLights[LIGHTTYPE_OMNI];
		const numOmnis = omnis.length;

		for (let i = 0; i < numOmnis; i++) {
			const omni = omnis[i];
			if (!(omni.mask & mask)) continue;
			if (omni.isStatic) continue;
			this.dispatchOmniLight(scene, scope, omni, cnt);
			cnt++;
		}

		let staticId = 0;

		if (staticLightList) {
			let omni = staticLightList[staticId];

			while (omni && omni._type === LIGHTTYPE_OMNI) {
				this.dispatchOmniLight(scene, scope, omni, cnt);
				cnt++;
				staticId++;
				omni = staticLightList[staticId];
			}
		}

		const spts = sortedLights[LIGHTTYPE_SPOT];
		const numSpts = spts.length;

		for (let i = 0; i < numSpts; i++) {
			const spot = spts[i];
			if (!(spot.mask & mask)) continue;
			if (spot.isStatic) continue;
			this.dispatchSpotLight(scene, scope, spot, cnt);
			cnt++;
		}

		if (staticLightList) {
			let spot = staticLightList[staticId];

			while (spot && spot._type === LIGHTTYPE_SPOT) {
				this.dispatchSpotLight(scene, scope, spot, cnt);
				cnt++;
				staticId++;
				spot = staticLightList[staticId];
			}
		}
	}

	cull(camera, drawCalls, visibleList) {
		let visibleLength = 0;
		const drawCallsCount = drawCalls.length;
		const cullingMask = camera.cullingMask || 0xFFFFFFFF;

		if (!camera.frustumCulling) {
			for (let i = 0; i < drawCallsCount; i++) {
				const drawCall = drawCalls[i];
				if (!drawCall.visible && !drawCall.command) continue;
				if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;
				visibleList[visibleLength] = drawCall;
				visibleLength++;
				drawCall.visibleThisFrame = true;
			}

			return visibleLength;
		}

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];

			if (!drawCall.command) {
				if (!drawCall.visible) continue;
				let visible = true;
				if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;

				if (drawCall.cull) {
					visible = drawCall._isVisible(camera);
				}

				if (visible) {
					visibleList[visibleLength] = drawCall;
					visibleLength++;
					drawCall.visibleThisFrame = true;
				}
			} else {
				visibleList[visibleLength] = drawCall;
				visibleLength++;
				drawCall.visibleThisFrame = true;
			}
		}

		return visibleLength;
	}

	cullLights(camera, lights) {
		const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (light.enabled) {
				if (light._type !== LIGHTTYPE_DIRECTIONAL) {
					light.getBoundingSphere(tempSphere$1);

					if (camera.frustum.containsSphere(tempSphere$1)) {
						light.visibleThisFrame = true;
						const screenSize = camera.getScreenSize(tempSphere$1);
						light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
					} else {
						if (!clusteredLightingEnabled) {
							if (light.castShadows && !light.shadowMap) {
								light.visibleThisFrame = true;
							}
						}
					}
				}
			}
		}
	}

	updateCpuSkinMatrices(drawCalls) {
		_skinUpdateIndex++;
		const drawCallsCount = drawCalls.length;
		if (drawCallsCount === 0) return;

		for (let i = 0; i < drawCallsCount; i++) {
			const si = drawCalls[i].skinInstance;

			if (si) {
				si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
				si._dirty = true;
			}
		}
	}

	updateGpuSkinMatrices(drawCalls) {
		const drawCallsCount = drawCalls.length;

		for (let i = 0; i < drawCallsCount; i++) {
			if (!drawCalls[i].visibleThisFrame) continue;
			const skin = drawCalls[i].skinInstance;

			if (skin) {
				if (skin._dirty) {
					skin.updateMatrixPalette(drawCalls[i].node, _skinUpdateIndex);
					skin._dirty = false;
				}
			}
		}
	}

	updateMorphing(drawCalls) {
		const drawCallsCount = drawCalls.length;

		for (let i = 0; i < drawCallsCount; i++) {
			const morphInst = drawCalls[i].morphInstance;

			if (morphInst && morphInst._dirty && drawCalls[i].visibleThisFrame) {
				morphInst.update();
			}
		}
	}

	setBaseConstants(device, material) {
		device.setCullMode(material.cull);

		if (material.opacityMap) {
			this.opacityMapId.setValue(material.opacityMap);
			this.alphaTestId.setValue(material.alphaTest);
		}
	}

	setSkinning(device, meshInstance, material) {
		if (meshInstance.skinInstance) {
			this._skinDrawCalls++;

			if (device.supportsBoneTextures) {
				boneTexture = meshInstance.skinInstance.boneTexture;
				this.boneTextureId.setValue(boneTexture);
				boneTextureSize[0] = boneTexture.width;
				boneTextureSize[1] = boneTexture.height;
				boneTextureSize[2] = 1.0 / boneTexture.width;
				boneTextureSize[3] = 1.0 / boneTexture.height;
				this.boneTextureSizeId.setValue(boneTextureSize);
			} else {
				this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
			}
		}
	}

	drawInstance(device, meshInstance, mesh, style, normal) {
		instancingData = meshInstance.instancingData;

		if (instancingData) {
			if (instancingData.count > 0) {
				this._instancedDrawCalls++;
				device.setVertexBuffer(instancingData.vertexBuffer);
				device.draw(mesh.primitive[style], instancingData.count);

				if (instancingData.vertexBuffer === _autoInstanceBuffer) {
					this._removedByInstancing += instancingData.count;
					meshInstance.instancingData = null;
					return instancingData.count - 1;
				}
			}
		} else {
			modelMatrix = meshInstance.node.worldTransform;
			this.modelMatrixId.setValue(modelMatrix.data);

			if (normal) {
				normalMatrix = meshInstance.node.normalMatrix;

				if (meshInstance.node._dirtyNormal) {
					modelMatrix.invertTo3x3(normalMatrix);
					normalMatrix.transpose();
					meshInstance.node._dirtyNormal = false;
				}

				this.normalMatrixId.setValue(normalMatrix.data);
			}

			device.draw(mesh.primitive[style]);
		}

		return 0;
	}

	drawInstance2(device, meshInstance, mesh, style) {
		instancingData = meshInstance.instancingData;

		if (instancingData) {
			if (instancingData.count > 0) {
				this._instancedDrawCalls++;
				device.draw(mesh.primitive[style], instancingData.count, true);

				if (instancingData.vertexBuffer === _autoInstanceBuffer) {
					this._removedByInstancing += instancingData.count;
					meshInstance.instancingData = null;
					return instancingData.count - 1;
				}
			}
		} else {
			device.draw(mesh.primitive[style], undefined, true);
		}

		return 0;
	}

	renderShadows(lights, camera) {
		const isClustered = this.scene.clusteredLightingEnabled;
		const device = this.device;
		device.grabPassAvailable = false;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (isClustered && light._type !== LIGHTTYPE_DIRECTIONAL) {
				if (!light.atlasViewportAllocated) {
					continue;
				}

				if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
					light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
				}
			}

			this._shadowRenderer.render(light, camera);
		}

		device.grabPassAvailable = true;
	}

	renderCookies(lights) {
		const cookieRenderTarget = this.lightTextureAtlas.cookieRenderTarget;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];
			if (!light.atlasViewportAllocated) continue;
			if (!light.atlasSlotUpdated) continue;

			this._cookieRenderer.render(light, cookieRenderTarget);
		}
	}

	updateShader(meshInstance, objDefs, staticLightList, pass, sortedLights) {
		meshInstance.material._scene = this.scene;

		if (meshInstance.material._dirtyBlend) {
			this.scene.layers._dirtyBlend = true;
		}

		meshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);
		meshInstance._shader[pass] = meshInstance.material.shader;
	}

	setCullMode(cullFaces, flip, drawCall) {
		const material = drawCall.material;
		let mode = CULLFACE_NONE;

		if (cullFaces) {
			let flipFaces = 1;

			if (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {
				if (drawCall.flipFaces) flipFaces *= -1;
				if (flip) flipFaces *= -1;
				const wt = drawCall.node.worldTransform;
				wt.getX(worldMatX);
				wt.getY(worldMatY);
				wt.getZ(worldMatZ);
				worldMatX.cross(worldMatX, worldMatY);

				if (worldMatX.dot(worldMatZ) < 0) {
					flipFaces *= -1;
				}
			}

			if (flipFaces < 0) {
				mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
			} else {
				mode = material.cull;
			}
		}

		this.device.setCullMode(mode);

		if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
			const wt2 = drawCall.node.worldTransform;
			wt2.getX(worldMatX);
			wt2.getY(worldMatY);
			wt2.getZ(worldMatZ);
			worldMatX.cross(worldMatX, worldMatY);

			if (worldMatX.dot(worldMatZ) < 0) {
				this.twoSidedLightingNegScaleFactorId.setValue(-1.0);
			} else {
				this.twoSidedLightingNegScaleFactorId.setValue(1.0);
			}
		}
	}

	setVertexBuffers(device, mesh) {
		device.setVertexBuffer(mesh.vertexBuffer);
	}

	setMorphing(device, morphInstance) {
		if (morphInstance) {
			if (morphInstance.morph.useTextureMorph) {
				device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
				this.morphPositionTex.setValue(morphInstance.texturePositions);
				this.morphNormalTex.setValue(morphInstance.textureNormals);
				this.morphTexParams.setValue(morphInstance._textureParams);
			} else {
				for (let t = 0; t < morphInstance._activeVertexBuffers.length; t++) {
					const vb = morphInstance._activeVertexBuffers[t];

					if (vb) {
						const semantic = SEMANTIC_ATTR + (t + 8);
						vb.format.elements[0].name = semantic;
						vb.format.elements[0].scopeId = device.scope.resolve(semantic);
						vb.format.update();
						device.setVertexBuffer(vb);
					}
				}

				this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);
				this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);
			}
		}
	}

	dispatchViewPos(position) {
		const vp = this.viewPos;
		vp[0] = position.x;
		vp[1] = position.y;
		vp[2] = position.z;
		this.viewPosId.setValue(vp);
	}

	renderForwardPrepareMaterials(camera, drawCalls, drawCallsCount, sortedLights, cullingMask, layer, pass) {
		const addCall = (drawCall, isNewMaterial, lightMaskChanged) => {
			_drawCallList.drawCalls.push(drawCall);

			_drawCallList.isNewMaterial.push(isNewMaterial);

			_drawCallList.lightMaskChanged.push(lightMaskChanged);
		};

		_drawCallList.drawCalls.length = 0;
		_drawCallList.isNewMaterial.length = 0;
		_drawCallList.lightMaskChanged.length = 0;
		const device = this.device;
		const scene = this.scene;
		const lightHash = layer ? layer._lightHash : 0;
		let prevMaterial = null,
				prevObjDefs,
				prevStatic,
				prevLightMask;

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];
			if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;

			if (drawCall.command) {
				addCall(drawCall, false, false);
			} else {
				if (!drawCall.material) drawCall.material = DefaultMaterial.get(device);
				const material = drawCall.material;
				const objDefs = drawCall._shaderDefs;
				const lightMask = drawCall.mask;

				if (material && material === prevMaterial && objDefs !== prevObjDefs) {
					prevMaterial = null;
				}

				if (drawCall.isStatic || prevStatic) {
					prevMaterial = null;
				}

				if (material !== prevMaterial) {
					this._materialSwitches++;

					if (material.dirty) {
						material.updateUniforms(device, scene);
						material.dirty = false;
					}

					if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
						if (!drawCall.isStatic) {
							const variantKey = pass + "_" + objDefs + "_" + lightHash;
							drawCall._shader[pass] = material.variants[variantKey];

							if (!drawCall._shader[pass]) {
								this.updateShader(drawCall, objDefs, null, pass, sortedLights);
								material.variants[variantKey] = drawCall._shader[pass];
							}
						} else {
							this.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);
						}

						drawCall._shaderDefs = objDefs;
						drawCall._lightHash = lightHash;
					}
				}

				addCall(drawCall, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
				prevMaterial = material;
				prevObjDefs = objDefs;
				prevLightMask = lightMask;
				prevStatic = drawCall.isStatic;
			}
		}

		return _drawCallList;
	}

	renderForward(camera, allDrawCalls, allDrawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer, flipFaces) {
		const device = this.device;
		const scene = this.scene;
		const vrDisplay = camera.vrDisplay;
		const passFlag = 1 << pass;
		const halfWidth = device.width * 0.5;
		const preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, allDrawCallsCount, sortedLights, cullingMask, layer, pass);
		const preparedCallsCount = preparedCalls.drawCalls.length;

		for (let i = 0; i < preparedCallsCount; i++) {
			const drawCall = preparedCalls.drawCalls[i];

			if (drawCall.command) {
				drawCall.command();
			} else {
				const newMaterial = preparedCalls.isNewMaterial[i];
				const lightMaskChanged = preparedCalls.lightMaskChanged[i];
				const material = drawCall.material;
				drawCall._shaderDefs;
				const lightMask = drawCall.mask;

				if (newMaterial) {
					const shader = drawCall._shader[pass];

					if (!shader.failed && !device.setShader(shader)) {
						shader.failed = true;
					}

					material.setParameters(device);

					if (lightMaskChanged) {
						const usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);
						this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
					}

					this.alphaTestId.setValue(material.alphaTest);
					device.setBlending(material.blend);

					if (material.blend) {
						if (material.separateAlphaBlend) {
							device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
							device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
						} else {
							device.setBlendFunction(material.blendSrc, material.blendDst);
							device.setBlendEquation(material.blendEquation);
						}
					}

					device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
					device.setDepthWrite(material.depthWrite);

					if (material.depthWrite && !material.depthTest) {
						device.setDepthFunc(FUNC_ALWAYS);
						device.setDepthTest(true);
					} else {
						device.setDepthFunc(FUNC_LESSEQUAL);
						device.setDepthTest(material.depthTest);
					}

					device.setAlphaToCoverage(material.alphaToCoverage);

					if (material.depthBias || material.slopeDepthBias) {
						device.setDepthBias(true);
						device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
					} else {
						device.setDepthBias(false);
					}
				}

				this.setCullMode(camera._cullFaces, flipFaces, drawCall);
				const stencilFront = drawCall.stencilFront || material.stencilFront;
				const stencilBack = drawCall.stencilBack || material.stencilBack;

				if (stencilFront || stencilBack) {
					device.setStencilTest(true);

					if (stencilFront === stencilBack) {
						device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
						device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
					} else {
						if (stencilFront) {
							device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
							device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
						} else {
							device.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);
							device.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
						}

						if (stencilBack) {
							device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
							device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
						} else {
							device.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);
							device.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
						}
					}
				} else {
					device.setStencilTest(false);
				}

				const mesh = drawCall.mesh;
				drawCall.setParameters(device, passFlag);
				this.setVertexBuffers(device, mesh);
				this.setMorphing(device, drawCall.morphInstance);
				this.setSkinning(device, drawCall, material);
				const style = drawCall.renderStyle;
				device.setIndexBuffer(mesh.indexBuffer[style]);

				if (drawCallback) {
					drawCallback(drawCall, i);
				}

				if (vrDisplay && vrDisplay.presenting) {
					device.setViewport(0, 0, halfWidth, device.height);
					this.projId.setValue(projL.data);
					this.projSkyboxId.setValue(projL.data);
					this.viewInvId.setValue(viewInvL.data);
					this.viewId.setValue(viewL.data);
					this.viewId3.setValue(viewMat3L.data);
					this.viewProjId.setValue(viewProjMatL.data);
					this.dispatchViewPos(viewPosL);
					i += this.drawInstance(device, drawCall, mesh, style, true);
					this._forwardDrawCalls++;
					device.setViewport(halfWidth, 0, halfWidth, device.height);
					this.projId.setValue(projR.data);
					this.projSkyboxId.setValue(projR.data);
					this.viewInvId.setValue(viewInvR.data);
					this.viewId.setValue(viewR.data);
					this.viewId3.setValue(viewMat3R.data);
					this.viewProjId.setValue(viewProjMatR.data);
					this.dispatchViewPos(viewPosR);
					i += this.drawInstance2(device, drawCall, mesh, style);
					this._forwardDrawCalls++;
				} else if (camera.xr && camera.xr.session && camera.xr.views.length) {
					const views = camera.xr.views;

					for (let v = 0; v < views.length; v++) {
						const view = views[v];
						device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
						this.projId.setValue(view.projMat.data);
						this.projSkyboxId.setValue(view.projMat.data);
						this.viewId.setValue(view.viewOffMat.data);
						this.viewInvId.setValue(view.viewInvOffMat.data);
						this.viewId3.setValue(view.viewMat3.data);
						this.viewProjId.setValue(view.projViewOffMat.data);
						this.viewPosId.setValue(view.position);

						if (v === 0) {
							i += this.drawInstance(device, drawCall, mesh, style, true);
						} else {
							i += this.drawInstance2(device, drawCall, mesh, style);
						}

						this._forwardDrawCalls++;
					}
				} else {
					i += this.drawInstance(device, drawCall, mesh, style, true);
					this._forwardDrawCalls++;
				}

				if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
					material.setParameters(device, drawCall.parameters);
				}
			}
		}

		device.updateEnd();
		_drawCallList.length = 0;
	}

	setupInstancing(device) {
		if (device.enableAutoInstancing) {
			if (!_autoInstanceBuffer) {
				_autoInstanceBuffer = new VertexBuffer(device, VertexFormat.defaultInstancingFormat, device.autoInstancingMaxObjects, BUFFER_DYNAMIC);
			}
		}
	}

	updateShaders(drawCalls, onlyLitShaders) {
		const count = drawCalls.length;

		for (let i = 0; i < count; i++) {
			const mat = drawCalls[i].material;

			if (mat) {
				if (!_tempMaterialSet.has(mat)) {
					_tempMaterialSet.add(mat);

					if (mat.updateShader !== Material$1.prototype.updateShader) {
						if (onlyLitShaders) {
							if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;
						}

						mat.clearVariants();
						mat.shader = null;
					}
				}
			}
		}

		_tempMaterialSet.clear();
	}

	beginFrame(comp, lightsChanged) {
		const meshInstances = comp._meshInstances;
		const scene = this.scene;

		if (scene.updateShaders || lightsChanged) {
			const onlyLitShaders = !scene.updateShaders && lightsChanged;
			this.updateShaders(meshInstances, onlyLitShaders);
			scene.updateShaders = false;
			scene._shaderVersion++;
		}

		this.updateCpuSkinMatrices(meshInstances);
		const miCount = meshInstances.length;

		for (let i = 0; i < miCount; i++) {
			meshInstances[i].visibleThisFrame = false;
		}

		const lights = comp._lights;
		const lightCount = lights.length;

		for (let i = 0; i < lightCount; i++) {
			lights[i].beginFrame();
		}
	}

	beginLayers(comp) {
		const len = comp.layerList.length;

		for (let i = 0; i < len; i++) {
			comp.layerList[i]._postRenderCounter = 0;
		}

		const scene = this.scene;
		const shaderVersion = scene._shaderVersion;

		for (let i = 0; i < len; i++) {
			const layer = comp.layerList[i];
			layer._shaderVersion = shaderVersion;
			layer._preRenderCalledForCameras = 0;
			layer._postRenderCalledForCameras = 0;
			const transparent = comp.subLayerList[i];

			if (transparent) {
				layer._postRenderCounter |= 2;
			} else {
				layer._postRenderCounter |= 1;
			}

			layer._postRenderCounterMax = layer._postRenderCounter;

			for (let j = 0; j < layer.cameras.length; j++) {
				layer.instances.prepare(j);
			}

			if (layer._needsStaticPrepare && layer._staticLightHash && !this.scene.clusteredLightingEnabled) {
				if (layer._staticPrepareDone) {
					StaticMeshes.revert(layer.opaqueMeshInstances);
					StaticMeshes.revert(layer.transparentMeshInstances);
				}

				StaticMeshes.prepare(this.device, scene, layer.opaqueMeshInstances, layer._lights);
				StaticMeshes.prepare(this.device, scene, layer.transparentMeshInstances, layer._lights);
				comp._dirty = true;
				scene.updateShaders = true;
				layer._needsStaticPrepare = false;
				layer._staticPrepareDone = true;
			}
		}
	}

	gpuUpdate(drawCalls) {
		this.updateGpuSkinMatrices(drawCalls);
		this.updateMorphing(drawCalls);
	}

	setSceneConstants() {
		const scene = this.scene;
		this.dispatchGlobalLights(scene);

		if (scene.fog !== FOG_NONE) {
			this.fogColor[0] = scene.fogColor.r;
			this.fogColor[1] = scene.fogColor.g;
			this.fogColor[2] = scene.fogColor.b;

			if (scene.gammaCorrection) {
				for (let i = 0; i < 3; i++) {
					this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
				}
			}

			this.fogColorId.setValue(this.fogColor);

			if (scene.fog === FOG_LINEAR) {
				this.fogStartId.setValue(scene.fogStart);
				this.fogEndId.setValue(scene.fogEnd);
			} else {
				this.fogDensityId.setValue(scene.fogDensity);
			}
		}

		const device = this.device;
		this._screenSize[0] = device.width;
		this._screenSize[1] = device.height;
		this._screenSize[2] = 1 / device.width;
		this._screenSize[3] = 1 / device.height;
		this.screenSizeId.setValue(this._screenSize);
	}

	updateLightStats(comp, compUpdatedFlags) {}

	cullShadowmaps(comp) {
		for (let i = 0; i < comp._lights.length; i++) {
			const light = comp._lights[i];

			if (light._type !== LIGHTTYPE_DIRECTIONAL) {
				if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
					const casters = comp._lightCompositionData[i].shadowCastersList;

					this._shadowRenderer.cullLocal(light, casters);
				}
			}
		}

		const renderActions = comp._renderActions;

		for (let i = 0; i < renderActions.length; i++) {
			const renderAction = renderActions[i];
			const count = renderAction.directionalLightsIndices.length;

			for (let j = 0; j < count; j++) {
				const lightIndex = renderAction.directionalLightsIndices[j];
				const light = comp._lights[lightIndex];
				const casters = comp._lightCompositionData[lightIndex].shadowCastersList;

				this._shadowRenderer.cullDirectional(light, casters, renderAction.camera.camera);
			}
		}
	}

	cullComposition(comp) {
		const renderActions = comp._renderActions;

		for (let i = 0; i < renderActions.length; i++) {
			const renderAction = renderActions[i];
			const layerIndex = renderAction.layerIndex;
			const layer = comp.layerList[layerIndex];
			if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) continue;
			const transparent = comp.subLayerList[layerIndex];
			const cameraPass = renderAction.cameraIndex;
			const camera = layer.cameras[cameraPass];

			if (camera) {
				camera.frameBegin(renderAction.renderTarget);

				if (renderAction.firstCameraUse) {
					this.updateCameraFrustum(camera.camera);
					this._camerasRendered++;
				}

				this.cullLights(camera.camera, layer._lights);
				const objects = layer.instances;
				const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

				if (!visible.done) {
					if (layer.onPreCull) {
						layer.onPreCull(cameraPass);
					}

					const drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;
					visible.length = this.cull(camera.camera, drawCalls, visible.list);
					visible.done = true;

					if (layer.onPostCull) {
						layer.onPostCull(cameraPass);
					}
				}

				camera.frameEnd();
			}
		}

		this.cullShadowmaps(comp);
	}

	updateLightTextureAtlas(comp) {
		this.lightTextureAtlas.update(comp._splitLights[LIGHTTYPE_SPOT], comp._splitLights[LIGHTTYPE_OMNI], this.scene.lighting);
	}

	updateClusters(comp) {
		for (let i = 0; i < comp._worldClusters.length; i++) {
			const cluster = comp._worldClusters[i];
			cluster.update(comp._lights, this.scene.gammaCorrection, this.scene.lighting);
		}
	}

	renderComposition(comp) {
		const device = this.device;
		const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

		this.scene._updateSkybox(this.device);

		this.beginLayers(comp);

		const updated = comp._update(device, clusteredLightingEnabled);

		const lightsChanged = (updated & COMPUPDATED_LIGHTS) !== 0;
		this.updateLightStats(comp, updated);
		this.beginFrame(comp, lightsChanged);
		this.setSceneConstants();
		this.cullComposition(comp);
		this.gpuUpdate(comp._meshInstances);

		if (clusteredLightingEnabled) {
			this.updateLightTextureAtlas(comp);

			if (this.scene.lighting.cookiesEnabled) {
				this.renderCookies(comp._splitLights[LIGHTTYPE_SPOT]);
				this.renderCookies(comp._splitLights[LIGHTTYPE_OMNI]);
			}
		}

		if (!clusteredLightingEnabled || clusteredLightingEnabled && this.scene.lighting.shadowsEnabled) {
			this.renderShadows(comp._splitLights[LIGHTTYPE_SPOT]);
			this.renderShadows(comp._splitLights[LIGHTTYPE_OMNI]);
		}

		if (clusteredLightingEnabled) {
			this.updateClusters(comp);
		}
		let clustersDebugRendered = false;
		const renderActions = comp._renderActions;

		for (let i = 0; i < renderActions.length; i++) {
			const renderAction = renderActions[i];
			const layerIndex = renderAction.layerIndex;
			const layer = comp.layerList[layerIndex];
			const transparent = comp.subLayerList[layerIndex];
			const cameraPass = renderAction.cameraIndex;
			const camera = layer.cameras[cameraPass];

			if (renderAction.directionalLights.length > 0) {
				this.renderShadows(renderAction.directionalLights, camera.camera);
			}

			if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) {
				continue;
			}

			if (camera) {
				camera.frameBegin(renderAction.renderTarget);

				if (renderAction.firstCameraUse && camera.onPreRender) {
					camera.onPreRender();
				}
			}

			if (!transparent && layer.onPreRenderOpaque) {
				layer.onPreRenderOpaque(cameraPass);
			} else if (transparent && layer.onPreRenderTransparent) {
				layer.onPreRenderTransparent(cameraPass);
			}

			if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {
				if (layer.onPreRender) {
					layer.onPreRender(cameraPass);
				}

				layer._preRenderCalledForCameras |= 1 << cameraPass;
			}

			if (camera) {
				var _renderAction$renderT;

				if (renderAction.clearColor || renderAction.clearDepth || renderAction.clearStencil) {
					const backupColor = camera.camera._clearColorBuffer;
					const backupDepth = camera.camera._clearDepthBuffer;
					const backupStencil = camera.camera._clearStencilBuffer;
					camera.camera._clearColorBuffer = renderAction.clearColor;
					camera.camera._clearDepthBuffer = renderAction.clearDepth;
					camera.camera._clearStencilBuffer = renderAction.clearStencil;
					this.clearView(camera.camera, renderAction.renderTarget, true, true);
					camera.camera._clearColorBuffer = backupColor;
					camera.camera._clearDepthBuffer = backupDepth;
					camera.camera._clearStencilBuffer = backupStencil;
				}

				layer._sortVisible(transparent, camera.camera.node, cameraPass);

				const objects = layer.instances;
				const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
				this.scene.immediate.onPreRenderLayer(layer, visible, transparent);
				this.scene._activeCamera = camera.camera;
				this.setCamera(camera.camera, renderAction.renderTarget);

				if (clusteredLightingEnabled && renderAction.lightClusters) {
					renderAction.lightClusters.activate(this.lightTextureAtlas);

					if (!clustersDebugRendered && this.scene.lighting.debugLayer === layer.id) {
						clustersDebugRendered = true;
					}
				}

				const flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null ? void 0 : (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));
				const draws = this._forwardDrawCalls;
				this.renderForward(camera.camera, visible.list, visible.length, layer._splitLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer, flipFaces);
				layer._forwardDrawCalls += this._forwardDrawCalls - draws;
				device.setColorWrite(true, true, true, true);
				device.setStencilTest(false);
				device.setAlphaToCoverage(false);
				device.setDepthBias(false);
				camera.frameEnd();

				if (renderAction.lastCameraUse && camera.onPostRender) {
					camera.onPostRender();
				}

				if (renderAction.triggerPostprocess && camera.onPostprocessing) {
					camera.onPostprocessing();
				}
			}

			if (!transparent && layer.onPostRenderOpaque) {
				layer.onPostRenderOpaque(cameraPass);
			} else if (transparent && layer.onPostRenderTransparent) {
				layer.onPostRenderTransparent(cameraPass);
			}

			if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {
				layer._postRenderCounter &= ~(transparent ? 2 : 1);

				if (layer._postRenderCounter === 0) {
					layer.onPostRender(cameraPass);
					layer._postRenderCalledForCameras |= 1 << cameraPass;
					layer._postRenderCounter = layer._postRenderCounterMax;
				}
			}
		}
	}

}

let keyA, keyB, sortPos, sortDir;

function sortManual(drawCallA, drawCallB) {
	return drawCallA.drawOrder - drawCallB.drawOrder;
}

function sortMaterialMesh(drawCallA, drawCallB) {
	keyA = drawCallA._key[SORTKEY_FORWARD];
	keyB = drawCallB._key[SORTKEY_FORWARD];

	if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
		return drawCallB.mesh.id - drawCallA.mesh.id;
	}

	return keyB - keyA;
}

function sortBackToFront(drawCallA, drawCallB) {
	return drawCallB.zdist - drawCallA.zdist;
}

function sortFrontToBack(drawCallA, drawCallB) {
	return drawCallA.zdist - drawCallB.zdist;
}

const sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];

function sortLights(lightA, lightB) {
	return lightB.key - lightA.key;
}

let layerCounter = 0;

class VisibleInstanceList {
	constructor() {
		this.list = [];
		this.length = 0;
		this.done = false;
	}

}

class InstanceList {
	constructor() {
		this.opaqueMeshInstances = [];
		this.transparentMeshInstances = [];
		this.shadowCasters = [];
		this.visibleOpaque = [];
		this.visibleTransparent = [];
	}

	prepare(index) {
		if (!this.visibleOpaque[index]) {
			this.visibleOpaque[index] = new VisibleInstanceList();
		}

		if (!this.visibleTransparent[index]) {
			this.visibleTransparent[index] = new VisibleInstanceList();
		}

		this.visibleOpaque[index].done = false;
		this.visibleTransparent[index].done = false;
	}

	delete(index) {
		if (index < this.visibleOpaque.length) {
			this.visibleOpaque.splice(index, 1);
		}

		if (index < this.visibleTransparent.length) {
			this.visibleTransparent.splice(index, 1);
		}
	}

}

class Layer {
	constructor(options = {}) {
		if (options.id !== undefined) {
			this.id = options.id;
			layerCounter = Math.max(this.id + 1, layerCounter);
		} else {
			this.id = layerCounter++;
		}

		this.name = options.name;
		this._enabled = options.enabled === undefined ? true : options.enabled;
		this._refCounter = this._enabled ? 1 : 0;
		this.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;
		this.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;
		this.renderTarget = options.renderTarget;
		this.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;
		this.passThrough = options.passThrough === undefined ? false : options.passThrough;
		this._clearColorBuffer = options.clearColorBuffer ? options.clearColorBuffer : false;
		this._clearDepthBuffer = options.clearDepthBuffer ? options.clearDepthBuffer : false;
		this._clearStencilBuffer = options.clearStencilBuffer ? options.clearStencilBuffer : false;
		this.onPreCull = options.onPreCull;
		this.onPreRender = options.onPreRender;
		this.onPreRenderOpaque = options.onPreRenderOpaque;
		this.onPreRenderTransparent = options.onPreRenderTransparent;
		this.onPostCull = options.onPostCull;
		this.onPostRender = options.onPostRender;
		this.onPostRenderOpaque = options.onPostRenderOpaque;
		this.onPostRenderTransparent = options.onPostRenderTransparent;
		this.onDrawCall = options.onDrawCall;
		this.onEnable = options.onEnable;
		this.onDisable = options.onDisable;

		if (this._enabled && this.onEnable) {
			this.onEnable();
		}

		this.layerReference = options.layerReference;
		this.instances = options.layerReference ? options.layerReference.instances : new InstanceList();
		this.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;
		this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
		this.transparentMeshInstances = this.instances.transparentMeshInstances;
		this.shadowCasters = this.instances.shadowCasters;
		this.customSortCallback = null;
		this.customCalculateSortValues = null;
		this._lights = [];
		this._lightsSet = new Set();
		this._clusteredLightsSet = new Set();
		this._splitLights = [[], [], []];
		this.cameras = [];
		this._dirty = false;
		this._dirtyLights = false;
		this._dirtyCameras = false;
		this._lightHash = 0;
		this._staticLightHash = 0;
		this._needsStaticPrepare = true;
		this._staticPrepareDone = false;
		this._shaderVersion = -1;
		this._lightCube = null;
	}

	set renderTarget(rt) {
		this._renderTarget = rt;
		this._dirtyCameras = true;
	}

	get renderTarget() {
		return this._renderTarget;
	}

	set enabled(val) {
		if (val !== this._enabled) {
			this._enabled = val;

			if (val) {
				this.incrementCounter();
				if (this.onEnable) this.onEnable();
			} else {
				this.decrementCounter();
				if (this.onDisable) this.onDisable();
			}
		}
	}

	get enabled() {
		return this._enabled;
	}

	set clearColor(val) {
		this._clearColor.copy(val);
	}

	get clearColor() {
		return this._clearColor;
	}

	set clearColorBuffer(val) {
		this._clearColorBuffer = val;
		this._dirtyCameras = true;
	}

	get clearColorBuffer() {
		return this._clearColorBuffer;
	}

	set clearDepthBuffer(val) {
		this._clearDepthBuffer = val;
		this._dirtyCameras = true;
	}

	get clearDepthBuffer() {
		return this._clearDepthBuffer;
	}

	set clearStencilBuffer(val) {
		this._clearStencilBuffer = val;
		this._dirtyCameras = true;
	}

	get clearStencilBuffer() {
		return this._clearStencilBuffer;
	}

	incrementCounter() {
		if (this._refCounter === 0) {
			this._enabled = true;
			if (this.onEnable) this.onEnable();
		}

		this._refCounter++;
	}

	decrementCounter() {
		if (this._refCounter === 1) {
			this._enabled = false;
			if (this.onDisable) this.onDisable();
		} else if (this._refCounter === 0) {
			return;
		}

		this._refCounter--;
	}

	addMeshInstances(meshInstances, skipShadowCasters) {
		const sceneShaderVer = this._shaderVersion;
		const casters = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const m = meshInstances[i];
			const mat = m.material;
			const arr = mat.blendType === BLEND_NONE ? this.opaqueMeshInstances : this.transparentMeshInstances;

			if (this.opaqueMeshInstances.indexOf(m) < 0 && this.transparentMeshInstances.indexOf(m) < 0) {
				arr.push(m);
			}

			if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);

			if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
				if (mat.updateShader !== Material$1.prototype.updateShader) {
					mat.clearVariants();
					mat.shader = null;
				}

				mat._shaderVersion = sceneShaderVer;
			}
		}

		if (!this.passThrough) this._dirty = true;
	}

	removeMeshInstanceFromArray(m, arr) {
		let spliceOffset = -1;
		let spliceCount = 0;
		const len = arr.length;

		for (let j = 0; j < len; j++) {
			const drawCall = arr[j];

			if (drawCall === m) {
				spliceOffset = j;
				spliceCount = 1;
				break;
			}

			if (drawCall._staticSource === m) {
				if (spliceOffset < 0) spliceOffset = j;
				spliceCount++;
			} else if (spliceOffset >= 0) {
				break;
			}
		}

		if (spliceOffset >= 0) {
			arr.splice(spliceOffset, spliceCount);
		}
	}

	removeMeshInstances(meshInstances, skipShadowCasters) {
		const opaque = this.opaqueMeshInstances;
		const transparent = this.transparentMeshInstances;
		const casters = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const m = meshInstances[i];
			this.removeMeshInstanceFromArray(m, opaque);
			this.removeMeshInstanceFromArray(m, transparent);

			if (!skipShadowCasters) {
				const j = casters.indexOf(m);
				if (j >= 0) casters.splice(j, 1);
			}
		}

		this._dirty = true;
	}

	clearMeshInstances(skipShadowCasters) {
		if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
			if (skipShadowCasters || this.shadowCasters.length === 0) return;
		}

		this.opaqueMeshInstances.length = 0;
		this.transparentMeshInstances.length = 0;
		if (!skipShadowCasters) this.shadowCasters.length = 0;
		if (!this.passThrough) this._dirty = true;
	}

	addLight(light) {
		const l = light.light;

		if (!this._lightsSet.has(l)) {
			this._lightsSet.add(l);

			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.add(l);
			}

			this._lights.push(l);

			this._dirtyLights = true;

			this._generateLightHash();
		}
	}

	removeLight(light) {
		const l = light.light;

		if (this._lightsSet.has(l)) {
			this._lightsSet.delete(l);

			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.delete(l);
			}

			this._lights.splice(this._lights.indexOf(l), 1);

			this._dirtyLights = true;

			this._generateLightHash();
		}
	}

	clearLights() {
		this._lightsSet.clear();

		this._clusteredLightsSet.clear();

		this._lights.length = 0;
		this._dirtyLights = true;
	}

	get clusteredLightsSet() {
		return this._clusteredLightsSet;
	}

	addShadowCasters(meshInstances) {
		const arr = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const m = meshInstances[i];
			if (!m.castShadow) continue;
			if (arr.indexOf(m) < 0) arr.push(m);
		}

		this._dirtyLights = true;
	}

	removeShadowCasters(meshInstances) {
		const arr = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const id = arr.indexOf(meshInstances[i]);
			if (id >= 0) arr.splice(id, 1);
		}

		this._dirtyLights = true;
	}

	_generateLightHash() {
		if (this._lights.length > 0) {
			this._lights.sort(sortLights);

			let str = "";
			let strStatic = "";

			for (let i = 0; i < this._lights.length; i++) {
				if (this._lights[i].isStatic) {
					strStatic += this._lights[i].key;
				} else {
					str += this._lights[i].key;
				}
			}

			if (str.length === 0) {
				this._lightHash = 0;
			} else {
				this._lightHash = hashCode(str);
			}

			if (strStatic.length === 0) {
				this._staticLightHash = 0;
			} else {
				this._staticLightHash = hashCode(strStatic);
			}
		} else {
			this._lightHash = 0;
			this._staticLightHash = 0;
		}
	}

	addCamera(camera) {
		if (this.cameras.indexOf(camera) >= 0) return;
		this.cameras.push(camera);
		this._dirtyCameras = true;
	}

	removeCamera(camera) {
		const index = this.cameras.indexOf(camera);

		if (index >= 0) {
			this.cameras.splice(index, 1);
			this._dirtyCameras = true;
			this.instances.delete(index);
		}
	}

	clearCameras() {
		this.cameras.length = 0;
		this._dirtyCameras = true;
	}

	_calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {
		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];
			if (drawCall.command) continue;
			if (drawCall.layer <= LAYER_FX) continue;

			if (drawCall.calculateSortDistance) {
				drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
				continue;
			}

			const meshPos = drawCall.aabb.center;
			const tempx = meshPos.x - camPos.x;
			const tempy = meshPos.y - camPos.y;
			const tempz = meshPos.z - camPos.z;
			drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
		}
	}

	_sortVisible(transparent, cameraNode, cameraPass) {
		const objects = this.instances;
		const sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
		if (sortMode === SORTMODE_NONE) return;
		const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

		if (sortMode === SORTMODE_CUSTOM) {
			sortPos = cameraNode.getPosition();
			sortDir = cameraNode.forward;

			if (this.customCalculateSortValues) {
				this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);
			}

			if (visible.list.length !== visible.length) {
				visible.list.length = visible.length;
			}

			if (this.customSortCallback) {
				visible.list.sort(this.customSortCallback);
			}
		} else {
			if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
				sortPos = cameraNode.getPosition();
				sortDir = cameraNode.forward;

				this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
			}

			if (visible.list.length !== visible.length) {
				visible.list.length = visible.length;
			}

			visible.list.sort(sortCallbacks[sortMode]);
		}
	}

}

const set = {
	equals: function (set1, set2) {
		if (set1.size !== set2.size) {
			return false;
		}

		for (const item of set1) {
			if (!set2.has(item)) {
				return false;
			}
		}

		return true;
	}
};

class RenderAction {
	constructor() {
		this.layerIndex = 0;
		this.cameraIndex = 0;
		this.camera = null;
		this.renderTarget = null;
		this.lightClusters = null;
		this.clearColor = false;
		this.clearDepth = false;
		this.clearStencil = false;
		this.triggerPostprocess = false;
		this.firstCameraUse = false;
		this.lastCameraUse = false;
		this.directionalLightsSet = new Set();
		this.directionalLights = [];
		this.directionalLightsIndices = [];
	}

	reset() {
		this.lightClusters = null;
		this.directionalLightsSet.clear();
		this.directionalLights.length = 0;
		this.directionalLightsIndices.length = 0;
	}

	collectDirectionalLights(cameraLayers, dirLights, allLights) {
		this.directionalLightsSet.clear();
		this.directionalLights.length = 0;
		this.directionalLightsIndices.length = 0;

		for (let i = 0; i < dirLights.length; i++) {
			const light = dirLights[i];

			if (light.castShadows) {
				for (let l = 0; l < cameraLayers.length; l++) {
					if (cameraLayers[l]._splitLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) >= 0) {
						if (!this.directionalLightsSet.has(light)) {
							this.directionalLightsSet.add(light);
							this.directionalLights.push(light);
							const lightIndex = allLights.indexOf(light);
							this.directionalLightsIndices.push(lightIndex);
						}
					}
				}
			}
		}
	}

}

class LightCompositionData {
	constructor() {
		this.shadowCastersSet = new Set();
		this.shadowCastersList = [];
	}

	clearShadowCasters() {
		this.shadowCastersSet.clear();
		this.shadowCastersList.length = 0;
	}

	addShadowCasters(casters) {
		for (let i = 0; i < casters.length; i++) {
			const item = casters[i];

			if (!this.shadowCastersSet.has(item)) {
				this.shadowCastersSet.add(item);
				this.shadowCastersList.push(item);
			}
		}
	}

}

const tempSet$1 = new Set();
const tempClusterArray = [];

class LayerComposition extends EventHandler {
	constructor(name = "Untitled") {
		super();
		this.name = name;
		this.logRenderActions = false;
		this.layerList = [];
		this.subLayerList = [];
		this.subLayerEnabled = [];
		this._opaqueOrder = {};
		this._transparentOrder = {};
		this._dirty = false;
		this._dirtyBlend = false;
		this._dirtyLights = false;
		this._dirtyCameras = false;
		this._meshInstances = [];
		this._meshInstancesSet = new Set();
		this._lights = [];
		this._lightsMap = new Map();
		this._lightCompositionData = [];
		this._splitLights = [[], [], []];
		this.cameras = [];
		this._renderActions = [];
		this._worldClusters = [];
		this._emptyWorldClusters = null;
	}

	destroy() {
		if (this._emptyWorldClusters) {
			this._emptyWorldClusters.destroy();

			this._emptyWorldClusters = null;
		}

		this._worldClusters.forEach(cluster => {
			cluster.destroy();
		});

		this._worldClusters = null;
	}

	getEmptyWorldClusters(device) {
		if (!this._emptyWorldClusters) {
			this._emptyWorldClusters = new WorldClusters(device);
			this._emptyWorldClusters.name = "ClusterEmpty";

			this._emptyWorldClusters.update([], false, null);
		}

		return this._emptyWorldClusters;
	}

	_splitLightsArray(target) {
		const lights = target._lights;
		target._splitLights[LIGHTTYPE_DIRECTIONAL].length = 0;
		target._splitLights[LIGHTTYPE_OMNI].length = 0;
		target._splitLights[LIGHTTYPE_SPOT].length = 0;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (light.enabled) {
				target._splitLights[light._type].push(light);
			}
		}
	}

	_update(device, clusteredLightingEnabled = false) {
		const len = this.layerList.length;
		let result = 0;

		if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {
			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];

				if (layer._dirty) {
					this._dirty = true;
				}

				if (layer._dirtyLights) {
					this._dirtyLights = true;
				}

				if (layer._dirtyCameras) {
					this._dirtyCameras = true;
				}
			}
		}

		function addUniqueMeshInstance(destArray, destSet, srcArray) {
			let dirtyBlend = false;
			const srcLen = srcArray.length;

			for (let s = 0; s < srcLen; s++) {
				const meshInst = srcArray[s];

				if (!destSet.has(meshInst)) {
					destSet.add(meshInst);
					destArray.push(meshInst);
					const material = meshInst.material;

					if (material && material._dirtyBlend) {
						dirtyBlend = true;
						material._dirtyBlend = false;
					}
				}
			}

			return dirtyBlend;
		}

		if (this._dirty) {
			result |= COMPUPDATED_INSTANCES;
			this._meshInstances.length = 0;

			this._meshInstancesSet.clear();

			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];

				if (!layer.passThrough) {
					this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.opaqueMeshInstances) || this._dirtyBlend;
					this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.transparentMeshInstances) || this._dirtyBlend;
				}

				layer._dirty = false;
			}

			this._dirty = false;
		}

		function moveByBlendType(dest, src, moveTransparent) {
			for (let s = 0; s < src.length;) {
				var _src$s$material;

				if (((_src$s$material = src[s].material) == null ? void 0 : _src$s$material.transparent) === moveTransparent) {
					dest.push(src[s]);
					src[s] = src[src.length - 1];
					src.length--;
				} else {
					s++;
				}
			}
		}

		if (this._dirtyBlend) {
			result |= COMPUPDATED_BLEND;

			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];

				if (!layer.passThrough) {
					moveByBlendType(layer.opaqueMeshInstances, layer.transparentMeshInstances, false);
					moveByBlendType(layer.transparentMeshInstances, layer.opaqueMeshInstances, true);
				}
			}

			this._dirtyBlend = false;
		}

		if (this._dirtyLights) {
			result |= COMPUPDATED_LIGHTS;
			this._dirtyLights = false;
			this.updateLights();
		}

		if (result) {
			this.updateShadowCasters();
		}

		if (this._dirtyCameras || result & COMPUPDATED_LIGHTS) {
			this._dirtyCameras = false;
			result |= COMPUPDATED_CAMERAS;
			this.cameras.length = 0;

			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];
				layer._dirtyCameras = false;

				for (let j = 0; j < layer.cameras.length; j++) {
					const camera = layer.cameras[j];
					const index = this.cameras.indexOf(camera);

					if (index < 0) {
						this.cameras.push(camera);
					}
				}
			}

			if (this.cameras.length > 1) {
				this.cameras.sort((a, b) => a.priority - b.priority);
			}

			const cameraLayers = [];
			let renderActionCount = 0;

			for (let i = 0; i < this.cameras.length; i++) {
				const camera = this.cameras[i];
				cameraLayers.length = 0;
				let cameraFirstRenderAction = true;
				const cameraFirstRenderActionIndex = renderActionCount;
				let lastRenderAction = null;
				let postProcessMarked = false;

				for (let j = 0; j < len; j++) {
					const layer = this.layerList[j];

					if (layer) {
						if (layer.cameras.length > 0) {
							if (camera.layers.indexOf(layer.id) >= 0) {
								cameraLayers.push(layer);

								if (!postProcessMarked && layer.id === camera.disablePostEffectsLayer) {
									postProcessMarked = true;

									if (lastRenderAction) {
										lastRenderAction.triggerPostprocess = true;
									}
								}

								const cameraIndex = layer.cameras.indexOf(camera);

								if (cameraIndex >= 0) {
									lastRenderAction = this.addRenderAction(this._renderActions, renderActionCount, layer, j, cameraIndex, cameraFirstRenderAction, postProcessMarked);
									renderActionCount++;
									cameraFirstRenderAction = false;
								}
							}
						}
					}
				}

				if (cameraFirstRenderActionIndex < renderActionCount) {
					this._renderActions[cameraFirstRenderActionIndex].collectDirectionalLights(cameraLayers, this._splitLights[LIGHTTYPE_DIRECTIONAL], this._lights);

					lastRenderAction.lastCameraUse = true;
				}

				if (!postProcessMarked && lastRenderAction) {
					lastRenderAction.triggerPostprocess = true;
				}

				if (camera.renderTarget && camera.postEffectsEnabled) {
					this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera);
				}
			}

			this._renderActions.length = renderActionCount;

			if (clusteredLightingEnabled) {
				this.allocateLightClusters(device);
			}
		}

		if (result & COMPUPDATED_LIGHTS || result & COMPUPDATED_CAMERAS) {
			this._logRenderActions();
		}

		return result;
	}

	updateShadowCasters() {
		const lightCount = this._lights.length;

		for (let i = 0; i < lightCount; i++) {
			this._lightCompositionData[i].clearShadowCasters();
		}

		const len = this.layerList.length;

		for (let i = 0; i < len; i++) {
			const layer = this.layerList[i];

			if (!tempSet$1.has(layer)) {
				tempSet$1.add(layer);
				const lights = layer._lights;

				for (let j = 0; j < lights.length; j++) {
					if (lights[j].castShadows) {
						const lightIndex = this._lightsMap.get(lights[j]);

						const lightCompData = this._lightCompositionData[lightIndex];
						lightCompData.addShadowCasters(layer.shadowCasters);
					}
				}
			}
		}

		tempSet$1.clear();
	}

	updateLights() {
		this._lights.length = 0;

		this._lightsMap.clear();

		const count = this.layerList.length;

		for (let i = 0; i < count; i++) {
			const layer = this.layerList[i];

			if (!tempSet$1.has(layer)) {
				tempSet$1.add(layer);
				const lights = layer._lights;

				for (let j = 0; j < lights.length; j++) {
					const light = lights[j];

					let lightIndex = this._lightsMap.get(light);

					if (lightIndex === undefined) {
						lightIndex = this._lights.length;

						this._lightsMap.set(light, lightIndex);

						this._lights.push(light);

						let lightCompData = this._lightCompositionData[lightIndex];

						if (!lightCompData) {
							lightCompData = new LightCompositionData();
							this._lightCompositionData[lightIndex] = lightCompData;
						}
					}
				}
			}

			this._splitLightsArray(layer);

			layer._dirtyLights = false;
		}

		tempSet$1.clear();

		this._splitLightsArray(this);

		const lightCount = this._lights.length;
		this._lightCompositionData.length = lightCount;
	}

	findCompatibleCluster(layer, renderActionCount) {
		for (let i = 0; i < renderActionCount; i++) {
			const ra = this._renderActions[i];
			const raLayer = this.layerList[ra.layerIndex];

			if (layer === raLayer) {
				return ra.lightClusters;
			}

			if (ra.lightClusters) {
				if (set.equals(layer._clusteredLightsSet, raLayer._clusteredLightsSet)) {
					return ra.lightClusters;
				}
			}
		}

		return null;
	}

	allocateLightClusters(device) {
		tempClusterArray.push(...this._worldClusters);
		this._worldClusters.length = 0;
		const count = this._renderActions.length;

		for (let i = 0; i < count; i++) {
			const ra = this._renderActions[i];
			const layer = this.layerList[ra.layerIndex];

			if (layer._clusteredLightsSet.size) {
				const transparent = this.subLayerList[ra.layerIndex];
				const meshInstances = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;

				if (meshInstances.length) {
					let clusters = this.findCompatibleCluster(layer, i);

					if (!clusters) {
						if (tempClusterArray.length) {
							clusters = tempClusterArray.pop();
						}

						if (!clusters) {
							clusters = new WorldClusters(device);
						}

						clusters.name = "Cluster-" + this._worldClusters.length;

						this._worldClusters.push(clusters);
					}

					ra.lightClusters = clusters;
				}
			}

			if (!ra.lightClusters) {
				ra.lightClusters = this.getEmptyWorldClusters(device);
			}
		}

		tempClusterArray.forEach(item => {
			item.destroy();
		});
		tempClusterArray.length = 0;
	}

	addRenderAction(renderActions, renderActionIndex, layer, layerIndex, cameraIndex, cameraFirstRenderAction, postProcessMarked) {
		let renderAction = renderActions[renderActionIndex];

		if (!renderAction) {
			renderAction = renderActions[renderActionIndex] = new RenderAction();
		}

		let rt = layer.renderTarget;
		const camera = layer.cameras[cameraIndex];

		if (camera && camera.renderTarget) {
			if (layer.id !== LAYERID_DEPTH) {
				rt = camera.renderTarget;
			}
		}

		let used = false;

		for (let i = renderActionIndex - 1; i >= 0; i--) {
			if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
				used = true;
				break;
			}
		}

		const needsClear = cameraFirstRenderAction || !used;
		let clearColor = needsClear ? camera.clearColorBuffer : false;
		let clearDepth = needsClear ? camera.clearDepthBuffer : false;
		let clearStencil = needsClear ? camera.clearStencilBuffer : false;
		clearColor |= layer.clearColorBuffer;
		clearDepth |= layer.clearDepthBuffer;
		clearStencil |= layer.clearStencilBuffer;

		if (postProcessMarked && camera.postEffectsEnabled) {
			rt = null;
		}

		renderAction.reset();
		renderAction.triggerPostprocess = false;
		renderAction.layerIndex = layerIndex;
		renderAction.cameraIndex = cameraIndex;
		renderAction.camera = camera;
		renderAction.renderTarget = rt;
		renderAction.clearColor = clearColor;
		renderAction.clearDepth = clearDepth;
		renderAction.clearStencil = clearStencil;
		renderAction.firstCameraUse = cameraFirstRenderAction;
		renderAction.lastCameraUse = false;
		return renderAction;
	}

	propagateRenderTarget(startIndex, fromCamera) {
		for (let a = startIndex; a >= 0; a--) {
			const ra = this._renderActions[a];
			const layer = this.layerList[ra.layerIndex];

			if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
				break;
			}

			if (layer.id === LAYERID_DEPTH) {
				continue;
			}

			const thisCamera = ra == null ? void 0 : ra.camera.camera;

			if (thisCamera) {
				if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
					break;
				}
			}

			ra.renderTarget = fromCamera.renderTarget;
		}
	}

	_logRenderActions() {}

	_isLayerAdded(layer) {
		if (this.layerList.indexOf(layer) >= 0) {
			return true;
		}

		return false;
	}

	_isSublayerAdded(layer, transparent) {
		for (let i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
				return true;
			}
		}

		return false;
	}

	push(layer) {
		if (this._isLayerAdded(layer)) return;
		this.layerList.push(layer);
		this.layerList.push(layer);
		this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
		this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
		this.subLayerEnabled.push(true);
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	insert(layer, index) {
		if (this._isLayerAdded(layer)) return;
		this.layerList.splice(index, 0, layer, layer);
		this.subLayerList.splice(index, 0, false, true);
		const count = this.layerList.length;

		this._updateOpaqueOrder(index, count - 1);

		this._updateTransparentOrder(index, count - 1);

		this.subLayerEnabled.splice(index, 0, true, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	remove(layer) {
		let id = this.layerList.indexOf(layer);
		delete this._opaqueOrder[id];
		delete this._transparentOrder[id];

		while (id >= 0) {
			this.layerList.splice(id, 1);
			this.subLayerList.splice(id, 1);
			this.subLayerEnabled.splice(id, 1);
			id = this.layerList.indexOf(layer);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("remove", layer);
		}

		const count = this.layerList.length;

		this._updateOpaqueOrder(0, count - 1);

		this._updateTransparentOrder(0, count - 1);
	}

	pushOpaque(layer) {
		if (this._isSublayerAdded(layer, false)) return;
		this.layerList.push(layer);
		this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	insertOpaque(layer, index) {
		if (this._isSublayerAdded(layer, false)) return;
		this.layerList.splice(index, 0, layer);
		this.subLayerList.splice(index, 0, false);
		const count = this.subLayerList.length;

		this._updateOpaqueOrder(index, count - 1);

		this.subLayerEnabled.splice(index, 0, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	removeOpaque(layer) {
		for (let i = 0, len = this.layerList.length; i < len; i++) {
			if (this.layerList[i] === layer && !this.subLayerList[i]) {
				this.layerList.splice(i, 1);
				this.subLayerList.splice(i, 1);
				len--;

				this._updateOpaqueOrder(i, len - 1);

				this.subLayerEnabled.splice(i, 1);
				this._dirty = true;
				this._dirtyLights = true;
				this._dirtyCameras = true;

				if (this.layerList.indexOf(layer) < 0) {
					this.fire("remove", layer);
				}

				return;
			}
		}
	}

	pushTransparent(layer) {
		if (this._isSublayerAdded(layer, true)) return;
		this.layerList.push(layer);
		this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	insertTransparent(layer, index) {
		if (this._isSublayerAdded(layer, true)) return;
		this.layerList.splice(index, 0, layer);
		this.subLayerList.splice(index, 0, true);
		const count = this.subLayerList.length;

		this._updateTransparentOrder(index, count - 1);

		this.subLayerEnabled.splice(index, 0, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	removeTransparent(layer) {
		for (let i = 0, len = this.layerList.length; i < len; i++) {
			if (this.layerList[i] === layer && this.subLayerList[i]) {
				this.layerList.splice(i, 1);
				this.subLayerList.splice(i, 1);
				len--;

				this._updateTransparentOrder(i, len - 1);

				this.subLayerEnabled.splice(i, 1);
				this._dirty = true;
				this._dirtyLights = true;
				this._dirtyCameras = true;

				if (this.layerList.indexOf(layer) < 0) {
					this.fire("remove", layer);
				}

				return;
			}
		}
	}

	_getSublayerIndex(layer, transparent) {
		let id = this.layerList.indexOf(layer);
		if (id < 0) return -1;

		if (this.subLayerList[id] !== transparent) {
			id = this.layerList.indexOf(layer, id + 1);
			if (id < 0) return -1;

			if (this.subLayerList[id] !== transparent) {
				return -1;
			}
		}

		return id;
	}

	getOpaqueIndex(layer) {
		return this._getSublayerIndex(layer, false);
	}

	getTransparentIndex(layer) {
		return this._getSublayerIndex(layer, true);
	}

	getLayerById(id) {
		for (let i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i].id === id) return this.layerList[i];
		}

		return null;
	}

	getLayerByName(name) {
		for (let i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i].name === name) return this.layerList[i];
		}

		return null;
	}

	_updateOpaqueOrder(startIndex, endIndex) {
		for (let i = startIndex; i <= endIndex; i++) {
			if (this.subLayerList[i] === false) {
				this._opaqueOrder[this.layerList[i].id] = i;
			}
		}
	}

	_updateTransparentOrder(startIndex, endIndex) {
		for (let i = startIndex; i <= endIndex; i++) {
			if (this.subLayerList[i] === true) {
				this._transparentOrder[this.layerList[i].id] = i;
			}
		}
	}

	_sortLayersDescending(layersA, layersB, order) {
		let topLayerA = -1;
		let topLayerB = -1;

		for (let i = 0, len = layersA.length; i < len; i++) {
			const id = layersA[i];

			if (order.hasOwnProperty(id)) {
				topLayerA = Math.max(topLayerA, order[id]);
			}
		}

		for (let i = 0, len = layersB.length; i < len; i++) {
			const id = layersB[i];

			if (order.hasOwnProperty(id)) {
				topLayerB = Math.max(topLayerB, order[id]);
			}
		}

		if (topLayerA === -1 && topLayerB !== -1) {
			return 1;
		} else if (topLayerB === -1 && topLayerA !== -1) {
			return -1;
		}

		return topLayerB - topLayerA;
	}

	sortTransparentLayers(layersA, layersB) {
		return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
	}

	sortOpaqueLayers(layersA, layersB) {
		return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
	}

}

const spotCenter = new Vec3();
const spotEndPoint = new Vec3();
const tmpVec = new Vec3();
const tmpBiases = {
	bias: 0,
	normalBias: 0
};
const chanId = {
	r: 0,
	g: 1,
	b: 2,
	a: 3
};
const directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];
let id = 0;

class LightRenderData {
	constructor(device, camera, face, light) {
		this.light = light;
		this.camera = camera;
		this.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);
		this.shadowMatrix = new Mat4();
		this.shadowViewport = new Vec4(0, 0, 1, 1);
		this.shadowScissor = new Vec4(0, 0, 1, 1);
		this.face = face;
		this.visibleCasters = [];
	}

	get shadowBuffer() {
		const rt = this.shadowCamera.renderTarget;

		if (rt) {
			const light = this.light;

			if (light._type === LIGHTTYPE_OMNI) {
				return rt.colorBuffer;
			}

			return light._isPcf && light.device.webgl2 ? rt.depthBuffer : rt.colorBuffer;
		}

		return null;
	}

}

class Light {
	constructor(graphicsDevice) {
		this.device = graphicsDevice;
		this.id = id++;
		this._type = LIGHTTYPE_DIRECTIONAL;
		this._color = new Color(0.8, 0.8, 0.8);
		this._intensity = 1;
		this._castShadows = false;
		this._enabled = false;
		this.mask = MASK_AFFECT_DYNAMIC;
		this.isStatic = false;
		this.key = 0;
		this.bakeDir = true;
		this.bakeNumSamples = 1;
		this.bakeArea = 0;
		this.attenuationStart = 10;
		this.attenuationEnd = 10;
		this._falloffMode = LIGHTFALLOFF_LINEAR;
		this._shadowType = SHADOW_PCF3;
		this._vsmBlurSize = 11;
		this.vsmBlurMode = BLUR_GAUSSIAN;
		this.vsmBias = 0.01 * 0.25;
		this._cookie = null;
		this.cookieIntensity = 1;
		this._cookieFalloff = true;
		this._cookieChannel = "rgb";
		this._cookieTransform = null;
		this._cookieTransformUniform = new Float32Array(4);
		this._cookieOffset = null;
		this._cookieOffsetUniform = new Float32Array(2);
		this._cookieTransformSet = false;
		this._cookieOffsetSet = false;
		this._innerConeAngle = 40;
		this._outerConeAngle = 45;
		this.cascades = null;
		this._shadowMatrixPalette = null;
		this._shadowCascadeDistances = null;
		this.numCascades = 1;
		this.cascadeDistribution = 0.5;
		this._shape = LIGHTSHAPE_PUNCTUAL;
		this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
		const c = Math.pow(this._finalColor[0], 2.2);
		this._linearFinalColor = new Float32Array([c, c, c]);
		this._position = new Vec3(0, 0, 0);
		this._direction = new Vec3(0, 0, 0);
		this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
		this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
		this._shadowMap = null;
		this._shadowRenderParams = [];
		this.shadowDistance = 40;
		this._shadowResolution = 1024;
		this.shadowBias = -0.0005;
		this._normalOffsetBias = 0.0;
		this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
		this._isVsm = false;
		this._isPcf = true;
		this._cookieMatrix = null;
		this._atlasViewport = null;
		this.atlasViewportAllocated = false;
		this.atlasVersion = 0;
		this.atlasSlotIndex = 0;
		this.atlasSlotUpdated = false;
		this._scene = null;
		this._node = null;
		this._renderData = [];
		this.visibleThisFrame = false;
		this.maxScreenSize = 0;
	}

	destroy() {
		this._destroyShadowMap();

		this._renderData = null;
	}

	set numCascades(value) {
		if (!this.cascades || this.numCascades != value) {
			this.cascades = directionalCascades[value - 1];
			this._shadowMatrixPalette = new Float32Array(4 * 16);
			this._shadowCascadeDistances = new Float32Array(4);

			this._destroyShadowMap();

			this.updateKey();
		}
	}

	get numCascades() {
		return this.cascades.length;
	}

	set shadowMap(shadowMap) {
		if (this._shadowMap !== shadowMap) {
			this._destroyShadowMap();

			this._shadowMap = shadowMap;
		}
	}

	get shadowMap() {
		return this._shadowMap;
	}

	get numShadowFaces() {
		const type = this._type;

		if (type === LIGHTTYPE_DIRECTIONAL) {
			return this.numCascades;
		} else if (type === LIGHTTYPE_OMNI) {
			return 6;
		}

		return 1;
	}

	set type(value) {
		if (this._type === value) return;
		this._type = value;

		this._destroyShadowMap();

		this.updateKey();
		const stype = this._shadowType;
		this._shadowType = null;
		this.shadowType = stype;
	}

	get type() {
		return this._type;
	}

	set shape(value) {
		if (this._shape === value) return;
		this._shape = value;

		this._destroyShadowMap();

		this.updateKey();
		const stype = this._shadowType;
		this._shadowType = null;
		this.shadowType = stype;
	}

	get shape() {
		return this._shape;
	}

	set shadowType(value) {
		if (this._shadowType === value) return;
		const device = this.device;
		if (this._type === LIGHTTYPE_OMNI) value = SHADOW_PCF3;

		if (value === SHADOW_PCF5 && !device.webgl2) {
			value = SHADOW_PCF3;
		}

		if (value === SHADOW_VSM32 && !device.textureFloatRenderable) value = SHADOW_VSM16;
		if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = SHADOW_VSM8;
		this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
		this._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;
		this._shadowType = value;

		this._destroyShadowMap();

		this.updateKey();
	}

	get shadowType() {
		return this._shadowType;
	}

	set enabled(value) {
		if (this._enabled !== value) {
			this._enabled = value;
			this.layersDirty();
		}
	}

	get enabled() {
		return this._enabled;
	}

	set castShadows(value) {
		if (this._castShadows !== value) {
			this._castShadows = value;

			this._destroyShadowMap();

			this.layersDirty();
			this.updateKey();
		}
	}

	get castShadows() {
		return this._castShadows && this.mask !== MASK_BAKE && this.mask !== 0;
	}

	set shadowResolution(value) {
		if (this._shadowResolution !== value) {
			if (this._type === LIGHTTYPE_OMNI) {
				value = Math.min(value, this.device.maxCubeMapSize);
			} else {
				value = Math.min(value, this.device.maxTextureSize);
			}

			this._shadowResolution = value;

			this._destroyShadowMap();
		}
	}

	get shadowResolution() {
		return this._shadowResolution;
	}

	set vsmBlurSize(value) {
		if (this._vsmBlurSize === value) return;
		if (value % 2 === 0) value++;
		this._vsmBlurSize = value;
	}

	get vsmBlurSize() {
		return this._vsmBlurSize;
	}

	set normalOffsetBias(value) {
		if (this._normalOffsetBias === value) return;

		if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
			this.updateKey();
		}

		this._normalOffsetBias = value;
	}

	get normalOffsetBias() {
		return this._normalOffsetBias;
	}

	set falloffMode(value) {
		if (this._falloffMode === value) return;
		this._falloffMode = value;
		this.updateKey();
	}

	get falloffMode() {
		return this._falloffMode;
	}

	set innerConeAngle(value) {
		if (this._innerConeAngle === value) return;
		this._innerConeAngle = value;
		this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
	}

	get innerConeAngle() {
		return this._innerConeAngle;
	}

	set outerConeAngle(value) {
		if (this._outerConeAngle === value) return;
		this._outerConeAngle = value;
		this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
	}

	get outerConeAngle() {
		return this._outerConeAngle;
	}

	set intensity(value) {
		if (this._intensity !== value) {
			this._intensity = value;

			this._updateFinalColor();
		}
	}

	get intensity() {
		return this._intensity;
	}

	get cookieMatrix() {
		if (!this._cookieMatrix) {
			this._cookieMatrix = new Mat4();
		}

		return this._cookieMatrix;
	}

	get atlasViewport() {
		if (!this._atlasViewport) {
			this._atlasViewport = new Vec4(0, 0, 1, 1);
		}

		return this._atlasViewport;
	}

	set cookie(value) {
		if (this._cookie === value) return;
		this._cookie = value;
		this.updateKey();
	}

	get cookie() {
		return this._cookie;
	}

	set cookieFalloff(value) {
		if (this._cookieFalloff === value) return;
		this._cookieFalloff = value;
		this.updateKey();
	}

	get cookieFalloff() {
		return this._cookieFalloff;
	}

	set cookieChannel(value) {
		if (this._cookieChannel === value) return;

		if (value.length < 3) {
			const chr = value.charAt(value.length - 1);
			const addLen = 3 - value.length;

			for (let i = 0; i < addLen; i++) value += chr;
		}

		this._cookieChannel = value;
		this.updateKey();
	}

	get cookieChannel() {
		return this._cookieChannel;
	}

	set cookieTransform(value) {
		if (this._cookieTransform === value) return;
		this._cookieTransform = value;
		this._cookieTransformSet = !!value;

		if (value && !this._cookieOffset) {
			this.cookieOffset = new Vec2();
			this._cookieOffsetSet = false;
		}

		this.updateKey();
	}

	get cookieTransform() {
		return this._cookieTransform;
	}

	set cookieOffset(value) {
		if (this._cookieOffset === value) return;
		const xformNew = !!(this._cookieTransformSet || value);

		if (xformNew && !value && this._cookieOffset) {
			this._cookieOffset.set(0, 0);
		} else {
			this._cookieOffset = value;
		}

		this._cookieOffsetSet = !!value;

		if (value && !this._cookieTransform) {
			this.cookieTransform = new Vec4(1, 1, 0, 0);
			this._cookieTransformSet = false;
		}

		this.updateKey();
	}

	get cookieOffset() {
		return this._cookieOffset;
	}

	beginFrame() {
		this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
		this.maxScreenSize = 0;
		this.atlasViewportAllocated = false;
		this.atlasSlotUpdated = false;
	}

	_destroyShadowMap() {
		if (this._renderData) {
			this._renderData.length = 0;
		}

		if (this._shadowMap) {
			if (!this._shadowMap.cached) {
				this._shadowMap.destroy();
			}

			this._shadowMap = null;
		}

		if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
			this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
		}
	}

	getRenderData(camera, face) {
		for (let i = 0; i < this._renderData.length; i++) {
			const current = this._renderData[i];

			if (current.camera === camera && current.face === face) {
				return current;
			}
		}

		const rd = new LightRenderData(this.device, camera, face, this);

		this._renderData.push(rd);

		return rd;
	}

	clone() {
		const clone = new Light(this.device);
		clone.type = this._type;
		clone.setColor(this._color);
		clone.intensity = this._intensity;
		clone.castShadows = this.castShadows;
		clone._enabled = this._enabled;
		clone.attenuationStart = this.attenuationStart;
		clone.attenuationEnd = this.attenuationEnd;
		clone.falloffMode = this._falloffMode;
		clone.shadowType = this._shadowType;
		clone.vsmBlurSize = this._vsmBlurSize;
		clone.vsmBlurMode = this.vsmBlurMode;
		clone.vsmBias = this.vsmBias;
		clone.shadowUpdateMode = this.shadowUpdateMode;
		clone.mask = this.mask;
		clone.innerConeAngle = this._innerConeAngle;
		clone.outerConeAngle = this._outerConeAngle;
		clone.numCascades = this.numCascades;
		clone.cascadeDistribution = this.cascadeDistribution;
		clone.shape = this._shape;
		clone.shadowBias = this.shadowBias;
		clone.normalOffsetBias = this._normalOffsetBias;
		clone.shadowResolution = this._shadowResolution;
		clone.shadowDistance = this.shadowDistance;
		return clone;
	}

	_getUniformBiasValues(lightRenderData) {
		const farClip = lightRenderData.shadowCamera._farClip;

		switch (this._type) {
			case LIGHTTYPE_OMNI:
				tmpBiases.bias = this.shadowBias;
				tmpBiases.normalBias = this._normalOffsetBias;
				break;

			case LIGHTTYPE_SPOT:
				if (this._isVsm) {
					tmpBiases.bias = -0.00001 * 20;
				} else {
					tmpBiases.bias = this.shadowBias * 20;
					if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
				}

				tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
				break;

			case LIGHTTYPE_DIRECTIONAL:
				if (this._isVsm) {
					tmpBiases.bias = -0.00001 * 20;
				} else {
					tmpBiases.bias = this.shadowBias / farClip * 100;
					if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
				}

				tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
				break;
		}

		return tmpBiases;
	}

	getColor() {
		return this._color;
	}

	getBoundingSphere(sphere) {
		if (this._type === LIGHTTYPE_SPOT) {
			const range = this.attenuationEnd;
			const angle = this._outerConeAngle;
			const f = Math.cos(angle * math.DEG_TO_RAD);
			const node = this._node;
			spotCenter.copy(node.up);
			spotCenter.mulScalar(-range * 0.5 * f);
			spotCenter.add(node.getPosition());
			sphere.center = spotCenter;
			spotEndPoint.copy(node.up);
			spotEndPoint.mulScalar(-range);
			tmpVec.copy(node.right);
			tmpVec.mulScalar(Math.sin(angle * math.DEG_TO_RAD) * range);
			spotEndPoint.add(tmpVec);
			sphere.radius = spotEndPoint.length() * 0.5;
		} else if (this._type === LIGHTTYPE_OMNI) {
			sphere.center = this._node.getPosition();
			sphere.radius = this.attenuationEnd;
		}
	}

	getBoundingBox(box) {
		if (this._type === LIGHTTYPE_SPOT) {
			const range = this.attenuationEnd;
			const angle = this._outerConeAngle;
			const node = this._node;
			const scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
			box.center.set(0, -range * 0.5, 0);
			box.halfExtents.set(scl, range * 0.5, scl);
			box.setFromTransformedAabb(box, node.getWorldTransform(), true);
		} else if (this._type === LIGHTTYPE_OMNI) {
			box.center.copy(this._node.getPosition());
			box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
		}
	}

	_updateFinalColor() {
		const color = this._color;
		const r = color.r;
		const g = color.g;
		const b = color.b;
		const i = this._intensity;
		const finalColor = this._finalColor;
		const linearFinalColor = this._linearFinalColor;
		finalColor[0] = r * i;
		finalColor[1] = g * i;
		finalColor[2] = b * i;

		if (i >= 1) {
			linearFinalColor[0] = Math.pow(r, 2.2) * i;
			linearFinalColor[1] = Math.pow(g, 2.2) * i;
			linearFinalColor[2] = Math.pow(b, 2.2) * i;
		} else {
			linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
			linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
			linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
		}
	}

	setColor() {
		if (arguments.length === 1) {
			this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
		} else if (arguments.length === 3) {
			this._color.set(arguments[0], arguments[1], arguments[2]);
		}

		this._updateFinalColor();
	}

	updateShadow() {
		if (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {
			this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
		}
	}

	layersDirty() {
		var _this$_scene;

		if ((_this$_scene = this._scene) != null && _this$_scene.layers) {
			this._scene.layers._dirtyLights = true;
		}
	}

	updateKey() {
		let key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;

		if (this._cookieChannel.length === 3) {
			key |= chanId[this._cookieChannel.charAt(1)] << 16;
			key |= chanId[this._cookieChannel.charAt(2)] << 14;
		}

		if (key !== this.key && this._scene !== null) {
			this.layersDirty();
		}

		this.key = key;
	}

}

class LightingParams {
	constructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {
		this._maxTextureSize = maxTextureSize;
		this._supportsAreaLights = supportsAreaLights;
		this._dirtyLightsFnc = dirtyLightsFnc;
		this._areaLightsEnabled = false;
		this._cells = new Vec3(10, 3, 10);
		this._maxLightsPerCell = 255;
		this._shadowsEnabled = true;
		this._shadowType = SHADOW_PCF3;
		this._shadowAtlasResolution = 2048;
		this._cookiesEnabled = false;
		this._cookieAtlasResolution = 2048;
		this.atlasSplit = null;
		this.debugLayer = undefined;
	}

	set cells(value) {
		this._cells.copy(value);
	}

	get cells() {
		return this._cells;
	}

	set maxLightsPerCell(value) {
		this._maxLightsPerCell = math.clamp(value, 1, 255);
	}

	get maxLightsPerCell() {
		return this._maxLightsPerCell;
	}

	set cookieAtlasResolution(value) {
		this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
	}

	get cookieAtlasResolution() {
		return this._cookieAtlasResolution;
	}

	set shadowAtlasResolution(value) {
		this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
	}

	get shadowAtlasResolution() {
		return this._shadowAtlasResolution;
	}

	set shadowType(value) {
		if (this._shadowType !== value) {
			this._shadowType = value;

			this._dirtyLightsFnc();
		}
	}

	get shadowType() {
		return this._shadowType;
	}

	set cookiesEnabled(value) {
		if (this._cookiesEnabled !== value) {
			this._cookiesEnabled = value;

			this._dirtyLightsFnc();
		}
	}

	get cookiesEnabled() {
		return this._cookiesEnabled;
	}

	set areaLightsEnabled(value) {
		if (this._supportsAreaLights) {
			if (this._areaLightsEnabled !== value) {
				this._areaLightsEnabled = value;

				this._dirtyLightsFnc();
			}
		}
	}

	get areaLightsEnabled() {
		return this._areaLightsEnabled;
	}

	set shadowsEnabled(value) {
		if (this._shadowsEnabled !== value) {
			this._shadowsEnabled = value;

			this._dirtyLightsFnc();
		}
	}

	get shadowsEnabled() {
		return this._shadowsEnabled;
	}

}

const tempSphere = new BoundingSphere();

class BakeLight {
	constructor(scene, light) {
		this.scene = scene;
		this.light = light;
		this.store();
		light.numCascades = 1;

		if (light.type !== LIGHTTYPE_DIRECTIONAL) {
			light._node.getWorldTransform();

			light.getBoundingSphere(tempSphere);
			this.lightBounds = new BoundingBox();
			this.lightBounds.center.copy(tempSphere.center);
			this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
		}
	}

	store() {
		this.mask = this.light.mask;
		this.shadowUpdateMode = this.light.shadowUpdateMode;
		this.enabled = this.light.enabled;
		this.intensity = this.light.intensity;
		this.rotation = this.light._node.getLocalRotation().clone();
		this.numCascades = this.light.numCascades;
	}

	restore() {
		const light = this.light;
		light.mask = this.mask;
		light.shadowUpdateMode = this.shadowUpdateMode;
		light.enabled = this.enabled;
		light.intensity = this.intensity;

		light._node.setLocalRotation(this.rotation);

		light.numCascades = this.numCascades;
	}

	startBake() {
		this.light.enabled = true;

		this.light._destroyShadowMap();
	}

	endBake(shadowMapCache) {
		const light = this.light;
		light.enabled = false;

		if (light.shadowMap) {
			if (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);
			light.shadowMap = null;
		}
	}

}

const _tempPoint$1 = new Vec2();

class BakeLightSimple extends BakeLight {
	get numVirtualLights() {
		if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
			return this.light.bakeNumSamples;
		}

		return 1;
	}

	prepareVirtualLight(index, numVirtualLights) {
		const light = this.light;

		light._node.setLocalRotation(this.rotation);

		if (index > 0) {
			const directionalSpreadAngle = light.bakeArea;
			random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);

			_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);

			light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
		}

		light._node.getWorldTransform();

		const gamma = this.scene.gammaCorrection ? 2.2 : 1;
		const linearIntensity = Math.pow(this.intensity, gamma);
		light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
	}

}

class AreaLightLuts {
	static createTexture(device, format, size) {
		const tex = new Texture(device, {
			width: size,
			height: size,
			format: format,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			type: TEXTURETYPE_DEFAULT,
			magFilter: FILTER_LINEAR,
			minFilter: FILTER_NEAREST,
			anisotropy: 1
		});
		tex.name = 'AreaLightLUT';
		return tex;
	}

	static setUniforms(device, texture1, texture2) {
		device.scope.resolve('areaLightsLutTex1').setValue(texture1);
		device.scope.resolve('areaLightsLutTex2').setValue(texture2);
	}

	static createPlaceholder(device) {
		const texture = AreaLightLuts.createTexture(device, PIXELFORMAT_R8_G8_B8_A8, 2);
		const pixels = texture.lock();
		pixels.fill(0);
		texture.unlock();
		AreaLightLuts.setUniforms(device, texture, texture);
	}

	static set(device, resource) {
		function buildTexture(device, data, format) {
			const texture = AreaLightLuts.createTexture(device, format, 64);
			texture.lock().set(data);
			texture.unlock();
			texture.upload();
			return texture;
		}

		function offsetScale(data, offset, scale) {
			const count = data.length;
			const ret = new Float32Array(count);

			for (let i = 0; i < count; i++) {
				const n = i % 4;
				ret[i] = (data[i] + offset[n]) * scale[n];
			}

			return ret;
		}

		function convertToHalfFloat(data) {
			const count = data.length;
			const ret = new Uint16Array(count);
			const float2Half = FloatPacking.float2Half;

			for (let i = 0; i < count; i++) {
				ret[i] = float2Half(data[i]);
			}

			return ret;
		}

		function convertToUint(data) {
			const count = data.length;
			const ret = new Uint8ClampedArray(count);

			for (let i = 0; i < count; i++) {
				ret[i] = data[i] * 255;
			}

			return ret;
		}

		const versions = new Int16Array(resource, 0, 2);
		const majorVersion = versions[0];
		const minorVersion = versions[1];

		if (majorVersion !== 0 || minorVersion !== 1) ; else {
			const srcData1 = new Float32Array(resource, 4, 16384);
			const srcData2 = new Float32Array(resource, 4 + 16384 * 4, 16384);
			let data1, data2;
			const format = device.areaLightLutFormat;

			if (format === PIXELFORMAT_RGBA32F) {
				data1 = srcData1;
				data2 = srcData2;
			} else if (format === PIXELFORMAT_RGBA16F) {
				data1 = convertToHalfFloat(srcData1);
				data2 = convertToHalfFloat(srcData2);
			} else {
				const o1 = [0.0, 0.2976, 0.01381, 0.0];
				const s1 = [0.999, 3.08737, 1.6546, 0.603249];
				const o2 = [-0.306897, 0.0, 0.0, 0.0];
				const s2 = [1.442787, 1.0, 1.0, 1.0];
				data1 = convertToUint(offsetScale(srcData1, o1, s1));
				data2 = convertToUint(offsetScale(srcData2, o2, s2));
			}

			const tex1 = buildTexture(device, data1, format);
			const tex2 = buildTexture(device, data2, format);
			AreaLightLuts.setUniforms(device, tex1, tex2);
		}
	}

}

let nonUniformScale;
let uniformScale = 1;
const particleTexChannels$1 = 4;
const rotMat = new Mat4();
const rotMatInv = new Mat4();
const randomPosTformed = new Vec3();
const randomPos = new Vec3();
const rndFactor3Vec = new Vec3();
const particlePosPrev = new Vec3();
const velocityVec = new Vec3();
const localVelocityVec = new Vec3();
const velocityVec2 = new Vec3();
const localVelocityVec2 = new Vec3();
const radialVelocityVec = new Vec3();
const particlePos = new Vec3();
const particleFinalPos = new Vec3();
const moveDirVec = new Vec3();
const tmpVec3$1 = new Vec3();

function frac(f) {
	return f - Math.floor(f);
}

function saturate$1(x) {
	return Math.max(Math.min(x, 1), 0);
}

function glMod(x, y) {
	return x - y * Math.floor(x / y);
}

function encodeFloatRGBA(v) {
	let encX = frac(v);
	let encY = frac(255.0 * v);
	let encZ = frac(65025.0 * v);
	let encW = frac(160581375.0 * v);
	encX -= encY / 255.0;
	encY -= encZ / 255.0;
	encZ -= encW / 255.0;
	encW -= encW / 255.0;
	return [encX, encY, encZ, encW];
}

function encodeFloatRG(v) {
	let encX = frac(v);
	let encY = frac(255.0 * v);
	encX -= encY / 255.0;
	encY -= encY / 255.0;
	return [encX, encY];
}

class ParticleCPUUpdater {
	constructor(emitter) {
		this._emitter = emitter;
	}

	calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
		const emitter = this._emitter;
		const rX = Math.random();
		const rY = Math.random();
		const rZ = Math.random();
		const rW = Math.random();

		if (emitter.useCpu) {
			particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
			particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
			particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
		}

		randomPos.x = rX - 0.5;
		randomPos.y = rY - 0.5;
		randomPos.z = rZ - 0.5;

		if (emitter.emitterShape === EMITTERSHAPE_BOX) {
			const max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
			const edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
			const edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
			const edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
			randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
			randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
			randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
			if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
		} else {
			randomPos.normalize();
			const spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
			const r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
			if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
		}

		const particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
		let startSpawnTime = -particleRate * i;

		if (emitter.pack8) {
			const packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
			const packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
			const packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
			let packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
			packA = packA % (Math.PI * 2) / (Math.PI * 2);
			const rg0 = encodeFloatRG(packX);
			particleTex[i * particleTexChannels$1] = rg0[0];
			particleTex[i * particleTexChannels$1 + 1] = rg0[1];
			const ba0 = encodeFloatRG(packY);
			particleTex[i * particleTexChannels$1 + 2] = ba0[0];
			particleTex[i * particleTexChannels$1 + 3] = ba0[1];
			const rg1 = encodeFloatRG(packZ);
			particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
			particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
			const ba1 = encodeFloatRG(packA);
			particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
			const a2 = 1.0;
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
			const maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
			const maxPosLife = emitter.lifetime + 1.0;
			startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
			const rgba3 = encodeFloatRGBA(startSpawnTime);
			particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
			particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
			particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
		} else {
			particleTex[i * particleTexChannels$1] = randomPosTformed.x;
			particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
			particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
			particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
		}
	}

	update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
		let a, b, c;
		const emitter = this._emitter;

		if (emitter.meshInstance.node) {
			const fullMat = emitter.meshInstance.node.worldTransform;

			for (let j = 0; j < 12; j++) {
				rotMat.data[j] = fullMat.data[j];
			}

			rotMatInv.copy(rotMat);
			rotMatInv.invert();
			nonUniformScale = emitter.meshInstance.node.localScale;
			uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
		}

		emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
		const posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
		const vertSize = !emitter.useMesh ? 15 : 17;
		let cf, cc;
		let rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
		const precision1 = emitter.precision - 1;

		for (let i = 0; i < emitter.numParticles; i++) {
			const id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
			const rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
			rndFactor3Vec.x = rndFactor;
			rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
			rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
			const particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
			const particleLifetime = emitter.lifetime;
			let life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
			const nlife = saturate$1(life / particleLifetime);
			let scale = 0;
			let alphaDiv = 0;
			const angle = 0;
			const respawn = life - delta <= 0.0 || life >= particleLifetime;

			if (respawn) {
				this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
			}

			let particleEnabled = life > 0.0 && life < particleLifetime;

			if (particleEnabled) {
				c = nlife * precision1;
				cf = Math.floor(c);
				cc = Math.ceil(c);
				c %= 1;
				a = emitter.qRotSpeed[cf];
				b = emitter.qRotSpeed[cc];
				rotSpeed = a + (b - a) * c;
				a = emitter.qRotSpeed2[cf];
				b = emitter.qRotSpeed2[cc];
				rotSpeed2 = a + (b - a) * c;
				a = emitter.qScale[cf];
				b = emitter.qScale[cc];
				scale = a + (b - a) * c;
				a = emitter.qScale2[cf];
				b = emitter.qScale2[cc];
				scale2 = a + (b - a) * c;
				a = emitter.qAlpha[cf];
				b = emitter.qAlpha[cc];
				alpha = a + (b - a) * c;
				a = emitter.qAlpha2[cf];
				b = emitter.qAlpha2[cc];
				alpha2 = a + (b - a) * c;
				a = emitter.qRadialSpeed[cf];
				b = emitter.qRadialSpeed[cc];
				radialSpeed = a + (b - a) * c;
				a = emitter.qRadialSpeed2[cf];
				b = emitter.qRadialSpeed2[cc];
				radialSpeed2 = a + (b - a) * c;
				radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
				particlePosPrev.x = particleTex[id * particleTexChannels$1];
				particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
				particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
				if (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);
				radialVelocityVec.normalize().mulScalar(radialSpeed);
				cf *= 3;
				cc *= 3;
				a = emitter.qLocalVelocity[cf];
				b = emitter.qLocalVelocity[cc];
				localVelocityVec.x = a + (b - a) * c;
				a = emitter.qLocalVelocity[cf + 1];
				b = emitter.qLocalVelocity[cc + 1];
				localVelocityVec.y = a + (b - a) * c;
				a = emitter.qLocalVelocity[cf + 2];
				b = emitter.qLocalVelocity[cc + 2];
				localVelocityVec.z = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf];
				b = emitter.qLocalVelocity2[cc];
				localVelocityVec2.x = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf + 1];
				b = emitter.qLocalVelocity2[cc + 1];
				localVelocityVec2.y = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf + 2];
				b = emitter.qLocalVelocity2[cc + 2];
				localVelocityVec2.z = a + (b - a) * c;
				a = emitter.qVelocity[cf];
				b = emitter.qVelocity[cc];
				velocityVec.x = a + (b - a) * c;
				a = emitter.qVelocity[cf + 1];
				b = emitter.qVelocity[cc + 1];
				velocityVec.y = a + (b - a) * c;
				a = emitter.qVelocity[cf + 2];
				b = emitter.qVelocity[cc + 2];
				velocityVec.z = a + (b - a) * c;
				a = emitter.qVelocity2[cf];
				b = emitter.qVelocity2[cc];
				velocityVec2.x = a + (b - a) * c;
				a = emitter.qVelocity2[cf + 1];
				b = emitter.qVelocity2[cc + 1];
				velocityVec2.y = a + (b - a) * c;
				a = emitter.qVelocity2[cf + 2];
				b = emitter.qVelocity2[cc + 2];
				velocityVec2.z = a + (b - a) * c;
				localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
				localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
				localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;

				if (emitter.initialVelocity > 0) {
					if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
						randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
						localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
					} else {
						localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
					}
				}

				velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
				velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
				velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
				rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
				scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
				alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);

				if (emitter.meshInstance.node) {
					if (!emitter.localSpace) {
						rotMat.transformPoint(localVelocityVec, localVelocityVec);
					} else {
						localVelocityVec.x /= nonUniformScale.x;
						localVelocityVec.y /= nonUniformScale.y;
						localVelocityVec.z /= nonUniformScale.z;
					}
				}

				if (!emitter.localSpace) {
					localVelocityVec.add(velocityVec.mul(nonUniformScale));
					localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
				} else {
					rotMatInv.transformPoint(velocityVec, velocityVec);
					localVelocityVec.add(velocityVec).add(radialVelocityVec);
				}

				moveDirVec.copy(localVelocityVec);
				particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
				particleFinalPos.copy(particlePos);
				particleTex[id * particleTexChannels$1] = particleFinalPos.x;
				particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
				particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
				particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;

				if (emitter.wrap && emitter.wrapBounds) {
					if (!emitter.localSpace) particleFinalPos.sub(emitterPos);
					particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
					particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
					particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
					if (!emitter.localSpace) particleFinalPos.add(emitterPos);
				}

				if (emitter.sort > 0) {
					if (emitter.sort === 1) {
						tmpVec3$1.copy(particleFinalPos).sub(posCam);
						emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
					} else if (emitter.sort === 2) {
						emitter.particleDistance[id] = life;
					} else if (emitter.sort === 3) {
						emitter.particleDistance[id] = -life;
					}
				}
			}

			if (isOnStop) {
				if (life < 0) {
					particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
				}
			} else {
				if (life >= particleLifetime) {
					life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
					particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
				}

				if (life < 0 && emitter.loop) {
					particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
				}
			}

			if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) particleEnabled = false;
			particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;

			for (let v = 0; v < emitter.numParticleVerts; v++) {
				const vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
				let quadX = emitter.vbCPU[vbOffset];
				let quadY = emitter.vbCPU[vbOffset + 1];
				let quadZ = emitter.vbCPU[vbOffset + 2];

				if (!particleEnabled) {
					quadX = quadY = quadZ = 0;
				}

				const w = i * emitter.numParticleVerts * vertSize + v * vertSize;
				data[w] = particleFinalPos.x;
				data[w + 1] = particleFinalPos.y;
				data[w + 2] = particleFinalPos.z;
				data[w + 3] = nlife;
				data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
				data[w + 5] = scale;
				data[w + 6] = alphaDiv;
				data[w + 7] = moveDirVec.x;
				data[w + 8] = quadX;
				data[w + 9] = quadY;
				data[w + 10] = quadZ;
				data[w + 11] = moveDirVec.y;
				data[w + 12] = id;
				data[w + 13] = moveDirVec.z;
				data[w + 14] = emitter.vbCPU[vbOffset + 3];

				if (emitter.useMesh) {
					data[w + 15] = emitter.vbCPU[vbOffset + 4];
					data[w + 16] = emitter.vbCPU[vbOffset + 5];
				}
			}
		}

		if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
			const vbStride = emitter.useMesh ? 6 : 4;
			const particleDistance = emitter.particleDistance;

			for (let i = 0; i < emitter.numParticles; i++) {
				vbToSort[i][0] = i;
				vbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];
			}

			emitter.vbOld.set(emitter.vbCPU);
			vbToSort.sort(function (p1, p2) {
				return p1[1] - p2[1];
			});

			for (let i = 0; i < emitter.numParticles; i++) {
				const src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;
				const dest = i * emitter.numParticleVerts * vbStride;

				for (let j = 0; j < emitter.numParticleVerts * vbStride; j++) {
					emitter.vbCPU[dest + j] = emitter.vbOld[src + j];
				}
			}
		}
	}

}

const spawnMatrix3 = new Mat3();
const emitterMatrix3 = new Mat3();
const emitterMatrix3Inv = new Mat3();

class ParticleGPUUpdater {
	constructor(emitter, gd) {
		this._emitter = emitter;
		this.frameRandomUniform = new Float32Array(3);
		this.emitterPosUniform = new Float32Array(3);
		this.emitterScaleUniform = new Float32Array([1, 1, 1]);
		this.worldBoundsMulUniform = new Float32Array(3);
		this.worldBoundsAddUniform = new Float32Array(3);
		this.inBoundsSizeUniform = new Float32Array(3);
		this.inBoundsCenterUniform = new Float32Array(3);
		this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
		this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
		this.constantEmitterPos = gd.scope.resolve("emitterPos");
		this.constantEmitterScale = gd.scope.resolve("emitterScale");
		this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
		this.constantSpawnPosInnerRatio = gd.scope.resolve("spawnPosInnerRatio");
		this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
		this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve("spawnBoundsSphereInnerRatio");
		this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
		this.constantFrameRandom = gd.scope.resolve("frameRandom");
		this.constantDelta = gd.scope.resolve("delta");
		this.constantRate = gd.scope.resolve("rate");
		this.constantRateDiv = gd.scope.resolve("rateDiv");
		this.constantLifetime = gd.scope.resolve("lifetime");
		this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
		this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
		this.constantInternalTex0 = gd.scope.resolve("internalTex0");
		this.constantInternalTex1 = gd.scope.resolve("internalTex1");
		this.constantInternalTex2 = gd.scope.resolve("internalTex2");
		this.constantInternalTex3 = gd.scope.resolve("internalTex3");
		this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
		this.constantEmitterMatrixInv = gd.scope.resolve("emitterMatrixInv");
		this.constantNumParticles = gd.scope.resolve("numParticles");
		this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
		this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
		this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
		this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
		this.constantSeed = gd.scope.resolve("seed");
		this.constantStartAngle = gd.scope.resolve("startAngle");
		this.constantStartAngle2 = gd.scope.resolve("startAngle2");
		this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
		this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
		this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
		this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
		this.constantMaxVel = gd.scope.resolve("maxVel");
		this.constantFaceTangent = gd.scope.resolve("faceTangent");
		this.constantFaceBinorm = gd.scope.resolve("faceBinorm");
	}

	_setInputBounds() {
		this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
		this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
		this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
		this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
		this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
		this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
		this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
		this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
	}

	randomize() {
		this.frameRandomUniform[0] = Math.random();
		this.frameRandomUniform[1] = Math.random();
		this.frameRandomUniform[2] = Math.random();
	}

	update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
		const emitter = this._emitter;
		device.setBlending(false);
		device.setColorWrite(true, true, true, true);
		device.setCullMode(CULLFACE_NONE);
		device.setDepthTest(false);
		device.setDepthWrite(false);
		this.randomize();
		this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
		this.constantGraphNumSamples.setValue(emitter.precision);
		this.constantNumParticles.setValue(emitter.numParticles);
		this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
		this.constantInternalTex0.setValue(emitter.internalTex0);
		this.constantInternalTex1.setValue(emitter.internalTex1);
		this.constantInternalTex2.setValue(emitter.internalTex2);
		this.constantInternalTex3.setValue(emitter.internalTex3);
		const node = emitter.meshInstance.node;
		const emitterScale = node === null ? Vec3.ONE : node.localScale;

		if (emitter.pack8) {
			this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
			this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
			this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
			this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
			this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
			this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
			this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
			this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);

			this._setInputBounds();

			let maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
			maxVel = Math.max(maxVel, 1);
			this.constantMaxVel.setValue(maxVel);
		}

		const emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
		const emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();

		if (emitter.emitterShape === EMITTERSHAPE_BOX) {
			spawnMatrix3.setFromMat4(spawnMatrix);
			this.constantSpawnBounds.setValue(spawnMatrix3.data);
			this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
		} else {
			this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
			this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
		}

		this.constantInitialVelocity.setValue(emitter.initialVelocity);
		emitterMatrix3.setFromMat4(emitterMatrix);
		emitterMatrix.invertTo3x3(emitterMatrix3Inv);
		this.emitterPosUniform[0] = emitterPos.x;
		this.emitterPosUniform[1] = emitterPos.y;
		this.emitterPosUniform[2] = emitterPos.z;
		this.constantEmitterPos.setValue(this.emitterPosUniform);
		this.constantFrameRandom.setValue(this.frameRandomUniform);
		this.constantDelta.setValue(delta);
		this.constantRate.setValue(emitter.rate);
		this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
		this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
		this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
		this.constantSeed.setValue(emitter.seed);
		this.constantLifetime.setValue(emitter.lifetime);
		this.emitterScaleUniform[0] = emitterScale.x;
		this.emitterScaleUniform[1] = emitterScale.y;
		this.emitterScaleUniform[2] = emitterScale.z;
		this.constantEmitterScale.setValue(this.emitterScaleUniform);
		this.constantEmitterMatrix.setValue(emitterMatrix3.data);
		this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
		this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
		this.constantVelocityDivMult.setValue(emitter.velocityUMax);
		this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
		let texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
		texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
		const texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
		this.constantParticleTexIN.setValue(texIN);
		drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
		emitter.material.setParameter("particleTexOUT", texIN);
		emitter.material.setParameter("particleTexIN", texOUT);
		emitter.beenReset = false;
		emitter.swapTex = !emitter.swapTex;
		device.setDepthTest(true);
		device.setDepthWrite(true);
		emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
		emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
		if (emitter.pack8) this._setInputBounds();
	}

}

const particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];

function _createTexture(device, width, height, pixelData, format = PIXELFORMAT_RGBA32F, mult8Bit, filter) {
	let mipFilter = FILTER_NEAREST;
	if (filter && format === PIXELFORMAT_R8_G8_B8_A8) mipFilter = FILTER_LINEAR;
	const texture = new Texture(device, {
		width: width,
		height: height,
		format: format,
		cubemap: false,
		mipmaps: false,
		minFilter: mipFilter,
		magFilter: mipFilter,
		addressU: ADDRESS_CLAMP_TO_EDGE,
		addressV: ADDRESS_CLAMP_TO_EDGE
	});
	texture.name = "PSTexture";
	const pixels = texture.lock();

	if (format === PIXELFORMAT_R8_G8_B8_A8) {
		const temp = new Uint8Array(pixelData.length);

		for (let i = 0; i < pixelData.length; i++) {
			temp[i] = pixelData[i] * mult8Bit * 255;
		}

		pixelData = temp;
	}

	pixels.set(pixelData);
	texture.unlock();
	return texture;
}

function saturate(x) {
	return Math.max(Math.min(x, 1), 0);
}

const default0Curve = new Curve([0, 0, 1, 0]);
const default1Curve = new Curve([0, 1, 1, 1]);
const default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
const default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
let particleTexHeight = 2;
const particleTexChannels = 4;
const extentsInnerRatioUniform = new Float32Array(3);
const spawnMatrix = new Mat4();
const tmpVec3 = new Vec3();
const bMin = new Vec3();
const bMax = new Vec3();
let setPropertyTarget;
let setPropertyOptions;

function setProperty(pName, defaultVal) {
	if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
		setPropertyTarget[pName] = setPropertyOptions[pName];
	} else {
		setPropertyTarget[pName] = defaultVal;
	}
}

function pack3NFloats(a, b, c) {
	const packed = a * 255 << 16 | b * 255 << 8 | c * 255;
	return packed / (1 << 24);
}

function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
	const num = qXYZ.length / 3;
	const colors = new Array(num * 4);

	for (let i = 0; i < num; i++) {
		colors[i * 4] = qXYZ[i * 3];
		colors[i * 4 + 1] = qXYZ[i * 3 + 1];
		colors[i * 4 + 2] = qXYZ[i * 3 + 2];
		colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
	}

	return colors;
}

function packTextureRGBA(qRGB, qA) {
	const colors = new Array(qA.length * 4);

	for (let i = 0; i < qA.length; i++) {
		colors[i * 4] = qRGB[i * 3];
		colors[i * 4 + 1] = qRGB[i * 3 + 1];
		colors[i * 4 + 2] = qRGB[i * 3 + 2];
		colors[i * 4 + 3] = qA[i];
	}

	return colors;
}

function packTexture5Floats(qA, qB, qC, qD, qE) {
	const colors = new Array(qA.length * 4);

	for (let i = 0; i < qA.length; i++) {
		colors[i * 4] = qA[i];
		colors[i * 4 + 1] = qB[i];
		colors[i * 4 + 2] = 0;
		colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
	}

	return colors;
}

function packTexture2Floats(qA, qB) {
	const colors = new Array(qA.length * 4);

	for (let i = 0; i < qA.length; i++) {
		colors[i * 4] = qA[i];
		colors[i * 4 + 1] = qB[i];
		colors[i * 4 + 2] = 0;
		colors[i * 4 + 3] = 0;
	}

	return colors;
}

function calcEndTime(emitter) {
	const interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
	return Date.now() + interval * 1000;
}

function subGraph(A, B) {
	const r = new Float32Array(A.length);

	for (let i = 0; i < A.length; i++) {
		r[i] = A[i] - B[i];
	}

	return r;
}

function maxUnsignedGraphValue(A, outUMax) {
	const chans = outUMax.length;
	const values = A.length / chans;

	for (let i = 0; i < values; i++) {
		for (let j = 0; j < chans; j++) {
			const a = Math.abs(A[i * chans + j]);
			outUMax[j] = Math.max(outUMax[j], a);
		}
	}
}

function normalizeGraph(A, uMax) {
	const chans = uMax.length;
	const values = A.length / chans;

	for (let i = 0; i < values; i++) {
		for (let j = 0; j < chans; j++) {
			A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
			A[i * chans + j] *= 0.5;
			A[i * chans + j] += 0.5;
		}
	}
}

function divGraphFrom2Curves(curve1, curve2, outUMax) {
	const sub = subGraph(curve2, curve1);
	maxUnsignedGraphValue(sub, outUMax);
	normalizeGraph(sub, outUMax);
	return sub;
}

class ParticleEmitter {
	constructor(graphicsDevice, options) {
		this.graphicsDevice = graphicsDevice;
		const gd = graphicsDevice;
		const precision = 32;
		this.precision = precision;
		this._addTimeTime = 0;
		ParticleEmitter.staticInit(gd);
		setPropertyTarget = this;
		setPropertyOptions = options;
		setProperty("numParticles", 1);

		if (this.numParticles > graphicsDevice.maxTextureSize) {
			this.numParticles = graphicsDevice.maxTextureSize;
		}

		setProperty("rate", 1);
		setProperty("rate2", this.rate);
		setProperty("lifetime", 50);
		setProperty("emitterExtents", new Vec3(0, 0, 0));
		setProperty("emitterExtentsInner", new Vec3(0, 0, 0));
		setProperty("emitterRadius", 0);
		setProperty("emitterRadiusInner", 0);
		setProperty("emitterShape", EMITTERSHAPE_BOX);
		setProperty("initialVelocity", 1);
		setProperty("wrap", false);
		setProperty("localSpace", false);
		setProperty("screenSpace", false);
		setProperty("wrapBounds", null);
		setProperty("colorMap", ParticleEmitter.DEFAULT_PARAM_TEXTURE);
		setProperty("normalMap", null);
		setProperty("loop", true);
		setProperty("preWarm", false);
		setProperty("sort", PARTICLESORT_NONE);
		setProperty("mode", PARTICLEMODE_GPU);
		setProperty("scene", null);
		setProperty("lighting", false);
		setProperty("halfLambert", false);
		setProperty("intensity", 1.0);
		setProperty("stretch", 0.0);
		setProperty("alignToMotion", false);
		setProperty("depthSoftening", 0);
		setProperty("mesh", null);
		setProperty("particleNormal", new Vec3(0, 1, 0));
		setProperty("orientation", PARTICLEORIENTATION_SCREEN);
		setProperty("depthWrite", false);
		setProperty("noFog", false);
		setProperty("blendType", BLEND_NORMAL);
		setProperty("node", null);
		setProperty("startAngle", 0);
		setProperty("startAngle2", this.startAngle);
		setProperty("animTilesX", 1);
		setProperty("animTilesY", 1);
		setProperty("animStartFrame", 0);
		setProperty("animNumFrames", 1);
		setProperty("animNumAnimations", 1);
		setProperty("animIndex", 0);
		setProperty("randomizeAnimIndex", false);
		setProperty("animSpeed", 1);
		setProperty("animLoop", true);
		this._gpuUpdater = new ParticleGPUUpdater(this, gd);
		this._cpuUpdater = new ParticleCPUUpdater(this);
		this.constantLightCube = gd.scope.resolve("lightCube[0]");
		this.emitterPosUniform = new Float32Array(3);
		this.wrapBoundsUniform = new Float32Array(3);
		this.emitterScaleUniform = new Float32Array([1, 1, 1]);
		setProperty("colorGraph", default1Curve3);
		setProperty("colorGraph2", this.colorGraph);
		setProperty("scaleGraph", default1Curve);
		setProperty("scaleGraph2", this.scaleGraph);
		setProperty("alphaGraph", default1Curve);
		setProperty("alphaGraph2", this.alphaGraph);
		setProperty("localVelocityGraph", default0Curve3);
		setProperty("localVelocityGraph2", this.localVelocityGraph);
		setProperty("velocityGraph", default0Curve3);
		setProperty("velocityGraph2", this.velocityGraph);
		setProperty("rotationSpeedGraph", default0Curve);
		setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);
		setProperty("radialSpeedGraph", default0Curve);
		setProperty("radialSpeedGraph2", this.radialSpeedGraph);
		this.lightCube = new Float32Array(6 * 3);
		this.lightCubeDir = new Array(6);
		this.lightCubeDir[0] = new Vec3(-1, 0, 0);
		this.lightCubeDir[1] = new Vec3(1, 0, 0);
		this.lightCubeDir[2] = new Vec3(0, -1, 0);
		this.lightCubeDir[3] = new Vec3(0, 1, 0);
		this.lightCubeDir[4] = new Vec3(0, 0, -1);
		this.lightCubeDir[5] = new Vec3(0, 0, 1);
		this.animTilesParams = new Float32Array(2);
		this.animParams = new Float32Array(4);
		this.animIndexParams = new Float32Array(2);
		this.internalTex0 = null;
		this.internalTex1 = null;
		this.internalTex2 = null;
		this.colorParam = null;
		this.vbToSort = null;
		this.vbOld = null;
		this.particleDistance = null;
		this.camera = null;
		this.swapTex = false;
		this.useMesh = true;
		this.useCpu = false;
		this.pack8 = true;
		this.localBounds = new BoundingBox();
		this.worldBoundsNoTrail = new BoundingBox();
		this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
		this.worldBounds = new BoundingBox();
		this.worldBoundsSize = new Vec3();
		this.prevWorldBoundsSize = new Vec3();
		this.prevWorldBoundsCenter = new Vec3();
		this.prevEmitterExtents = this.emitterExtents;
		this.prevEmitterRadius = this.emitterRadius;
		this.worldBoundsMul = new Vec3();
		this.worldBoundsAdd = new Vec3();
		this.timeToSwitchBounds = 0;
		this.shaderParticleUpdateRespawn = null;
		this.shaderParticleUpdateNoRespawn = null;
		this.shaderParticleUpdateOnStop = null;
		this.numParticleVerts = 0;
		this.numParticleIndices = 0;
		this.material = null;
		this.meshInstance = null;
		this.drawOrder = 0;
		this.seed = Math.random();
		this.fixedTimeStep = 1.0 / 60;
		this.maxSubSteps = 10;
		this.simTime = 0;
		this.simTimeTotal = 0;
		this.beenReset = false;
		this._layer = null;
		this.rebuild();
	}

	static staticInit(device) {
		if (!ParticleEmitter.DEFAULT_PARAM_TEXTURE) {
			const resolution = 16;
			const centerPoint = resolution * 0.5 + 0.5;
			const dtex = new Float32Array(resolution * resolution * 4);

			for (let y = 0; y < resolution; y++) {
				for (let x = 0; x < resolution; x++) {
					const xgrad = x + 1 - centerPoint;
					const ygrad = y + 1 - centerPoint;
					const c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
					const p = y * resolution + x;
					dtex[p * 4] = 1;
					dtex[p * 4 + 1] = 1;
					dtex[p * 4 + 2] = 1;
					dtex[p * 4 + 3] = c;
				}
			}

			ParticleEmitter.DEFAULT_PARAM_TEXTURE = _createTexture(device, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
			ParticleEmitter.DEFAULT_PARAM_TEXTURE.minFilter = FILTER_LINEAR;
			ParticleEmitter.DEFAULT_PARAM_TEXTURE.magFilter = FILTER_LINEAR;
		}
	}

	static staticDestroy() {
		if (ParticleEmitter.DEFAULT_PARAM_TEXTURE) {
			ParticleEmitter.DEFAULT_PARAM_TEXTURE.destroy();
			ParticleEmitter.DEFAULT_PARAM_TEXTURE = null;
		}
	}

	onChangeCamera() {
		this.regenShader();
		this.resetMaterial();
	}

	calculateBoundsMad() {
		this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
		this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
		this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
		this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
		this.worldBoundsAdd.x += 0.5;
		this.worldBoundsAdd.y += 0.5;
		this.worldBoundsAdd.z += 0.5;
	}

	calculateWorldBounds() {
		if (!this.node) return;
		this.prevWorldBoundsSize.copy(this.worldBoundsSize);
		this.prevWorldBoundsCenter.copy(this.worldBounds.center);

		if (!this.useCpu) {
			let recalculateLocalBounds = false;

			if (this.emitterShape === EMITTERSHAPE_BOX) {
				recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
			} else {
				recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
			}

			if (recalculateLocalBounds) {
				this.calculateLocalBounds();
			}
		}

		const nodeWT = this.node.getWorldTransform();

		if (this.localSpace) {
			this.worldBoundsNoTrail.copy(this.localBounds);
		} else {
			this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
		}

		this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
		this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
		const now = this.simTimeTotal;

		if (now >= this.timeToSwitchBounds) {
			this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
			this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
			this.timeToSwitchBounds = now + this.lifetime;
		}

		this.worldBounds.copy(this.worldBoundsTrail[0]);
		this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);

		if (this.localSpace) {
			this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
			this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
		} else {
			this.meshInstance.aabb.copy(this.worldBounds);
			this.meshInstance.mesh.aabb.copy(this.worldBounds);
		}

		this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
		if (this.pack8) this.calculateBoundsMad();
	}

	resetWorldBounds() {
		if (!this.node) return;
		this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
		this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
		this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
		this.worldBounds.copy(this.worldBoundsTrail[0]);
		this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
		this.prevWorldBoundsSize.copy(this.worldBoundsSize);
		this.prevWorldBoundsCenter.copy(this.worldBounds.center);
		this.simTimeTotal = 0;
		this.timeToSwitchBounds = 0;
	}

	calculateLocalBounds() {
		let minx = Number.MAX_VALUE;
		let miny = Number.MAX_VALUE;
		let minz = Number.MAX_VALUE;
		let maxx = -Number.MAX_VALUE;
		let maxy = -Number.MAX_VALUE;
		let maxz = -Number.MAX_VALUE;
		let maxR = 0;
		let maxScale = 0;
		const stepWeight = this.lifetime / this.precision;
		const wVels = [this.qVelocity, this.qVelocity2];
		const lVels = [this.qLocalVelocity, this.qLocalVelocity2];
		const accumX = [0, 0];
		const accumY = [0, 0];
		const accumZ = [0, 0];
		const accumR = [0, 0];
		const accumW = [0, 0];
		let x, y, z;

		for (let i = 0; i < this.precision + 1; i++) {
			const index = Math.min(i, this.precision - 1);

			for (let j = 0; j < 2; j++) {
				x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
				y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
				z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
				minx = Math.min(x, minx);
				miny = Math.min(y, miny);
				minz = Math.min(z, minz);
				maxx = Math.max(x, maxx);
				maxy = Math.max(y, maxy);
				maxz = Math.max(z, maxz);
				accumX[j] = x;
				accumY[j] = y;
				accumZ[j] = z;
			}

			for (let j = 0; j < 2; j++) {
				accumW[j] += stepWeight * Math.sqrt(wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] + wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] + wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);
			}

			accumR[0] += this.qRadialSpeed[index] * stepWeight;
			accumR[1] += this.qRadialSpeed2[index] * stepWeight;
			maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
			maxScale = Math.max(maxScale, this.qScale[index]);
		}

		if (this.emitterShape === EMITTERSHAPE_BOX) {
			x = this.emitterExtents.x * 0.5;
			y = this.emitterExtents.y * 0.5;
			z = this.emitterExtents.z * 0.5;
		} else {
			x = this.emitterRadius;
			y = this.emitterRadius;
			z = this.emitterRadius;
		}

		const w = Math.max(accumW[0], accumW[1]);
		bMin.x = minx - maxScale - x - maxR - w;
		bMin.y = miny - maxScale - y - maxR - w;
		bMin.z = minz - maxScale - z - maxR - w;
		bMax.x = maxx + maxScale + x + maxR + w;
		bMax.y = maxy + maxScale + y + maxR + w;
		bMax.z = maxz + maxScale + z + maxR + w;
		this.localBounds.setMinMax(bMin, bMax);
	}

	rebuild() {
		const gd = this.graphicsDevice;
		if (this.colorMap === null) this.colorMap = ParticleEmitter.DEFAULT_PARAM_TEXTURE;
		this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
		this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;

		this._destroyResources();

		this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
		particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
		this.useMesh = false;

		if (this.mesh) {
			const totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;

			if (totalVertCount > 65535) ; else {
				this.useMesh = true;
			}
		}

		this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
		this.rebuildGraphs();
		this.calculateLocalBounds();
		this.resetWorldBounds();

		if (this.node) {
			this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
			this.worldBoundsTrail[0].copy(this.worldBounds);
			this.worldBoundsTrail[1].copy(this.worldBounds);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			if (this.pack8) this.calculateBoundsMad();
		}

		this.vbToSort = new Array(this.numParticles);

		for (let iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];

		this.particleDistance = new Float32Array(this.numParticles);

		this._gpuUpdater.randomize();

		this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
		const emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();

		if (this.emitterShape === EMITTERSHAPE_BOX) {
			if (this.node === null || this.localSpace) {
				spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
			} else {
				spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
			}

			extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
			extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
			extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
		}

		for (let i = 0; i < this.numParticles; i++) {
			this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);

			if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
		}

		this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);

		for (let i = 0; i < this.particleTexStart.length; i++) {
			this.particleTexStart[i] = this.particleTex[i];
		}

		if (!this.useCpu) {
			if (this.pack8) {
				this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
				this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
				this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);
			} else {
				this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
				this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
				this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
			}

			this.rtParticleTexIN = new RenderTarget({
				colorBuffer: this.particleTexIN,
				depth: false
			});
			this.rtParticleTexOUT = new RenderTarget({
				colorBuffer: this.particleTexOUT,
				depth: false
			});
			this.swapTex = false;
		}

		const shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
		const shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
		const shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
		const shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
		const params = this.emitterShape + "" + this.pack8 + "" + this.localSpace;
		this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, "fsQuad0" + params);
		this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, "fsQuad1" + params);
		this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, "fsQuad2" + params);
		this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
		this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;

		this._allocate(this.numParticles);

		const mesh = new Mesh(gd);
		mesh.vertexBuffer = this.vertexBuffer;
		mesh.indexBuffer[0] = this.indexBuffer;
		mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
		mesh.primitive[0].base = 0;
		mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
		mesh.primitive[0].indexed = true;
		this.material = new Material$1();
		this.material.name = this.node.name;
		this.material.cull = CULLFACE_NONE;
		this.material.alphaWrite = false;
		this.material.blend = true;
		this.material.blendType = this.blendType;
		this.material.depthWrite = this.depthWrite;
		this.material.emitter = this;
		this.regenShader();
		this.resetMaterial();
		const wasVisible = this.meshInstance ? this.meshInstance.visible : true;
		this.meshInstance = new MeshInstance(mesh, this.material, this.node);
		this.meshInstance.pick = false;
		this.meshInstance.updateKey();
		this.meshInstance.cull = true;
		this.meshInstance._noDepthDrawGl1 = true;

		if (this.localSpace) {
			this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
		} else {
			this.meshInstance.aabb.copy(this.worldBounds);
		}

		this.meshInstance._updateAabb = false;
		this.meshInstance.visible = wasVisible;

		this._initializeTextures();

		this.resetTime();
		this.addTime(0, false);
		if (this.preWarm) this.prewarm(this.lifetime);
	}

	_isAnimated() {
		return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== ParticleEmitter.DEFAULT_PARAM_TEXTURE || this.normalMap);
	}

	rebuildGraphs() {
		const precision = this.precision;
		const gd = this.graphicsDevice;
		this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
		this.qVelocity = this.velocityGraph.quantize(precision);
		this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
		this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
		this.qScale = this.scaleGraph.quantize(precision);
		this.qAlpha = this.alphaGraph.quantize(precision);
		this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
		this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
		this.qVelocity2 = this.velocityGraph2.quantize(precision);
		this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
		this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
		this.qScale2 = this.scaleGraph2.quantize(precision);
		this.qAlpha2 = this.alphaGraph2.quantize(precision);
		this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);

		for (let i = 0; i < precision; i++) {
			this.qRotSpeed[i] *= math.DEG_TO_RAD;
			this.qRotSpeed2[i] *= math.DEG_TO_RAD;
		}

		this.localVelocityUMax = new Float32Array(3);
		this.velocityUMax = new Float32Array(3);
		this.colorUMax = new Float32Array(3);
		this.rotSpeedUMax = [0];
		this.scaleUMax = [0];
		this.alphaUMax = [0];
		this.radialSpeedUMax = [0];
		this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
		this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
		this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
		this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
		this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
		this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
		this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);

		if (this.pack8) {
			const umax = [0, 0, 0];
			maxUnsignedGraphValue(this.qVelocity, umax);
			const umax2 = [0, 0, 0];
			maxUnsignedGraphValue(this.qVelocity2, umax2);
			const lumax = [0, 0, 0];
			maxUnsignedGraphValue(this.qLocalVelocity, lumax);
			const lumax2 = [0, 0, 0];
			maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
			const rumax = [0];
			maxUnsignedGraphValue(this.qRadialSpeed, rumax);
			const rumax2 = [0];
			maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
			let maxVel = Math.max(umax[0], umax2[0]);
			maxVel = Math.max(maxVel, umax[1]);
			maxVel = Math.max(maxVel, umax2[1]);
			maxVel = Math.max(maxVel, umax[2]);
			maxVel = Math.max(maxVel, umax2[2]);
			let lmaxVel = Math.max(lumax[0], lumax2[0]);
			lmaxVel = Math.max(lmaxVel, lumax[1]);
			lmaxVel = Math.max(lmaxVel, lumax2[1]);
			lmaxVel = Math.max(lmaxVel, lumax[2]);
			lmaxVel = Math.max(lmaxVel, lumax2[2]);
			const maxRad = Math.max(rumax[0], rumax2[0]);
			this.maxVel = maxVel + lmaxVel + maxRad;
		}

		if (!this.useCpu) {
			this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
			this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
			this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
			this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
		}

		this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
	}

	_initializeTextures() {
		if (this.colorMap) {
			this.material.setParameter('colorMap', this.colorMap);

			if (this.lighting && this.normalMap) {
				this.material.setParameter('normalMap', this.normalMap);
			}
		}
	}

	regenShader() {
		const programLib = this.graphicsDevice.getProgramLibrary();
		const hasNormal = this.normalMap !== null;
		this.normalOption = 0;

		if (this.lighting) {
			this.normalOption = hasNormal ? 2 : 1;
		}

		this.material.updateShader = function () {
			if (this.emitter.scene) {
				if (this.emitter.camera !== this.emitter.scene._activeCamera) {
					this.emitter.camera = this.emitter.scene._activeCamera;
					this.emitter.onChangeCamera();
				}
			}

			const inTools = this.emitter.inTools;
			const shader = programLib.getProgram("particle", {
				useCpu: this.emitter.useCpu,
				normal: this.emitter.normalOption,
				halflambert: this.emitter.halfLambert,
				stretch: this.emitter.stretch,
				alignToMotion: this.emitter.alignToMotion,
				soft: this.emitter.depthSoftening,
				mesh: this.emitter.useMesh,
				gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
				toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
				fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none",
				wrap: this.emitter.wrap && this.emitter.wrapBounds,
				localSpace: this.emitter.localSpace,
				screenSpace: inTools ? false : this.emitter.screenSpace,
				blend: this.blendType,
				animTex: this.emitter._isAnimated(),
				animTexLoop: this.emitter.animLoop,
				pack8: this.emitter.pack8,
				customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
			});
			this.shader = shader;
		};

		this.material.updateShader();
	}

	resetMaterial() {
		const material = this.material;
		material.setParameter('stretch', this.stretch);

		if (this._isAnimated()) {
			material.setParameter('animTexTilesParams', this.animTilesParams);
			material.setParameter('animTexParams', this.animParams);
			material.setParameter('animTexIndexParams', this.animIndexParams);
		}

		material.setParameter('colorMult', this.intensity);

		if (!this.useCpu) {
			material.setParameter('internalTex0', this.internalTex0);
			material.setParameter('internalTex1', this.internalTex1);
			material.setParameter('internalTex2', this.internalTex2);
			material.setParameter('internalTex3', this.internalTex3);
		}

		material.setParameter('colorParam', this.colorParam);
		material.setParameter('numParticles', this.numParticles);
		material.setParameter('numParticlesPot', this.numParticlesPot);
		material.setParameter('lifetime', this.lifetime);
		material.setParameter('rate', this.rate);
		material.setParameter('rateDiv', this.rate2 - this.rate);
		material.setParameter('seed', this.seed);
		material.setParameter('scaleDivMult', this.scaleUMax[0]);
		material.setParameter('alphaDivMult', this.alphaUMax[0]);
		material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
		material.setParameter("graphNumSamples", this.precision);
		material.setParameter("graphSampleSize", 1.0 / this.precision);
		material.setParameter("emitterScale", new Float32Array([1, 1, 1]));

		if (this.pack8) {
			this._gpuUpdater._setInputBounds();

			material.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform);
			material.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform);
			material.setParameter("maxVel", this.maxVel);
		}

		if (this.wrap && this.wrapBounds) {
			this.wrapBoundsUniform[0] = this.wrapBounds.x;
			this.wrapBoundsUniform[1] = this.wrapBounds.y;
			this.wrapBoundsUniform[2] = this.wrapBounds.z;
			material.setParameter('wrapBounds', this.wrapBoundsUniform);
		}

		if (this.colorMap) {
			material.setParameter('colorMap', this.colorMap);
		}

		if (this.lighting) {
			if (this.normalMap) {
				material.setParameter('normalMap', this.normalMap);
			}
		}

		if (this.depthSoftening > 0) {
			material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
		}

		if (this.stretch > 0.0) material.cull = CULLFACE_NONE;

		this._compParticleFaceParams();
	}

	_compParticleFaceParams() {
		let tangent, binormal;

		if (this.orientation === PARTICLEORIENTATION_SCREEN) {
			tangent = new Float32Array([1, 0, 0]);
			binormal = new Float32Array([0, 0, 1]);
		} else {
			let n;

			if (this.orientation === PARTICLEORIENTATION_WORLD) {
				n = this.particleNormal.normalize();
			} else {
				const emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
				n = emitterMat.transformVector(this.particleNormal).normalize();
			}

			const t = new Vec3(1, 0, 0);
			if (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);
			const b = new Vec3().cross(n, t).normalize();
			t.cross(b, n).normalize();
			tangent = new Float32Array([t.x, t.y, t.z]);
			binormal = new Float32Array([b.x, b.y, b.z]);
		}

		this.material.setParameter("faceTangent", tangent);
		this.material.setParameter("faceBinorm", binormal);
	}

	_allocate(numParticles) {
		const psysVertCount = numParticles * this.numParticleVerts;
		const psysIndexCount = numParticles * this.numParticleIndices;

		if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
			if (!this.useCpu) {
				const elements = [{
					semantic: SEMANTIC_ATTR0,
					components: 4,
					type: TYPE_FLOAT32
				}];

				if (this.useMesh) {
					elements.push({
						semantic: SEMANTIC_ATTR1,
						components: 2,
						type: TYPE_FLOAT32
					});
				}

				const particleFormat = new VertexFormat(this.graphicsDevice, elements);
				this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
				this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
			} else {
				const elements = [{
					semantic: SEMANTIC_ATTR0,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR1,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR2,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR3,
					components: 1,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR4,
					components: this.useMesh ? 4 : 2,
					type: TYPE_FLOAT32
				}];
				const particleFormat = new VertexFormat(this.graphicsDevice, elements);
				this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
				this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
			}

			const data = new Float32Array(this.vertexBuffer.lock());
			let meshData, stride, texCoordOffset;

			if (this.useMesh) {
				meshData = new Float32Array(this.mesh.vertexBuffer.lock());
				stride = meshData.length / this.mesh.vertexBuffer.numVertices;

				for (let elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
					if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
						texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
						break;
					}
				}
			}

			for (let i = 0; i < psysVertCount; i++) {
				const id = Math.floor(i / this.numParticleVerts);

				if (!this.useMesh) {
					const vertID = i % 4;
					data[i * 4] = particleVerts[vertID][0];
					data[i * 4 + 1] = particleVerts[vertID][1];
					data[i * 4 + 2] = 0;
					data[i * 4 + 3] = id;
				} else {
					const vert = i % this.numParticleVerts;
					data[i * 6] = meshData[vert * stride];
					data[i * 6 + 1] = meshData[vert * stride + 1];
					data[i * 6 + 2] = meshData[vert * stride + 2];
					data[i * 6 + 3] = id;
					data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
					data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
				}
			}

			if (this.useCpu) {
				this.vbCPU = new Float32Array(data);
				this.vbOld = new Float32Array(this.vbCPU.length);
			}

			this.vertexBuffer.unlock();

			if (this.useMesh) {
				this.mesh.vertexBuffer.unlock();
			}

			let dst = 0;
			const indices = new Uint16Array(this.indexBuffer.lock());
			if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());

			for (let i = 0; i < numParticles; i++) {
				if (!this.useMesh) {
					const baseIndex = i * 4;
					indices[dst++] = baseIndex;
					indices[dst++] = baseIndex + 1;
					indices[dst++] = baseIndex + 2;
					indices[dst++] = baseIndex;
					indices[dst++] = baseIndex + 2;
					indices[dst++] = baseIndex + 3;
				} else {
					for (let j = 0; j < this.numParticleIndices; j++) {
						indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;
					}
				}
			}

			this.indexBuffer.unlock();
			if (this.useMesh) this.mesh.indexBuffer[0].unlock();
		}
	}

	reset() {
		this.beenReset = true;
		this.seed = Math.random();
		this.material.setParameter('seed', this.seed);

		if (this.useCpu) {
			for (let i = 0; i < this.particleTexStart.length; i++) {
				this.particleTex[i] = this.particleTexStart[i];
			}
		} else {
			this._initializeTextures();
		}

		this.resetWorldBounds();
		this.resetTime();
		const origLoop = this.loop;
		this.loop = true;
		this.addTime(0, false);
		this.loop = origLoop;

		if (this.preWarm) {
			this.prewarm(this.lifetime);
		}
	}

	prewarm(time) {
		const lifetimeFraction = time / this.lifetime;
		const iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
		const stepDelta = time / iterations;

		for (let i = 0; i < iterations; i++) {
			this.addTime(stepDelta, false);
		}
	}

	resetTime() {
		this.endTime = calcEndTime(this);
	}

	finishFrame() {
		if (this.useCpu) this.vertexBuffer.unlock();
	}

	addTime(delta, isOnStop) {
		const device = this.graphicsDevice;
		this.simTimeTotal += delta;
		this.calculateWorldBounds();

		if (this._isAnimated()) {
			const tilesParams = this.animTilesParams;
			tilesParams[0] = 1.0 / this.animTilesX;
			tilesParams[1] = 1.0 / this.animTilesY;
			const params = this.animParams;
			params[0] = this.animStartFrame;
			params[1] = this.animNumFrames * this.animSpeed;
			params[2] = this.animNumFrames - 1;
			params[3] = this.animNumAnimations - 1;
			const animIndexParams = this.animIndexParams;
			animIndexParams[0] = this.animIndex;
			animIndexParams[1] = this.randomizeAnimIndex;
		}

		if (this.scene) {
			if (this.camera !== this.scene._activeCamera) {
				this.camera = this.scene._activeCamera;
				this.onChangeCamera();
			}
		}

		if (this.emitterShape === EMITTERSHAPE_BOX) {
			extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
			extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
			extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;

			if (this.meshInstance.node === null) {
				spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
			} else {
				spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
			}
		}

		let emitterPos;
		const emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
		this.emitterScaleUniform[0] = emitterScale.x;
		this.emitterScaleUniform[1] = emitterScale.y;
		this.emitterScaleUniform[2] = emitterScale.z;
		this.material.setParameter("emitterScale", this.emitterScaleUniform);

		if (this.localSpace && this.meshInstance.node) {
			emitterPos = this.meshInstance.node.getPosition();
			this.emitterPosUniform[0] = emitterPos.x;
			this.emitterPosUniform[1] = emitterPos.y;
			this.emitterPosUniform[2] = emitterPos.z;
			this.material.setParameter("emitterPos", this.emitterPosUniform);
		}

		this._compParticleFaceParams();

		if (!this.useCpu) {
			this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
		} else {
			const data = new Float32Array(this.vertexBuffer.lock());

			this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
		}

		if (!this.loop) {
			if (Date.now() > this.endTime) {
				if (this.onFinished) this.onFinished();
				this.meshInstance.visible = false;
			}
		}

		if (this.meshInstance) {
			this.meshInstance.drawOrder = this.drawOrder;
		}
	}

	_destroyResources() {
		if (this.particleTexIN) {
			this.particleTexIN.destroy();
			this.particleTexIN = null;
		}

		if (this.particleTexOUT) {
			this.particleTexOUT.destroy();
			this.particleTexOUT = null;
		}

		if (this.particleTexStart && this.particleTexStart.destroy) {
			this.particleTexStart.destroy();
			this.particleTexStart = null;
		}

		if (this.rtParticleTexIN) {
			this.rtParticleTexIN.destroy();
			this.rtParticleTexIN = null;
		}

		if (this.rtParticleTexOUT) {
			this.rtParticleTexOUT.destroy();
			this.rtParticleTexOUT = null;
		}

		if (this.internalTex0) {
			this.internalTex0.destroy();
			this.internalTex0 = null;
		}

		if (this.internalTex1) {
			this.internalTex1.destroy();
			this.internalTex1 = null;
		}

		if (this.internalTex2) {
			this.internalTex2.destroy();
			this.internalTex2 = null;
		}

		if (this.internalTex3) {
			this.internalTex3.destroy();
			this.internalTex3 = null;
		}

		if (this.colorParam) {
			this.colorParam.destroy();
			this.colorParam = null;
		}

		if (this.vertexBuffer) {
			this.vertexBuffer.destroy();
			this.vertexBuffer = undefined;
		}

		if (this.indexBuffer) {
			this.indexBuffer.destroy();
			this.indexBuffer = undefined;
		}

		if (this.material) {
			this.material.destroy();
			this.material = null;
		}
	}

	destroy() {
		this.camera = null;

		this._destroyResources();
	}

}

ParticleEmitter.DEFAULT_PARAM_TEXTURE = null;

const _floatRounding = 0.2;

class Morph extends RefCountedObject {
	constructor(targets, graphicsDevice) {
		super();
		this.device = graphicsDevice || getApplication().graphicsDevice;
		this._targets = targets;

		if (this.device.supportsMorphTargetTexturesCore) {
			if (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable) {
				this._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;
			} else if (this.device.extTextureFloat && this.device.textureFloatRenderable) {
				this._renderTextureFormat = Morph.FORMAT_FLOAT;
			}

			if (this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable) {
				this._textureFormat = Morph.FORMAT_HALF_FLOAT;
			} else if (this.device.extTextureFloat) {
				this._textureFormat = Morph.FORMAT_FLOAT;
			}

			if (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {
				this._useTextureMorph = true;
			}
		}

		this._init();

		this._updateMorphFlags();

		this._calculateAabb();
	}

	get morphPositions() {
		return this._morphPositions;
	}

	get morphNormals() {
		return this._morphNormals;
	}

	get maxActiveTargets() {
		if (this._useTextureMorph) return this._targets.length;
		return this._morphPositions && this._morphNormals ? 4 : 8;
	}

	get useTextureMorph() {
		return this._useTextureMorph;
	}

	_init() {
		if (this._useTextureMorph) {
			this._useTextureMorph = this._initTextureBased();
		}

		if (!this._useTextureMorph) {
			for (let i = 0; i < this._targets.length; i++) {
				this._targets[i]._initVertexBuffers(this.device);
			}
		}

		for (let i = 0; i < this._targets.length; i++) {
			this._targets[i]._postInit();
		}
	}

	_initTextureBased() {
		const deltaArrays = [],
					deltaInfos = [];

		for (let i = 0; i < this._targets.length; i++) {
			const target = this._targets[i];

			if (target.options.deltaPositions) {
				deltaArrays.push(target.options.deltaPositions);
				deltaInfos.push({
					target: target,
					name: 'texturePositions'
				});
			}

			if (target.options.deltaNormals) {
				deltaArrays.push(target.options.deltaNormals);
				deltaInfos.push({
					target: target,
					name: 'textureNormals'
				});
			}
		}

		const ids = [],
					usedDataIndices = [];
		let freeIndex = 1;
		const dataCount = deltaArrays[0].length;

		for (let v = 0; v < dataCount; v += 3) {
			let vertexUsed = false;

			for (let i = 0; i < deltaArrays.length; i++) {
				const data = deltaArrays[i];

				if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
					vertexUsed = true;
					break;
				}
			}

			if (vertexUsed) {
				ids.push(freeIndex + _floatRounding);
				usedDataIndices.push(v / 3);
				freeIndex++;
			} else {
				ids.push(0 + _floatRounding);
			}
		}

		const maxTextureSize = Math.min(this.device.maxTextureSize, 4096);
		let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
		morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
		const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);

		if (morphTextureHeight > maxTextureSize) {
			return false;
		}

		this.morphTextureWidth = morphTextureWidth;
		this.morphTextureHeight = morphTextureHeight;
		let halfFloat = false;
		let numComponents = 3;
		const float2Half = FloatPacking.float2Half;

		if (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {
			halfFloat = true;
			numComponents = 4;
		}

		const arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;
		const packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);

		for (let i = 0; i < deltaArrays.length; i++) {
			const data = deltaArrays[i];

			for (let v = 0; v < usedDataIndices.length; v++) {
				const index = usedDataIndices[v];

				if (halfFloat) {
					packedDeltas[v * numComponents + numComponents] = float2Half(data[index * 3]);
					packedDeltas[v * numComponents + numComponents + 1] = float2Half(data[index * 3 + 1]);
					packedDeltas[v * numComponents + numComponents + 2] = float2Half(data[index * 3 + 2]);
				} else {
					packedDeltas[v * numComponents + numComponents] = data[index * 3];
					packedDeltas[v * numComponents + numComponents + 1] = data[index * 3 + 1];
					packedDeltas[v * numComponents + numComponents + 2] = data[index * 3 + 2];
				}
			}

			const target = deltaInfos[i].target;
			const format = this._textureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;

			target._setTexture(deltaInfos[i].name, this._createTexture("MorphTarget", format, packedDeltas));
		}

		const formatDesc = [{
			semantic: SEMANTIC_ATTR15,
			components: 1,
			type: TYPE_FLOAT32
		}];
		this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));
		return true;
	}

	destroy() {
		if (this.vertexBufferIds) {
			this.vertexBufferIds.destroy();
			this.vertexBufferIds = null;
		}

		for (let i = 0; i < this._targets.length; i++) {
			this._targets[i].destroy();
		}

		this._targets.length = 0;
	}

	get targets() {
		return this._targets;
	}

	_updateMorphFlags() {
		this._morphPositions = false;
		this._morphNormals = false;

		for (let i = 0; i < this._targets.length; i++) {
			const target = this._targets[i];

			if (target.morphPositions) {
				this._morphPositions = true;
			}

			if (target.morphNormals) {
				this._morphNormals = true;
			}
		}
	}

	_calculateAabb() {
		const min = new Vec3();
		const max = new Vec3();

		for (let i = 0; i < this._targets.length; i++) {
			const targetAabb = this._targets[i].aabb;
			min.min(targetAabb.getMin());
			max.max(targetAabb.getMax());
		}

		this.aabb = new BoundingBox();
		this.aabb.setMinMax(min, max);
	}

	_createTexture(name, format, pixelData) {
		const texture = new Texture(this.device, {
			width: this.morphTextureWidth,
			height: this.morphTextureHeight,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = name;

		if (pixelData) {
			texture.lock().set(pixelData);
			texture.unlock();
		}

		return texture;
	}

}

Morph.FORMAT_FLOAT = 0;
Morph.FORMAT_HALF_FLOAT = 1;

const textureMorphVertexShader = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}
		`;

class MorphInstance {
	constructor(morph) {
		this.morph = morph;
		morph.incRefCount();
		this.device = morph.device;
		this.meshInstance = null;
		this._weights = [];

		for (let v = 0; v < morph._targets.length; v++) {
			this.setWeight(v, morph._targets[v].defaultWeight);
		}

		this._activeTargets = [];

		if (morph.useTextureMorph) {
			this.shaderCache = {};
			this.maxSubmitCount = this.device.maxTextures;
			this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);

			const createRT = (name, textureVar) => {
				const format = morph._renderTextureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;
				this[textureVar] = morph._createTexture(name, format);
				return new RenderTarget({
					colorBuffer: this[textureVar],
					depth: false
				});
			};

			if (morph.morphPositions) {
				this.rtPositions = createRT("MorphRTPos", "texturePositions");
			}

			if (morph.morphNormals) {
				this.rtNormals = createRT("MorphRTNrm", "textureNormals");
			}

			this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);

			for (let i = 0; i < this.maxSubmitCount; i++) {
				this["morphBlendTex" + i] = this.device.scope.resolve("morphBlendTex" + i);
			}

			this.morphFactor = this.device.scope.resolve("morphFactor[0]");
			this.zeroTextures = false;
		} else {
			this.maxSubmitCount = 8;
			this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
			this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);
			this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);
			this._activeVertexBuffers = new Array(this.maxSubmitCount);
		}
	}

	destroy() {
		this.meshInstance = null;
		this.shader = null;
		const morph = this.morph;

		if (morph) {
			this.morph = null;
			morph.decRefCount();

			if (morph.refCount < 1) {
				morph.destroy();
			}
		}

		if (this.rtPositions) {
			this.rtPositions.destroy();
			this.rtPositions = null;
		}

		if (this.texturePositions) {
			this.texturePositions.destroy();
			this.texturePositions = null;
		}

		if (this.rtNormals) {
			this.rtNormals.destroy();
			this.rtNormals = null;
		}

		if (this.textureNormals) {
			this.textureNormals.destroy();
			this.textureNormals = null;
		}
	}

	clone() {
		const clone = new MorphInstance(this.morph);
		return clone;
	}

	getWeight(index) {
		return this._weights[index];
	}

	setWeight(index, weight) {
		this._weights[index] = weight;
		this._dirty = true;
	}

	_getFragmentShader(numTextures) {
		let fragmentShader = '';

		if (numTextures > 0) {
			fragmentShader += 'varying vec2 uv0;\n' + 'uniform highp float morphFactor[' + numTextures + '];\n';
		}

		for (let i = 0; i < numTextures; i++) {
			fragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\n';
		}

		fragmentShader += 'void main (void) {\n' + '		highp vec4 color = vec4(0, 0, 0, 1);\n';

		for (let i = 0; i < numTextures; i++) {
			fragmentShader += '		color.xyz += morphFactor[' + i + '] * texture2D(morphBlendTex' + i + ', uv0).xyz;\n';
		}

		fragmentShader += '		gl_FragColor = color;\n' + '}\n';
		return fragmentShader;
	}

	_getShader(count) {
		let shader = this.shaderCache[count];

		if (!shader) {
			const fs = this._getFragmentShader(count);

			shader = createShaderFromCode(this.device, textureMorphVertexShader, fs, "textureMorph" + count);
			this.shaderCache[count] = shader;
		}

		return shader;
	}

	_updateTextureRenderTarget(renderTarget, srcTextureName) {
		const device = this.device;

		const submitBatch = (usedCount, blending) => {
			this.morphFactor.setValue(this._shaderMorphWeights);
			device.setBlending(blending);

			if (blending) {
				device.setBlendFunction(BLENDMODE_ONE, BLENDMODE_ONE);
				device.setBlendEquation(BLENDEQUATION_ADD);
			}

			const shader = this._getShader(usedCount);

			drawQuadWithShader(device, renderTarget, shader, undefined, undefined, blending);
		};

		let usedCount = 0;
		let blending = false;
		const count = this._activeTargets.length;

		for (let i = 0; i < count; i++) {
			const activeTarget = this._activeTargets[i];
			const tex = activeTarget.target[srcTextureName];

			if (tex) {
				this["morphBlendTex" + usedCount].setValue(tex);
				this._shaderMorphWeights[usedCount] = activeTarget.weight;
				usedCount++;

				if (usedCount >= this.maxSubmitCount) {
					submitBatch(usedCount, blending);
					usedCount = 0;
					blending = true;
				}
			}
		}

		if (usedCount > 0 || count === 0 && !this.zeroTextures) {
			submitBatch(usedCount, blending);
		}
	}

	_updateTextureMorph() {
		this.device;

		if (this._activeTargets.length > 0 || !this.zeroTextures) {
			this._updateTextureRenderTarget(this.rtPositions, 'texturePositions');

			this._updateTextureRenderTarget(this.rtNormals, 'textureNormals');

			this.zeroTextures = this._activeTargets.length === 0;
		}
	}

	_updateVertexMorph() {
		const count = this.maxSubmitCount;

		for (let i = 0; i < count; i++) {
			this._shaderMorphWeights[i] = 0;
			this._activeVertexBuffers[i] = null;
		}

		let posIndex = 0;
		let nrmIndex = this.morph.morphPositions ? 4 : 0;

		for (let i = 0; i < this._activeTargets.length; i++) {
			const target = this._activeTargets[i].target;

			if (target._vertexBufferPositions) {
				this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;
				this._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;
				posIndex++;
			}

			if (target._vertexBufferNormals) {
				this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;
				this._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;
				nrmIndex++;
			}
		}
	}

	update() {
		this._dirty = false;
		const targets = this.morph._targets;
		let activeCount = 0;
		const epsilon = 0.00001;

		for (let i = 0; i < targets.length; i++) {
			const absWeight = Math.abs(this.getWeight(i));

			if (absWeight > epsilon) {
				if (this._activeTargets.length <= activeCount) {
					this._activeTargets[activeCount] = {};
				}

				const activeTarget = this._activeTargets[activeCount++];
				activeTarget.absWeight = absWeight;
				activeTarget.weight = this.getWeight(i);
				activeTarget.target = targets[i];
			}
		}

		this._activeTargets.length = activeCount;
		const maxActiveTargets = this.morph.maxActiveTargets;

		if (this._activeTargets.length > maxActiveTargets) {
			this._activeTargets.sort(function (l, r) {
				return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
			});

			this._activeTargets.length = maxActiveTargets;
		}

		if (this.morph.useTextureMorph) {
			this._updateTextureMorph();
		} else {
			this._updateVertexMorph();
		}
	}

}

class Model {
	constructor() {
		this.graph = null;
		this.meshInstances = [];
		this.skinInstances = [];
		this.morphInstances = [];
		this.cameras = [];
		this.lights = [];
		this._shadersVersion = 0;
		this._immutable = false;
	}

	getGraph() {
		return this.graph;
	}

	setGraph(graph) {
		this.graph = graph;
	}

	getCameras() {
		return this.cameras;
	}

	setCameras(cameras) {
		this.cameras = cameras;
	}

	getLights() {
		return this.lights;
	}

	setLights(lights) {
		this.lights = lights;
	}

	getMaterials() {
		const materials = [];

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];

			if (materials.indexOf(meshInstance.material) === -1) {
				materials.push(meshInstance.material);
			}
		}

		return materials;
	}

	clone() {
		const srcNodes = [];
		const cloneNodes = [];

		const _duplicate = function _duplicate(node) {
			const newNode = node.clone();
			srcNodes.push(node);
			cloneNodes.push(newNode);

			for (let idx = 0; idx < node._children.length; idx++) {
				newNode.addChild(_duplicate(node._children[idx]));
			}

			return newNode;
		};

		const cloneGraph = _duplicate(this.graph);

		const cloneMeshInstances = [];
		const cloneSkinInstances = [];
		const cloneMorphInstances = [];

		for (let i = 0; i < this.skinInstances.length; i++) {
			const skin = this.skinInstances[i].skin;
			const cloneSkinInstance = new SkinInstance(skin);
			const bones = [];

			for (let j = 0; j < skin.boneNames.length; j++) {
				const boneName = skin.boneNames[j];
				const bone = cloneGraph.findByName(boneName);
				bones.push(bone);
			}

			cloneSkinInstance.bones = bones;
			cloneSkinInstances.push(cloneSkinInstance);
		}

		for (let i = 0; i < this.morphInstances.length; i++) {
			const morph = this.morphInstances[i].morph;
			const cloneMorphInstance = new MorphInstance(morph);
			cloneMorphInstances.push(cloneMorphInstance);
		}

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];
			const nodeIndex = srcNodes.indexOf(meshInstance.node);
			const cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);

			if (meshInstance.skinInstance) {
				const skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
				cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
			}

			if (meshInstance.morphInstance) {
				const morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
				cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
			}

			cloneMeshInstances.push(cloneMeshInstance);
		}

		const clone = new Model();
		clone.graph = cloneGraph;
		clone.meshInstances = cloneMeshInstances;
		clone.skinInstances = cloneSkinInstances;
		clone.morphInstances = cloneMorphInstances;
		clone.getGraph().syncHierarchy();
		return clone;
	}

	destroy() {
		const meshInstances = this.meshInstances;

		for (let i = 0; i < meshInstances.length; i++) {
			meshInstances[i].destroy();
		}

		this.meshInstances.length = 0;
	}

	generateWireframe() {
		MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
	}

}

const identityGraphNode = new GraphNode();
identityGraphNode.worldTransform = Mat4.IDENTITY;
identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;

class ImmediateBatch {
	constructor(device, material, layer) {
		this.material = material;
		this.layer = layer;
		this.positions = [];
		this.colors = [];
		this.mesh = new Mesh(device);
		this.meshInstance = null;
	}

	addLines(positions, color) {
		const destPos = this.positions;
		const count = positions.length;

		for (let i = 0; i < count; i++) {
			const pos = positions[i];
			destPos.push(pos.x, pos.y, pos.z);
		}

		const destCol = this.colors;

		if (color.length) {
			for (let i = 0; i < count; i++) {
				const col = color[i];
				destCol.push(col.r, col.g, col.b, col.a);
			}
		} else {
			for (let i = 0; i < count; i++) {
				destCol.push(color.r, color.g, color.b, color.a);
			}
		}
	}

	addLinesArrays(positions, color) {
		this.positions.push(...positions);
		const destCol = this.colors;

		if (color.length) {
			destCol.push(...color);
		} else {
			const count = positions.length / 3;

			for (let i = 0; i < count; i++) {
				destCol.push(color.r, color.g, color.b, color.a);
			}
		}
	}

	onPreRender(visibleList, transparent) {
		if (this.positions.length > 0 && this.material.transparent === transparent) {
			this.mesh.setPositions(this.positions);
			this.mesh.setColors(this.colors);
			this.mesh.update(PRIMITIVE_LINES, false);

			if (!this.meshInstance) {
				this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
			}

			this.positions.length = 0;
			this.colors.length = 0;
			visibleList.list.push(this.meshInstance);
			visibleList.length++;
		}
	}

}

class ImmediateBatches {
	constructor(device) {
		this.device = device;
		this.map = new Map();
	}

	getBatch(material, layer) {
		let batch = this.map.get(material);

		if (!batch) {
			batch = new ImmediateBatch(this.device, material, layer);
			this.map.set(material, batch);
		}

		return batch;
	}

	onPreRender(visibleList, transparent) {
		this.map.forEach(batch => {
			batch.onPreRender(visibleList, transparent);
		});
	}

}

const tempPoints = [];

class Immediate {
	constructor(device) {
		this.device = device;
		this.quadMesh = null;
		this.textureShader = null;
		this.depthTextureShader = null;
		this.cubeLocalPos = null;
		this.cubeWorldPos = null;
		this.batchesMap = new Map();
		this.allBatches = new Set();
		this.updatedLayers = new Set();
		this._materialDepth = null;
		this._materialNoDepth = null;
		this.layerMeshInstances = new Map();
	}

	createMaterial(depthTest) {
		const material = new BasicMaterial();
		material.vertexColors = true;
		material.blend = true;
		material.blendType = BLEND_NORMAL;
		material.depthTest = depthTest;
		material.update();
		return material;
	}

	get materialDepth() {
		if (!this._materialDepth) {
			this._materialDepth = this.createMaterial(true);
		}

		return this._materialDepth;
	}

	get materialNoDepth() {
		if (!this._materialNoDepth) {
			this._materialNoDepth = this.createMaterial(false);
		}

		return this._materialNoDepth;
	}

	getBatch(layer, depthTest) {
		let batches = this.batchesMap.get(layer);

		if (!batches) {
			batches = new ImmediateBatches(this.device);
			this.batchesMap.set(layer, batches);
		}

		this.allBatches.add(batches);
		const material = depthTest ? this.materialDepth : this.materialNoDepth;
		return batches.getBatch(material, layer);
	}

	static getTextureVS() {
		return `
						attribute vec2 aPosition;
						uniform mat4 matrix_model;
						varying vec2 uv0;
						void main(void) {
								gl_Position = matrix_model * vec4(aPosition, 0, 1);
								uv0 = aPosition.xy + 0.5;
						}
				`;
	}

	getTextureShader() {
		if (!this.textureShader) {
			const shaderDefinition = {
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vshader: Immediate.getTextureVS(),
				fshader: `
										precision lowp float;
										varying vec2 uv0;
										uniform sampler2D colorMap;
										void main (void) {
												gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);
										}
								`
			};
			this.textureShader = new Shader(this.device, shaderDefinition);
		}

		return this.textureShader;
	}

	getDepthTextureShader() {
		if (!this.depthTextureShader) {
			const gl2 = this.device.webgl2 ? "#define GL2" : "";
			const shaderDefinition = {
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vshader: Immediate.getTextureVS(),
				fshader: `
										precision ${this.device.precision} float;
										${gl2}
										${shaderChunks.screenDepthPS}
										varying vec2 uv0;
										void main() {
												float depth = getLinearScreenDepth(uv0) * camera_params.x;
												gl_FragColor = vec4(vec3(depth), 1.0);
										}
										`
			};
			this.depthTextureShader = new Shader(this.device, shaderDefinition);
		}

		return this.depthTextureShader;
	}

	getQuadMesh() {
		if (!this.quadMesh) {
			this.quadMesh = new Mesh(this.device);
			this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);
			this.quadMesh.update(PRIMITIVE_TRISTRIP);
		}

		return this.quadMesh;
	}

	drawMesh(material, matrix, mesh, meshInstance, layer) {
		if (!meshInstance) {
			const graphNode = this.getGraphNode(matrix);
			meshInstance = new MeshInstance(mesh, material, graphNode);
		}

		let layerMeshInstances = this.layerMeshInstances.get(layer);

		if (!layerMeshInstances) {
			layerMeshInstances = [];
			this.layerMeshInstances.set(layer, layerMeshInstances);
		}

		layerMeshInstances.push(meshInstance);
	}

	drawWireAlignedBox(min, max, color, depthTest, layer) {
		tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
		const batch = this.getBatch(layer, depthTest);
		batch.addLinesArrays(tempPoints, color);
		tempPoints.length = 0;
	}

	drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
		const step = 2 * Math.PI / numSegments;
		let angle = 0;

		for (let i = 0; i < numSegments; i++) {
			const sin0 = Math.sin(angle);
			const cos0 = Math.cos(angle);
			angle += step;
			const sin1 = Math.sin(angle);
			const cos1 = Math.cos(angle);
			tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
			tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
			tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
			tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
			tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
			tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
		}

		const batch = this.getBatch(layer, depthTest);
		batch.addLinesArrays(tempPoints, color);
		tempPoints.length = 0;
	}

	getGraphNode(matrix) {
		const graphNode = new GraphNode();
		graphNode.worldTransform = matrix;
		graphNode._dirtyWorld = graphNode._dirtyNormal = false;
		return graphNode;
	}

	onPreRenderLayer(layer, visibleList, transparent) {
		this.batchesMap.forEach((batches, batchLayer) => {
			if (batchLayer === layer) {
				batches.onPreRender(visibleList, transparent);
			}
		});

		if (!this.updatedLayers.has(layer)) {
			this.updatedLayers.add(layer);
			const meshInstances = this.layerMeshInstances.get(layer);

			if (meshInstances) {
				for (let i = 0; i < meshInstances.length; i++) {
					visibleList.list[visibleList.length + i] = meshInstances[i];
				}

				visibleList.length += meshInstances.length;
				meshInstances.length = 0;
			}
		}
	}

	onPostRender() {
		this.allBatches.clear();
		this.updatedLayers.clear();
	}

}

class Scene$1 extends EventHandler {
	constructor(graphicsDevice) {
		super();
		this.ambientBake = false;
		this.ambientBakeOcclusionBrightness = 0;
		this.ambientBakeOcclusionContrast = 0;
		this.ambientLight = new Color(0, 0, 0);
		this.exposure = 1;
		this.fogColor = new Color(0, 0, 0);
		this.fogDensity = 0;
		this.fogEnd = 1000;
		this.fogStart = 1;
		this.lightmapSizeMultiplier = 1;
		this.lightmapMaxResolution = 2048;
		this.lightmapMode = BAKE_COLORDIR;
		this.lightmapFilterEnabled = false;
		this.root = null;
		this.device = graphicsDevice || getApplication().graphicsDevice;
		this._gravity = new Vec3(0, -9.8, 0);
		this._layers = null;
		this._fog = FOG_NONE;
		this._gammaCorrection = GAMMA_SRGB;
		this._toneMapping = 0;
		this._skyboxCubeMap = null;
		this._prefilteredCubemaps = [null, null, null, null, null, null];
		this._envAtlas = null;
		this._internalEnvAtlas = null;
		this.skyboxModel = null;
		this._skyboxIntensity = 1;
		this._skyboxMip = 0;
		this._skyboxRotation = new Quat();
		this._skyboxRotationMat3 = null;
		this._skyboxRotationMat4 = null;
		this._ambientBakeNumSamples = 1;
		this._ambientBakeSpherePart = 0.4;
		this._lightmapFilterRange = 10;
		this._lightmapFilterSmoothness = 0.2;
		this._clusteredLightingEnabled = false;
		this._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, () => {
			this._layers._dirtyLights = true;
		});
		this._stats = {
			meshInstances: 0,
			lights: 0,
			dynamicLights: 0,
			bakedLights: 0,
			lastStaticPrepareFullTime: 0,
			lastStaticPrepareSearchTime: 0,
			lastStaticPrepareWriteTime: 0,
			lastStaticPrepareTriAabbTime: 0,
			lastStaticPrepareCombineTime: 0,
			updateShadersTime: 0
		};
		this.updateShaders = true;
		this._shaderVersion = 0;
		this._statsUpdated = false;
		this._models = [];
		this.immediate = new Immediate(this.device);
	}

	get defaultDrawLayer() {
		return this.layers.getLayerById(LAYERID_IMMEDIATE);
	}

	set ambientBakeNumSamples(value) {
		this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
	}

	get ambientBakeNumSamples() {
		return this._ambientBakeNumSamples;
	}

	set ambientBakeSpherePart(value) {
		this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
	}

	get ambientBakeSpherePart() {
		return this._ambientBakeSpherePart;
	}

	set clusteredLightingEnabled(value) {
		if (this._clusteredLightingEnabled && !value) {
			console.error("Turning off enabled clustered lighting is not currently supported");
			return;
		}

		this._clusteredLightingEnabled = value;
	}

	get clusteredLightingEnabled() {
		return this._clusteredLightingEnabled;
	}

	set drawCalls(value) {}

	get drawCalls() {
		let drawCalls = this.layers._meshInstances;

		if (!drawCalls.length) {
			this.layers._update(this.device, this.clusteredLightingEnabled);

			drawCalls = this.layers._meshInstances;
		}

		return drawCalls;
	}

	set envAtlas(value) {
		if (value !== this._envAtlas) {
			this._envAtlas = value;
			this.updateShaders = true;
		}
	}

	get envAtlas() {
		return this._envAtlas;
	}

	set fog(type) {
		if (type !== this._fog) {
			this._fog = type;
			this.updateShaders = true;
		}
	}

	get fog() {
		return this._fog;
	}

	set gammaCorrection(value) {
		if (value !== this._gammaCorrection) {
			this._gammaCorrection = value;
			this.updateShaders = true;
		}
	}

	get gammaCorrection() {
		return this._gammaCorrection;
	}

	set layers(layers) {
		const prev = this._layers;
		this._layers = layers;
		this.fire("set:layers", prev, layers);
	}

	get layers() {
		return this._layers;
	}

	get lighting() {
		return this._lightingParams;
	}

	set lightmapFilterRange(value) {
		this._lightmapFilterRange = Math.max(value, 0.001);
	}

	get lightmapFilterRange() {
		return this._lightmapFilterRange;
	}

	set lightmapFilterSmoothness(value) {
		this._lightmapFilterSmoothness = Math.max(value, 0.001);
	}

	get lightmapFilterSmoothness() {
		return this._lightmapFilterSmoothness;
	}

	set prefilteredCubemaps(value) {
		const cubemaps = this._prefilteredCubemaps;
		value = value || [];
		let changed = false;
		let complete = true;

		for (let i = 0; i < 6; ++i) {
			const v = value[i] || null;

			if (cubemaps[i] !== v) {
				cubemaps[i] = v;
				changed = true;
			}

			complete = complete && !!cubemaps[i];
		}

		if (changed) {
			this._resetSkyboxModel();

			if (complete) {
				this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
					target: this._internalEnvAtlas
				});

				if (!this._envAtlas) {
					this.envAtlas = this._internalEnvAtlas;
				}
			} else if (this._internalEnvAtlas) {
				if (this._envAtlas === this._internalEnvAtlas) {
					this.envAtlas = null;
				}

				this._internalEnvAtlas.destroy();

				this._internalEnvAtlas = null;
			}
		}
	}

	get prefilteredCubemaps() {
		return this._prefilteredCubemaps;
	}

	set skybox(value) {
		if (value !== this._skyboxCubeMap) {
			this._skyboxCubeMap = value;

			this._resetSkyboxModel();
		}
	}

	get skybox() {
		return this._skyboxCubeMap;
	}

	set skyboxIntensity(value) {
		if (value !== this._skyboxIntensity) {
			this._skyboxIntensity = value;

			this._resetSkyboxModel();
		}
	}

	get skyboxIntensity() {
		return this._skyboxIntensity;
	}

	set skyboxMip(value) {
		if (value !== this._skyboxMip) {
			this._skyboxMip = value;

			this._resetSkyboxModel();
		}
	}

	get skyboxMip() {
		return this._skyboxMip;
	}

	set skyboxRotation(value) {
		if (!this._skyboxRotation.equals(value)) {
			this._skyboxRotation.copy(value);

			this._resetSkyboxModel();
		}
	}

	get skyboxRotation() {
		return this._skyboxRotation;
	}

	set toneMapping(value) {
		if (value !== this._toneMapping) {
			this._toneMapping = value;
			this.updateShaders = true;
		}
	}

	get toneMapping() {
		return this._toneMapping;
	}

	destroy() {
		this._resetSkyboxModel();

		this.root = null;
		this.off();
	}

	drawLine(start, end, color = Color.WHITE, depthTest = true, layer = this.defaultDrawLayer) {
		const batch = this.immediate.getBatch(layer, depthTest);
		batch.addLines([start, end], [color, color]);
	}

	drawLines(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {
		const batch = this.immediate.getBatch(layer, depthTest);
		batch.addLines(positions, colors);
	}

	drawLineArrays(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {
		const batch = this.immediate.getBatch(layer, depthTest);
		batch.addLinesArrays(positions, colors);
	}

	applySettings(settings) {
		this._gravity.set(settings.physics.gravity[0], settings.physics.gravity[1], settings.physics.gravity[2]);

		this.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);
		this._fog = settings.render.fog;
		this.fogColor.set(settings.render.fog_color[0], settings.render.fog_color[1], settings.render.fog_color[2]);
		this.fogStart = settings.render.fog_start;
		this.fogEnd = settings.render.fog_end;
		this.fogDensity = settings.render.fog_density;
		this._gammaCorrection = settings.render.gamma_correction;
		this._toneMapping = settings.render.tonemapping;
		this.lightmapSizeMultiplier = settings.render.lightmapSizeMultiplier;
		this.lightmapMaxResolution = settings.render.lightmapMaxResolution;
		this.lightmapMode = settings.render.lightmapMode;
		this.exposure = settings.render.exposure;
		this._skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;
		this._skyboxMip = settings.render.skyboxMip === undefined ? 0 : settings.render.skyboxMip;

		if (settings.render.skyboxRotation) {
			this._skyboxRotation.setFromEulerAngles(settings.render.skyboxRotation[0], settings.render.skyboxRotation[1], settings.render.skyboxRotation[2]);
		}

		this._resetSkyboxModel();
	}

	_getSkyboxTex() {
		const cubemaps = this._prefilteredCubemaps;

		if (this._skyboxMip) {
			const skyboxMapping = [0, 1, 3, 4, 5, 6];
			return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
		}

		return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
	}

	_updateSkybox(device) {
		if (this.skyboxModel) {
			return;
		}

		const skyboxTex = this._getSkyboxTex();

		if (!skyboxTex) {
			return;
		}

		const material = new Material$1();
		const scene = this;

		material.updateShader = function (dev, sc, defs, staticLightList, pass) {
			const library = device.getProgramLibrary();

			if (skyboxTex.cubemap) {
				this.shader = library.getProgram('skybox', {
					type: 'cubemap',
					rgbm: skyboxTex.type === TEXTURETYPE_RGBM,
					hdr: skyboxTex.type === TEXTURETYPE_RGBM || skyboxTex.format === PIXELFORMAT_RGBA32F,
					useIntensity: scene.skyboxIntensity !== 1,
					mip: skyboxTex.fixCubemapSeams ? scene.skyboxMip : 0,
					fixSeams: skyboxTex.fixCubemapSeams,
					gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
					toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
				});
			} else {
				this.shader = library.getProgram('skybox', {
					type: 'envAtlas',
					encoding: skyboxTex.encoding,
					useIntensity: scene.skyboxIntensity !== 1,
					gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
					toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
				});
			}
		};

		material.updateShader();

		if (skyboxTex.cubemap) {
			material.setParameter("texture_cubeMap", skyboxTex);
		} else {
			material.setParameter("texture_envAtlas", skyboxTex);
			material.setParameter("mipLevel", this._skyboxMip);
		}

		if (!this.skyboxRotation.equals(Quat.IDENTITY)) {
			if (!this._skyboxRotationMat4) this._skyboxRotationMat4 = new Mat4();
			if (!this._skyboxRotationMat3) this._skyboxRotationMat3 = new Mat3();

			this._skyboxRotationMat4.setTRS(Vec3.ZERO, this._skyboxRotation, Vec3.ONE);

			this._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3);

			material.setParameter("cubeMapRotationMatrix", this._skyboxRotationMat3.data);
		} else {
			material.setParameter("cubeMapRotationMatrix", Mat3.IDENTITY.data);
		}

		material.cull = CULLFACE_FRONT;
		material.depthWrite = false;
		const skyLayer = this.layers.getLayerById(LAYERID_SKYBOX);

		if (skyLayer) {
			const node = new GraphNode("Skybox");
			const mesh = createBox(device);
			const meshInstance = new MeshInstance(mesh, material, node);
			meshInstance.cull = false;
			meshInstance._noDepthDrawGl1 = true;
			meshInstance.pick = false;
			const model = new Model();
			model.graph = node;
			model.meshInstances = [meshInstance];
			this.skyboxModel = model;
			skyLayer.addMeshInstances(model.meshInstances);
			this.skyLayer = skyLayer;
			this.fire("set:skybox", skyboxTex);
		}
	}

	_resetSkyboxModel() {
		if (this.skyboxModel) {
			this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);
			this.skyboxModel.destroy();
		}

		this.skyboxModel = null;
		this.updateShaders = true;
	}

	setSkybox(cubemaps) {
		if (!cubemaps) {
			this.skybox = null;
			this.prefilteredCubemaps = [null, null, null, null, null, null];
		} else {
			this.skybox = cubemaps[0] || null;
			this.prefilteredCubemaps = cubemaps.slice(1);
		}
	}

	addModel(model) {
		if (this.containsModel(model)) return;
		const layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addMeshInstances(model.meshInstances);

		this._models.push(model);
	}

	addShadowCaster(model) {
		const layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addShadowCasters(model.meshInstances);
	}

	removeModel(model) {
		const index = this._models.indexOf(model);

		if (index !== -1) {
			const layer = this.layers.getLayerById(LAYERID_WORLD);
			if (!layer) return;
			layer.removeMeshInstances(model.meshInstances);

			this._models.splice(index, 1);
		}
	}

	removeShadowCasters(model) {
		const layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.removeShadowCasters(model.meshInstances);
	}

	containsModel(model) {
		return this._models.indexOf(model) >= 0;
	}

	getModels(model) {
		return this._models;
	}

}

function hasAudioContext() {
	return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
}

class Channel {
	constructor(manager, sound, options = {}) {
		this.volume = options.volume === undefined ? 1 : options.volume;
		this.loop = options.loop === undefined ? false : options.loop;
		this.pitch = options.pitch === undefined ? 1 : options.pitch;
		this.sound = sound;
		this.paused = false;
		this.suspended = false;
		this.manager = manager;
		this.source = null;

		if (hasAudioContext()) {
			this.startTime = 0;
			this.startOffset = 0;
			const context = manager.context;
			this.gain = context.createGain();
		} else if (sound.audio) {
			this.source = sound.audio.cloneNode(false);
			this.source.pause();
		}
	}

	getVolume() {
		return this.volume;
	}

	getLoop() {
		return this.loop;
	}

	setLoop(loop) {
		this.loop = loop;

		if (this.source) {
			this.source.loop = loop;
		}
	}

	getPitch() {
		return this.pitch;
	}

	onManagerVolumeChange() {
		this.setVolume(this.getVolume());
	}

	onManagerSuspend() {
		if (this.isPlaying() && !this.suspended) {
			this.suspended = true;
			this.pause();
		}
	}

	onManagerResume() {
		if (this.suspended) {
			this.suspended = false;
			this.unpause();
		}
	}

	play() {
		if (this.source) {
			throw new Error('Call stop() before calling play()');
		}

		this._createSource();

		if (!this.source) {
			return;
		}

		this.startTime = this.manager.context.currentTime;
		this.source.start(0, this.startOffset % this.source.buffer.duration);
		this.setVolume(this.volume);
		this.setLoop(this.loop);
		this.setPitch(this.pitch);
		this.manager.on('volumechange', this.onManagerVolumeChange, this);
		this.manager.on('suspend', this.onManagerSuspend, this);
		this.manager.on('resume', this.onManagerResume, this);
		if (this.manager.suspended) this.onManagerSuspend();
	}

	pause() {
		if (this.source) {
			this.paused = true;
			this.startOffset += this.manager.context.currentTime - this.startTime;
			this.source.stop(0);
			this.source = null;
		}
	}

	unpause() {
		if (this.source || !this.paused) {
			console.warn('Call pause() before unpausing.');
			return;
		}

		this._createSource();

		if (!this.source) {
			return;
		}

		this.startTime = this.manager.context.currentTime;
		this.source.start(0, this.startOffset % this.source.buffer.duration);
		this.setVolume(this.volume);
		this.setLoop(this.loop);
		this.setPitch(this.pitch);
		this.paused = false;
	}

	stop() {
		if (this.source) {
			this.source.stop(0);
			this.source = null;
		}

		this.manager.off('volumechange', this.onManagerVolumeChange, this);
		this.manager.off('suspend', this.onManagerSuspend, this);
		this.manager.off('resume', this.onManagerResume, this);
	}

	setVolume(volume) {
		volume = math.clamp(volume, 0, 1);
		this.volume = volume;

		if (this.gain) {
			this.gain.gain.value = volume * this.manager.volume;
		}
	}

	setPitch(pitch) {
		this.pitch = pitch;

		if (this.source) {
			this.source.playbackRate.value = pitch;
		}
	}

	isPlaying() {
		return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
	}

	getDuration() {
		return this.source ? this.source.buffer.duration : 0;
	}

	_createSource() {
		const context = this.manager.context;

		if (this.sound.buffer) {
			this.source = context.createBufferSource();
			this.source.buffer = this.sound.buffer;
			this.source.connect(this.gain);
			this.gain.connect(context.destination);

			if (!this.loop) {
				this.source.onended = this.pause.bind(this);
			}
		}
	}

}

if (!hasAudioContext()) {
	Object.assign(Channel.prototype, {
		play: function () {
			if (this.source) {
				this.paused = false;
				this.setVolume(this.volume);
				this.setLoop(this.loop);
				this.setPitch(this.pitch);
				this.source.play();
			}

			this.manager.on('volumechange', this.onManagerVolumeChange, this);
			this.manager.on('suspend', this.onManagerSuspend, this);
			this.manager.on('resume', this.onManagerResume, this);
			if (this.manager.suspended) this.onManagerSuspend();
		},
		pause: function () {
			if (this.source) {
				this.paused = true;
				this.source.pause();
			}
		},
		unpause: function () {
			if (this.source) {
				this.paused = false;
				this.source.play();
			}
		},
		stop: function () {
			if (this.source) {
				this.source.pause();
			}

			this.manager.off('volumechange', this.onManagerVolumeChange, this);
			this.manager.off('suspend', this.onManagerSuspend, this);
			this.manager.off('resume', this.onManagerResume, this);
		},
		setVolume: function (volume) {
			volume = math.clamp(volume, 0, 1);
			this.volume = volume;

			if (this.source) {
				this.source.volume = volume * this.manager.volume;
			}
		},
		setPitch: function (pitch) {
			this.pitch = pitch;

			if (this.source) {
				this.source.playbackRate = pitch;
			}
		},
		getDuration: function () {
			return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
		},
		isPlaying: function () {
			return !this.source.paused;
		}
	});
}

const DISTANCE_LINEAR = 'linear';
const DISTANCE_INVERSE = 'inverse';
const DISTANCE_EXPONENTIAL = 'exponential';

const MAX_DISTANCE$1 = 10000;

class Channel3d extends Channel {
	constructor(manager, sound, options) {
		super(manager, sound, options);
		this.position = new Vec3();
		this.velocity = new Vec3();

		if (hasAudioContext()) {
			this.panner = manager.context.createPanner();
		} else {
			this.maxDistance = MAX_DISTANCE$1;
			this.minDistance = 1;
			this.rollOffFactor = 1;
			this.distanceModel = DISTANCE_INVERSE;
		}
	}

	getPosition() {
		return this.position;
	}

	getVelocity() {
		return this.velocity;
	}

	setPosition(position) {
		this.position.copy(position);
		this.panner.setPosition(position.x, position.y, position.z);
	}

	setVelocity(velocity) {
		this.velocity.copy(velocity);
		this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
	}

	getMaxDistance() {
		return this.panner.maxDistance;
	}

	setMaxDistance(max) {
		this.panner.maxDistance = max;
	}

	getMinDistance() {
		return this.panner.refDistance;
	}

	setMinDistance(min) {
		this.panner.refDistance = min;
	}

	getRollOffFactor() {
		return this.panner.rolloffFactor;
	}

	setRollOffFactor(factor) {
		this.panner.rolloffFactor = factor;
	}

	getDistanceModel() {
		return this.pannel.distanceModel;
	}

	setDistanceModel(distanceModel) {
		this.panner.distanceModel = distanceModel;
	}

	_createSource() {
		const context = this.manager.context;
		this.source = context.createBufferSource();
		this.source.buffer = this.sound.buffer;
		this.source.connect(this.panner);
		this.panner.connect(this.gain);
		this.gain.connect(context.destination);

		if (!this.loop) {
			this.source.onended = this.pause.bind(this);
		}
	}

}

if (!hasAudioContext()) {
	let offset = new Vec3();

	const fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
		offset = offset.sub2(posOne, posTwo);
		const distance = offset.length();

		if (distance < refDistance) {
			return 1;
		} else if (distance > maxDistance) {
			return 0;
		}

		let result = 0;

		if (distanceModel === DISTANCE_LINEAR) {
			result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
		} else if (distanceModel === DISTANCE_INVERSE) {
			result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
		} else if (distanceModel === DISTANCE_EXPONENTIAL) {
			result = Math.pow(distance / refDistance, -rolloffFactor);
		}

		return math.clamp(result, 0, 1);
	};

	Object.assign(Channel3d.prototype, {
		setPosition: function (position) {
			this.position.copy(position);

			if (this.source) {
				const listener = this.manager.listener;
				const lpos = listener.getPosition();
				const factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
				const v = this.getVolume();
				this.source.volume = v * factor;
			}
		},
		setVelocity: function (velocity) {
			this.velocity.copy(velocity);
		},
		getMaxDistance: function () {
			return this.maxDistance;
		},
		setMaxDistance: function (max) {
			this.maxDistance = max;
		},
		getMinDistance: function () {
			return this.minDistance;
		},
		setMinDistance: function (min) {
			this.minDistance = min;
		},
		getRollOffFactor: function () {
			return this.rollOffFactor;
		},
		setRollOffFactor: function (factor) {
			this.rollOffFactor = factor;
		},
		getDistanceModel: function () {
			return this.distanceModel;
		},
		setDistanceModel: function (distanceModel) {
			this.distanceModel = distanceModel;
		}
	});
}

class Listener {
	constructor(manager) {
		this._manager = manager;
		this.position = new Vec3();
		this.velocity = new Vec3();
		this.orientation = new Mat4();
	}

	getPosition() {
		return this.position;
	}

	setPosition(position) {
		this.position.copy(position);
		const listener = this.listener;

		if (listener) {
			listener.setPosition(position.x, position.y, position.z);
		}
	}

	getVelocity() {
		return this.velocity;
	}

	setVelocity(velocity) {
		this.velocity.copy(velocity);
		const listener = this.listener;

		if (listener) {
			listener.setPosition(velocity.x, velocity.y, velocity.z);
		}
	}

	setOrientation(orientation) {
		this.orientation.copy(orientation);
		const listener = this.listener;

		if (listener) {
			listener.setOrientation(-orientation.data[8], -orientation.data[9], -orientation.data[10], orientation.data[4], orientation.data[5], orientation.data[6]);
		}
	}

	getOrientation() {
		return this.orientation;
	}

	get listener() {
		const context = this._manager.context;
		return context ? context.listener : null;
	}

}

class SoundManager extends EventHandler {
	constructor(options) {
		super();
		this._context = null;
		this._forceWebAudioApi = options.forceWebAudioApi;
		this._resumeContext = null;
		this._unlock = null;

		if (hasAudioContext() || this._forceWebAudioApi) {
			this._resumeContext = () => {
				window.removeEventListener('mousedown', this._resumeContext);
				window.removeEventListener('touchend', this._resumeContext);

				if (this.context) {
					this.context.resume();
				}
			};

			window.addEventListener('mousedown', this._resumeContext);
			window.addEventListener('touchend', this._resumeContext);

			if (platform.ios) {
				this._unlock = () => {
					window.removeEventListener('touchend', this._unlock);
					const context = this.context;

					if (context) {
						const buffer = context.createBuffer(1, 1, 44100);
						const source = context.createBufferSource();
						source.buffer = buffer;
						source.connect(context.destination);
						source.start(0);
						source.disconnect();
					}
				};

				window.addEventListener('touchend', this._unlock);
			}
		} else {
			console.warn('No support for 3D audio found');
		}

		this.listener = new Listener(this);
		this._volume = 1;
		this.suspended = false;
	}

	set volume(volume) {
		volume = math.clamp(volume, 0, 1);
		this._volume = volume;
		this.fire('volumechange', volume);
	}

	get volume() {
		return this._volume;
	}

	get context() {
		if (!this._context) {
			if (hasAudioContext() || this._forceWebAudioApi) {
				if (typeof AudioContext !== 'undefined') {
					this._context = new AudioContext();
				} else if (typeof webkitAudioContext !== 'undefined') {
					this._context = new webkitAudioContext();
				}
			}
		}

		return this._context;
	}

	suspend() {
		this.suspended = true;
		this.fire('suspend');
	}

	resume() {
		const resumeFunction = () => {
			this.suspended = false;
			this.fire('resume');
		};

		if ((hasAudioContext() || this._forceWebAudioApi) && (this.context.state === 'interrupted' || this.context.state === 'suspended')) {
			this.context.resume().then(resumeFunction);
		} else resumeFunction();
	}

	destroy() {
		if (this._resumeContext) {
			window.removeEventListener('mousedown', this._resumeContext);
			window.removeEventListener('touchend', this._resumeContext);
		}

		if (this._unlock) {
			window.removeEventListener('touchend', this._unlock);
		}

		this.fire('destroy');

		if (this._context && this._context.close) {
			this._context.close();

			this._context = null;
		}
	}

	playSound(sound, options = {}) {
		let channel = null;

		if (Channel) {
			channel = new Channel(this, sound, options);
			channel.play();
		}

		return channel;
	}

	playSound3d(sound, position, options = {}) {
		let channel = null;

		if (Channel3d) {
			channel = new Channel3d(this, sound, options);
			channel.setPosition(position);

			if (options.volume) {
				channel.setVolume(options.volume);
			}

			if (options.loop) {
				channel.setLoop(options.loop);
			}

			if (options.maxDistance) {
				channel.setMaxDistance(options.maxDistance);
			}

			if (options.minDistance) {
				channel.setMinDistance(options.minDistance);
			}

			if (options.rollOffFactor) {
				channel.setRollOffFactor(options.rollOffFactor);
			}

			if (options.distanceModel) {
				channel.setDistanceModel(options.distanceModel);
			}

			channel.play();
		}

		return channel;
	}

}

class Key {
	constructor(time, position, rotation, scale) {
		this.time = time;
		this.position = position;
		this.rotation = rotation;
		this.scale = scale;
	}

}

class Node {
	constructor() {
		this._name = "";
		this._keys = [];
	}

}

class Animation {
	constructor() {
		this.name = '';
		this.duration = 0;
		this._nodes = [];
		this._nodeDict = {};
	}

	getNode(name) {
		return this._nodeDict[name];
	}

	addNode(node) {
		this._nodes.push(node);

		this._nodeDict[node._name] = node;
	}

	get nodes() {
		return this._nodes;
	}

}

class MorphTarget {
	constructor(options) {
		if (arguments.length === 2) {
			options = arguments[1];
		}

		this.options = options;
		this._name = options.name;
		this._defaultWeight = options.defaultWeight || 0;
		this.aabb = options.aabb;

		if (!this.aabb) {
			this.aabb = new BoundingBox();
			if (options.deltaPositions) this.aabb.compute(options.deltaPositions);
		}

		this.deltaPositions = options.deltaPositions;
	}

	get name() {
		return this._name;
	}

	get defaultWeight() {
		return this._defaultWeight;
	}

	get morphPositions() {
		return !!this._vertexBufferPositions || !!this.texturePositions;
	}

	get morphNormals() {
		return !!this._vertexBufferNormals || !!this.textureNormals;
	}

	_postInit() {
		this.options = null;
	}

	_initVertexBuffers(graphicsDevice) {
		const options = this.options;
		this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);
		this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);

		if (this._vertexBufferPositions) {
			this.deltaPositions = this._vertexBufferPositions.lock();
		}
	}

	_createVertexBuffer(device, data, dataType = TYPE_FLOAT32) {
		if (data) {
			const formatDesc = [{
				semantic: SEMANTIC_ATTR0,
				components: 3,
				type: dataType
			}];
			return new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);
		}

		return null;
	}

	_setTexture(name, texture) {
		this[name] = texture;
	}

	destroy() {
		if (this._vertexBufferPositions) {
			this._vertexBufferPositions.destroy();

			this._vertexBufferPositions = null;
		}

		if (this._vertexBufferNormals) {
			this._vertexBufferNormals.destroy();

			this._vertexBufferNormals = null;
		}

		if (this.texturePositions) {
			this.texturePositions.destroy();
			this.texturePositions = null;
		}

		if (this.textureNormals) {
			this.textureNormals.destroy();
			this.textureNormals = null;
		}
	}

}

class Skin {
	constructor(graphicsDevice, ibp, boneNames) {
		this.device = graphicsDevice;
		this.inverseBindPose = ibp;
		this.boneNames = boneNames;
	}

}

class Render extends EventHandler {
	constructor() {
		super();
		this._meshes = null;
	}

	set meshes(value) {
		this.decRefMeshes();
		this._meshes = value;
		this.incRefMeshes();
		this.fire('set:meshes', value);
	}

	get meshes() {
		return this._meshes;
	}

	destroy() {
		this.meshes = null;
	}

	decRefMeshes() {
		if (this._meshes) {
			const count = this._meshes.length;

			for (let i = 0; i < count; i++) {
				const mesh = this._meshes[i];

				if (mesh) {
					mesh.decRefCount();

					if (mesh.refCount < 1) {
						mesh.destroy();
						this._meshes[i] = null;
					}
				}
			}
		}
	}

	incRefMeshes() {
		if (this._meshes) {
			const count = this._meshes.length;

			for (let i = 0; i < count; i++) {
				if (this._meshes[i]) {
					this._meshes[i].incRefCount();
				}
			}
		}
	}

}

class AnimCurve {
	constructor(paths, input, output, interpolation) {
		this._paths = paths;
		this._input = input;
		this._output = output;
		this._interpolation = interpolation;
	}

	get paths() {
		return this._paths;
	}

	get input() {
		return this._input;
	}

	get output() {
		return this._output;
	}

	get interpolation() {
		return this._interpolation;
	}

}

class AnimData {
	constructor(components, data) {
		this._components = components;
		this._data = data;
	}

	get components() {
		return this._components;
	}

	get data() {
		return this._data;
	}

}

class AnimEvents {
	constructor(events) {
		this._events = [...events];

		this._events.sort((a, b) => a.time - b.time);
	}

	get events() {
		return this._events;
	}

}

class AnimTrack {
	constructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])) {
		this._name = name;
		this._duration = duration;
		this._inputs = inputs;
		this._outputs = outputs;
		this._curves = curves;
		this._animEvents = animEvents;
	}

	get name() {
		return this._name;
	}

	get duration() {
		return this._duration;
	}

	get inputs() {
		return this._inputs;
	}

	get outputs() {
		return this._outputs;
	}

	get curves() {
		return this._curves;
	}

	set events(animEvents) {
		this._animEvents = animEvents;
	}

	get events() {
		return this._animEvents.events;
	}

	eval(time, snapshot) {
		snapshot._time = time;
		const inputs = this._inputs;
		const outputs = this._outputs;
		const curves = this._curves;
		const cache = snapshot._cache;
		const results = snapshot._results;

		for (let i = 0; i < inputs.length; ++i) {
			cache[i].update(time, inputs[i]._data);
		}

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const output = outputs[curve._output];
			const result = results[i];

			cache[curve._input].eval(result, curve._interpolation, output);
		}
	}

}

const INTERPOLATION_STEP = 0;
const INTERPOLATION_LINEAR = 1;
const INTERPOLATION_CUBIC = 2;

const DEFAULT_LOCALE = 'en-US';
const DEFAULT_LOCALE_FALLBACKS = {
	'en': 'en-US',
	'es': 'en-ES',
	'zh': 'zh-CN',
	'zh-HK': 'zh-TW',
	'zh-TW': 'zh-HK',
	'zh-MO': 'zh-HK',
	'fr': 'fr-FR',
	'de': 'de-DE',
	'it': 'it-IT',
	'ru': 'ru-RU',
	'ja': 'ja-JP'
};

const PLURALS = {};

function definePluralFn(locales, fn) {
	for (let i = 0, len = locales.length; i < len; i++) {
		PLURALS[locales[i]] = fn;
	}
}

function getLang(locale) {
	const idx = locale.indexOf('-');

	if (idx !== -1) {
		return locale.substring(0, idx);
	}

	return locale;
}

function replaceLang(locale, desiredLang) {
	const idx = locale.indexOf('-');

	if (idx !== -1) {
		return desiredLang + locale.substring(idx);
	}

	return desiredLang;
}

function findAvailableLocale(desiredLocale, availableLocales) {
	if (availableLocales[desiredLocale]) {
		return desiredLocale;
	}

	let fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];

	if (fallback && availableLocales[fallback]) {
		return fallback;
	}

	const lang = getLang(desiredLocale);
	fallback = DEFAULT_LOCALE_FALLBACKS[lang];

	if (availableLocales[fallback]) {
		return fallback;
	}

	if (availableLocales[lang]) {
		return lang;
	}

	return DEFAULT_LOCALE;
}

definePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {
	return 0;
});
definePluralFn(['fa', 'hi'], function (n) {
	if (n >= 0 && n <= 1) {
		return 0;
	}

	return 1;
});
definePluralFn(['fr', 'pt'], function (n) {
	if (n >= 0 && n < 2) {
		return 0;
	}

	return 1;
});
definePluralFn(['da'], function (n) {
	if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
		return 0;
	}

	return 1;
});
definePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {
	if (n === 1) {
		return 0;
	}

	return 1;
});
definePluralFn(['ru', 'uk'], function (n) {
	if (Number.isInteger(n)) {
		const mod10 = n % 10;
		const mod100 = n % 100;

		if (mod10 === 1 && mod100 !== 11) {
			return 0;
		} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
			return 1;
		} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
			return 2;
		}
	}

	return 3;
});
definePluralFn(['pl'], function (n) {
	if (Number.isInteger(n)) {
		if (n === 1) {
			return 0;
		}

		const mod10 = n % 10;
		const mod100 = n % 100;

		if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
			return 1;
		} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
			return 2;
		}
	}

	return 3;
});
definePluralFn(['ar'], function (n) {
	if (n === 0) {
		return 0;
	} else if (n === 1) {
		return 1;
	} else if (n === 2) {
		return 2;
	}

	if (Number.isInteger(n)) {
		const mod100 = n % 100;

		if (mod100 >= 3 && mod100 <= 10) {
			return 3;
		} else if (mod100 >= 11 && mod100 <= 99) {
			return 4;
		}
	}

	return 5;
});
const DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];

function getPluralFn(lang) {
	return PLURALS[lang] || DEFAULT_PLURAL_FN;
}

const ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-\\+\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');

class AssetFile {
	constructor(url, filename, hash, size, opt, contents) {
		this.url = url || '';
		this.filename = filename || '';
		this.hash = hash === undefined ? null : hash;
		this.size = size === undefined ? null : size;
		this.opt = opt === undefined ? null : opt;
		this.contents = contents || null;
	}

	equals(other) {
		return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
	}

}

let assetIdCounter = -1;
const VARIANT_SUPPORT = {
	pvr: 'extCompressedTexturePVRTC',
	dxt: 'extCompressedTextureS3TC',
	etc2: 'extCompressedTextureETC',
	etc1: 'extCompressedTextureETC1',
	basis: 'canvas'
};
const VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];

class Asset extends EventHandler {
	constructor(name, type, file, data, options) {
		super();
		this._id = assetIdCounter--;
		this.name = name || '';
		this.type = type;
		this.tags = new Tags(this);
		this._preload = false;
		this._file = null;
		this._data = data || {};
		this.options = options || {};
		this._resources = [];
		this._i18n = {};
		this.loaded = false;
		this.loading = false;
		this.registry = null;
		if (file) this.file = file;
	}

	set id(value) {
		this._id = value;
	}

	get id() {
		return this._id;
	}

	set file(value) {
		if (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {
			var _this$registry, _this$registry$_loade;

			const app = ((_this$registry = this.registry) == null ? void 0 : (_this$registry$_loade = _this$registry._loader) == null ? void 0 : _this$registry$_loade._app) || getApplication();
			const device = app == null ? void 0 : app.graphicsDevice;

			if (device) {
				for (let i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
					const variant = VARIANT_DEFAULT_PRIORITY[i];

					if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
						value = value.variants[variant];
						break;
					}

					if (app.enableBundles) {
						const bundles = app.bundles.listBundlesForAsset(this);

						if (bundles && bundles.find(b => {
							var _b$file;

							return b == null ? void 0 : (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];
						})) {
							break;
						}
					}
				}
			}
		}

		const oldFile = this._file;
		const newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;

		if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
			this._file = newFile;
			this.fire('change', this, 'file', newFile, oldFile);
			this.reload();
		}
	}

	get file() {
		return this._file;
	}

	set data(value) {
		const old = this._data;
		this._data = value;

		if (value !== old) {
			this.fire('change', this, 'data', value, old);
			if (this.loaded) this.registry._loader.patch(this, this.registry);
		}
	}

	get data() {
		return this._data;
	}

	set resource(value) {
		const _old = this._resources[0];
		this._resources[0] = value;
		this.fire('change', this, 'resource', value, _old);
	}

	get resource() {
		return this._resources[0];
	}

	set resources(value) {
		const _old = this._resources;
		this._resources = value;
		this.fire('change', this, 'resources', value, _old);
	}

	get resources() {
		return this._resources;
	}

	set preload(value) {
		value = !!value;
		if (this._preload === value) return;
		this._preload = value;
		if (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);
	}

	get preload() {
		return this._preload;
	}

	set loadFaces(value) {
		value = !!value;

		if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
			this._loadFaces = value;
			if (this.loaded) this.registry._loader.patch(this, this.registry);
		}
	}

	get loadFaces() {
		return this._loadFaces;
	}

	getFileUrl() {
		const file = this.file;
		if (!file || !file.url) return null;
		let url = file.url;
		if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;

		if (this.type !== 'script' && file.hash) {
			const separator = url.indexOf('?') !== -1 ? '&' : '?';
			url += separator + 't=' + file.hash;
		}

		return url;
	}

	getAbsoluteUrl(relativePath) {
		if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
			return relativePath;
		}

		const base = path.getDirectory(this.file.url);
		return path.join(base, relativePath);
	}

	getLocalizedAssetId(locale) {
		locale = findAvailableLocale(locale, this._i18n);
		return this._i18n[locale] || null;
	}

	addLocalizedAssetId(locale, assetId) {
		this._i18n[locale] = assetId;
		this.fire('add:localized', locale, assetId);
	}

	removeLocalizedAssetId(locale) {
		const assetId = this._i18n[locale];

		if (assetId) {
			delete this._i18n[locale];
			this.fire('remove:localized', locale, assetId);
		}
	}

	ready(callback, scope) {
		scope = scope || this;

		if (this.resource) {
			callback.call(scope, this);
		} else {
			this.once("load", function (asset) {
				callback.call(scope, asset);
			});
		}
	}

	reload() {
		if (this.loaded) {
			this.loaded = false;
			this.registry.load(this);
		}
	}

	unload() {
		if (!this.loaded && this._resources.length === 0) return;
		this.fire('unload', this);
		this.registry.fire('unload:' + this.id, this);
		const old = this._resources;
		this.resources = [];
		this.loaded = false;

		if (this.file) {
			this.registry._loader.clearCache(this.getFileUrl(), this.type);
		}

		for (let i = 0; i < old.length; ++i) {
			const resource = old[i];

			if (resource && resource.destroy) {
				resource.destroy();
			}
		}
	}

	static fetchArrayBuffer(loadUrl, callback, asset, maxRetries = 0) {
		var _asset$file;

		if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {
			setTimeout(() => {
				callback(null, asset.file.contents);
			});
		} else {
			http.get(loadUrl, {
				cache: true,
				responseType: 'arraybuffer',
				retry: maxRetries > 0,
				maxRetries: maxRetries
			}, callback);
		}
	}

}

class SkinInstanceCachedObject extends RefCountedObject {
	constructor(skin, skinInstance) {
		super();
		this.skin = skin;
		this.skinInstance = skinInstance;
	}

}

class SkinInstanceCache {
	static createCachedSkinInstance(skin, rootBone, entity) {
		let skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);

		if (!skinInst) {
			skinInst = new SkinInstance(skin);
			skinInst.resolve(rootBone, entity);
			SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
		}

		return skinInst;
	}

	static getCachedSkinInstance(skin, rootBone) {
		let skinInstance = null;

		const cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

		if (cachedObjArray) {
			const cachedObj = cachedObjArray.find(element => element.skin === skin);

			if (cachedObj) {
				cachedObj.incRefCount();
				skinInstance = cachedObj.skinInstance;
			}
		}

		return skinInstance;
	}

	static addCachedSkinInstance(skin, rootBone, skinInstance) {
		let cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

		if (!cachedObjArray) {
			cachedObjArray = [];

			SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
		}

		let cachedObj = cachedObjArray.find(element => element.skin === skin);

		if (!cachedObj) {
			cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
			cachedObjArray.push(cachedObj);
		}

		cachedObj.incRefCount();
	}

	static removeCachedSkinInstance(skinInstance) {
		if (skinInstance) {
			const rootBone = skinInstance.rootBone;

			if (rootBone) {
				const cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

				if (cachedObjArray) {
					const cachedObjIndex = cachedObjArray.findIndex(element => element.skinInstance === skinInstance);

					if (cachedObjIndex >= 0) {
						const cachedObj = cachedObjArray[cachedObjIndex];
						cachedObj.decRefCount();

						if (cachedObj.refCount === 0) {
							cachedObjArray.splice(cachedObjIndex, 1);

							if (!cachedObjArray.length) {
								SkinInstanceCache._skinInstanceCache.delete(rootBone);
							}

							if (skinInstance) {
								skinInstance.destroy();
								cachedObj.skinInstance = null;
							}
						}
					}
				}
			}
		}
	}

}

SkinInstanceCache._skinInstanceCache = new Map();

class GlbContainerResource {
	constructor(data, asset, assets, defaultMaterial) {
		const createAsset = function createAsset(type, resource, index) {
			const subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
			assets.add(subAsset);
			return subAsset;
		};

		const renders = [];

		for (let i = 0; i < data.renders.length; ++i) {
			renders.push(createAsset('render', data.renders[i], i));
		}

		const materials = [];

		for (let i = 0; i < data.materials.length; ++i) {
			materials.push(createAsset('material', data.materials[i], i));
		}

		const animations = [];

		for (let i = 0; i < data.animations.length; ++i) {
			animations.push(createAsset('animation', data.animations[i], i));
		}

		this.data = data;
		this._model = null;
		this._assetName = asset.name;
		this._assets = assets;
		this._defaultMaterial = defaultMaterial;
		this.renders = renders;
		this.materials = materials;
		this.textures = data.textures;
		this.animations = animations;
	}

	get model() {
		if (!this._model) {
			const model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
			const modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);

			this._assets.add(modelAsset);

			this._model = modelAsset;
		}

		return this._model;
	}

	static createAsset(assetName, type, resource, index) {
		const subAsset = new Asset(assetName + '/' + type + '/' + index, type, {
			url: ''
		});
		subAsset.resource = resource;
		subAsset.loaded = true;
		return subAsset;
	}

	instantiateModelEntity(options) {
		const entity = new Entity();
		entity.addComponent("model", Object.assign({
			type: "asset",
			asset: this.model
		}, options));
		return entity;
	}

	instantiateRenderEntity(options) {
		const defaultMaterial = this._defaultMaterial;
		const skinnedMeshInstances = [];

		const createMeshInstance = function createMeshInstance(root, entity, mesh, materials, skins, gltfNode) {
			const material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];
			const meshInstance = new MeshInstance(mesh, material);

			if (mesh.morph) {
				meshInstance.morphInstance = new MorphInstance(mesh.morph);
			}

			if (gltfNode.hasOwnProperty('skin')) {
				skinnedMeshInstances.push({
					meshInstance: meshInstance,
					rootBone: root,
					entity: entity
				});
			}

			return meshInstance;
		};

		const cloneHierarchy = function cloneHierarchy(root, node, glb) {
			const entity = new Entity();

			node._cloneInternal(entity);

			if (!root) root = entity;
			let attachedMi = null;

			for (let i = 0; i < glb.nodes.length; i++) {
				const glbNode = glb.nodes[i];

				if (glbNode === node) {
					const gltfNode = glb.gltf.nodes[i];

					if (gltfNode.hasOwnProperty('mesh')) {
						const meshGroup = glb.renders[gltfNode.mesh].meshes;

						for (var mi = 0; mi < meshGroup.length; mi++) {
							const mesh = meshGroup[mi];

							if (mesh) {
								const cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.skins, gltfNode);

								if (!attachedMi) {
									attachedMi = [];
								}

								attachedMi.push(cloneMi);
							}
						}
					}

					if (glb.lights) {
						const lightEntity = glb.lights.get(gltfNode);

						if (lightEntity) {
							entity.addChild(lightEntity.clone());
						}
					}

					if (glb.cameras) {
						const cameraEntity = glb.cameras.get(gltfNode);

						if (cameraEntity) {
							cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
						}
					}
				}
			}

			if (attachedMi) {
				entity.addComponent("render", Object.assign({
					type: "asset",
					meshInstances: attachedMi,
					rootBone: root
				}, options));
			}

			const children = node.children;

			for (let i = 0; i < children.length; i++) {
				const childClone = cloneHierarchy(root, children[i], glb);
				entity.addChild(childClone);
			}

			return entity;
		};

		const sceneClones = [];

		for (const scene of this.data.scenes) {
			sceneClones.push(cloneHierarchy(null, scene, this.data));
		}

		skinnedMeshInstances.forEach(data => {
			data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
		});
		return GlbContainerResource.createSceneHierarchy(sceneClones, "Entity");
	}

	static createSceneHierarchy(sceneNodes, nodeType) {
		let root = null;

		if (sceneNodes.length === 1) {
			root = sceneNodes[0];
		} else {
			root = new nodeType('SceneGroup');

			for (const scene of sceneNodes) {
				root.addChild(scene);
			}
		}

		return root;
	}

	static createModel(glb, defaultMaterial) {
		const createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
			const material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];
			const meshInstance = new MeshInstance(mesh, material, node);

			if (mesh.morph) {
				const morphInstance = new MorphInstance(mesh.morph);
				meshInstance.morphInstance = morphInstance;
				model.morphInstances.push(morphInstance);
			}

			if (gltfNode.hasOwnProperty('skin')) {
				const skinIndex = gltfNode.skin;
				const skin = skins[skinIndex];
				mesh.skin = skin;
				const skinInstance = skinInstances[skinIndex];
				meshInstance.skinInstance = skinInstance;
				model.skinInstances.push(skinInstance);
			}

			model.meshInstances.push(meshInstance);
		};

		const model = new Model();
		const skinInstances = [];

		for (const skin of glb.skins) {
			const skinInstance = new SkinInstance(skin);
			skinInstance.bones = skin.bones;
			skinInstances.push(skinInstance);
		}

		model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, "GraphNode");

		for (let i = 0; i < glb.nodes.length; i++) {
			const node = glb.nodes[i];

			if (node.root === model.graph) {
				const gltfNode = glb.gltf.nodes[i];

				if (gltfNode.hasOwnProperty('mesh')) {
					const meshGroup = glb.renders[gltfNode.mesh].meshes;

					for (var mi = 0; mi < meshGroup.length; mi++) {
						const mesh = meshGroup[mi];

						if (mesh) {
							createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
						}
					}
				}
			}
		}

		return model;
	}

	destroy() {
		const registry = this._assets;

		const destroyAsset = function destroyAsset(asset) {
			registry.remove(asset);
			asset.unload();
		};

		const destroyAssets = function destroyAssets(assets) {
			assets.forEach(function (asset) {
				destroyAsset(asset);
			});
		};

		if (this.animations) {
			destroyAssets(this.animations);
			this.animations = null;
		}

		if (this.textures) {
			destroyAssets(this.textures);
			this.textures = null;
		}

		if (this.materials) {
			destroyAssets(this.materials);
			this.materials = null;
		}

		if (this.renders) {
			destroyAssets(this.renders);
			this.renders = null;
		}

		if (this._model) {
			destroyAsset(this._model);
			this._model = null;
		}

		this.data = null;
		this.assets = null;
	}

}

class GlbResources {
	constructor(gltf) {
		this.gltf = gltf;
		this.nodes = null;
		this.scenes = null;
		this.animations = null;
		this.textures = null;
		this.materials = null;
		this.renders = null;
		this.skins = null;
		this.lights = null;
		this.cameras = null;
	}

	destroy() {
		if (this.renders) {
			this.renders.forEach(render => {
				render.meshes = null;
			});
		}
	}

}

const isDataURI = function isDataURI(uri) {
	return /^data:.*,.*$/i.test(uri);
};

const getDataURIMimeType = function getDataURIMimeType(uri) {
	return uri.substring(uri.indexOf(":") + 1, uri.indexOf(";"));
};

const getNumComponents = function getNumComponents(accessorType) {
	switch (accessorType) {
		case 'SCALAR':
			return 1;

		case 'VEC2':
			return 2;

		case 'VEC3':
			return 3;

		case 'VEC4':
			return 4;

		case 'MAT2':
			return 4;

		case 'MAT3':
			return 9;

		case 'MAT4':
			return 16;

		default:
			return 3;
	}
};

const getComponentType = function getComponentType(componentType) {
	switch (componentType) {
		case 5120:
			return TYPE_INT8;

		case 5121:
			return TYPE_UINT8;

		case 5122:
			return TYPE_INT16;

		case 5123:
			return TYPE_UINT16;

		case 5124:
			return TYPE_INT32;

		case 5125:
			return TYPE_UINT32;

		case 5126:
			return TYPE_FLOAT32;

		default:
			return 0;
	}
};

const getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {
	switch (componentType) {
		case 5120:
			return 1;

		case 5121:
			return 1;

		case 5122:
			return 2;

		case 5123:
			return 2;

		case 5124:
			return 4;

		case 5125:
			return 4;

		case 5126:
			return 4;

		default:
			return 0;
	}
};

const getComponentDataType = function getComponentDataType(componentType) {
	switch (componentType) {
		case 5120:
			return Int8Array;

		case 5121:
			return Uint8Array;

		case 5122:
			return Int16Array;

		case 5123:
			return Uint16Array;

		case 5124:
			return Int32Array;

		case 5125:
			return Uint32Array;

		case 5126:
			return Float32Array;

		default:
			return null;
	}
};

const gltfToEngineSemanticMap = {
	'POSITION': SEMANTIC_POSITION,
	'NORMAL': SEMANTIC_NORMAL,
	'TANGENT': SEMANTIC_TANGENT,
	'COLOR_0': SEMANTIC_COLOR,
	'JOINTS_0': SEMANTIC_BLENDINDICES,
	'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
	'TEXCOORD_0': SEMANTIC_TEXCOORD0,
	'TEXCOORD_1': SEMANTIC_TEXCOORD1,
	'TEXCOORD_2': SEMANTIC_TEXCOORD2,
	'TEXCOORD_3': SEMANTIC_TEXCOORD3,
	'TEXCOORD_4': SEMANTIC_TEXCOORD4,
	'TEXCOORD_5': SEMANTIC_TEXCOORD5,
	'TEXCOORD_6': SEMANTIC_TEXCOORD6,
	'TEXCOORD_7': SEMANTIC_TEXCOORD7
};

const getDequantizeFunc = srcType => {
	switch (srcType) {
		case TYPE_INT8:
			return x => Math.max(x / 127.0, -1.0);

		case TYPE_UINT8:
			return x => x / 255.0;

		case TYPE_INT16:
			return x => Math.max(x / 32767.0, -1.0);

		case TYPE_UINT16:
			return x => x / 65535.0;

		default:
			return x => x;
	}
};

const dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {
	const convFunc = getDequantizeFunc(srcType);
	const len = srcArray.length;

	for (let i = 0; i < len; ++i) {
		dstArray[i] = convFunc(srcArray[i]);
	}

	return dstArray;
};

const getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten = false) {
	const numComponents = getNumComponents(gltfAccessor.type);
	const dataType = getComponentDataType(gltfAccessor.componentType);

	if (!dataType) {
		return null;
	}

	const bufferView = bufferViews[gltfAccessor.bufferView];
	let result;

	if (gltfAccessor.sparse) {
		const sparse = gltfAccessor.sparse;
		const indicesAccessor = {
			count: sparse.count,
			type: "SCALAR"
		};
		const indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
		const valuesAccessor = {
			count: sparse.count,
			type: gltfAccessor.scalar,
			componentType: gltfAccessor.componentType
		};
		const values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);

		if (gltfAccessor.hasOwnProperty('bufferView')) {
			const baseAccessor = {
				bufferView: gltfAccessor.bufferView,
				byteOffset: gltfAccessor.byteOffset,
				componentType: gltfAccessor.componentType,
				count: gltfAccessor.count,
				type: gltfAccessor.type
			};
			result = getAccessorData(baseAccessor, bufferViews, true).slice();
		} else {
			result = new dataType(gltfAccessor.count * numComponents);
		}

		for (let i = 0; i < sparse.count; ++i) {
			const targetIndex = indices[i];

			for (let j = 0; j < numComponents; ++j) {
				result[targetIndex * numComponents + j] = values[i * numComponents + j];
			}
		}
	} else if (flatten && bufferView.hasOwnProperty('byteStride')) {
		const bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
		const storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
		const tmpArray = new Uint8Array(storage);
		let dstOffset = 0;

		for (let i = 0; i < gltfAccessor.count; ++i) {
			let srcOffset = (gltfAccessor.byteOffset || 0) + i * bufferView.byteStride;

			for (let b = 0; b < bytesPerElement; ++b) {
				tmpArray[dstOffset++] = bufferView[srcOffset++];
			}
		}

		result = new dataType(storage);
	} else {
		result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
	}

	return result;
};

const getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {
	const data = getAccessorData(gltfAccessor, bufferViews, true);

	if (data instanceof Float32Array || !gltfAccessor.normalized) {
		return data;
	}

	const float32Data = new Float32Array(data.length);
	dequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));
	return float32Data;
};

const getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {
	let min = gltfAccessor.min;
	let max = gltfAccessor.max;

	if (!min || !max) {
		return null;
	}

	if (gltfAccessor.normalized) {
		const ctype = getComponentType(gltfAccessor.componentType);
		min = dequantizeArray([], min, ctype);
		max = dequantizeArray([], max, ctype);
	}

	return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
};

const getPrimitiveType = function getPrimitiveType(primitive) {
	if (!primitive.hasOwnProperty('mode')) {
		return PRIMITIVE_TRIANGLES;
	}

	switch (primitive.mode) {
		case 0:
			return PRIMITIVE_POINTS;

		case 1:
			return PRIMITIVE_LINES;

		case 2:
			return PRIMITIVE_LINELOOP;

		case 3:
			return PRIMITIVE_LINESTRIP;

		case 4:
			return PRIMITIVE_TRIANGLES;

		case 5:
			return PRIMITIVE_TRISTRIP;

		case 6:
			return PRIMITIVE_TRIFAN;

		default:
			return PRIMITIVE_TRIANGLES;
	}
};

const generateIndices = function generateIndices(numVertices) {
	const dummyIndices = new Uint16Array(numVertices);

	for (let i = 0; i < numVertices; i++) {
		dummyIndices[i] = i;
	}

	return dummyIndices;
};

const generateNormals = function generateNormals(sourceDesc, indices) {
	const p = sourceDesc[SEMANTIC_POSITION];

	if (!p || p.components !== 3) {
		return;
	}

	let positions;

	if (p.size !== p.stride) {
		const srcStride = p.stride / typedArrayTypesByteSize[p.type];
		const src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
		positions = new typedArrayTypes[p.type](p.count * 3);

		for (let i = 0; i < p.count; ++i) {
			positions[i * 3 + 0] = src[i * srcStride + 0];
			positions[i * 3 + 1] = src[i * srcStride + 1];
			positions[i * 3 + 2] = src[i * srcStride + 2];
		}
	} else {
		positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
	}

	const numVertices = p.count;

	if (!indices) {
		indices = generateIndices(numVertices);
	}

	const normalsTemp = calculateNormals(positions, indices);
	const normals = new Float32Array(normalsTemp.length);
	normals.set(normalsTemp);
	sourceDesc[SEMANTIC_NORMAL] = {
		buffer: normals.buffer,
		size: 12,
		offset: 0,
		stride: 12,
		count: numVertices,
		components: 3,
		type: TYPE_FLOAT32
	};
};

const flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {
	let i, j;
	const floatOffsets = [];
	const shortOffsets = [];
	const byteOffsets = [];

	for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
		const element = vertexBuffer.format.elements[i];

		if (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {
			switch (element.dataType) {
				case TYPE_FLOAT32:
					floatOffsets.push({
						offset: element.offset / 4 + 1,
						stride: element.stride / 4
					});
					break;

				case TYPE_UINT16:
					shortOffsets.push({
						offset: element.offset / 2 + 1,
						stride: element.stride / 2
					});
					break;

				case TYPE_UINT8:
					byteOffsets.push({
						offset: element.offset + 1,
						stride: element.stride
					});
					break;
			}
		}
	}

	const flip = function flip(offsets, type, one) {
		const typedArray = new type(vertexBuffer.storage);

		for (i = 0; i < offsets.length; ++i) {
			let index = offsets[i].offset;
			const stride = offsets[i].stride;

			for (j = 0; j < vertexBuffer.numVertices; ++j) {
				typedArray[index] = one - typedArray[index];
				index += stride;
			}
		}
	};

	if (floatOffsets.length > 0) {
		flip(floatOffsets, Float32Array, 1.0);
	}

	if (shortOffsets.length > 0) {
		flip(shortOffsets, Uint16Array, 65535);
	}

	if (byteOffsets.length > 0) {
		flip(byteOffsets, Uint8Array, 255);
	}
};

const cloneTexture = function cloneTexture(texture) {
	const shallowCopyLevels = function shallowCopyLevels(texture) {
		const result = [];

		for (let mip = 0; mip < texture._levels.length; ++mip) {
			let level = [];

			if (texture.cubemap) {
				for (let face = 0; face < 6; ++face) {
					level.push(texture._levels[mip][face]);
				}
			} else {
				level = texture._levels[mip];
			}

			result.push(level);
		}

		return result;
	};

	const result = new Texture(texture.device, texture);
	result._levels = shallowCopyLevels(texture);
	return result;
};

const cloneTextureAsset = function cloneTextureAsset(src) {
	const result = new Asset(src.name + '_clone', src.type, src.file, src.data, src.options);
	result.loaded = true;
	result.resource = cloneTexture(src.resource);
	src.registry.add(result);
	return result;
};

const createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {
	const positionDesc = sourceDesc[SEMANTIC_POSITION];

	if (!positionDesc) {
		return null;
	}

	const numVertices = positionDesc.count;
	const vertexDesc = [];

	for (const semantic in sourceDesc) {
		if (sourceDesc.hasOwnProperty(semantic)) {
			vertexDesc.push({
				semantic: semantic,
				components: sourceDesc[semantic].components,
				type: sourceDesc[semantic].type,
				normalize: !!sourceDesc[semantic].normalize
			});
		}
	}

	const elementOrder = [SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1];
	vertexDesc.sort(function (lhs, rhs) {
		const lhsOrder = elementOrder.indexOf(lhs.semantic);
		const rhsOrder = elementOrder.indexOf(rhs.semantic);
		return lhsOrder < rhsOrder ? -1 : rhsOrder < lhsOrder ? 1 : 0;
	});
	let i, j, k;
	let source, target, sourceOffset;
	const vertexFormat = new VertexFormat(device, vertexDesc);
	let isCorrectlyInterleaved = true;

	for (i = 0; i < vertexFormat.elements.length; ++i) {
		target = vertexFormat.elements[i];
		source = sourceDesc[target.name];
		sourceOffset = source.offset - positionDesc.offset;

		if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
			isCorrectlyInterleaved = false;
			break;
		}
	}

	const vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC);
	const vertexData = vertexBuffer.lock();
	const targetArray = new Uint32Array(vertexData);
	let sourceArray;

	if (isCorrectlyInterleaved) {
		sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
		targetArray.set(sourceArray);
	} else {
		let targetStride, sourceStride;

		for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
			target = vertexBuffer.format.elements[i];
			targetStride = target.stride / 4;
			source = sourceDesc[target.name];
			sourceStride = source.stride / 4;
			sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
			let src = 0;
			let dst = target.offset / 4;
			const kend = Math.floor((source.size + 3) / 4);

			for (j = 0; j < numVertices; ++j) {
				for (k = 0; k < kend; ++k) {
					targetArray[dst + k] = sourceArray[src + k];
				}

				src += sourceStride;
				dst += targetStride;
			}
		}
	}

	if (flipV) {
		flipTexCoordVs(vertexBuffer);
	}

	vertexBuffer.unlock();
	return vertexBuffer;
};

const createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {
	const useAttributes = {};
	const attribIds = [];

	for (const attrib in attributes) {
		if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
			useAttributes[attrib] = attributes[attrib];
			attribIds.push(attrib + ":" + attributes[attrib]);
		}
	}

	attribIds.sort();
	const vbKey = attribIds.join();
	let vb = vertexBufferDict[vbKey];

	if (!vb) {
		const sourceDesc = {};

		for (const attrib in useAttributes) {
			const accessor = accessors[attributes[attrib]];
			const accessorData = getAccessorData(accessor, bufferViews);
			const bufferView = bufferViews[accessor.bufferView];
			const semantic = gltfToEngineSemanticMap[attrib];
			const size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
			const stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
			sourceDesc[semantic] = {
				buffer: accessorData.buffer,
				size: size,
				offset: accessorData.byteOffset,
				stride: stride,
				count: accessor.count,
				components: getNumComponents(accessor.type),
				type: getComponentType(accessor.componentType),
				normalize: accessor.normalized
			};
		}

		if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
			generateNormals(sourceDesc, indices);
		}

		vb = createVertexBufferInternal(device, sourceDesc, flipV);
		vertexBufferDict[vbKey] = vb;
	}

	return vb;
};

const createVertexBufferDraco = function createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV) {
	const numPoints = outputGeometry.num_points();

	const extractDracoAttributeInfo = function extractDracoAttributeInfo(uniqueId) {
		const attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);
		const numValues = numPoints * attribute.num_components();
		const dracoFormat = attribute.data_type();
		let ptr, values, componentSizeInBytes, storageType;

		switch (dracoFormat) {
			case decoderModule.DT_UINT8:
				storageType = TYPE_UINT8;
				componentSizeInBytes = 1;
				ptr = decoderModule._malloc(numValues * componentSizeInBytes);
				decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);
				values = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();
				break;

			case decoderModule.DT_UINT16:
				storageType = TYPE_UINT16;
				componentSizeInBytes = 2;
				ptr = decoderModule._malloc(numValues * componentSizeInBytes);
				decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);
				values = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();
				break;

			case decoderModule.DT_FLOAT32:
			default:
				storageType = TYPE_FLOAT32;
				componentSizeInBytes = 4;
				ptr = decoderModule._malloc(numValues * componentSizeInBytes);
				decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);
				values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
				break;
		}

		decoderModule._free(ptr);

		return {
			values: values,
			numComponents: attribute.num_components(),
			componentSizeInBytes: componentSizeInBytes,
			storageType: storageType,
			normalized: attribute.normalized()
		};
	};

	const sourceDesc = {};
	const attributes = extDraco.attributes;

	for (const attrib in attributes) {
		if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
			const semantic = gltfToEngineSemanticMap[attrib];
			const attributeInfo = extractDracoAttributeInfo(attributes[attrib]);
			const size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;
			sourceDesc[semantic] = {
				values: attributeInfo.values,
				buffer: attributeInfo.values.buffer,
				size: size,
				offset: 0,
				stride: size,
				count: numPoints,
				components: attributeInfo.numComponents,
				type: attributeInfo.storageType,
				normalize: attributeInfo.normalized
			};
		}
	}

	if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
		generateNormals(sourceDesc, indices);
	}

	return createVertexBufferInternal(device, sourceDesc, flipV);
};

const createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {
	let i, j, bindMatrix;
	const joints = gltfSkin.joints;
	const numJoints = joints.length;
	const ibp = [];

	if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
		const inverseBindMatrices = gltfSkin.inverseBindMatrices;
		const ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
		const ibmValues = [];

		for (i = 0; i < numJoints; i++) {
			for (j = 0; j < 16; j++) {
				ibmValues[j] = ibmData[i * 16 + j];
			}

			bindMatrix = new Mat4();
			bindMatrix.set(ibmValues);
			ibp.push(bindMatrix);
		}
	} else {
		for (i = 0; i < numJoints; i++) {
			bindMatrix = new Mat4();
			ibp.push(bindMatrix);
		}
	}

	const boneNames = [];

	for (i = 0; i < numJoints; i++) {
		boneNames[i] = nodes[joints[i]].name;
	}

	const key = boneNames.join("#");
	let skin = glbSkins.get(key);

	if (!skin) {
		skin = new Skin(device, ibp, boneNames);
		glbSkins.set(key, skin);
	}

	return skin;
};

const tempMat = new Mat4();
const tempVec$1 = new Vec3();

const createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, callback, flipV, vertexBufferDict) {
	const meshes = [];
	gltfMesh.primitives.forEach(function (primitive) {
		let primitiveType, vertexBuffer, numIndices;
		let indices = null;
		let canUseMorph = true;

		if (primitive.hasOwnProperty('extensions')) {
			const extensions = primitive.extensions;

			if (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {
				const decoderModule = window.DracoDecoderModule;

				if (decoderModule) {
					const extDraco = extensions.KHR_draco_mesh_compression;

					if (extDraco.hasOwnProperty('attributes')) {
						const uint8Buffer = bufferViews[extDraco.bufferView];
						const buffer = new decoderModule.DecoderBuffer();
						buffer.Init(uint8Buffer, uint8Buffer.length);
						const decoder = new decoderModule.Decoder();
						const geometryType = decoder.GetEncodedGeometryType(buffer);
						let outputGeometry, status;

						switch (geometryType) {
							case decoderModule.POINT_CLOUD:
								primitiveType = PRIMITIVE_POINTS;
								outputGeometry = new decoderModule.PointCloud();
								status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);
								break;

							case decoderModule.TRIANGULAR_MESH:
								primitiveType = PRIMITIVE_TRIANGLES;
								outputGeometry = new decoderModule.Mesh();
								status = decoder.DecodeBufferToMesh(buffer, outputGeometry);
								break;

							case decoderModule.INVALID_GEOMETRY_TYPE:
						}

						if (!status || !status.ok() || outputGeometry.ptr == 0) {
							callback("Failed to decode draco compressed asset: " + (status ? status.error_msg() : 'Mesh asset - invalid draco compressed geometry type: ' + geometryType));
							return;
						}

						const numFaces = outputGeometry.num_faces();

						if (geometryType === decoderModule.TRIANGULAR_MESH) {
							const bit32 = outputGeometry.num_points() > 65535;
							numIndices = numFaces * 3;
							const dataSize = numIndices * (bit32 ? 4 : 2);

							const ptr = decoderModule._malloc(dataSize);

							if (bit32) {
								decoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);
								indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
							} else {
								decoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);
								indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
							}

							decoderModule._free(ptr);
						}

						vertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV);
						decoderModule.destroy(outputGeometry);
						decoderModule.destroy(decoder);
						decoderModule.destroy(buffer);
						canUseMorph = false;
					}
				}
			}
		}

		if (!vertexBuffer) {
			indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
			vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);
			primitiveType = getPrimitiveType(primitive);
		}

		let mesh = null;

		if (vertexBuffer) {
			mesh = new Mesh(device);
			mesh.vertexBuffer = vertexBuffer;
			mesh.primitive[0].type = primitiveType;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].indexed = indices !== null;

			if (indices !== null) {
				let indexFormat;

				if (indices instanceof Uint8Array) {
					indexFormat = INDEXFORMAT_UINT8;
				} else if (indices instanceof Uint16Array) {
					indexFormat = INDEXFORMAT_UINT16;
				} else {
					indexFormat = INDEXFORMAT_UINT32;
				}

				if (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {
					indexFormat = INDEXFORMAT_UINT16;
					indices = new Uint16Array(indices);
				}

				const indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
				mesh.indexBuffer[0] = indexBuffer;
				mesh.primitive[0].count = indices.length;
			} else {
				mesh.primitive[0].count = vertexBuffer.numVertices;
			}

			mesh.materialIndex = primitive.material;
			let accessor = accessors[primitive.attributes.POSITION];
			mesh.aabb = getAccessorBoundingBox(accessor);

			if (canUseMorph && primitive.hasOwnProperty('targets')) {
				const targets = [];
				primitive.targets.forEach(function (target, index) {
					const options = {};

					if (target.hasOwnProperty('POSITION')) {
						accessor = accessors[target.POSITION];
						options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
						options.deltaPositionsType = TYPE_FLOAT32;
						options.aabb = getAccessorBoundingBox(accessor);
					}

					if (target.hasOwnProperty('NORMAL')) {
						accessor = accessors[target.NORMAL];
						options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
						options.deltaNormalsType = TYPE_FLOAT32;
					}

					if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
						options.name = gltfMesh.extras.targetNames[index];
					} else {
						options.name = index.toString(10);
					}

					if (gltfMesh.hasOwnProperty('weights')) {
						options.defaultWeight = gltfMesh.weights[index];
					}

					targets.push(new MorphTarget(options));
				});
				mesh.morph = new Morph(targets, device);
			}
		}

		meshes.push(mesh);
	});
	return meshes;
};

const createMaterial = function createMaterial(gltfMaterial, textures, flipV) {
	const glossChunk = ["#ifdef MAPFLOAT", "uniform float material_shininess;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_glossMap;", "#endif", "", "void getGlossiness() {", "		dGlossiness = 1.0;", "", "#ifdef MAPFLOAT", "		dGlossiness *= material_shininess;", "#endif", "", "#ifdef MAPTEXTURE", "		dGlossiness *= texture2D(texture_glossMap, $UV).$CH;", "#endif", "", "#ifdef MAPVERTEX", "		dGlossiness *= saturate(vVertexColor.$VC);", "#endif", "", "		dGlossiness = 1.0 - dGlossiness;", "", "		dGlossiness += 0.0000001;", "}"].join('\n');
	const specularChunk = ["#ifdef MAPCOLOR", "uniform vec3 material_specular;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_specularMap;", "#endif", "", "void getSpecularity() {", "		dSpecularity = vec3(1.0);", "", "		#ifdef MAPCOLOR", "				dSpecularity *= material_specular;", "		#endif", "", "		#ifdef MAPTEXTURE", "				vec3 srgb = texture2D(texture_specularMap, $UV).$CH;", "				dSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));", "		#endif", "", "		#ifdef MAPVERTEX", "				dSpecularity *= saturate(vVertexColor.$VC);", "		#endif", "}"].join('\n');
	const clearCoatGlossChunk = ["#ifdef MAPFLOAT", "uniform float material_clearCoatGlossiness;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_clearCoatGlossMap;", "#endif", "", "void getClearCoatGlossiness() {", "		ccGlossiness = 1.0;", "", "#ifdef MAPFLOAT", "		ccGlossiness *= material_clearCoatGlossiness;", "#endif", "", "#ifdef MAPTEXTURE", "		ccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;", "#endif", "", "#ifdef MAPVERTEX", "		ccGlossiness *= saturate(vVertexColor.$VC);", "#endif", "", "		ccGlossiness = 1.0 - ccGlossiness;", "", "		ccGlossiness += 0.0000001;", "}"].join('\n');
	const zeros = [0, 0];
	const ones = [1, 1];

	const extractTextureTransform = function extractTextureTransform(source, material, maps) {
		var _source$extensions;

		let map;
		const texCoord = source.texCoord;

		if (texCoord) {
			for (map = 0; map < maps.length; ++map) {
				material[maps[map] + 'MapUv'] = texCoord;
			}
		}

		const textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;

		if (textureTransform) {
			const offset = textureTransform.offset || zeros;
			const scale = textureTransform.scale || ones;
			const rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
			const tilingVec = new Vec2(scale[0], scale[1]);
			const offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);

			for (map = 0; map < maps.length; ++map) {
				material[`${maps[map]}MapTiling`] = tilingVec;
				material[`${maps[map]}MapOffset`] = offsetVec;
				material[`${maps[map]}MapRotation`] = rotation;
			}
		}
	};

	const material = new StandardMaterial();
	material.occludeSpecular = true;
	material.diffuseTint = true;
	material.diffuseVertexColor = true;
	material.specularTint = true;
	material.specularVertexColor = true;

	if (gltfMaterial.hasOwnProperty('name')) {
		material.name = gltfMaterial.name;
	}

	let color, texture;

	if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_pbrSpecularGlossiness')) {
		const specData = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;

		if (specData.hasOwnProperty('diffuseFactor')) {
			color = specData.diffuseFactor;
			material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.opacity = color[3];
		} else {
			material.diffuse.set(1, 1, 1);
			material.opacity = 1;
		}

		if (specData.hasOwnProperty('diffuseTexture')) {
			const diffuseTexture = specData.diffuseTexture;
			texture = textures[diffuseTexture.index];
			material.diffuseMap = texture;
			material.diffuseMapChannel = 'rgb';
			material.opacityMap = texture;
			material.opacityMapChannel = 'a';
			extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
		}

		material.useMetalness = false;

		if (specData.hasOwnProperty('specularFactor')) {
			color = specData.specularFactor;
			material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.specular.set(1, 1, 1);
		}

		if (specData.hasOwnProperty('glossinessFactor')) {
			material.shininess = 100 * specData.glossinessFactor;
		} else {
			material.shininess = 100;
		}

		if (specData.hasOwnProperty('specularGlossinessTexture')) {
			const specularGlossinessTexture = specData.specularGlossinessTexture;
			material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
			material.specularMapChannel = 'rgb';
			material.glossMapChannel = 'a';
			extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
		}

		material.chunks.specularPS = specularChunk;
	} else if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
		const pbrData = gltfMaterial.pbrMetallicRoughness;

		if (pbrData.hasOwnProperty('baseColorFactor')) {
			color = pbrData.baseColorFactor;
			material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.opacity = color[3];
		} else {
			material.diffuse.set(1, 1, 1);
			material.opacity = 1;
		}

		if (pbrData.hasOwnProperty('baseColorTexture')) {
			const baseColorTexture = pbrData.baseColorTexture;
			texture = textures[baseColorTexture.index];
			material.diffuseMap = texture;
			material.diffuseMapChannel = 'rgb';
			material.opacityMap = texture;
			material.opacityMapChannel = 'a';
			extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
		}

		material.useMetalness = true;

		if (pbrData.hasOwnProperty('metallicFactor')) {
			material.metalness = pbrData.metallicFactor;
		} else {
			material.metalness = 1;
		}

		if (pbrData.hasOwnProperty('roughnessFactor')) {
			material.shininess = 100 * pbrData.roughnessFactor;
		} else {
			material.shininess = 100;
		}

		if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
			const metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
			material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
			material.metalnessMapChannel = 'b';
			material.glossMapChannel = 'g';
			extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
		}

		material.chunks.glossPS = glossChunk;
	}

	if (gltfMaterial.hasOwnProperty('normalTexture')) {
		const normalTexture = gltfMaterial.normalTexture;
		material.normalMap = textures[normalTexture.index];
		extractTextureTransform(normalTexture, material, ['normal']);

		if (normalTexture.hasOwnProperty('scale')) {
			material.bumpiness = normalTexture.scale;
		}
	}

	if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
		const occlusionTexture = gltfMaterial.occlusionTexture;
		material.aoMap = textures[occlusionTexture.index];
		material.aoMapChannel = 'r';
		extractTextureTransform(occlusionTexture, material, ['ao']);
	}

	if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
		color = gltfMaterial.emissiveFactor;
		material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		material.emissiveTint = true;
	} else {
		material.emissive.set(0, 0, 0);
		material.emissiveTint = false;
	}

	if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
		const emissiveTexture = gltfMaterial.emissiveTexture;
		material.emissiveMap = textures[emissiveTexture.index];
		extractTextureTransform(emissiveTexture, material, ['emissive']);
	}

	if (gltfMaterial.hasOwnProperty('alphaMode')) {
		switch (gltfMaterial.alphaMode) {
			case 'MASK':
				material.blendType = BLEND_NONE;

				if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
					material.alphaTest = gltfMaterial.alphaCutoff;
				} else {
					material.alphaTest = 0.5;
				}

				break;

			case 'BLEND':
				material.blendType = BLEND_NORMAL;
				break;

			default:
			case 'OPAQUE':
				material.blendType = BLEND_NONE;
				break;
		}
	} else {
		material.blendType = BLEND_NONE;
	}

	if (gltfMaterial.hasOwnProperty('doubleSided')) {
		material.twoSidedLighting = gltfMaterial.doubleSided;
		material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
	} else {
		material.twoSidedLighting = false;
		material.cull = CULLFACE_BACK;
	}

	if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_clearcoat')) {
		const ccData = gltfMaterial.extensions.KHR_materials_clearcoat;

		if (ccData.hasOwnProperty('clearcoatFactor')) {
			material.clearCoat = ccData.clearcoatFactor * 0.25;
		} else {
			material.clearCoat = 0;
		}

		if (ccData.hasOwnProperty('clearcoatTexture')) {
			const clearcoatTexture = ccData.clearcoatTexture;
			material.clearCoatMap = textures[clearcoatTexture.index];
			material.clearCoatMapChannel = 'r';
			extractTextureTransform(clearcoatTexture, material, ['clearCoat']);
		}

		if (ccData.hasOwnProperty('clearcoatRoughnessFactor')) {
			material.clearCoatGlossiness = ccData.clearcoatRoughnessFactor;
		} else {
			material.clearCoatGlossiness = 0;
		}

		if (ccData.hasOwnProperty('clearcoatRoughnessTexture')) {
			const clearcoatRoughnessTexture = ccData.clearcoatRoughnessTexture;
			material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
			material.clearCoatGlossMapChannel = 'g';
			extractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);
		}

		if (ccData.hasOwnProperty('clearcoatNormalTexture')) {
			const clearcoatNormalTexture = ccData.clearcoatNormalTexture;
			material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
			extractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);

			if (clearcoatNormalTexture.hasOwnProperty('scale')) {
				material.clearCoatBumpiness = clearcoatNormalTexture.scale;
			}
		}

		material.chunks.clearCoatGlossPS = clearCoatGlossChunk;
	}

	if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_unlit')) {
		material.useLighting = false;
		material.emissive.copy(material.diffuse);
		material.emissiveTint = material.diffuseTint;
		material.emissiveMap = material.diffuseMap;
		material.emissiveMapUv = material.diffuseMapUv;
		material.emissiveMapTiling.copy(material.diffuseMapTiling);
		material.emissiveMapOffset.copy(material.diffuseMapOffset);
		material.emissiveMapChannel = material.diffuseMapChannel;
		material.emissiveVertexColor = material.diffuseVertexColor;
		material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
		material.diffuse.set(0, 0, 0);
		material.diffuseTint = false;
		material.diffuseMap = null;
		material.diffuseVertexColor = false;
	}

	material.update();
	return material;
};

const createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes) {
	const createAnimData = function createAnimData(gltfAccessor) {
		return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
	};

	const interpMap = {
		"STEP": INTERPOLATION_STEP,
		"LINEAR": INTERPOLATION_LINEAR,
		"CUBICSPLINE": INTERPOLATION_CUBIC
	};
	const inputMap = {};
	const inputs = [];
	const outputMap = {};
	const outputs = [];
	const curves = [];
	let i;

	for (i = 0; i < gltfAnimation.samplers.length; ++i) {
		const sampler = gltfAnimation.samplers[i];

		if (!inputMap.hasOwnProperty(sampler.input)) {
			inputMap[sampler.input] = inputs.length;
			inputs.push(createAnimData(gltfAccessors[sampler.input]));
		}

		if (!outputMap.hasOwnProperty(sampler.output)) {
			outputMap[sampler.output] = outputs.length;
			outputs.push(createAnimData(gltfAccessors[sampler.output]));
		}

		const interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
		curves.push(new AnimCurve([], inputMap[sampler.input], outputMap[sampler.output], interpolation));
	}

	const quatArrays = [];
	const transformSchema = {
		'translation': 'localPosition',
		'rotation': 'localRotation',
		'scale': 'localScale',
		'weights': 'weights'
	};

	const constructNodePath = node => {
		const path = [];

		while (node) {
			path.unshift(node.name);
			node = node.parent;
		}

		return path;
	};

	for (i = 0; i < gltfAnimation.channels.length; ++i) {
		const channel = gltfAnimation.channels[i];
		const target = channel.target;
		const curve = curves[channel.sampler];
		const node = nodes[target.node];
		const entityPath = constructNodePath(node);

		curve._paths.push({
			entityPath: entityPath,
			component: 'graph',
			propertyPath: [transformSchema[target.path]]
		});

		if (target.path.startsWith('rotation') && curve.interpolation !== INTERPOLATION_CUBIC) {
			quatArrays.push(curve.output);
		} else if (target.path.startsWith('weights')) {
			outputs[curve.output]._components = outputs[curve.output].data.length / inputs[curve.input].data.length;
		}
	}

	quatArrays.sort();
	let prevIndex = null;
	let data;

	for (i = 0; i < quatArrays.length; ++i) {
		const index = quatArrays[i];

		if (i === 0 || index !== prevIndex) {
			data = outputs[index];

			if (data.components === 4) {
				const d = data.data;
				const len = d.length - 4;

				for (let j = 0; j < len; j += 4) {
					const dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];

					if (dp < 0) {
						d[j + 4] *= -1;
						d[j + 5] *= -1;
						d[j + 6] *= -1;
						d[j + 7] *= -1;
					}
				}
			}

			prevIndex = index;
		}
	}

	let duration = 0;

	for (i = 0; i < inputs.length; i++) {
		data = inputs[i]._data;
		duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
	}

	return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : "animation_" + animationIndex, duration, inputs, outputs, curves);
};

const createNode = function createNode(gltfNode, nodeIndex) {
	const entity = new GraphNode();

	if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
		entity.name = gltfNode.name;
	} else {
		entity.name = "node_" + nodeIndex;
	}

	if (gltfNode.hasOwnProperty('matrix')) {
		tempMat.data.set(gltfNode.matrix);
		tempMat.getTranslation(tempVec$1);
		entity.setLocalPosition(tempVec$1);
		tempMat.getEulerAngles(tempVec$1);
		entity.setLocalEulerAngles(tempVec$1);
		tempMat.getScale(tempVec$1);
		entity.setLocalScale(tempVec$1);
	}

	if (gltfNode.hasOwnProperty('rotation')) {
		const r = gltfNode.rotation;
		entity.setLocalRotation(r[0], r[1], r[2], r[3]);
	}

	if (gltfNode.hasOwnProperty('translation')) {
		const t = gltfNode.translation;
		entity.setLocalPosition(t[0], t[1], t[2]);
	}

	if (gltfNode.hasOwnProperty('scale')) {
		const s = gltfNode.scale;
		entity.setLocalScale(s[0], s[1], s[2]);
	}

	return entity;
};

const createCamera = function createCamera(gltfCamera, node) {
	const projection = gltfCamera.type === "orthographic" ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
	const gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
	const componentData = {
		enabled: false,
		projection: projection,
		nearClip: gltfProperties.znear,
		aspectRatioMode: ASPECT_AUTO
	};

	if (gltfProperties.zfar) {
		componentData.farClip = gltfProperties.zfar;
	}

	if (projection === PROJECTION_ORTHOGRAPHIC) {
		componentData.orthoHeight = 0.5 * gltfProperties.ymag;

		if (gltfProperties.ymag) {
			componentData.aspectRatioMode = ASPECT_MANUAL;
			componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
		}
	} else {
		componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;

		if (gltfProperties.aspectRatio) {
			componentData.aspectRatioMode = ASPECT_MANUAL;
			componentData.aspectRatio = gltfProperties.aspectRatio;
		}
	}

	const cameraEntity = new Entity(gltfCamera.name);
	cameraEntity.addComponent("camera", componentData);
	return cameraEntity;
};

const createLight = function createLight(gltfLight, node) {
	const lightProps = {
		enabled: false,
		type: gltfLight.type === "point" ? "omni" : gltfLight.type,
		color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
		range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
		falloffMode: LIGHTFALLOFF_INVERSESQUARED,
		intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
	};

	if (gltfLight.hasOwnProperty('spot')) {
		lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
		lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
	}

	const lightEntity = new Entity(node.name);
	lightEntity.rotateLocal(90, 0, 0);
	lightEntity.addComponent("light", lightProps);
	return lightEntity;
};

const createSkins = function createSkins(device, gltf, nodes, bufferViews) {
	if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
		return [];
	}

	const glbSkins = new Map();
	return gltf.skins.map(function (gltfSkin) {
		return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
	});
};

const createMeshes = function createMeshes(device, gltf, bufferViews, callback, flipV) {
	if (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 || !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 || !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {
		return [];
	}

	const vertexBufferDict = {};
	return gltf.meshes.map(function (gltfMesh) {
		return createMesh(device, gltfMesh, gltf.accessors, bufferViews, callback, flipV, vertexBufferDict);
	});
};

const createMaterials = function createMaterials(gltf, textures, options, flipV) {
	if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
		return [];
	}

	const preprocess = options && options.material && options.material.preprocess;
	const process = options && options.material && options.material.process || createMaterial;
	const postprocess = options && options.material && options.material.postprocess;
	return gltf.materials.map(function (gltfMaterial) {
		if (preprocess) {
			preprocess(gltfMaterial);
		}

		const material = process(gltfMaterial, textures, flipV);

		if (postprocess) {
			postprocess(gltfMaterial, material);
		}

		return material;
	});
};

const createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {
	if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
		return [];
	}

	const preprocess = options && options.animation && options.animation.preprocess;
	const postprocess = options && options.animation && options.animation.postprocess;
	return gltf.animations.map(function (gltfAnimation, index) {
		if (preprocess) {
			preprocess(gltfAnimation);
		}

		const animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes);

		if (postprocess) {
			postprocess(gltfAnimation, animation);
		}

		return animation;
	});
};

const createNodes = function createNodes(gltf, options) {
	if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
		return [];
	}

	const preprocess = options && options.node && options.node.preprocess;
	const process = options && options.node && options.node.process || createNode;
	const postprocess = options && options.node && options.node.postprocess;
	const nodes = gltf.nodes.map(function (gltfNode, index) {
		if (preprocess) {
			preprocess(gltfNode);
		}

		const node = process(gltfNode, index);

		if (postprocess) {
			postprocess(gltfNode, node);
		}

		return node;
	});

	for (let i = 0; i < gltf.nodes.length; ++i) {
		const gltfNode = gltf.nodes[i];

		if (gltfNode.hasOwnProperty('children')) {
			const parent = nodes[i];
			const uniqueNames = {};

			for (let j = 0; j < gltfNode.children.length; ++j) {
				const child = nodes[gltfNode.children[j]];

				if (!child.parent) {
					if (uniqueNames.hasOwnProperty(child.name)) {
						child.name += uniqueNames[child.name]++;
					} else {
						uniqueNames[child.name] = 1;
					}

					parent.addChild(child);
				}
			}
		}
	}

	return nodes;
};

const createScenes = function createScenes(gltf, nodes) {
	var _gltf$scenes$0$nodes;

	const scenes = [];
	const count = gltf.scenes.length;

	if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {
		const nodeIndex = gltf.scenes[0].nodes[0];
		scenes.push(nodes[nodeIndex]);
	} else {
		for (let i = 0; i < count; i++) {
			const scene = gltf.scenes[i];

			if (scene.nodes) {
				const sceneRoot = new GraphNode(scene.name);

				for (let n = 0; n < scene.nodes.length; n++) {
					const childNode = nodes[scene.nodes[n]];
					sceneRoot.addChild(childNode);
				}

				scenes.push(sceneRoot);
			}
		}
	}

	return scenes;
};

const createCameras = function createCameras(gltf, nodes, options) {
	let cameras = null;

	if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
		const preprocess = options && options.camera && options.camera.preprocess;
		const process = options && options.camera && options.camera.process || createCamera;
		const postprocess = options && options.camera && options.camera.postprocess;
		gltf.nodes.forEach(function (gltfNode, nodeIndex) {
			if (gltfNode.hasOwnProperty('camera')) {
				const gltfCamera = gltf.cameras[gltfNode.camera];

				if (gltfCamera) {
					if (preprocess) {
						preprocess(gltfCamera);
					}

					const camera = process(gltfCamera, nodes[nodeIndex]);

					if (postprocess) {
						postprocess(gltfCamera, camera);
					}

					if (camera) {
						if (!cameras) cameras = new Map();
						cameras.set(gltfNode, camera);
					}
				}
			}
		});
	}

	return cameras;
};

const createLights = function createLights(gltf, nodes, options) {
	let lights = null;

	if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
		const gltfLights = gltf.extensions.KHR_lights_punctual.lights;

		if (gltfLights.length) {
			const preprocess = options && options.light && options.light.preprocess;
			const process = options && options.light && options.light.process || createLight;
			const postprocess = options && options.light && options.light.postprocess;
			gltf.nodes.forEach(function (gltfNode, nodeIndex) {
				if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
					const lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
					const gltfLight = gltfLights[lightIndex];

					if (gltfLight) {
						if (preprocess) {
							preprocess(gltfLight);
						}

						const light = process(gltfLight, nodes[nodeIndex]);

						if (postprocess) {
							postprocess(gltfLight, light);
						}

						if (light) {
							if (!lights) lights = new Map();
							lights.set(gltfNode, light);
						}
					}
				}
			});
		}
	}

	return lights;
};

const linkSkins = function linkSkins(gltf, renders, skins) {
	gltf.nodes.forEach(gltfNode => {
		if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
			const meshGroup = renders[gltfNode.mesh].meshes;
			meshGroup.forEach(mesh => {
				mesh.skin = skins[gltfNode.skin];
			});
		}
	});
};

const createResources = function createResources(device, gltf, bufferViews, textureAssets, options, callback) {
	const preprocess = options && options.global && options.global.preprocess;
	const postprocess = options && options.global && options.global.postprocess;

	if (preprocess) {
		preprocess(gltf);
	}

	const flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';
	const nodes = createNodes(gltf, options);
	const scenes = createScenes(gltf, nodes);
	const lights = createLights(gltf, nodes, options);
	const cameras = createCameras(gltf, nodes, options);
	const animations = createAnimations(gltf, nodes, bufferViews, options);
	const materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {
		return textureAsset.resource;
	}), options, flipV);
	const meshes = createMeshes(device, gltf, bufferViews, callback, flipV);
	const skins = createSkins(device, gltf, nodes, bufferViews);
	const renders = [];

	for (let i = 0; i < meshes.length; i++) {
		renders[i] = new Render();
		renders[i].meshes = meshes[i];
	}

	linkSkins(gltf, renders, skins);
	const result = new GlbResources(gltf);
	result.nodes = nodes;
	result.scenes = scenes;
	result.animations = animations;
	result.textures = textureAssets;
	result.materials = materials;
	result.renders = renders;
	result.skins = skins;
	result.lights = lights;
	result.cameras = cameras;

	if (postprocess) {
		postprocess(gltf, result);
	}

	callback(null, result);
};

const applySampler = function applySampler(texture, gltfSampler) {
	const getFilter = function getFilter(filter, defaultValue) {
		switch (filter) {
			case 9728:
				return FILTER_NEAREST;

			case 9729:
				return FILTER_LINEAR;

			case 9984:
				return FILTER_NEAREST_MIPMAP_NEAREST;

			case 9985:
				return FILTER_LINEAR_MIPMAP_NEAREST;

			case 9986:
				return FILTER_NEAREST_MIPMAP_LINEAR;

			case 9987:
				return FILTER_LINEAR_MIPMAP_LINEAR;

			default:
				return defaultValue;
		}
	};

	const getWrap = function getWrap(wrap, defaultValue) {
		switch (wrap) {
			case 33071:
				return ADDRESS_CLAMP_TO_EDGE;

			case 33648:
				return ADDRESS_MIRRORED_REPEAT;

			case 10497:
				return ADDRESS_REPEAT;

			default:
				return defaultValue;
		}
	};

	if (texture) {
		gltfSampler = gltfSampler || {};
		texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
		texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
		texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
		texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
	}
};

let gltfTextureUniqueId = 0;

const loadImageAsync = function loadImageAsync(gltfImage, index, bufferViews, urlBase, registry, options, callback) {
	const preprocess = options && options.image && options.image.preprocess;

	const processAsync = options && options.image && options.image.processAsync || function (gltfImage, callback) {
		callback(null, null);
	};

	const postprocess = options && options.image && options.image.postprocess;

	const onLoad = function onLoad(textureAsset) {
		if (postprocess) {
			postprocess(gltfImage, textureAsset);
		}

		callback(null, textureAsset);
	};

	const mimeTypeFileExtensions = {
		'image/png': 'png',
		'image/jpeg': 'jpg',
		'image/basis': 'basis',
		'image/ktx': 'ktx',
		'image/ktx2': 'ktx2',
		'image/vnd-ms.dds': 'dds'
	};

	const loadTexture = function loadTexture(url, bufferView, mimeType, options) {
		const name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;
		const file = {
			url: url || name
		};

		if (bufferView) {
			file.contents = bufferView.slice(0).buffer;
		}

		if (mimeType) {
			const extension = mimeTypeFileExtensions[mimeType];

			if (extension) {
				file.filename = file.url + '.' + extension;
			}
		}

		const asset = new Asset(name, 'texture', file, null, options);
		asset.on('load', onLoad);
		asset.on('error', callback);
		registry.add(asset);
		registry.load(asset);
	};

	if (preprocess) {
		preprocess(gltfImage);
	}

	processAsync(gltfImage, function (err, textureAsset) {
		if (err) {
			callback(err);
		} else if (textureAsset) {
			onLoad(textureAsset);
		} else {
			if (gltfImage.hasOwnProperty('uri')) {
				if (isDataURI(gltfImage.uri)) {
					loadTexture(gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);
				} else {
					loadTexture(path.join(urlBase, gltfImage.uri), null, null, {
						crossOrigin: "anonymous"
					});
				}
			} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
				loadTexture(null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);
			} else {
				callback("Invalid image found in gltf (neither uri or bufferView found). index=" + index);
			}
		}
	});
};

const loadTexturesAsync = function loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, callback) {
	if (!gltf.hasOwnProperty('images') || gltf.images.length === 0 || !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {
		callback(null, []);
		return;
	}

	const preprocess = options && options.texture && options.texture.preprocess;

	const processAsync = options && options.texture && options.texture.processAsync || function (gltfTexture, gltfImages, callback) {
		callback(null, null);
	};

	const postprocess = options && options.texture && options.texture.postprocess;
	const assets = [];
	const textures = [];
	let remaining = gltf.textures.length;

	const onLoad = function onLoad(textureIndex, imageIndex) {
		if (!textures[imageIndex]) {
			textures[imageIndex] = [];
		}

		textures[imageIndex].push(textureIndex);

		if (--remaining === 0) {
			const result = [];
			textures.forEach(function (textureList, imageIndex) {
				textureList.forEach(function (textureIndex, index) {
					const textureAsset = index === 0 ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);
					applySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);
					result[textureIndex] = textureAsset;

					if (postprocess) {
						postprocess(gltf.textures[textureIndex], textureAsset);
					}
				});
			});
			callback(null, result);
		}
	};

	for (let i = 0; i < gltf.textures.length; ++i) {
		const gltfTexture = gltf.textures[i];

		if (preprocess) {
			preprocess(gltfTexture);
		}

		processAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {
			if (err) {
				callback(err);
			} else {
				if (gltfImageIndex === undefined || gltfImageIndex === null) {
					var _gltfTexture$extensio, _gltfTexture$extensio2;

					gltfImageIndex = gltfTexture == null ? void 0 : (_gltfTexture$extensio = gltfTexture.extensions) == null ? void 0 : (_gltfTexture$extensio2 = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source;

					if (gltfImageIndex === undefined) {
						gltfImageIndex = gltfTexture.source;
					}
				}

				if (assets[gltfImageIndex]) {
					onLoad(i, gltfImageIndex);
				} else {
					const gltfImage = gltf.images[gltfImageIndex];
					loadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {
						if (err) {
							callback(err);
						} else {
							assets[gltfImageIndex] = textureAsset;
							onLoad(i, gltfImageIndex);
						}
					});
				}
			}
		}.bind(null, i, gltfTexture));
	}
};

const loadBuffersAsync = function loadBuffersAsync(gltf, binaryChunk, urlBase, options, callback) {
	const result = [];

	if (!gltf.buffers || gltf.buffers.length === 0) {
		callback(null, result);
		return;
	}

	const preprocess = options && options.buffer && options.buffer.preprocess;

	const processAsync = options && options.buffer && options.buffer.processAsync || function (gltfBuffer, callback) {
		callback(null, null);
	};

	const postprocess = options && options.buffer && options.buffer.postprocess;
	let remaining = gltf.buffers.length;

	const onLoad = function onLoad(index, buffer) {
		result[index] = buffer;

		if (postprocess) {
			postprocess(gltf.buffers[index], buffer);
		}

		if (--remaining === 0) {
			callback(null, result);
		}
	};

	for (let i = 0; i < gltf.buffers.length; ++i) {
		const gltfBuffer = gltf.buffers[i];

		if (preprocess) {
			preprocess(gltfBuffer);
		}

		processAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {
			if (err) {
				callback(err);
			} else if (arrayBuffer) {
				onLoad(i, new Uint8Array(arrayBuffer));
			} else {
				if (gltfBuffer.hasOwnProperty('uri')) {
					if (isDataURI(gltfBuffer.uri)) {
						const byteString = atob(gltfBuffer.uri.split(',')[1]);
						const binaryArray = new Uint8Array(byteString.length);

						for (let j = 0; j < byteString.length; j++) {
							binaryArray[j] = byteString.charCodeAt(j);
						}

						onLoad(i, binaryArray);
					} else {
						http.get(path.join(urlBase, gltfBuffer.uri), {
							cache: true,
							responseType: 'arraybuffer',
							retry: false
						}, function (i, err, result) {
							if (err) {
								callback(err);
							} else {
								onLoad(i, new Uint8Array(result));
							}
						}.bind(null, i));
					}
				} else {
					onLoad(i, binaryChunk);
				}
			}
		}.bind(null, i, gltfBuffer));
	}
};

const parseGltf = function parseGltf(gltfChunk, callback) {
	const decodeBinaryUtf8 = function decodeBinaryUtf8(array) {
		if (typeof TextDecoder !== 'undefined') {
			return new TextDecoder().decode(array);
		}

		let str = "";

		for (let i = 0; i < array.length; i++) {
			str += String.fromCharCode(array[i]);
		}

		return decodeURIComponent(escape(str));
	};

	const gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));

	if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
		callback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);
		return;
	}

	callback(null, gltf);
};

const parseGlb = function parseGlb(glbData, callback) {
	const data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
	const magic = data.getUint32(0, true);
	const version = data.getUint32(4, true);
	const length = data.getUint32(8, true);

	if (magic !== 0x46546C67) {
		callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
		return;
	}

	if (version !== 2) {
		callback("Invalid version number found in glb header. Expected 2, found " + version);
		return;
	}

	if (length <= 0 || length > data.byteLength) {
		callback("Invalid length found in glb header. Found " + length);
		return;
	}

	const chunks = [];
	let offset = 12;

	while (offset < length) {
		const chunkLength = data.getUint32(offset, true);

		if (offset + chunkLength + 8 > data.byteLength) {
			throw new Error("Invalid chunk length found in glb. Found " + chunkLength);
		}

		const chunkType = data.getUint32(offset + 4, true);
		const chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
		chunks.push({
			length: chunkLength,
			type: chunkType,
			data: chunkData
		});
		offset += chunkLength + 8;
	}

	if (chunks.length !== 1 && chunks.length !== 2) {
		callback("Invalid number of chunks found in glb file.");
		return;
	}

	if (chunks[0].type !== 0x4E4F534A) {
		callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
		return;
	}

	if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
		callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
		return;
	}

	callback(null, {
		gltfChunk: chunks[0].data,
		binaryChunk: chunks.length === 2 ? chunks[1].data : null
	});
};

const parseChunk = function parseChunk(filename, data, callback) {
	if (filename && filename.toLowerCase().endsWith('.glb')) {
		parseGlb(data, callback);
	} else {
		callback(null, {
			gltfChunk: data,
			binaryChunk: null
		});
	}
};

const parseBufferViewsAsync = function parseBufferViewsAsync(gltf, buffers, options, callback) {
	const result = [];
	const preprocess = options && options.bufferView && options.bufferView.preprocess;

	const processAsync = options && options.bufferView && options.bufferView.processAsync || function (gltfBufferView, buffers, callback) {
		callback(null, null);
	};

	const postprocess = options && options.bufferView && options.bufferView.postprocess;
	let remaining = gltf.bufferViews ? gltf.bufferViews.length : 0;

	if (!remaining) {
		callback(null, null);
		return;
	}

	const onLoad = function onLoad(index, bufferView) {
		const gltfBufferView = gltf.bufferViews[index];

		if (gltfBufferView.hasOwnProperty('byteStride')) {
			bufferView.byteStride = gltfBufferView.byteStride;
		}

		result[index] = bufferView;

		if (postprocess) {
			postprocess(gltfBufferView, bufferView);
		}

		if (--remaining === 0) {
			callback(null, result);
		}
	};

	for (let i = 0; i < gltf.bufferViews.length; ++i) {
		const gltfBufferView = gltf.bufferViews[i];

		if (preprocess) {
			preprocess(gltfBufferView);
		}

		processAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {
			if (err) {
				callback(err);
			} else if (result) {
				onLoad(i, result);
			} else {
				const buffer = buffers[gltfBufferView.buffer];
				const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
				onLoad(i, typedArray);
			}
		}.bind(null, i, gltfBufferView));
	}
};

class GlbParser {
	static parseAsync(filename, urlBase, data, device, registry, options, callback) {
		parseChunk(filename, data, function (err, chunks) {
			if (err) {
				callback(err);
				return;
			}

			parseGltf(chunks.gltfChunk, function (err, gltf) {
				if (err) {
					callback(err);
					return;
				}

				loadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {
					if (err) {
						callback(err);
						return;
					}

					parseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {
						if (err) {
							callback(err);
							return;
						}

						loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {
							if (err) {
								callback(err);
								return;
							}

							createResources(device, gltf, bufferViews, textureAssets, options, callback);
						});
					});
				});
			});
		});
	}

	static parse(filename, data, device, options) {
		let result = null;
		options = options || {};
		parseChunk(filename, data, function (err, chunks) {
			if (err) {
				console.error(err);
			} else {
				parseGltf(chunks.gltfChunk, function (err, gltf) {
					if (err) {
						console.error(err);
					} else {
						parseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {
							if (err) {
								console.error(err);
							} else {
								createResources(device, gltf, bufferViews, [], options, function (err, result_) {
									if (err) {
										console.error(err);
									} else {
										result = result_;
									}
								});
							}
						});
					}
				});
			}
		});
		return result;
	}

	constructor(device, assets, maxRetries) {
		this._device = device;
		this._assets = assets;
		this._defaultMaterial = DefaultMaterial.get(device);
		this._maxRetries = maxRetries;
	}

	_getUrlWithoutParams(url) {
		return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, (err, result) => {
			if (err) {
				callback(err);
			} else {
				GlbParser.parseAsync(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result) => {
					if (err) {
						callback(err);
					} else {
						callback(null, new GlbContainerResource(result, asset, this._assets, this._defaultMaterial));
					}
				});
			}
		}, asset, this._maxRetries);
	}

	open(url, data, asset) {
		return data;
	}

	patch(asset, assets) {}

}

class AnimationHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
			if (path.getExtension(url.original).toLowerCase() === '.glb') {
				options.responseType = Http.ResponseType.ARRAY_BUFFER;
			} else {
				options.responseType = Http.ResponseType.JSON;
			}
		}

		http.get(url.load, options, function (err, response) {
			if (err) {
				callback(`Error loading animation resource: ${url.original} [${err}]`);
			} else {
				callback(null, response);
			}
		});
	}

	open(url, data) {
		if (path.getExtension(url).toLowerCase() === '.glb') {
			const glbResources = GlbParser.parse("filename.glb", data, null);

			if (glbResources) {
				const animations = glbResources.animations;
				glbResources.destroy();
				return animations;
			}

			return null;
		}

		return this["_parseAnimationV" + data.animation.version](data);
	}

	patch(asset, assets) {}

	_parseAnimationV3(data) {
		const animData = data.animation;
		const anim = new Animation();
		anim.name = animData.name;
		anim.duration = animData.duration;

		for (let i = 0; i < animData.nodes.length; i++) {
			const node = new Node();
			const n = animData.nodes[i];
			node._name = n.name;

			for (let j = 0; j < n.keys.length; j++) {
				const k = n.keys[j];
				const t = k.time;
				const p = k.pos;
				const r = k.rot;
				const s = k.scale;
				const pos = new Vec3(p[0], p[1], p[2]);
				const rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
				const scl = new Vec3(s[0], s[1], s[2]);
				const key = new Key(t, pos, rot, scl);

				node._keys.push(key);
			}

			anim.addNode(node);
		}

		return anim;
	}

	_parseAnimationV4(data) {
		const animData = data.animation;
		const anim = new Animation();
		anim.name = animData.name;
		anim.duration = animData.duration;

		for (let i = 0; i < animData.nodes.length; i++) {
			const node = new Node();
			const n = animData.nodes[i];
			node._name = n.name;
			const defPos = n.defaults.p;
			const defRot = n.defaults.r;
			const defScl = n.defaults.s;

			for (let j = 0; j < n.keys.length; j++) {
				const k = n.keys[j];
				const t = k.t;
				const p = defPos ? defPos : k.p;
				const r = defRot ? defRot : k.r;
				const s = defScl ? defScl : k.s;
				const pos = new Vec3(p[0], p[1], p[2]);
				const rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
				const scl = new Vec3(s[0], s[1], s[2]);
				const key = new Key(t, pos, rot, scl);

				node._keys.push(key);
			}

			anim.addNode(node);
		}

		return anim;
	}

}

class AnimClipHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:')) {
			options.responseType = Http.ResponseType.JSON;
		}

		http.get(url.load, options, function (err, response) {
			if (err) {
				callback(`Error loading animation clip resource: ${url.original} [${err}]`);
			} else {
				callback(null, response);
			}
		});
	}

	open(url, data) {
		const name = data.name;
		const duration = data.duration;
		const inputs = data.inputs.map(function (input) {
			return new AnimData(1, input);
		});
		const outputs = data.outputs.map(function (output) {
			return new AnimData(output.components, output.data);
		});
		const curves = data.curves.map(function (curve) {
			return new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);
		});
		return new AnimTrack(name, duration, inputs, outputs, curves);
	}

	patch(asset, assets) {}

}

class AnimStateGraph {
	constructor(data) {
		this._layers = [];
		this._parameters = {};

		if (!Array.isArray(data.layers)) {
			for (const layerId in data.layers) {
				const dataLayer = data.layers[layerId];
				const layer = {
					name: dataLayer.name,
					blendType: dataLayer.blendType,
					weight: dataLayer.weight,
					states: [],
					transitions: []
				};

				for (let i = 0; i < dataLayer.states.length; i++) {
					layer.states.push(data.states[dataLayer.states[i]]);
				}

				for (let i = 0; i < dataLayer.transitions.length; i++) {
					const dataLayerTransition = data.transitions[dataLayer.transitions[i]];

					if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
						const conditionKeys = Object.keys(dataLayerTransition.conditions);
						const conditions = [];

						for (let j = 0; j < conditionKeys.length; j++) {
							const condition = dataLayerTransition.conditions[conditionKeys[j]];

							if (condition.parameterName) {
								conditions.push(condition);
							}
						}

						dataLayerTransition.conditions = conditions;
					}

					if (Number.isInteger(dataLayerTransition.from)) {
						dataLayerTransition.from = data.states[dataLayerTransition.from].name;
					}

					if (Number.isInteger(dataLayerTransition.to)) {
						dataLayerTransition.to = data.states[dataLayerTransition.to].name;
					}

					layer.transitions.push(dataLayerTransition);
				}

				this._layers.push(layer);
			}
		} else {
			this._layers = data.layers;
		}

		for (const paramId in data.parameters) {
			const param = data.parameters[paramId];
			this._parameters[param.name] = {
				type: param.type,
				value: param.value
			};
		}
	}

	get parameters() {
		return Object.assign({}, this._parameters);
	}

	get layers() {
		return this._layers;
	}

}

class AnimStateGraphHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:')) {
			options.responseType = Http.ResponseType.JSON;
		}

		http.get(url.load, options, function (err, response) {
			if (err) {
				callback(`Error loading animation state graph resource: ${url.original} [${err}]`);
			} else {
				callback(null, response);
			}
		});
	}

	open(url, data) {
		return new AnimStateGraph(data);
	}

	patch(asset, assets) {}

}

class Sound {
	constructor(resource) {
		if (resource instanceof Audio) {
			this.audio = resource;
		} else {
			this.buffer = resource;
		}
	}

	get duration() {
		let duration = 0;

		if (this.buffer) {
			duration = this.buffer.duration;
		} else if (this.audio) {
			duration = this.audio.duration;
		}

		return duration || 0;
	}

}

const ie = function () {
	if (typeof window === 'undefined') {
		return false;
	}

	const ua = window.navigator.userAgent;
	const msie = ua.indexOf('MSIE ');

	if (msie > 0) {
		return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	}

	const trident = ua.indexOf('Trident/');

	if (trident > 0) {
		const rv = ua.indexOf('rv:');
		return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	}

	return false;
}();

const toMIME = {
	'.ogg': 'audio/ogg',
	'.mp3': 'audio/mpeg',
	'.wav': 'audio/x-wav',
	'.mp4a': 'audio/mp4',
	'.m4a': 'audio/mp4',
	'.mp4': 'audio/mp4',
	'.aac': 'audio/aac'
};

class AudioHandler {
	constructor(manager) {
		this.manager = manager;
		this.maxRetries = 0;
	}

	_isSupported(url) {
		const ext = path.getExtension(url);

		if (toMIME[ext]) {
			return true;
		}

		return false;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const success = function success(resource) {
			callback(null, new Sound(resource));
		};

		const error = function error(err) {
			let msg = 'Error loading audio url: ' + url.original;

			if (err) {
				msg += ': ' + (err.message || err);
			}

			console.warn(msg);
			callback(msg);
		};

		if (this._createSound) {
			if (!this._isSupported(url.original)) {
				error(`Audio format for ${url.original} not supported`);
				return;
			}

			this._createSound(url.load, success, error);
		} else {
			error(null);
		}
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

	_createSound(url, success, error) {
		if (hasAudioContext()) {
			const manager = this.manager;

			if (!manager.context) {
				error('Audio manager has no audio context');
				return;
			}

			const options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};

			if (url.startsWith('blob:') || url.startsWith('data:')) {
				options.responseType = Http.ResponseType.ARRAY_BUFFER;
			}

			http.get(url, options, function (err, response) {
				if (err) {
					error(err);
					return;
				}

				manager.context.decodeAudioData(response, success, error);
			});
		} else {
			let audio = null;

			try {
				audio = new Audio();
			} catch (e) {
				error("No support for Audio element");
				return;
			}

			if (ie) {
				document.body.appendChild(audio);
			}

			const onReady = function onReady() {
				audio.removeEventListener('canplaythrough', onReady);

				if (ie) {
					document.body.removeChild(audio);
				}

				success(audio);
			};

			audio.onerror = function () {
				audio.onerror = null;

				if (ie) {
					document.body.removeChild(audio);
				}

				error();
			};

			audio.addEventListener('canplaythrough', onReady);
			audio.src = url;
		}
	}

}

class BinaryHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			responseType: Http.ResponseType.ARRAY_BUFFER,
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading binary resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class Bundle {
	constructor(files) {
		this._blobUrls = {};

		for (let i = 0, len = files.length; i < len; i++) {
			if (files[i].url) {
				this._blobUrls[files[i].name] = files[i].url;
			}
		}
	}

	hasBlobUrl(url) {
		return !!this._blobUrls[url];
	}

	getBlobUrl(url) {
		return this._blobUrls[url];
	}

	destroy() {
		for (const key in this._blobUrls) {
			URL.revokeObjectURL(this._blobUrls[key]);
		}

		this._blobUrls = null;
	}

}

let Untar;

function UntarScope(isWorker) {
	let utfDecoder;
	let asciiDecoder;

	if (typeof TextDecoder !== 'undefined') {
		try {
			utfDecoder = new TextDecoder('utf-8');
			asciiDecoder = new TextDecoder('windows-1252');
		} catch (e) {
			console.warn('TextDecoder not supported - pc.Untar module will not work');
		}
	} else {
		console.warn('TextDecoder not supported - pc.Untar module will not work');
	}

	function PaxHeader(fields) {
		this._fields = fields;
	}

	PaxHeader.parse = function (buffer, start, length) {
		const paxArray = new Uint8Array(buffer, start, length);
		let bytesRead = 0;
		const fields = [];

		while (bytesRead < length) {
			let spaceIndex;

			for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
				if (paxArray[spaceIndex] === 0x20) break;
			}

			if (spaceIndex >= length) {
				throw new Error('Invalid PAX header data format.');
			}

			const fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
			const fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
			const field = fieldText.split('=');

			if (field.length !== 2) {
				throw new Error('Invalid PAX header data format.');
			}

			if (field[1].length === 0) {
				field[1] = null;
			}

			fields.push({
				name: field[0],
				value: field[1]
			});
			bytesRead += fieldLength;
		}

		return new PaxHeader(fields);
	};

	PaxHeader.prototype.applyHeader = function (file) {
		for (let i = 0; i < this._fields.length; i++) {
			let fieldName = this._fields[i].name;
			const fieldValue = this._fields[i].value;

			if (fieldName === 'path') {
				fieldName = 'name';
			}

			if (fieldValue === null) {
				delete file[fieldName];
			} else {
				file[fieldName] = fieldValue;
			}
		}
	};

	function UntarInternal(arrayBuffer) {
		this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
		this._bufferView = new DataView(this._arrayBuffer);
		this._globalPaxHeader = null;
		this._paxHeader = null;
		this._bytesRead = 0;
	}

	if (!isWorker) {
		Untar = UntarInternal;
	}

	UntarInternal.prototype._hasNext = function () {
		return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
	};

	UntarInternal.prototype._readNextFile = function () {
		const headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
		const headers = asciiDecoder.decode(headersDataView);
		this._bytesRead += 512;
		let name = headers.substr(0, 100).replace(/\0/g, '');
		const ustarFormat = headers.substr(257, 6);
		const size = parseInt(headers.substr(124, 12), 8);
		const type = headers.substr(156, 1);
		const start = this._bytesRead;
		let url = null;
		let normalFile = false;

		switch (type) {
			case "0":
			case "":
				normalFile = true;

				if (!isWorker) {
					const blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
					url = URL.createObjectURL(blob);
				}

				break;

			case "g":
				this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
				break;

			case "x":
				this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
				break;
		}

		this._bytesRead += size;
		const remainder = size % 512;

		if (remainder !== 0) {
			this._bytesRead += 512 - remainder;
		}

		if (!normalFile) {
			return null;
		}

		if (ustarFormat.indexOf("ustar") !== -1) {
			const namePrefix = headers.substr(345, 155).replace(/\0/g, '');

			if (namePrefix.length > 0) {
				name = namePrefix.trim() + name.trim();
			}
		}

		const file = {
			name: name,
			start: start,
			size: size,
			url: url
		};

		if (this._globalPaxHeader) {
			this._globalPaxHeader.applyHeader(file);
		}

		if (this._paxHeader) {
			this._paxHeader.applyHeader(file);

			this._paxHeader = null;
		}

		return file;
	};

	UntarInternal.prototype.untar = function (filenamePrefix) {
		if (!utfDecoder) {
			console.error('Cannot untar because TextDecoder interface is not available for this platform.');
			return [];
		}

		const files = [];

		while (this._hasNext()) {
			const file = this._readNextFile();

			if (!file) continue;

			if (filenamePrefix && file.name) {
				file.name = filenamePrefix + file.name;
			}

			files.push(file);
		}

		return files;
	};

	if (isWorker) {
		self.onmessage = function (e) {
			const id = e.data.id;

			try {
				const archive = new UntarInternal(e.data.arrayBuffer);
				const files = archive.untar(e.data.prefix);
				postMessage({
					id: id,
					files: files,
					arrayBuffer: e.data.arrayBuffer
				}, [e.data.arrayBuffer]);
			} catch (err) {
				postMessage({
					id: id,
					error: err.toString()
				});
			}
		};
	}
}

let workerUrl = null;

function getWorkerUrl() {
	if (!workerUrl) {
		const code = '(' + UntarScope.toString() + ')(true)\n\n';
		const blob = new Blob([code], {
			type: 'application/javascript'
		});
		workerUrl = URL.createObjectURL(blob);
	}

	return workerUrl;
}

class UntarWorker {
	constructor(filenamePrefix) {
		this._requestId = 0;
		this._pendingRequests = {};
		this._filenamePrefix = filenamePrefix;
		this._worker = new Worker(getWorkerUrl());

		this._worker.addEventListener('message', this._onMessage.bind(this));
	}

	_onMessage(e) {
		const id = e.data.id;
		if (!this._pendingRequests[id]) return;
		const callback = this._pendingRequests[id];
		delete this._pendingRequests[id];

		if (e.data.error) {
			callback(e.data.error);
		} else {
			const arrayBuffer = e.data.arrayBuffer;

			for (let i = 0, len = e.data.files.length; i < len; i++) {
				const file = e.data.files[i];
				const blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
				file.url = URL.createObjectURL(blob);
			}

			callback(null, e.data.files);
		}
	}

	untar(arrayBuffer, callback) {
		const id = this._requestId++;
		this._pendingRequests[id] = callback;

		this._worker.postMessage({
			id: id,
			prefix: this._filenamePrefix,
			arrayBuffer: arrayBuffer
		}, [arrayBuffer]);
	}

	hasPendingRequests() {
		return Object.keys(this._pendingRequests).length > 0;
	}

	destroy() {
		if (this._worker) {
			this._worker.terminate();

			this._worker = null;
			this._pendingRequests = null;
		}
	}

}

UntarScope();

class BundleHandler {
	constructor(assets) {
		this._assets = assets;
		this._worker = null;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;
		http.get(url.load, {
			responseType: Http.ResponseType.ARRAY_BUFFER,
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				try {
					self._untar(response, callback);
				} catch (ex) {
					callback("Error loading bundle resource " + url.original + ": " + ex);
				}
			} else {
				callback("Error loading bundle resource " + url.original + ": " + err);
			}
		});
	}

	_untar(response, callback) {
		const self = this;

		if (platform.workers) {
			if (!self._worker) {
				self._worker = new UntarWorker(self._assets.prefix);
			}

			self._worker.untar(response, function (err, files) {
				callback(err, files);

				if (!self._worker.hasPendingRequests()) {
					self._worker.destroy();

					self._worker = null;
				}
			});
		} else {
			const archive = new Untar(response);
			const files = archive.untar(self._assets.prefix);
			callback(null, files);
		}
	}

	open(url, data) {
		return new Bundle(data);
	}

	patch(asset, assets) {}

}

class ContainerHandler {
	constructor(device, assets) {
		this.glbParser = new GlbParser(device, assets, 0);
		this.parsers = {};
	}

	_getUrlWithoutParams(url) {
		return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	}

	_getParser(url) {
		const ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
		return this.parsers[ext] || this.glbParser;
	}

	load(url, callback, asset) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		this._getParser(url.original).load(url, callback, asset);
	}

	open(url, data, asset) {
		return this._getParser(url).open(url, data, asset);
	}

	patch(asset, assets) {}

}

class CssHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading css resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class CubemapHandler {
	constructor(device, assets, loader) {
		this._device = device;
		this._registry = assets;
		this._loader = loader;
	}

	load(url, callback, asset) {
		this.loadAssets(asset, callback);
	}

	open(url, data, asset) {
		return asset ? asset.resource : null;
	}

	patch(asset, registry) {
		this.loadAssets(asset, function (err, result) {
			if (err) {
				registry.fire('error', asset);
				registry.fire('error:' + asset.id, err, asset);
				asset.fire('error', asset);
			}
		});
	}

	getAssetIds(cubemapAsset) {
		const result = [];
		result[0] = cubemapAsset.file;

		if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
			for (let i = 0; i < 6; ++i) {
				result[i + 1] = cubemapAsset.data.textures[i];
			}
		} else {
			result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
		}

		return result;
	}

	compareAssetIds(assetIdA, assetIdB) {
		if (assetIdA && assetIdB) {
			if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === "string") {
				return assetIdA === assetIdB;
			}

			return assetIdA.url === assetIdB.url;
		}

		return assetIdA !== null === (assetIdB !== null);
	}

	update(cubemapAsset, assetIds, assets) {
		const assetData = cubemapAsset.data || {};
		const oldAssets = cubemapAsset._handlerState.assets;
		const oldResources = cubemapAsset._resources;
		let tex, mip, i;
		const resources = [null, null, null, null, null, null, null];

		const getType = function getType() {
			if (assetData.hasOwnProperty('type')) {
				return assetData.type;
			}

			if (assetData.hasOwnProperty('rgbm')) {
				return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			}

			return null;
		};

		if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
			if (assets[0]) {
				tex = assets[0].resource;

				for (i = 0; i < 6; ++i) {
					resources[i + 1] = new Texture(this._device, {
						name: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),
						cubemap: true,
						type: getType() || tex.type,
						width: tex.width >> i,
						height: tex.height >> i,
						format: tex.format,
						levels: [tex._levels[i]],
						fixCubemapSeams: true,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						mipmaps: i === 0
					});
				}
			}
		} else {
			resources[1] = oldResources[1] || null;
			resources[2] = oldResources[2] || null;
			resources[3] = oldResources[3] || null;
			resources[4] = oldResources[4] || null;
			resources[5] = oldResources[5] || null;
			resources[6] = oldResources[6] || null;
		}

		const faceAssets = assets.slice(1);

		if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
			if (faceAssets.indexOf(null) === -1) {
				const faceTextures = faceAssets.map(function (asset) {
					return asset.resource;
				});
				const faceLevels = [];

				for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
					faceLevels.push(faceTextures.map(function (faceTexture) {
						return faceTexture._levels[mip];
					}));
				}

				const faces = new Texture(this._device, {
					name: cubemapAsset.name + '_faces',
					cubemap: true,
					type: getType() || faceTextures[0].type,
					width: faceTextures[0].width,
					height: faceTextures[0].height,
					format: faceTextures[0].format,
					levels: faceLevels,
					minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
					magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
					anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
					addressU: ADDRESS_CLAMP_TO_EDGE,
					addressV: ADDRESS_CLAMP_TO_EDGE,
					fixCubemapSeams: !!assets[0]
				});
				resources[0] = faces;
			}
		} else {
			resources[0] = oldResources[0] || null;
		}

		if (!this.cmpArrays(resources, oldResources)) {
			cubemapAsset.resources = resources;
			cubemapAsset._handlerState.assetIds = assetIds;
			cubemapAsset._handlerState.assets = assets;

			for (i = 0; i < oldResources.length; ++i) {
				if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
					oldResources[i].destroy();
				}
			}
		}

		for (i = 0; i < oldAssets.length; ++i) {
			if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
				oldAssets[i].unload();
			}
		}
	}

	cmpArrays(arr1, arr2) {
		if (arr1.length !== arr2.length) {
			return false;
		}

		for (let i = 0; i < arr1.length; ++i) {
			if (arr1[i] !== arr2[i]) {
				return false;
			}
		}

		return true;
	}

	resolveId(value) {
		const valueInt = parseInt(value, 10);
		return valueInt === value || valueInt.toString() === value ? valueInt : value;
	}

	loadAssets(cubemapAsset, callback) {
		if (!cubemapAsset.hasOwnProperty('_handlerState')) {
			cubemapAsset._handlerState = {
				assetIds: [null, null, null, null, null, null, null],
				assets: [null, null, null, null, null, null, null]
			};
		}

		const self = this;
		const assetIds = self.getAssetIds(cubemapAsset);
		const assets = [null, null, null, null, null, null, null];
		const loadedAssetIds = cubemapAsset._handlerState.assetIds;
		const loadedAssets = cubemapAsset._handlerState.assets;
		const registry = self._registry;
		let awaiting = 7;

		const onLoad = function onLoad(index, asset) {
			assets[index] = asset;
			awaiting--;

			if (awaiting === 0) {
				self.update(cubemapAsset, assetIds, assets);
				callback(null, cubemapAsset.resources);
			}
		};

		const onError = function onError(index, err, asset) {
			callback(err);
		};

		const processTexAsset = function processTexAsset(index, texAsset) {
			if (texAsset.loaded) {
				onLoad(index, texAsset);
			} else {
				registry.once('load:' + texAsset.id, onLoad.bind(self, index));
				registry.once('error:' + texAsset.id, onError.bind(self, index));

				if (!texAsset.loading) {
					registry.load(texAsset);
				}
			}
		};

		let texAsset;

		for (let i = 0; i < 7; ++i) {
			const assetId = this.resolveId(assetIds[i]);

			if (!assetId) {
				onLoad(i, null);
			} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
				onLoad(i, loadedAssets[i]);
			} else if (parseInt(assetId, 10) === assetId) {
				texAsset = registry.get(assetId);

				if (texAsset) {
					processTexAsset(i, texAsset);
				} else {
					setTimeout(function (index, assetId_) {
						const texAsset = registry.get(assetId_);

						if (texAsset) {
							processTexAsset(index, texAsset);
						} else {
							onError(index, "failed to find dependent cubemap asset=" + assetId_);
						}
					}.bind(null, i, assetId));
				}
			} else {
				const file = typeof assetId === "string" ? {
					url: assetId,
					filename: assetId
				} : assetId;
				texAsset = new Asset(cubemapAsset.name + "_part_" + i, "texture", file);
				registry.add(texAsset);
				registry.once('load:' + texAsset.id, onLoad.bind(self, i));
				registry.once('error:' + texAsset.id, onError.bind(self, i));
				registry.load(texAsset);
			}
		}
	}

}

class FolderHandler {
	load(url, callback) {
		callback(null, null);
	}

	open(url, data) {
		return data;
	}

}

const FONT_MSDF = 'msdf';
const FONT_BITMAP = 'bitmap';

class Font {
	constructor(textures, data) {
		this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
		this.em = 1;
		this.textures = textures;
		this.intensity = 0.0;
		this._data = null;
		this.data = data;
	}

	set data(value) {
		this._data = value;
		if (!value) return;

		if (this._data.intensity !== undefined) {
			this.intensity = this._data.intensity;
		}

		if (!this._data.info) this._data.info = {};

		if (!this._data.version || this._data.version < 2) {
			this._data.info.maps = [{
				width: this._data.info.width,
				height: this._data.info.height
			}];

			if (this._data.chars) {
				for (const key in this._data.chars) {
					this._data.chars[key].map = 0;
				}
			}
		}
	}

	get data() {
		return this._data;
	}

}

function upgradeDataSchema(data) {
	if (data.version < 3) {
		if (data.version < 2) {
			data.info.maps = data.info.maps || [{
				width: data.info.width,
				height: data.info.height
			}];
		}

		data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
			const existing = data.chars[key];
			const newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);

			if (data.version < 2) {
				existing.map = existing.map || 0;
			}

			newChars[newKey] = existing;
			return newChars;
		}, {});
		data.version = 3;
	}

	return data;
}

class FontHandler {
	constructor(loader) {
		this._loader = loader;
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;

		if (path.getExtension(url.original) === '.json') {
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					const data = upgradeDataSchema(response);

					self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
						if (err) return callback(err);
						callback(null, {
							data: data,
							textures: textures
						});
					});
				} else {
					callback(`Error loading font resource: ${url.original} [${err}]`);
				}
			});
		} else {
			if (asset && asset.data) {
				asset.data = upgradeDataSchema(asset.data);
			}

			this._loadTextures(url.load, asset && asset.data, callback);
		}
	}

	_loadTextures(url, data, callback) {
		const numTextures = data.info.maps.length;
		let numLoaded = 0;
		let error = null;
		const textures = new Array(numTextures);
		const loader = this._loader;

		const loadTexture = function loadTexture(index) {
			const onLoaded = function onLoaded(err, texture) {
				if (error) return;

				if (err) {
					error = err;
					return callback(err);
				}

				texture.upload();
				textures[index] = texture;
				numLoaded++;

				if (numLoaded === numTextures) {
					callback(null, textures);
				}
			};

			if (index === 0) {
				loader.load(url, "texture", onLoaded);
			} else {
				loader.load(url.replace('.png', index + '.png'), "texture", onLoaded);
			}
		};

		for (let i = 0; i < numTextures; i++) loadTexture(i);
	}

	open(url, data, asset) {
		let font;

		if (data.textures) {
			font = new Font(data.textures, data.data);
		} else {
			font = new Font(data, null);
		}

		return font;
	}

	patch(asset, assets) {
		const font = asset.resource;

		if (!font.data && asset.data) {
			font.data = asset.data;
		} else if (!asset.data && font.data) {
			asset.data = font.data;
		}

		if (asset.data) {
			asset.data = upgradeDataSchema(asset.data);
		}
	}

}

const CompressUtils = {
	setCompressedPRS: function (entity, data, compressed) {
		const a = compressed.singleVecs;
		let b, i;
		const v = data.___1;

		if (!v) {
			b = compressed.tripleVecs;
			i = data.___2;
		}

		let n = v ? v[0] : b[i];
		entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
		n = v ? v[1] : b[i + 1];
		entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
		n = v ? v[2] : b[i + 2];
		entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
	},
	oneCharToKey: function (s, data) {
		const i = s.charCodeAt(0) - data.fieldFirstCode;
		return data.fieldArray[i];
	},
	multCharToKey: function (s, data) {
		let ind = 0;

		for (let i = 0; i < s.length; i++) {
			ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
		}

		return data.fieldArray[ind];
	}
};

class Decompress {
	constructor(node, data) {
		this._node = node;
		this._data = data;
	}

	run() {
		const type = Object.prototype.toString.call(this._node);

		if (type === '[object Object]') {
			this._handleMap();
		} else if (type === '[object Array]') {
			this._handleArray();
		} else {
			this._result = this._node;
		}

		return this._result;
	}

	_handleMap() {
		this._result = {};
		const a = Object.keys(this._node);
		a.forEach(this._handleKey, this);
	}

	_handleKey(origKey) {
		let newKey = origKey;
		const len = origKey.length;

		if (len === 1) {
			newKey = CompressUtils.oneCharToKey(origKey, this._data);
		} else if (len === 2) {
			newKey = CompressUtils.multCharToKey(origKey, this._data);
		}

		this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
	}

	_handleArray() {
		this._result = [];

		this._node.forEach(this._handleArElt, this);
	}

	_handleArElt(elt) {
		const v = new Decompress(elt, this._data).run();

		this._result.push(v);
	}

}

class SceneParser {
	constructor(app, isTemplate) {
		this._app = app;
		this._isTemplate = isTemplate;
	}

	parse(data) {
		const entities = {};
		let parent = null;
		const compressed = data.compressedFormat;

		if (compressed && !data.entDecompressed) {
			data.entDecompressed = true;
			data.entities = new Decompress(data.entities, compressed).run();
		}

		for (const id in data.entities) {
			const curData = data.entities[id];

			const curEnt = this._createEntity(curData, compressed);

			entities[id] = curEnt;

			if (curData.parent === null) {
				parent = curEnt;
			}
		}

		for (const id in data.entities) {
			const curEnt = entities[id];
			const children = data.entities[id].children;
			const len = children.length;

			for (let i = 0; i < len; i++) {
				const childEnt = entities[children[i]];

				if (childEnt) {
					curEnt.addChild(childEnt);
				}
			}
		}

		this._openComponentData(parent, data.entities);

		return parent;
	}

	_createEntity(data, compressed) {
		const entity = new Entity();
		entity.name = data.name;
		entity.setGuid(data.resource_id);

		this._setPosRotScale(entity, data, compressed);

		entity._enabled = data.enabled !== undefined ? data.enabled : true;

		if (this._isTemplate) {
			entity._template = true;
		} else {
			entity._enabledInHierarchy = entity._enabled;
		}

		entity.template = data.template;

		if (data.tags) {
			for (let i = 0; i < data.tags.length; i++) {
				entity.tags.add(data.tags[i]);
			}
		}

		if (data.labels) {
			data.labels.forEach(function (label) {
				entity.addLabel(label);
			});
		}

		return entity;
	}

	_setPosRotScale(entity, data, compressed) {
		if (compressed) {
			CompressUtils.setCompressedPRS(entity, data, compressed);
		} else {
			const p = data.position;
			const r = data.rotation;
			const s = data.scale;
			entity.setLocalPosition(p[0], p[1], p[2]);
			entity.setLocalEulerAngles(r[0], r[1], r[2]);
			entity.setLocalScale(s[0], s[1], s[2]);
		}
	}

	_openComponentData(entity, entities) {
		const systemsList = this._app.systems.list;
		let len = systemsList.length;
		const entityData = entities[entity.getGuid()];

		for (let i = 0; i < len; i++) {
			const system = systemsList[i];
			const componentData = entityData.components[system.id];

			if (componentData) {
				system.addComponent(entity, componentData);
			}
		}

		len = entityData.children.length;
		const children = entity._children;

		for (let i = 0; i < len; i++) {
			children[i] = this._openComponentData(children[i], entities);
		}

		return entity;
	}

}

const SceneUtils = {
	load: function (url, maxRetries, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: maxRetries > 0,
			maxRetries: maxRetries
		}, function (err, response) {
			if (!err) {
				callback(err, response);
			} else {
				let errMsg = 'Error while loading scene JSON ' + url.original;

				if (err.message) {
					errMsg += ': ' + err.message;

					if (err.stack) {
						errMsg += '\n' + err.stack;
					}
				} else {
					errMsg += ': ' + err;
				}

				callback(errMsg);
			}
		});
	}
};

class HierarchyHandler {
	constructor(app) {
		this._app = app;
		this.maxRetries = 0;
	}

	load(url, callback) {
		SceneUtils.load(url, this.maxRetries, callback);
	}

	open(url, data) {
		this._app.systems.script.preloading = true;
		const parser = new SceneParser(this._app, false);
		const parent = parser.parse(data);
		this._app.systems.script.preloading = false;
		return parent;
	}

}

class HtmlHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading html resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class JsonHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:')) {
			options.responseType = Http.ResponseType.JSON;
		}

		http.get(url.load, options, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading JSON resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class AssetReference {
	constructor(propertyName, parent, registry, callbacks, scope) {
		this.propertyName = propertyName;
		this.parent = parent;
		this._scope = scope;
		this._registry = registry;
		this.id = null;
		this.url = null;
		this.asset = null;
		this._onAssetLoad = callbacks.load;
		this._onAssetAdd = callbacks.add;
		this._onAssetRemove = callbacks.remove;
		this._onAssetUnload = callbacks.unload;
	}

	set id(value) {
		if (this.url) throw Error("Can't set id and url");

		this._unbind();

		this._id = value;
		this.asset = this._registry.get(this._id);

		this._bind();
	}

	get id() {
		return this._id;
	}

	set url(value) {
		if (this.id) throw Error("Can't set id and url");

		this._unbind();

		this._url = value;
		this.asset = this._registry.getByUrl(this._url);

		this._bind();
	}

	get url() {
		return this._url;
	}

	_bind() {
		if (this.id) {
			if (this._onAssetLoad) this._registry.on("load:" + this.id, this._onLoad, this);
			if (this._onAssetAdd) this._registry.once("add:" + this.id, this._onAdd, this);
			if (this._onAssetRemove) this._registry.on("remove:" + this.id, this._onRemove, this);
			if (this._onAssetUnload) this._registry.on("unload:" + this.id, this._onUnload, this);
		}

		if (this.url) {
			if (this._onAssetLoad) this._registry.on("load:url:" + this.url, this._onLoad, this);
			if (this._onAssetAdd) this._registry.once("add:url:" + this.url, this._onAdd, this);
			if (this._onAssetRemove) this._registry.on("remove:url:" + this.url, this._onRemove, this);
		}
	}

	_unbind() {
		if (this.id) {
			if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);
			if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);
			if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);
			if (this._onAssetUnload) this._registry.off("unload:" + this.id, this._onUnload, this);
		}

		if (this.url) {
			if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);
			if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);
			if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);
		}
	}

	_onLoad(asset) {
		this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
	}

	_onAdd(asset) {
		this.asset = asset;

		this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
	}

	_onRemove(asset) {
		this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);

		this.asset = null;
	}

	_onUnload(asset) {
		this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
	}

}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

class StandardMaterialValidator {
	constructor() {
		this.removeInvalid = true;
		this.valid = true;
		this.enumValidators = {
			occludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),
			cull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),
			blendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),
			shadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])
		};
	}

	setInvalid(key, data) {
		this.valid = false;

		if (this.removeInvalid) {
			delete data[key];
		}
	}

	validate(data) {
		const TYPES = standardMaterialParameterTypes;
		const pathMapping = data.mappingFormat === "path";

		for (const key in data) {
			const type = TYPES[key];

			if (!type) {
				this.valid = false;
				continue;
			}

			if (type.startsWith("enum")) {
				const enumType = type.split(":")[1];

				if (this.enumValidators[enumType]) {
					if (!this.enumValidators[enumType](data[key])) {
						this.setInvalid(key, data);
					}
				}
			} else if (type === 'number') {
				if (typeof data[key] !== 'number') {
					this.setInvalid(key, data);
				}
			} else if (type === 'boolean') {
				if (typeof data[key] !== 'boolean') {
					this.setInvalid(key, data);
				}
			} else if (type === 'string') {
				if (typeof data[key] !== 'string') {
					this.setInvalid(key, data);
				}
			} else if (type === 'vec2') {
				if (!(data[key] instanceof Array && data[key].length === 2)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'rgb') {
				if (!(data[key] instanceof Array && data[key].length === 3)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'texture') {
				if (!pathMapping) {
					if (!(typeof data[key] === 'number' || data[key] === null)) {
						if (!(data[key] instanceof Texture)) {
							this.setInvalid(key, data);
						}
					}
				} else {
					if (!(typeof data[key] === 'string' || data[key] === null)) {
						if (!(data[key] instanceof Texture)) {
							this.setInvalid(key, data);
						}
					}
				}
			} else if (type === 'boundingbox') {
				if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
					this.setInvalid(key, data);
				}

				if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'cubemap') {
				if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
					if (!(data[key] instanceof Texture && data[key].cubemap)) {
						this.setInvalid(key, data);
					}
				}
			} else if (type === 'chunks') {
				const chunkNames = Object.keys(data[key]);

				for (let i = 0; i < chunkNames.length; i++) {
					if (typeof data[key][chunkNames[i]] !== 'string') {
						this.setInvalid(chunkNames[i], data[key]);
					}
				}
			} else {
				console.error("Unknown material type: " + type);
			}
		}

		data.validated = true;
		return this.valid;
	}

	_createEnumValidator(values) {
		return function (value) {
			return values.indexOf(value) >= 0;
		};
	}

}

class JsonStandardMaterialParser {
	constructor() {
		this._validator = null;
	}

	parse(input) {
		const migrated = this.migrate(input);

		const validated = this._validate(migrated);

		const material = new StandardMaterial();
		this.initialize(material, validated);
		return material;
	}

	initialize(material, data) {
		if (!data.validated) {
			data = this._validate(data);
		}

		if (data.chunks) {
			material.chunks = _extends({}, data.chunks);
		}

		for (const key in data) {
			const type = standardMaterialParameterTypes[key];
			const value = data[key];

			if (type === 'vec2') {
				material[key] = new Vec2(value[0], value[1]);
			} else if (type === 'rgb') {
				material[key] = new Color(value[0], value[1], value[2]);
			} else if (type === 'texture') {
				if (value instanceof Texture) {
					material[key] = value;
				} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
					material[key] = null;
				}
			} else if (type === 'cubemap') {
				if (value instanceof Texture) {
					material[key] = value;
				} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
					material[key] = null;
				}

				if (key === 'cubeMap' && !value) {
					material.prefilteredCubemaps = null;
				}
			} else if (type === 'boundingbox') {
				const center = new Vec3(value.center[0], value.center[1], value.center[2]);
				const halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
				material[key] = new BoundingBox(center, halfExtents);
			} else {
				material[key] = data[key];
			}
		}

		material.update();
	}

	migrate(data) {
		if (data.shadingModel === undefined) {
			if (data.shader === 'blinn') {
				data.shadingModel = SPECULAR_BLINN;
			} else {
				data.shadingModel = SPECULAR_PHONG;
			}
		}

		if (data.shader) delete data.shader;

		if (data.mapping_format) {
			data.mappingFormat = data.mapping_format;
			delete data.mapping_format;
		}

		let i;
		const RENAMED_PROPERTIES = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["diffuseMapTint", "diffuseTint"], ["specularMapTint", "specularTint"], ["emissiveMapTint", "emissiveTint"], ["metalnessMapTint", "metalnessTint"]];

		for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
			const _old = RENAMED_PROPERTIES[i][0];
			const _new = RENAMED_PROPERTIES[i][1];

			if (data[_old] !== undefined && !(data[_new] !== undefined)) {
				data[_new] = data[_old];
				delete data[_old];
			}
		}

		const DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];

		for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
			const name = DEPRECATED_PROPERTIES[i];

			if (data.hasOwnProperty(name)) {
				delete data[name];
			}
		}

		return data;
	}

	_validate(data) {
		if (!data.validated) {
			if (!this._validator) {
				this._validator = new StandardMaterialValidator();
			}

			this._validator.validate(data);
		}

		return data;
	}

}

const PLACEHOLDER_MAP = {
	aoMap: 'white',
	diffuseMap: 'gray',
	specularMap: 'gray',
	metalnessMap: 'black',
	glossMap: 'gray',
	emissiveMap: 'gray',
	normalMap: 'normal',
	heightMap: 'gray',
	opacityMap: 'gray',
	sphereMap: 'gray',
	lightMap: 'white'
};

class MaterialHandler {
	constructor(app) {
		this._assets = app.assets;
		this._device = app.graphicsDevice;
		this._placeholderTextures = null;
		this._parser = new JsonStandardMaterialParser();
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				if (callback) {
					response._engine = true;
					callback(null, response);
				}
			} else {
				if (callback) {
					callback(`Error loading material: ${url.original} [${err}]`);
				}
			}
		});
	}

	open(url, data) {
		const material = this._parser.parse(data);

		if (data._engine) {
			material._data = data;
			delete data._engine;
		}

		return material;
	}

	_createPlaceholders() {
		this._placeholderTextures = {};
		const textures = {
			white: [255, 255, 255, 255],
			gray: [128, 128, 128, 255],
			black: [0, 0, 0, 255],
			normal: [128, 128, 255, 255]
		};

		for (const key in textures) {
			if (!textures.hasOwnProperty(key)) continue;
			this._placeholderTextures[key] = new Texture(this._device, {
				width: 2,
				height: 2,
				format: PIXELFORMAT_R8_G8_B8_A8
			});
			this._placeholderTextures[key].name = 'placeholder';

			const pixels = this._placeholderTextures[key].lock();

			for (let i = 0; i < 4; i++) {
				for (let c = 0; c < 4; c++) {
					pixels[i * 4 + c] = textures[key][c];
				}
			}

			this._placeholderTextures[key].unlock();
		}
	}

	patch(asset, assets) {
		if (asset.resource._data) {
			asset._data = asset.resource._data;
			delete asset.resource._data;
		}

		asset.data.name = asset.name;
		asset.resource.name = asset.name;

		this._bindAndAssignAssets(asset, assets);

		asset.off('unload', this._onAssetUnload, this);
		asset.on('unload', this._onAssetUnload, this);
	}

	_onAssetUnload(asset) {
		delete asset.data.parameters;
		delete asset.data.chunks;
		delete asset.data.name;
	}

	_assignTexture(parameterName, materialAsset, texture) {
		materialAsset.resource[parameterName] = texture;
	}

	_getPlaceholderTexture(parameterName) {
		if (!this._placeholderTextures) {
			this._createPlaceholders();
		}

		const placeholder = PLACEHOLDER_MAP[parameterName];
		const texture = this._placeholderTextures[placeholder];
		return texture;
	}

	_assignPlaceholderTexture(parameterName, materialAsset) {
		materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName, materialAsset);
	}

	_onTextureLoad(parameterName, materialAsset, textureAsset) {
		this._assignTexture(parameterName, materialAsset, textureAsset.resource);

		materialAsset.resource.update();
	}

	_onTextureAdd(parameterName, materialAsset, textureAsset) {
		this._assets.load(textureAsset);
	}

	_onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
		const material = materialAsset.resource;

		if (material) {
			if (materialAsset.resource[parameterName] === textureAsset.resource) {
				this._assignPlaceholderTexture(parameterName, materialAsset);

				material.update();
			}
		}
	}

	_assignCubemap(parameterName, materialAsset, textures) {
		materialAsset.resource[parameterName] = textures[0];

		if (parameterName === 'cubeMap') {
			materialAsset.resource.prefilteredCubemaps = textures.slice(1);
		}
	}

	_onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
		this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);

		this._parser.initialize(materialAsset.resource, materialAsset.data);
	}

	_onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
		if (materialAsset.data.shadingModel === SPECULAR_PHONG) {
			materialAsset.loadFaces = true;
		}

		this._assets.load(cubemapAsset);
	}

	_onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
		const material = materialAsset.resource;

		if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
			this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);

			material.update();
		}
	}

	_bindAndAssignAssets(materialAsset, assets) {
		const data = this._parser.migrate(materialAsset.data);

		const material = materialAsset.resource;
		const pathMapping = data.mappingFormat === "path";
		const TEXTURES = standardMaterialTextureParameters;
		let i, name, assetReference;

		for (i = 0; i < TEXTURES.length; i++) {
			name = TEXTURES[i];
			assetReference = material._assetReferences[name];
			const dataAssetId = data[name];
			const materialTexture = material[name];

			const isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name, materialAsset);

			const dataValidated = data.validated;

			if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
				if (!assetReference) {
					assetReference = new AssetReference(name, materialAsset, assets, {
						load: this._onTextureLoad,
						add: this._onTextureAdd,
						remove: this._onTextureRemoveOrUnload,
						unload: this._onTextureRemoveOrUnload
					}, this);
					material._assetReferences[name] = assetReference;
				}

				if (pathMapping) {
					assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
				} else {
					assetReference.id = dataAssetId;
				}

				if (assetReference.asset) {
					if (assetReference.asset.resource) {
						this._assignTexture(name, materialAsset, assetReference.asset.resource);
					} else {
						this._assignPlaceholderTexture(name, materialAsset);
					}

					assets.load(assetReference.asset);
				}
			} else {
				if (assetReference) {
					if (pathMapping) {
						assetReference.url = null;
					} else {
						assetReference.id = null;
					}
				}
			}
		}

		const CUBEMAPS = standardMaterialCubemapParameters;

		for (i = 0; i < CUBEMAPS.length; i++) {
			name = CUBEMAPS[i];
			assetReference = material._assetReferences[name];

			if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
				if (!assetReference) {
					assetReference = new AssetReference(name, materialAsset, assets, {
						load: this._onCubemapLoad,
						add: this._onCubemapAdd,
						remove: this._onCubemapRemoveOrUnload,
						unload: this._onCubemapRemoveOrUnload
					}, this);
					material._assetReferences[name] = assetReference;
				}

				if (pathMapping) {
					assetReference.url = data[name];
				} else {
					assetReference.id = data[name];
				}

				if (assetReference.asset) {
					if (assetReference.asset.loaded) {
						this._assignCubemap(name, materialAsset, assetReference.asset.resources);
					}

					assets.load(assetReference.asset);
				}
			}
		}

		this._parser.initialize(material, data);
	}

}

class GlbModelParser {
	constructor(device, defaultMaterial) {
		this._device = device;
		this._defaultMaterial = defaultMaterial;
	}

	parse(data) {
		const glbResources = GlbParser.parse("filename.glb", data, this._device);

		if (glbResources) {
			const model = GlbContainerResource.createModel(glbResources, this._defaultMaterial);
			glbResources.destroy();
			return model;
		}

		return null;
	}

}

class PartitionedVertex {
	constructor() {
		this.index = 0;
		this.boneIndices = [0, 0, 0, 0];
	}

}

class SkinPartition {
	constructor() {
		this.partition = 0;
		this.vertexStart = 0;
		this.vertexCount = 0;
		this.indexStart = 0;
		this.indexCount = 0;
		this.boneIndices = [];
		this.vertices = [];
		this.indices = [];
		this.indexMap = {};
		this.originalMesh = null;
	}

	addVertex(vertex, idx, vertexArray) {
		let remappedIndex = -1;

		if (this.indexMap[idx] !== undefined) {
			remappedIndex = this.indexMap[idx];
			this.indices.push(remappedIndex);
		} else {
			for (let influence = 0; influence < 4; influence++) {
				if (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;
				const originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
				vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
			}

			remappedIndex = this.vertices.length;
			this.indices.push(remappedIndex);
			this.vertices.push(vertex);
			this.indexMap[idx] = remappedIndex;
		}
	}

	addPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {
		const bonesToAdd = [];
		let bonesToAddCount = 0;
		const vertexCount = vertices.length;

		for (let i = 0; i < vertexCount; i++) {
			const vertex = vertices[i];
			const idx = vertex.index;

			for (let influence = 0; influence < 4; influence++) {
				if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
					const boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
					let needToAdd = true;

					for (let j = 0; j < bonesToAddCount; j++) {
						if (bonesToAdd[j] === boneIndex) {
							needToAdd = false;
							break;
						}
					}

					if (needToAdd) {
						bonesToAdd[bonesToAddCount] = boneIndex;
						const boneRemap = this.getBoneRemap(boneIndex);
						bonesToAddCount += boneRemap === -1 ? 1 : 0;
					}
				}
			}
		}

		if (this.boneIndices.length + bonesToAddCount > boneLimit) {
			return false;
		}

		for (let i = 0; i < bonesToAddCount; i++) {
			this.boneIndices.push(bonesToAdd[i]);
		}

		for (let i = 0; i < vertexCount; i++) {
			this.addVertex(vertices[i], vertexIndices[i], vertexArray);
		}

		return true;
	}

	getBoneRemap(boneIndex) {
		for (let i = 0; i < this.boneIndices.length; i++) {
			if (this.boneIndices[i] === boneIndex) {
				return i;
			}
		}

		return -1;
	}

}

function indicesToReferences(model) {
	const vertices = model.vertices;
	const skins = model.skins;
	const meshes = model.meshes;
	const meshInstances = model.meshInstances;

	for (let i = 0; i < meshes.length; i++) {
		meshes[i].vertices = vertices[meshes[i].vertices];

		if (meshes[i].skin !== undefined) {
			meshes[i].skin = skins[meshes[i].skin];
		}
	}

	for (let i = 0; i < meshInstances.length; i++) {
		meshInstances[i].mesh = meshes[meshInstances[i].mesh];
	}
}

function referencesToIndices(model) {
	const vertices = model.vertices;
	const skins = model.skins;
	const meshes = model.meshes;
	const meshInstances = model.meshInstances;

	for (let i = 0; i < meshes.length; i++) {
		meshes[i].vertices = vertices.indexOf(meshes[i].vertices);

		if (meshes[i].skin !== undefined) {
			meshes[i].skin = skins.indexOf(meshes[i].skin);
		}
	}

	for (let i = 0; i < meshInstances.length; i++) {
		meshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);
	}
}

function partitionSkin(model, materialMappings, boneLimit) {
	let i, j, k, index;
	indicesToReferences(model);
	const vertexArrays = model.vertices;
	const skins = model.skins;
	let mesh;
	const meshes = model.meshes;
	const meshInstances = model.meshInstances;

	const getVertex = function getVertex(idx) {
		const vert = new PartitionedVertex();
		vert.index = idx;
		return vert;
	};

	for (i = skins.length - 1; i >= 0; i--) {
		if (skins[i].boneNames.length > boneLimit) {
			const skin = skins.splice(i, 1)[0];
			const meshesToSplit = [];

			for (j = 0; j < meshes.length; j++) {
				if (meshes[j].skin === skin) {
					meshesToSplit.push(meshes[j]);
				}
			}

			for (j = 0; j < meshesToSplit.length; j++) {
				index = meshes.indexOf(meshesToSplit[j]);

				if (index !== -1) {
					meshes.splice(index, 1);
				}
			}

			if (meshesToSplit.length === 0) {
				throw new Error('partitionSkin: There should be at least one mesh that references a skin');
			}

			const vertexArray = meshesToSplit[0].vertices;

			for (j = 1; j < meshesToSplit.length; j++) {
				if (meshesToSplit[j].vertices !== vertexArray) {
					throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');
				}
			}

			let partition;
			const partitions = [];
			const primitiveVertices = [];
			const primitiveIndices = [];
			let basePartition = 0;

			for (j = 0; j < meshesToSplit.length; j++) {
				mesh = meshesToSplit[j];
				const indices = mesh.indices;

				for (let iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {
					index = indices[iIndex++];
					primitiveVertices[0] = getVertex(index);
					primitiveIndices[0] = index;
					index = indices[iIndex++];
					primitiveVertices[1] = getVertex(index);
					primitiveIndices[1] = index;
					index = indices[iIndex++];
					primitiveVertices[2] = getVertex(index);
					primitiveIndices[2] = index;
					let added = false;

					for (let iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {
						partition = partitions[iBonePartition];

						if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
							added = true;
							break;
						}
					}

					if (!added) {
						partition = new SkinPartition();
						partition.originalMesh = mesh;
						partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
						partitions.push(partition);
					}
				}

				basePartition = partitions.length;
			}

			const partitionedVertices = [];
			const partitionedIndices = [];

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];

				if (partition.vertices.length && partition.indices.length) {
					const vertexStart = partitionedVertices.length;
					const vertexCount = partition.vertices.length;
					const indexStart = partitionedIndices.length;
					const indexCount = partition.indices.length;
					partition.partition = j;
					partition.vertexStart = vertexStart;
					partition.vertexCount = vertexCount;
					partition.indexStart = indexStart;
					partition.indexCount = indexCount;
					let iSour;
					let iDest;
					iSour = 0;
					iDest = vertexStart;

					while (iSour < vertexCount) {
						partitionedVertices[iDest++] = partition.vertices[iSour++];
					}

					iSour = 0;
					iDest = indexStart;

					while (iSour < indexCount) {
						partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;
					}
				}
			}

			const splitSkins = [];

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];
				const ibp = [];
				const boneNames = [];

				for (k = 0; k < partition.boneIndices.length; k++) {
					ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
					boneNames.push(skin.boneNames[partition.boneIndices[k]]);
				}

				const splitSkin = {
					inverseBindMatrices: ibp,
					boneNames: boneNames
				};
				splitSkins.push(splitSkin);
				skins.push(splitSkin);
			}

			let attrib, attribName, data, components;
			const splitVertexArray = {};

			for (attribName in vertexArray) {
				splitVertexArray[attribName] = {
					components: vertexArray[attribName].components,
					data: [],
					type: vertexArray[attribName].type
				};
			}

			for (attribName in vertexArray) {
				if (attribName === 'blendIndices') {
					const dstBoneIndices = splitVertexArray[attribName].data;

					for (j = 0; j < partitionedVertices.length; j++) {
						const srcBoneIndices = partitionedVertices[j].boneIndices;
						dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
					}
				} else {
					attrib = vertexArray[attribName];
					data = attrib.data;
					components = attrib.components;

					for (j = 0; j < partitionedVertices.length; j++) {
						index = partitionedVertices[j].index;

						for (k = 0; k < components; k++) {
							splitVertexArray[attribName].data.push(data[index * components + k]);
						}
					}
				}
			}

			vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];
				mesh = {
					aabb: {
						min: [0, 0, 0],
						max: [0, 0, 0]
					},
					vertices: splitVertexArray,
					skin: splitSkins[j],
					indices: partitionedIndices.splice(0, partition.indexCount),
					type: 'triangles',
					base: 0,
					count: partition.indexCount
				};
				meshes.push(mesh);

				for (k = meshInstances.length - 1; k >= 0; k--) {
					if (meshInstances[k].mesh === partition.originalMesh) {
						meshInstances.push({
							mesh: mesh,
							node: meshInstances[k].node
						});

						if (materialMappings) {
							materialMappings.push({
								material: materialMappings[k].material,
								path: materialMappings[k].path
							});
						}
					}
				}
			}

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];

				for (k = meshInstances.length - 1; k >= 0; k--) {
					if (meshInstances[k].mesh === partition.originalMesh) {
						meshInstances.splice(k, 1);

						if (materialMappings) {
							materialMappings.splice(k, 1);
						}
					}
				}
			}
		}
	}

	referencesToIndices(model);
}

const JSON_PRIMITIVE_TYPE = {
	"points": PRIMITIVE_POINTS,
	"lines": PRIMITIVE_LINES,
	"lineloop": PRIMITIVE_LINELOOP,
	"linestrip": PRIMITIVE_LINESTRIP,
	"triangles": PRIMITIVE_TRIANGLES,
	"trianglestrip": PRIMITIVE_TRISTRIP,
	"trianglefan": PRIMITIVE_TRIFAN
};
const JSON_VERTEX_ELEMENT_TYPE = {
	"int8": TYPE_INT8,
	"uint8": TYPE_UINT8,
	"int16": TYPE_INT16,
	"uint16": TYPE_UINT16,
	"int32": TYPE_INT32,
	"uint32": TYPE_UINT32,
	"float32": TYPE_FLOAT32
};

class JsonModelParser {
	constructor(device, defaultMaterial) {
		this._device = device;
		this._defaultMaterial = defaultMaterial;
	}

	parse(data) {
		const modelData = data.model;

		if (!modelData) {
			return null;
		}

		if (modelData.version <= 1) {
			return null;
		}

		const nodes = this._parseNodes(data);

		const skins = this._parseSkins(data, nodes);

		const vertexBuffers = this._parseVertexBuffers(data);

		const indices = this._parseIndexBuffers(data, vertexBuffers);

		const morphs = this._parseMorphs(data, nodes, vertexBuffers);

		const meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);

		const meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);

		const model = new Model();
		model.graph = nodes[0];
		model.meshInstances = meshInstances;
		model.skinInstances = skins.instances;
		model.morphInstances = morphs.instances;
		model.getGraph().syncHierarchy();
		return model;
	}

	_parseNodes(data) {
		const modelData = data.model;
		const nodes = [];
		let i;

		for (i = 0; i < modelData.nodes.length; i++) {
			const nodeData = modelData.nodes[i];
			const node = new GraphNode(nodeData.name);
			node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
			node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
			node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
			node.scaleCompensation = !!nodeData.scaleCompensation;
			nodes.push(node);
		}

		for (i = 1; i < modelData.parents.length; i++) {
			nodes[modelData.parents[i]].addChild(nodes[i]);
		}

		return nodes;
	}

	_parseSkins(data, nodes) {
		const modelData = data.model;
		const skins = [];
		const skinInstances = [];
		let i, j;

		if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
			const boneLimit = this._device.getBoneLimit();

			partitionSkin(modelData, null, boneLimit);
		}

		for (i = 0; i < modelData.skins.length; i++) {
			const skinData = modelData.skins[i];
			const inverseBindMatrices = [];

			for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
				const ibm = skinData.inverseBindMatrices[j];
				inverseBindMatrices[j] = new Mat4().set(ibm);
			}

			const skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
			skins.push(skin);
			const skinInstance = new SkinInstance(skin);
			const bones = [];

			for (j = 0; j < skin.boneNames.length; j++) {
				const boneName = skin.boneNames[j];
				const bone = nodes[0].findByName(boneName);
				bones.push(bone);
			}

			skinInstance.bones = bones;
			skinInstances.push(skinInstance);
		}

		return {
			skins: skins,
			instances: skinInstances
		};
	}

	_getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
		for (let i = 0; i < modelData.meshes.length; i++) {
			const meshData = modelData.meshes[i];

			if (meshData.morph === morphIndex) {
				const vertexBuffer = vertexBuffers[meshData.vertices];
				return vertexBuffer.numVertices;
			}
		}

		return undefined;
	}

	_parseMorphs(data, nodes, vertexBuffers) {
		const modelData = data.model;
		const morphs = [];
		const morphInstances = [];
		let i, j, vertexCount;
		let targets, morphTarget, morphTargetArray;

		if (modelData.morphs) {
			const sparseToFull = function sparseToFull(data, indices, totalCount) {
				const full = new Float32Array(totalCount * 3);

				for (let s = 0; s < indices.length; s++) {
					const dstIndex = indices[s] * 3;
					full[dstIndex] = data[s * 3];
					full[dstIndex + 1] = data[s * 3 + 1];
					full[dstIndex + 2] = data[s * 3 + 2];
				}

				return full;
			};

			for (i = 0; i < modelData.morphs.length; i++) {
				targets = modelData.morphs[i].targets;
				morphTargetArray = [];
				vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);

				for (j = 0; j < targets.length; j++) {
					const targetAabb = targets[j].aabb;
					const min = targetAabb.min;
					const max = targetAabb.max;
					const aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
					const indices = targets[j].indices;
					let deltaPositions = targets[j].deltaPositions;
					let deltaNormals = targets[j].deltaNormals;

					if (indices) {
						deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
						deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
					}

					morphTarget = new MorphTarget({
						deltaPositions: deltaPositions,
						deltaNormals: deltaNormals,
						name: targets[j].name,
						aabb: aabb
					});
					morphTargetArray.push(morphTarget);
				}

				const morph = new Morph(morphTargetArray, this._device);
				morphs.push(morph);
				const morphInstance = new MorphInstance(morph);
				morphInstances.push(morphInstance);
			}
		}

		return {
			morphs: morphs,
			instances: morphInstances
		};
	}

	_parseVertexBuffers(data) {
		const modelData = data.model;
		const vertexBuffers = [];
		const attributeMap = {
			position: SEMANTIC_POSITION,
			normal: SEMANTIC_NORMAL,
			tangent: SEMANTIC_TANGENT,
			blendWeight: SEMANTIC_BLENDWEIGHT,
			blendIndices: SEMANTIC_BLENDINDICES,
			color: SEMANTIC_COLOR,
			texCoord0: SEMANTIC_TEXCOORD0,
			texCoord1: SEMANTIC_TEXCOORD1,
			texCoord2: SEMANTIC_TEXCOORD2,
			texCoord3: SEMANTIC_TEXCOORD3,
			texCoord4: SEMANTIC_TEXCOORD4,
			texCoord5: SEMANTIC_TEXCOORD5,
			texCoord6: SEMANTIC_TEXCOORD6,
			texCoord7: SEMANTIC_TEXCOORD7
		};

		for (let i = 0; i < modelData.vertices.length; i++) {
			const vertexData = modelData.vertices[i];
			const formatDesc = [];

			for (const attributeName in vertexData) {
				const attribute = vertexData[attributeName];
				formatDesc.push({
					semantic: attributeMap[attributeName],
					components: attribute.components,
					type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
					normalize: attributeMap[attributeName] === SEMANTIC_COLOR
				});
			}

			const vertexFormat = new VertexFormat(this._device, formatDesc);
			const numVertices = vertexData.position.data.length / vertexData.position.components;
			const vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
			const iterator = new VertexIterator(vertexBuffer);

			for (let j = 0; j < numVertices; j++) {
				for (const attributeName in vertexData) {
					const attribute = vertexData[attributeName];

					switch (attribute.components) {
						case 1:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j]);
							break;

						case 2:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j * 2], 1.0 - attribute.data[j * 2 + 1]);
							break;

						case 3:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);
							break;

						case 4:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);
							break;
					}
				}

				iterator.next();
			}

			iterator.end();
			vertexBuffers.push(vertexBuffer);
		}

		return vertexBuffers;
	}

	_parseIndexBuffers(data, vertexBuffers) {
		const modelData = data.model;
		let indexBuffer = null;
		let indexData = null;
		let i;
		let numIndices = 0;

		for (i = 0; i < modelData.meshes.length; i++) {
			const meshData = modelData.meshes[i];

			if (meshData.indices !== undefined) {
				numIndices += meshData.indices.length;
			}
		}

		let maxVerts = 0;

		for (i = 0; i < vertexBuffers.length; i++) {
			maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
		}

		if (numIndices > 0) {
			if (maxVerts > 0xFFFF && this._device.extUintElement) {
				indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
				indexData = new Uint32Array(indexBuffer.lock());
			} else {
				indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
				indexData = new Uint16Array(indexBuffer.lock());
			}
		}

		return {
			buffer: indexBuffer,
			data: indexData
		};
	}

	_parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
		const modelData = data.model;
		const meshes = [];
		let indexBase = 0;

		for (let i = 0; i < modelData.meshes.length; i++) {
			const meshData = modelData.meshes[i];
			const meshAabb = meshData.aabb;
			const min = meshAabb.min;
			const max = meshAabb.max;
			const aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
			const indexed = meshData.indices !== undefined;
			const mesh = new Mesh(this._device);
			mesh.vertexBuffer = vertexBuffers[meshData.vertices];
			mesh.indexBuffer[0] = indexed ? indexBuffer : null;
			mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
			mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
			mesh.primitive[0].count = meshData.count;
			mesh.primitive[0].indexed = indexed;
			mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
			mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
			mesh.aabb = aabb;

			if (indexed) {
				indexData.set(meshData.indices, indexBase);
				indexBase += meshData.indices.length;
			}

			meshes.push(mesh);
		}

		if (indexBuffer !== null) {
			indexBuffer.unlock();
		}

		return meshes;
	}

	_parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
		const modelData = data.model;
		const meshInstances = [];
		let i;

		for (i = 0; i < modelData.meshInstances.length; i++) {
			const meshInstanceData = modelData.meshInstances[i];
			const node = nodes[meshInstanceData.node];
			const mesh = meshes[meshInstanceData.mesh];
			const meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);

			if (mesh.skin) {
				const skinIndex = skins.indexOf(mesh.skin);
				meshInstance.skinInstance = skinInstances[skinIndex];
			}

			if (mesh.morph) {
				const morphIndex = morphs.indexOf(mesh.morph);
				meshInstance.morphInstance = morphInstances[morphIndex];
			}

			meshInstances.push(meshInstance);
		}

		return meshInstances;
	}

}

class ModelHandler {
	constructor(device) {
		this._device = device;
		this._parsers = [];
		this._defaultMaterial = DefaultMaterial.get(device);
		this.maxRetries = 0;
		this.addParser(new JsonModelParser(this._device, this._defaultMaterial), function (url, data) {
			return path.getExtension(url) === '.json';
		});
		this.addParser(new GlbModelParser(this._device, this._defaultMaterial), function (url, data) {
			return path.getExtension(url) === '.glb';
		});
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
			if (path.getExtension(url.original).toLowerCase() === '.glb') {
				options.responseType = Http.ResponseType.ARRAY_BUFFER;
			} else {
				options.responseType = Http.ResponseType.JSON;
			}
		}

		http.get(url.load, options, function (err, response) {
			if (!callback) return;

			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading model: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		for (let i = 0; i < this._parsers.length; i++) {
			const p = this._parsers[i];

			if (p.decider(url, data)) {
				return p.parser.parse(data);
			}
		}

		return null;
	}

	patch(asset, assets) {
		if (!asset.resource) return;
		const data = asset.data;
		const self = this;
		asset.resource.meshInstances.forEach(function (meshInstance, i) {
			if (data.mapping) {
				const handleMaterial = function handleMaterial(asset) {
					if (asset.resource) {
						meshInstance.material = asset.resource;
					} else {
						asset.once('load', handleMaterial);
						assets.load(asset);
					}

					asset.once('remove', function (asset) {
						if (meshInstance.material === asset.resource) {
							meshInstance.material = self._defaultMaterial;
						}
					});
				};

				if (!data.mapping[i]) {
					meshInstance.material = self._defaultMaterial;
					return;
				}

				const id = data.mapping[i].material;
				const url = data.mapping[i].path;
				let material;

				if (id !== undefined) {
					if (!id) {
						meshInstance.material = self._defaultMaterial;
					} else {
						material = assets.get(id);

						if (material) {
							handleMaterial(material);
						} else {
							assets.once('add:' + id, handleMaterial);
						}
					}
				} else if (url) {
					const path = asset.getAbsoluteUrl(data.mapping[i].path);
					material = assets.getByUrl(path);

					if (material) {
						handleMaterial(material);
					} else {
						assets.once('add:url:' + path, handleMaterial);
					}
				}
			}
		});
	}

	addParser(parser, decider) {
		this._parsers.push({
			parser: parser,
			decider: decider
		});
	}

}

function onContainerAssetLoaded(containerAsset) {
	const renderAsset = this;
	if (!renderAsset.resource) return;
	const containerResource = containerAsset.resource;
	const render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];

	if (render) {
		renderAsset.resource.meshes = render.resource.meshes;
	}
}

function onContainerAssetAdded(containerAsset) {
	const renderAsset = this;
	renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
	renderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
	renderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);
	renderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);

	if (!containerAsset.resource) {
		renderAsset.registry.load(containerAsset);
	} else {
		onContainerAssetLoaded.call(renderAsset, containerAsset);
	}
}

function onContainerAssetRemoved(containerAsset) {
	const renderAsset = this;
	renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);

	if (renderAsset.resource) {
		renderAsset.resource.destroy();
	}
}

class RenderHandler {
	constructor(assets) {
		this._registry = assets;
	}

	load(url, callback, asset) {}

	open(url, data) {
		return new Render();
	}

	patch(asset, registry) {
		if (!asset.data.containerAsset) return;
		const containerAsset = registry.get(asset.data.containerAsset);

		if (!containerAsset) {
			registry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);
			return;
		}

		onContainerAssetAdded.call(asset, containerAsset);
	}

}

class ResourceLoader {
	constructor(app) {
		this._handlers = {};
		this._requests = {};
		this._cache = {};
		this._app = app;
	}

	addHandler(type, handler) {
		this._handlers[type] = handler;
		handler._loader = this;
	}

	removeHandler(type) {
		delete this._handlers[type];
	}

	getHandler(type) {
		return this._handlers[type];
	}

	load(url, type, callback, asset) {
		const handler = this._handlers[type];

		if (!handler) {
			const err = "No handler for asset type: " + type;
			callback(err);
			return;
		}

		if (!url) {
			this._loadNull(handler, callback, asset);

			return;
		}

		const key = url + type;

		if (this._cache[key] !== undefined) {
			callback(null, this._cache[key]);
		} else if (this._requests[key]) {
			this._requests[key].push(callback);
		} else {
			this._requests[key] = [callback];
			const self = this;

			const handleLoad = function handleLoad(err, urlObj) {
				if (err) {
					self._onFailure(key, err);

					return;
				}

				handler.load(urlObj, function (err, data, extra) {
					if (!self._requests[key]) {
						return;
					}

					if (err) {
						self._onFailure(key, err);

						return;
					}

					try {
						self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
					} catch (e) {
						self._onFailure(key, e);
					}
				}, asset);
			};

			const normalizedUrl = url.split('?')[0];

			if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
				if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
					handleLoad(`Bundle for ${url} not loaded yet`);
					return;
				}

				this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
					handleLoad(err, {
						load: fileUrlFromBundle,
						original: normalizedUrl
					});
				});
			} else {
				handleLoad(null, {
					load: url,
					original: asset && asset.file.filename || url
				});
			}
		}
	}

	_loadNull(handler, callback, asset) {
		const onLoad = function onLoad(err, data, extra) {
			if (err) {
				callback(err);
			} else {
				try {
					callback(null, handler.open(null, data, asset), extra);
				} catch (e) {
					callback(e);
				}
			}
		};

		handler.load(null, onLoad, asset);
	}

	_onSuccess(key, result, extra) {
		this._cache[key] = result;

		for (let i = 0; i < this._requests[key].length; i++) {
			this._requests[key][i](null, result, extra);
		}

		delete this._requests[key];
	}

	_onFailure(key, err) {
		console.error(err);

		if (this._requests[key]) {
			for (let i = 0; i < this._requests[key].length; i++) {
				this._requests[key][i](err);
			}

			delete this._requests[key];
		}
	}

	open(type, data) {
		const handler = this._handlers[type];

		if (!handler) {
			console.warn("No resource handler found for: " + type);
			return data;
		}

		return handler.open(null, data);
	}

	patch(asset, assets) {
		const handler = this._handlers[asset.type];

		if (!handler) {
			console.warn("No resource handler found for: " + asset.type);
			return;
		}

		if (handler.patch) {
			handler.patch(asset, assets);
		}
	}

	clearCache(url, type) {
		delete this._cache[url + type];
	}

	getFromCache(url, type) {
		if (this._cache[url + type]) {
			return this._cache[url + type];
		}
	}

	enableRetry(maxRetries = 5) {
		maxRetries = Math.max(0, maxRetries) || 0;

		for (const key in this._handlers) {
			this._handlers[key].maxRetries = maxRetries;
		}
	}

	disableRetry() {
		for (const key in this._handlers) {
			this._handlers[key].maxRetries = 0;
		}
	}

	destroy() {
		this._handlers = {};
		this._requests = {};
		this._cache = {};
	}

}

class SceneHandler {
	constructor(app) {
		this._app = app;
		this.maxRetries = 0;
	}

	load(url, callback) {
		SceneUtils.load(url, this.maxRetries, callback);
	}

	open(url, data) {
		this._app.systems.script.preloading = true;
		const parser = new SceneParser(this._app, false);
		const parent = parser.parse(data);
		const scene = this._app.scene;
		scene.root = parent;

		this._app.applySceneSettings(data.settings);

		this._app.systems.script.preloading = false;
		return scene;
	}

	patch(asset, assets) {}

}

let _legacy = false;
let _createdLoadingScreen = false;
const script = {
	app: null,
	create: function (name, callback) {
		if (!_legacy) return;
		const ScriptType = callback(script.app);
		ScriptType._pcScriptName = name;

		ScriptHandler._push(ScriptType);

		this.fire("created", name, callback);
	},
	attribute: function (name, type, defaultValue, options) {},
	createLoadingScreen: function (callback) {
		if (_createdLoadingScreen) return;
		_createdLoadingScreen = true;
		const app = getApplication();
		callback(app);
	}
};
Object.defineProperty(script, 'legacy', {
	get: function () {
		return _legacy;
	},
	set: function (value) {
		_legacy = value;
	}
});
events.attach(script);

class ScriptHandler {
	constructor(app) {
		this._app = app;
		this._scripts = {};
		this._cache = {};
	}

	static _push(Type) {
		if (script.legacy && ScriptHandler._types.length > 0) {
			console.assert("Script Ordering Error. Contact support@playcanvas.com");
		} else {
			ScriptHandler._types.push(Type);
		}
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;
		script.app = this._app;

		this._loadScript(url.load, (err, url, extra) => {
			if (!err) {
				if (script.legacy) {
					let Type = null;

					if (ScriptHandler._types.length) {
						Type = ScriptHandler._types.pop();
					}

					if (Type) {
						this._scripts[url] = Type;
					} else {
						Type = null;
					}

					callback(null, Type, extra);
				} else {
					const obj = {};

					for (let i = 0; i < ScriptHandler._types.length; i++) obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];

					ScriptHandler._types.length = 0;
					callback(null, obj, extra);
					delete self._loader._cache[url + 'script'];
				}
			} else {
				callback(err);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

	_loadScript(url, callback) {
		const head = document.head;
		const element = document.createElement('script');
		this._cache[url] = element;
		element.async = false;
		element.addEventListener('error', function (e) {
			callback(`Script: ${e.target.src} failed to load`);
		}, false);
		let done = false;

		element.onload = element.onreadystatechange = function () {
			if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
				done = true;
				callback(null, url, element);
			}
		};

		element.src = url;
		head.appendChild(element);
	}

}

ScriptHandler._types = [];

class ShaderHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading shader resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

const spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
const spriteIndices = [0, 1, 3, 2, 3, 1];

class Sprite extends EventHandler {
	constructor(device, options) {
		super();
		this._device = device;
		this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
		this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
		this._atlas = options && options.atlas !== undefined ? options.atlas : null;
		this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
		this._meshes = [];
		this._updatingProperties = false;
		this._meshesDirty = false;

		if (this._atlas && this._frameKeys) {
			this._createMeshes();
		}
	}

	set frameKeys(value) {
		this._frameKeys = value;

		if (this._atlas && this._frameKeys) {
			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		}

		this.fire('set:frameKeys', value);
	}

	get frameKeys() {
		return this._frameKeys;
	}

	set atlas(value) {
		if (value === this._atlas) return;

		if (this._atlas) {
			this._atlas.off('set:frames', this._onSetFrames, this);

			this._atlas.off('set:frame', this._onFrameChanged, this);

			this._atlas.off('remove:frame', this._onFrameRemoved, this);
		}

		this._atlas = value;

		if (this._atlas && this._frameKeys) {
			this._atlas.on('set:frames', this._onSetFrames, this);

			this._atlas.on('set:frame', this._onFrameChanged, this);

			this._atlas.on('remove:frame', this._onFrameRemoved, this);

			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		}

		this.fire('set:atlas', value);
	}

	get atlas() {
		return this._atlas;
	}

	set pixelsPerUnit(value) {
		if (this._pixelsPerUnit === value) return;
		this._pixelsPerUnit = value;
		this.fire('set:pixelsPerUnit', value);

		if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		}
	}

	get pixelsPerUnit() {
		return this._pixelsPerUnit;
	}

	set renderMode(value) {
		if (this._renderMode === value) return;
		const prev = this._renderMode;
		this._renderMode = value;
		this.fire('set:renderMode', value);

		if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
			if (this._atlas && this._frameKeys) {
				if (this._updatingProperties) {
					this._meshesDirty = true;
				} else {
					this._createMeshes();
				}
			}
		}
	}

	get renderMode() {
		return this._renderMode;
	}

	get meshes() {
		return this._meshes;
	}

	_createMeshes() {
		const len = this._meshes.length;

		for (let i = 0; i < len; i++) {
			const mesh = this._meshes[i];

			if (mesh) {
				mesh.destroy();
			}
		}

		const count = this._frameKeys.length;
		this._meshes = new Array(count);
		const createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;

		for (let i = 0; i < count; i++) {
			const frame = this._atlas.frames[this._frameKeys[i]];
			this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;
		}

		this.fire('set:meshes');
	}

	_createSimpleMesh(frame) {
		const rect = frame.rect;
		const texWidth = this._atlas.texture.width;
		const texHeight = this._atlas.texture.height;
		const w = rect.z / this._pixelsPerUnit;
		const h = rect.w / this._pixelsPerUnit;
		const hp = frame.pivot.x;
		const vp = frame.pivot.y;
		const positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
		const lu = rect.x / texWidth;
		const bv = 1.0 - rect.y / texHeight;
		const ru = (rect.x + rect.z) / texWidth;
		const tv = 1.0 - (rect.y + rect.w) / texHeight;
		const uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
		const mesh = createMesh$1(this._device, positions, {
			uvs: uvs,
			normals: spriteNormals,
			indices: spriteIndices
		});
		return mesh;
	}

	_create9SliceMesh() {
		const he = Vec2.ONE;
		const ws = 3;
		const ls = 3;
		const positions = [];
		const normals = [];
		const uvs = [];
		const indices = [];
		let vcounter = 0;

		for (let i = 0; i <= ws; i++) {
			const u = i === 0 || i === ws ? 0 : 1;

			for (let j = 0; j <= ls; j++) {
				const x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
				const y = 0.0;
				const z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
				const v = j === 0 || j === ls ? 0 : 1;
				positions.push(-x, y, z);
				normals.push(0.0, 1.0, 0.0);
				uvs.push(u, v);

				if (i < ws && j < ls) {
					indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
					indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
				}

				vcounter++;
			}
		}

		const options = {
			normals: normals,
			uvs: uvs,
			indices: indices
		};
		return createMesh$1(this._device, positions, options);
	}

	_onSetFrames(frames) {
		if (this._updatingProperties) {
			this._meshesDirty = true;
		} else {
			this._createMeshes();
		}
	}

	_onFrameChanged(frameKey, frame) {
		const idx = this._frameKeys.indexOf(frameKey);

		if (idx < 0) return;

		if (frame) {
			if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
				this._meshes[idx] = this._createSimpleMesh(frame);
			}
		} else {
			this._meshes[idx] = null;
		}

		this.fire('set:meshes');
	}

	_onFrameRemoved(frameKey) {
		const idx = this._frameKeys.indexOf(frameKey);

		if (idx < 0) return;
		this._meshes[idx] = null;
		this.fire('set:meshes');
	}

	startUpdate() {
		this._updatingProperties = true;
		this._meshesDirty = false;
	}

	endUpdate() {
		this._updatingProperties = false;

		if (this._meshesDirty && this._atlas && this._frameKeys) {
			this._createMeshes();
		}

		this._meshesDirty = false;
	}

	destroy() {
		for (const mesh of this._meshes) {
			if (mesh) mesh.destroy();
		}

		this._meshes.length = 0;
	}

}

function onTextureAtlasLoaded(atlasAsset) {
	const spriteAsset = this;

	if (spriteAsset.resource) {
		spriteAsset.resource.atlas = atlasAsset.resource;
	}
}

function onTextureAtlasAdded(atlasAsset) {
	const spriteAsset = this;
	spriteAsset.registry.load(atlasAsset);
}

class SpriteHandler {
	constructor(assets, device) {
		this._assets = assets;
		this._device = device;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		if (path.getExtension(url.original) === '.json') {
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback(err);
				}
			});
		}
	}

	open(url, data) {
		const sprite = new Sprite(this._device);

		if (url) {
			sprite.__data = data;
		}

		return sprite;
	}

	patch(asset, assets) {
		const sprite = asset.resource;

		if (sprite.__data) {
			asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
			asset.data.renderMode = sprite.__data.renderMode;
			asset.data.frameKeys = sprite.__data.frameKeys;

			if (sprite.__data.textureAtlasAsset) {
				const atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);

				if (atlas) {
					asset.data.textureAtlasAsset = atlas.id;
				} else {
					console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
				}
			}
		}

		sprite.startUpdate();
		sprite.renderMode = asset.data.renderMode;
		sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
		sprite.frameKeys = asset.data.frameKeys;

		this._updateAtlas(asset);

		sprite.endUpdate();
		asset.off('change', this._onAssetChange, this);
		asset.on('change', this._onAssetChange, this);
	}

	_updateAtlas(asset) {
		const sprite = asset.resource;

		if (!asset.data.textureAtlasAsset) {
			sprite.atlas = null;
			return;
		}

		this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

		this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

		const atlasAsset = this._assets.get(asset.data.textureAtlasAsset);

		if (atlasAsset && atlasAsset.resource) {
			sprite.atlas = atlasAsset.resource;
		} else {
			if (!atlasAsset) {
				this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);

				this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
			} else {
				this._assets.load(atlasAsset);
			}
		}
	}

	_onAssetChange(asset, attribute, value, oldValue) {
		if (attribute === 'data') {
			if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
				this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);

				this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
			}
		}
	}

}

class Template {
	constructor(app, data) {
		this._app = app;
		this._data = data;
		this._templateRoot = null;
	}

	instantiate() {
		if (!this._templateRoot) {
			this._parseTemplate();
		}

		return this._templateRoot.clone();
	}

	_parseTemplate() {
		const parser = new SceneParser(this._app, true);
		this._templateRoot = parser.parse(this._data);
	}

}

class TemplateHandler {
	constructor(app) {
		this._app = app;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};
		http.get(url.load, options, function (err, response) {
			if (err) {
				callback("Error requesting template: " + url.original);
			} else {
				callback(err, response);
			}
		});
	}

	open(url, data) {
		return new Template(this._app, data);
	}

}

class TextHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading text resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class TextureAtlas extends EventHandler {
	constructor() {
		super();
		this._texture = null;
		this._frames = null;
	}

	set texture(value) {
		this._texture = value;
		this.fire('set:texture', value);
	}

	get texture() {
		return this._texture;
	}

	set frames(value) {
		this._frames = value;
		this.fire('set:frames', value);
	}

	get frames() {
		return this._frames;
	}

	setFrame(key, data) {
		let frame = this._frames[key];

		if (!frame) {
			frame = {
				rect: data.rect.clone(),
				pivot: data.pivot.clone(),
				border: data.border.clone()
			};
			this._frames[key] = frame;
		} else {
			frame.rect.copy(data.rect);
			frame.pivot.copy(data.pivot);
			frame.border.copy(data.border);
		}

		this.fire('set:frame', key.toString(), frame);
	}

	removeFrame(key) {
		const frame = this._frames[key];

		if (frame) {
			delete this._frames[key];
			this.fire('remove:frame', key.toString(), frame);
		}
	}

	destroy() {
		if (this._texture) {
			this._texture.destroy();
		}
	}

}

const JSON_ADDRESS_MODE$1 = {
	"repeat": ADDRESS_REPEAT,
	"clamp": ADDRESS_CLAMP_TO_EDGE,
	"mirror": ADDRESS_MIRRORED_REPEAT
};
const JSON_FILTER_MODE$1 = {
	"nearest": FILTER_NEAREST,
	"linear": FILTER_LINEAR,
	"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
	"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
	"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
	"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
};
const regexFrame = /^data\.frames\.(\d+)$/;

class TextureAtlasHandler {
	constructor(loader) {
		this._loader = loader;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;

		const handler = this._loader.getHandler("texture");

		if (path.getExtension(url.original) === '.json') {
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					const textureUrl = url.original.replace('.json', '.png');

					self._loader.load(textureUrl, "texture", function (err, texture) {
						if (err) {
							callback(err);
						} else {
							callback(null, {
								data: response,
								texture: texture
							});
						}
					});
				} else {
					callback(err);
				}
			});
		} else {
			return handler.load(url, callback);
		}
	}

	open(url, data) {
		const resource = new TextureAtlas();

		if (data.texture && data.data) {
			resource.texture = data.texture;
			resource.__data = data.data;
		} else {
			const handler = this._loader.getHandler("texture");

			const texture = handler.open(url, data);
			if (!texture) return null;
			resource.texture = texture;
		}

		return resource;
	}

	patch(asset, assets) {
		if (asset.resource.__data) {
			if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
			if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
			if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
			if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
			if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
			if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
			if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
			asset.data.frames = asset.resource.__data.frames;
			delete asset.resource.__data;
		}

		const texture = asset.resource.texture;

		if (texture) {
			texture.name = asset.name;
			if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];
			if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];
			if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];
			if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];
			if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;
			if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;

			if (asset.data.hasOwnProperty('rgbm')) {
				const type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;

				if (texture.type !== type) {
					texture.type = type;
				}
			}
		}

		asset.resource.texture = texture;
		const frames = {};

		for (const key in asset.data.frames) {
			const frame = asset.data.frames[key];
			frames[key] = {
				rect: new Vec4(frame.rect),
				pivot: new Vec2(frame.pivot),
				border: new Vec4(frame.border)
			};
		}

		asset.resource.frames = frames;
		asset.off('change', this._onAssetChange, this);
		asset.on('change', this._onAssetChange, this);
	}

	_onAssetChange(asset, attribute, value) {
		let frame;

		if (attribute === 'data' || attribute === 'data.frames') {
			const frames = {};

			for (const key in value.frames) {
				frame = value.frames[key];
				frames[key] = {
					rect: new Vec4(frame.rect),
					pivot: new Vec2(frame.pivot),
					border: new Vec4(frame.border)
				};
			}

			asset.resource.frames = frames;
		} else {
			const match = attribute.match(regexFrame);

			if (match) {
				const frameKey = match[1];

				if (value) {
					if (!asset.resource.frames[frameKey]) {
						asset.resource.frames[frameKey] = {
							rect: new Vec4(value.rect),
							pivot: new Vec2(value.pivot),
							border: new Vec4(value.border)
						};
					} else {
						frame = asset.resource.frames[frameKey];
						frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
						frame.pivot.set(value.pivot[0], value.pivot[1]);
						frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
					}

					asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
				} else {
					if (asset.resource.frames[frameKey]) {
						delete asset.resource.frames[frameKey];
						asset.resource.fire('remove:frame', frameKey);
					}
				}
			}
		}
	}

}

function BasisWorker() {
	const BASIS_FORMAT = {
		cTFETC1: 0,
		cTFETC2: 1,
		cTFBC1: 2,
		cTFBC3: 3,
		cTFPVRTC1_4_RGB: 8,
		cTFPVRTC1_4_RGBA: 9,
		cTFASTC_4x4: 10,
		cTFATC_RGB: 11,
		cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
		cTFRGBA32: 13,
		cTFRGB565: 14,
		cTFRGBA4444: 16
	};
	const opaqueMapping = {
		astc: BASIS_FORMAT.cTFASTC_4x4,
		dxt: BASIS_FORMAT.cTFBC1,
		etc1: BASIS_FORMAT.cTFETC1,
		etc2: BASIS_FORMAT.cTFETC1,
		pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
		atc: BASIS_FORMAT.cTFATC_RGB,
		none: BASIS_FORMAT.cTFRGB565
	};
	const alphaMapping = {
		astc: BASIS_FORMAT.cTFASTC_4x4,
		dxt: BASIS_FORMAT.cTFBC3,
		etc1: BASIS_FORMAT.cTFRGBA4444,
		etc2: BASIS_FORMAT.cTFETC2,
		pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
		atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
		none: BASIS_FORMAT.cTFRGBA4444
	};
	const PIXEL_FORMAT = {
		ETC1: 21,
		ETC2_RGB: 22,
		ETC2_RGBA: 23,
		DXT1: 8,
		DXT5: 10,
		PVRTC_4BPP_RGB_1: 26,
		PVRTC_4BPP_RGBA_1: 27,
		ASTC_4x4: 28,
		ATC_RGB: 29,
		ATC_RGBA: 30,
		R8_G8_B8_A8: 7,
		R5_G6_B5: 3,
		R4_G4_B4_A4: 5
	};

	const basisToEngineMapping = (basisFormat, deviceDetails) => {
		switch (basisFormat) {
			case BASIS_FORMAT.cTFETC1:
				return deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;

			case BASIS_FORMAT.cTFETC2:
				return PIXEL_FORMAT.ETC2_RGBA;

			case BASIS_FORMAT.cTFBC1:
				return PIXEL_FORMAT.DXT1;

			case BASIS_FORMAT.cTFBC3:
				return PIXEL_FORMAT.DXT5;

			case BASIS_FORMAT.cTFPVRTC1_4_RGB:
				return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;

			case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
				return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;

			case BASIS_FORMAT.cTFASTC_4x4:
				return PIXEL_FORMAT.ASTC_4x4;

			case BASIS_FORMAT.cTFATC_RGB:
				return PIXEL_FORMAT.ATC_RGB;

			case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
				return PIXEL_FORMAT.ATC_RGBA;

			case BASIS_FORMAT.cTFRGBA32:
				return PIXEL_FORMAT.R8_G8_B8_A8;

			case BASIS_FORMAT.cTFRGB565:
				return PIXEL_FORMAT.R5_G6_B5;

			case BASIS_FORMAT.cTFRGBA4444:
				return PIXEL_FORMAT.R4_G4_B4_A4;
		}
	};

	const unswizzleGGGR = data => {
		const genB = function genB(R, G) {
			const r = R * (2.0 / 255.0) - 1.0;
			const g = G * (2.0 / 255.0) - 1.0;
			const b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
			return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
		};

		for (let offset = 0; offset < data.length; offset += 4) {
			const R = data[offset + 3];
			const G = data[offset + 1];
			data[offset + 0] = R;
			data[offset + 2] = genB(R, G);
			data[offset + 3] = 255;
		}

		return data;
	};

	const pack565 = data => {
		const result = new Uint16Array(data.length / 4);

		for (let offset = 0; offset < data.length; offset += 4) {
			const R = data[offset + 0];
			const G = data[offset + 1];
			const B = data[offset + 2];
			result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
		}

		return result;
	};

	const isPOT = (width, height) => {
		return (width & width - 1) === 0 && (height & height - 1) === 0;
	};

	const performanceNow = () => {
		return typeof performance !== 'undefined' ? performance.now() : 0;
	};

	let basis;
	let rgbPriority;
	let rgbaPriority;

	const chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC) => {
		if (isUASTC) {
			if (deviceDetails.formats.astc) {
				return 'astc';
			}
		} else {
			if (hasAlpha) {
				if (deviceDetails.formats.etc2) {
					return 'etc2';
				}
			} else {
				if (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {
					return 'etc1';
				}
			}
		}

		const testInOrder = priority => {
			for (let i = 0; i < priority.length; ++i) {
				const format = priority[i];

				if (deviceDetails.formats[format]) {
					return format;
				}
			}

			return 'none';
		};

		return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
	};

	const dimensionsValid = (width, height, format, webgl2) => {
		switch (format) {
			case BASIS_FORMAT.cTFETC1:
			case BASIS_FORMAT.cTFETC2:
				return true;

			case BASIS_FORMAT.cTFBC1:
			case BASIS_FORMAT.cTFBC3:
				return (width & 0x3) === 0 && (height & 0x3) === 0;

			case BASIS_FORMAT.cTFPVRTC1_4_RGB:
			case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
				return isPOT(width, height) && (width === height || webgl2);

			case BASIS_FORMAT.cTFASTC_4x4:
				return true;

			case BASIS_FORMAT.cTFATC_RGB:
			case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
				return true;
		}
	};

	const transcodeKTX2 = (url, data, options) => {
		if (!basis.KTX2File) {
			throw new Error('Basis transcoder module does not include support for KTX2.');
		}

		const funcStart = performanceNow();
		const basisFile = new basis.KTX2File(new Uint8Array(data));
		const width = basisFile.getWidth();
		const height = basisFile.getHeight();
		const levels = basisFile.getLevels();
		const hasAlpha = !!basisFile.getHasAlpha();
		const isUASTC = basisFile.isUASTC && basisFile.isUASTC();

		if (!width || !height || !levels) {
			basisFile.close();
			basisFile.delete();
			throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`);
		}

		const format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
		const unswizzle = !!options.isGGGR && format === 'pvr';
		let basisFormat;

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGBA32;
		} else {
			basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

			if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
				basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
			}
		}

		if (!basisFile.startTranscoding()) {
			basisFile.close();
			basisFile.delete();
			throw new Error('Failed to start transcoding url=' + url);
		}

		let i;
		const levelData = [];

		for (let mip = 0; mip < levels; ++mip) {
			const dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
			const dst = new Uint8Array(dstSize);

			if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to transcode image url=' + url);
			}

			const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
			levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
		}

		basisFile.close();
		basisFile.delete();

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGB565;

			for (i = 0; i < levelData.length; ++i) {
				levelData[i] = pack565(unswizzleGGGR(levelData[i]));
			}
		}

		return {
			format: basisToEngineMapping(basisFormat, options.deviceDetails),
			width: width,
			height: height,
			levels: levelData,
			cubemap: false,
			transcodeTime: performanceNow() - funcStart,
			url: url,
			unswizzledGGGR: unswizzle
		};
	};

	const transcodeBasis = (url, data, options) => {
		const funcStart = performanceNow();
		const basisFile = new basis.BasisFile(new Uint8Array(data));
		const width = basisFile.getImageWidth(0, 0);
		const height = basisFile.getImageHeight(0, 0);
		const images = basisFile.getNumImages();
		const levels = basisFile.getNumLevels(0);
		const hasAlpha = !!basisFile.getHasAlpha();
		const isUASTC = basisFile.isUASTC && basisFile.isUASTC();

		if (!width || !height || !images || !levels) {
			basisFile.close();
			basisFile.delete();
			throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`);
		}

		const format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
		const unswizzle = !!options.isGGGR && format === 'pvr';
		let basisFormat;

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGBA32;
		} else {
			basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

			if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
				basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
			}
		}

		if (!basisFile.startTranscoding()) {
			basisFile.close();
			basisFile.delete();
			throw new Error('Failed to start transcoding url=' + url);
		}

		let i;
		const levelData = [];

		for (let mip = 0; mip < levels; ++mip) {
			const dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
			const dst = new Uint8Array(dstSize);

			if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to transcode image url=' + url);
			}

			const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
			levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
		}

		basisFile.close();
		basisFile.delete();

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGB565;

			for (i = 0; i < levelData.length; ++i) {
				levelData[i] = pack565(unswizzleGGGR(levelData[i]));
			}
		}

		return {
			format: basisToEngineMapping(basisFormat, options.deviceDetails),
			width: width,
			height: height,
			levels: levelData,
			cubemap: false,
			transcodeTime: performanceNow() - funcStart,
			url: url,
			unswizzledGGGR: unswizzle
		};
	};

	const transcode = (url, data, options) => {
		return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
	};

	const workerTranscode = (url, data, options) => {
		try {
			const result = transcode(url, data, options);
			result.levels = result.levels.map(v => v.buffer);
			self.postMessage({
				url: url,
				data: result
			}, result.levels);
		} catch (err) {
			self.postMessage({
				url: url,
				err: err
			}, null);
		}
	};

	const workerInit = (config, callback) => {
		self.importScripts(config.basisUrl);

		const instantiateWasmFunc = (imports, successCallback) => {
			WebAssembly.instantiate(config.module, imports).then(result => {
				successCallback(result);
			}).catch(reason => {
				console.error('instantiate failed + ' + reason);
			});
			return {};
		};

		self.BASIS(config.module ? {
			instantiateWasm: instantiateWasmFunc
		} : null).then(instance => {
			instance.initializeBasis();
			basis = instance;
			rgbPriority = config.rgbPriority;
			rgbaPriority = config.rgbaPriority;
			callback(null);
		});
	};

	const queue = [];

	self.onmessage = message => {
		const data = message.data;

		switch (data.type) {
			case 'init':
				workerInit(data.config, () => {
					for (let i = 0; i < queue.length; ++i) {
						workerTranscode(queue[i].url, queue[i].data, queue[i].options);
					}

					queue.length = 0;
				});
				break;

			case 'transcode':
				if (basis) {
					workerTranscode(data.url, data.data, data.options);
				} else {
					queue.push(data);
				}

				break;
		}
	};
}

const getCompressionFormats = device => {
	return {
		astc: !!device.extCompressedTextureASTC,
		atc: !!device.extCompressedTextureATC,
		dxt: !!device.extCompressedTextureS3TC,
		etc1: !!device.extCompressedTextureETC1,
		etc2: !!device.extCompressedTextureETC,
		pvr: !!device.extCompressedTexturePVRTC
	};
};

const prepareWorkerModules = (config, callback) => {
	const getWorkerBlob = () => {
		const code = '(' + BasisWorker.toString() + ')()\n\n';
		return new Blob([code], {
			type: 'application/javascript'
		});
	};

	const wasmSupported = () => {
		try {
			if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
				const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
				if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
			}
		} catch (e) {}

		return false;
	};

	const sendResponse = (basisCode, module) => {
		callback(null, {
			workerUrl: URL.createObjectURL(getWorkerBlob()),
			basisUrl: URL.createObjectURL(basisCode),
			module: module,
			rgbPriority: config.rgbPriority,
			rgbaPriority: config.rgbaPriority
		});
	};

	if (config.glueUrl && config.wasmUrl && wasmSupported()) {
		let basisCode = null;
		let module = null;
		http.get(config.glueUrl, {
			responseType: 'blob'
		}, (err, response) => {
			if (err) {
				callback(err);
			} else {
				if (module) {
					sendResponse(response, module);
				} else {
					basisCode = response;
				}
			}
		});
		const fetchPromise = fetch(config.wasmUrl);

		const compileManual = () => {
			fetchPromise.then(result => result.arrayBuffer()).then(buffer => WebAssembly.compile(buffer)).then(module_ => {
				if (basisCode) {
					sendResponse(basisCode, module_);
				} else {
					module = module_;
				}
			}).catch(err => {
				callback(err, null);
			});
		};

		if (WebAssembly.compileStreaming) {
			WebAssembly.compileStreaming(fetchPromise).then(module_ => {
				if (basisCode) {
					sendResponse(basisCode, module_);
				} else {
					module = module_;
				}
			}).catch(err => {
				compileManual();
			});
		} else {
			compileManual();
		}
	} else {
		http.get(config.fallbackUrl, {
			responseType: 'blob'
		}, (err, response) => {
			if (err) {
				callback(err, null);
			} else {
				sendResponse(response, null);
			}
		});
	}
};

class BasisQueue {
	constructor() {
		this.callbacks = {};
		this.queue = [];
		this.clients = [];
	}

	enqueueJob(url, data, callback, options) {
		if (this.callbacks.hasOwnProperty(url)) {
			this.callbacks[url].push(callback);
		} else {
			this.callbacks[url] = [callback];
			const job = {
				url: url,
				data: data,
				options: options
			};

			if (this.clients.length > 0) {
				this.clients.shift().run(job);
			} else {
				this.queue.push(job);
			}
		}
	}

	enqueueClient(client) {
		if (this.queue.length > 0) {
			client.run(this.queue.shift());
		} else {
			this.clients.push(client);
		}
	}

	handleResponse(url, err, data) {
		const callback = this.callbacks[url];

		if (err) {
			for (let i = 0; i < callback.length; ++i) {
				callback[i](err);
			}
		} else {
			if (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {
				data.levels = data.levels.map(function (v) {
					return new Uint16Array(v);
				});
			} else {
				data.levels = data.levels.map(function (v) {
					return new Uint8Array(v);
				});
			}

			for (let i = 0; i < callback.length; ++i) {
				callback[i](null, data);
			}
		}

		delete this.callbacks[url];
	}

}

class BasisClient {
	constructor(queue, config, eager) {
		this.queue = queue;
		this.worker = new Worker(config.workerUrl);
		this.worker.addEventListener('message', message => {
			const data = message.data;
			this.queue.handleResponse(data.url, data.err, data.data);

			if (!this.eager) {
				this.queue.enqueueClient(this);
			}
		});
		this.worker.postMessage({
			type: 'init',
			config: config
		});
		this.eager = eager;
	}

	run(job) {
		const transfer = [];

		if (job.data instanceof ArrayBuffer) {
			transfer.push(job.data);
		}

		this.worker.postMessage({
			type: 'transcode',
			url: job.url,
			format: job.format,
			data: job.data,
			options: job.options
		}, transfer);

		if (this.eager) {
			this.queue.enqueueClient(this);
		}
	}

}

const defaultNumWorkers = 1;
const defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];
const defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];
const queue = new BasisQueue();
let lazyConfig = null;
let initializing = false;

function basisInitialize(config) {
	if (initializing) {
		return;
	}

	if (!config) {
		config = lazyConfig || {};
	} else if (config.lazyInit) {
		lazyConfig = config;
		return;
	}

	if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
		const modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];
		const wasmModule = modules.find(function (m) {
			return m.moduleName === 'BASIS';
		});

		if (wasmModule) {
			const urlBase = window.ASSET_PREFIX || "";

			if (!config.glueUrl) {
				config.glueUrl = urlBase + wasmModule.glueUrl;
			}

			if (!config.wasmUrl) {
				config.wasmUrl = urlBase + wasmModule.wasmUrl;
			}

			if (!config.fallbackUrl) {
				config.fallbackUrl = urlBase + wasmModule.fallbackUrl;
			}
		}
	}

	if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
		initializing = true;
		const numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
		const eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
		config.rgbPriority = config.rgbPriority || defaultRgbPriority;
		config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
		prepareWorkerModules(config, (err, clientConfig) => {
			if (err) {
				console.error(`failed to initialize basis worker: ${err}`);
			} else {
				for (let i = 0; i < numWorkers; ++i) {
					queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
				}
			}
		});
	}
}

let deviceDetails = null;

function basisTranscode(device, url, data, callback, options) {
	basisInitialize();

	if (!deviceDetails) {
		deviceDetails = {
			webgl2: device.webgl2,
			formats: getCompressionFormats(device)
		};
	}

	queue.enqueueJob(url, data, callback, {
		deviceDetails: deviceDetails,
		isGGGR: !!(options != null && options.isGGGR),
		isKTX2: !!(options != null && options.isKTX2)
	});
	return initializing;
}

class BasisParser {
	constructor(registry, device) {
		this.device = device;
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		const device = this.device;

		const transcode = data => {
			var _asset$file, _asset$file$variants, _asset$file$variants$;

			const basisModuleFound = basisTranscode(device, url.load, data, callback, {
				isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0
			});

			if (!basisModuleFound) {
				callback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);
			}
		};

		Asset.fetchArrayBuffer(url.load, (err, result) => {
			if (err) {
				callback(err);
			} else {
				transcode(result);
			}
		}, asset, this.maxRetries);
	}

	open(url, data, device) {
		const texture = new Texture(device, {
			name: url,
			addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: data.width,
			height: data.height,
			format: data.format,
			cubemap: data.cubemap,
			levels: data.levels
		});
		texture.upload();
		return texture;
	}

}

class ImgParser {
	constructor(registry) {
		this.crossOrigin = registry.prefix ? 'anonymous' : null;
		this.maxRetries = 0;
		this.useImageBitmap = false  ;
	}

	load(url, callback, asset) {
		var _asset$file;

		const hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);

		if (hasContents) {
			url = {
				load: URL.createObjectURL(new Blob([asset.file.contents])),
				original: url.original
			};
		}

		const handler = (err, result) => {
			if (hasContents) {
				URL.revokeObjectURL(url.load);
			}

			callback(err, result);
		};

		let crossOrigin;

		if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
			crossOrigin = asset.options.crossOrigin;
		} else if (ABSOLUTE_URL.test(url.load)) {
			crossOrigin = this.crossOrigin;
		}

		if (this.useImageBitmap) {
			this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
		} else {
			this._loadImage(url.load, url.original, crossOrigin, handler);
		}
	}

	open(url, data, device) {
		const ext = path.getExtension(url).toLowerCase();
		const format = ext === ".jpg" || ext === ".jpeg" ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;
		const texture = new Texture(device, {
			name: url,
			width: data.width,
			height: data.height,
			format: format
		});
		texture.setSource(data);
		return texture;
	}

	_loadImage(url, originalUrl, crossOrigin, callback) {
		const image = new Image();

		if (crossOrigin) {
			image.crossOrigin = crossOrigin;
		}

		let retries = 0;
		const maxRetries = this.maxRetries;
		let retryTimeout;

		image.onload = function () {
			callback(null, image);
		};

		image.onerror = function () {
			if (retryTimeout) return;

			if (maxRetries > 0 && ++retries <= maxRetries) {
				const retryDelay = Math.pow(2, retries) * 100;
				console.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);
				const idx = url.indexOf('?');
				const separator = idx >= 0 ? '&' : '?';
				retryTimeout = setTimeout(function () {
					image.src = url + separator + 'retry=' + Date.now();
					retryTimeout = null;
				}, retryDelay);
			} else {
				callback(`Error loading Texture from: '${originalUrl}'`);
			}
		};

		image.src = url;
	}

	_loadImageBitmap(url, originalUrl, crossOrigin, callback) {
		const options = {
			cache: true,
			responseType: "blob",
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};
		http.get(url, options, function (err, blob) {
			if (err) {
				callback(err);
			} else {
				createImageBitmap(blob, {
					premultiplyAlpha: 'none'
				}).then(function (imageBitmap) {
					callback(null, imageBitmap);
				}).catch(function (e) {
					callback(e);
				});
			}
		});
	}

}

const IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];
const KNOWN_FORMATS = {
	0x83F0: PIXELFORMAT_DXT1,
	0x83F2: PIXELFORMAT_DXT3,
	0x83F3: PIXELFORMAT_DXT5,
	0x8D64: PIXELFORMAT_ETC1,
	0x9274: PIXELFORMAT_ETC2_RGB,
	0x9278: PIXELFORMAT_ETC2_RGBA,
	0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
	0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
	0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
	0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
	0x8051: PIXELFORMAT_R8_G8_B8,
	0x8058: PIXELFORMAT_R8_G8_B8_A8,
	0x8C41: PIXELFORMAT_SRGB,
	0x8C43: PIXELFORMAT_SRGBA,
	0x8C3A: PIXELFORMAT_111110F,
	0x881B: PIXELFORMAT_RGB16F,
	0x881A: PIXELFORMAT_RGBA16F
};

function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
	return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
}

class KtxParser {
	constructor(registry) {
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	}

	open(url, data, device) {
		const textureData = this.parse(data);

		if (!textureData) {
			return null;
		}

		const texture = new Texture(device, {
			name: url,
			addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: textureData.width,
			height: textureData.height,
			format: textureData.format,
			cubemap: textureData.cubemap,
			levels: textureData.levels
		});
		texture.upload();
		return texture;
	}

	parse(data) {
		const dataU32 = new Uint32Array(data);

		if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
			return null;
		}

		const header = {
			endianness: dataU32[3],
			glType: dataU32[4],
			glTypeSize: dataU32[5],
			glFormat: dataU32[6],
			glInternalFormat: dataU32[7],
			glBaseInternalFormat: dataU32[8],
			pixelWidth: dataU32[9],
			pixelHeight: dataU32[10],
			pixelDepth: dataU32[11],
			numberOfArrayElements: dataU32[12],
			numberOfFaces: dataU32[13],
			numberOfMipmapLevels: dataU32[14],
			bytesOfKeyValueData: dataU32[15]
		};

		if (header.pixelDepth > 1) {
			return null;
		}

		if (header.numberOfArrayElements !== 0) {
			return null;
		}

		const format = KNOWN_FORMATS[header.glInternalFormat];

		if (format === undefined) {
			return null;
		}

		let offset = 16 + header.bytesOfKeyValueData / 4;
		const isCubemap = header.numberOfFaces > 1;
		const levels = [];

		for (let mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
			const imageSizeInBytes = dataU32[offset++];

			if (isCubemap) {
				levels.push([]);
			}

			const target = isCubemap ? levels[mipmapLevel] : levels;

			for (let face = 0; face < (isCubemap ? 6 : 1); ++face) {
				target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
				offset += imageSizeInBytes + 3 >> 2;
			}
		}

		return {
			format: format,
			width: header.pixelWidth,
			height: header.pixelHeight,
			levels: levels,
			cubemap: isCubemap
		};
	}

}

const KHRConstants = {
	KHR_DF_MODEL_ETC1S: 163,
	KHR_DF_MODEL_UASTC: 166
};

class Ktx2Parser {
	constructor(registry, device) {
		this.maxRetries = 0;
		this.device = device;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, (err, result) => {
			if (err) {
				callback(err, result);
			} else {
				this.parse(result, url, callback, asset);
			}
		}, asset, this.maxRetries);
	}

	open(url, data, device) {
		const texture = new Texture(device, {
			name: url,
			addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: data.width,
			height: data.height,
			format: data.format,
			cubemap: data.cubemap,
			levels: data.levels
		});
		texture.upload();
		return texture;
	}

	parse(arraybuffer, url, callback, asset) {
		const rs = new ReadStream(arraybuffer);
		const magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];

		if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
			return null;
		}

		const header = {
			vkFormat: rs.readU32(),
			typeSize: rs.readU32(),
			pixelWidth: rs.readU32(),
			pixelHeight: rs.readU32(),
			pixelDepth: rs.readU32(),
			layerCount: rs.readU32(),
			faceCount: rs.readU32(),
			levelCount: rs.readU32(),
			supercompressionScheme: rs.readU32()
		};
		const index = {
			dfdByteOffset: rs.readU32(),
			dfdByteLength: rs.readU32(),
			kvdByteOffset: rs.readU32(),
			kvdByteLength: rs.readU32(),
			sgdByteOffset: rs.readU64(),
			sgdByteLength: rs.readU64()
		};
		const levels = [];

		for (let i = 0; i < Math.max(1, header.levelCount); ++i) {
			levels.push({
				byteOffset: rs.readU64(),
				byteLength: rs.readU64(),
				uncompressedByteLength: rs.readU64()
			});
		}

		const dfdTotalSize = rs.readU32();

		if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
			return null;
		}

		rs.skip(8);
		const colorModel = rs.readU8();
		rs.skip(index.dfdByteLength - 9);
		rs.skip(index.kvdByteLength);

		if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
			var _asset$file, _asset$file$variants, _asset$file$variants$;

			const basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
				isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0,
				isKTX2: true
			});

			if (!basisModuleFound) {
				callback('Basis module not found. Asset "' + asset.name + '" basis texture variant will not be loaded.');
			}
		} else {
			callback('unsupported KTX2 pixel format');
		}
	}

}

class DdsParser {
	constructor(registry) {
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	}

	open(url, data, device) {
		const header = new Uint32Array(data, 0, 128 / 4);
		const width = header[4];
		const height = header[3];
		const mips = Math.max(header[7], 1);
		const isFourCc = header[20] === 4;
		const fcc = header[21];
		const bpp = header[22];
		const isCubemap = header[28] === 65024;
		const FCC_DXT1 = 827611204;
		const FCC_DXT5 = 894720068;
		const FCC_FP16 = 113;
		const FCC_FP32 = 116;
		const FCC_ETC1 = 826496069;
		const FCC_PVRTC_2BPP_RGB_1 = 825438800;
		const FCC_PVRTC_2BPP_RGBA_1 = 825504336;
		const FCC_PVRTC_4BPP_RGB_1 = 825439312;
		const FCC_PVRTC_4BPP_RGBA_1 = 825504848;
		let compressed = false;
		let etc1 = false;
		let pvrtc2 = false;
		let pvrtc4 = false;
		let format = null;
		let componentSize = 1;
		let texture;

		if (isFourCc) {
			if (fcc === FCC_DXT1) {
				format = PIXELFORMAT_DXT1;
				compressed = true;
			} else if (fcc === FCC_DXT5) {
				format = PIXELFORMAT_DXT5;
				compressed = true;
			} else if (fcc === FCC_FP16) {
				format = PIXELFORMAT_RGBA16F;
				componentSize = 2;
			} else if (fcc === FCC_FP32) {
				format = PIXELFORMAT_RGBA32F;
				componentSize = 4;
			} else if (fcc === FCC_ETC1) {
				format = PIXELFORMAT_ETC1;
				compressed = true;
				etc1 = true;
			} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
				format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
				compressed = true;
				pvrtc2 = true;
			} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
				format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
				compressed = true;
				pvrtc4 = true;
			}
		} else {
			if (bpp === 32) {
				format = PIXELFORMAT_R8_G8_B8_A8;
			}
		}

		if (!format) {
			texture = new Texture(device, {
				width: 4,
				height: 4,
				format: PIXELFORMAT_R8_G8_B8
			});
			texture.name = 'dds-legacy-empty';
			return texture;
		}

		texture = new Texture(device, {
			name: url,
			addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: width,
			height: height,
			format: format,
			cubemap: isCubemap,
			mipmaps: mips > 1
		});
		let offset = 128;
		const faces = isCubemap ? 6 : 1;
		let mipSize;
		const DXT_BLOCK_WIDTH = 4;
		const DXT_BLOCK_HEIGHT = 4;
		const blockSize = fcc === FCC_DXT1 ? 8 : 16;
		let numBlocksAcross, numBlocksDown, numBlocks;

		for (let face = 0; face < faces; face++) {
			let mipWidth = width;
			let mipHeight = height;

			for (let i = 0; i < mips; i++) {
				if (compressed) {
					if (etc1) {
						mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
					} else if (pvrtc2) {
						mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
					} else if (pvrtc4) {
						mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
					} else {
						numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
						numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
						numBlocks = numBlocksAcross * numBlocksDown;
						mipSize = numBlocks * blockSize;
					}
				} else {
					mipSize = mipWidth * mipHeight * 4;
				}

				const mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);

				if (!isCubemap) {
					texture._levels[i] = mipBuff;
				} else {
					if (!texture._levels[i]) texture._levels[i] = [];
					texture._levels[i][face] = mipBuff;
				}

				offset += mipSize * componentSize;
				mipWidth = Math.max(mipWidth * 0.5, 1);
				mipHeight = Math.max(mipHeight * 0.5, 1);
			}
		}

		texture.upload();
		return texture;
	}

}

class HdrParser {
	constructor(registry) {
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	}

	open(url, data, device) {
		const textureData = this.parse(data);

		if (!textureData) {
			return null;
		}

		const texture = new Texture(device, {
			name: url,
			addressU: ADDRESS_REPEAT,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			minFilter: FILTER_NEAREST_MIPMAP_NEAREST,
			magFilter: FILTER_NEAREST,
			width: textureData.width,
			height: textureData.height,
			levels: textureData.levels,
			format: PIXELFORMAT_R8_G8_B8_A8,
			type: TEXTURETYPE_RGBE,
			mipmaps: false
		});
		texture.upload();
		return texture;
	}

	parse(data) {
		const readStream = new ReadStream(data);
		const magic = readStream.readLine();

		if (!magic.startsWith('#?RADIANCE')) {
			return null;
		}

		const variables = {};

		while (true) {
			const line = readStream.readLine();

			if (line.length === 0) {
				break;
			} else {
				const parts = line.split('=');

				if (parts.length === 2) {
					variables[parts[0]] = parts[1];
				}
			}
		}

		if (!variables.hasOwnProperty('FORMAT')) {
			return null;
		}

		const resolution = readStream.readLine().split(' ');

		if (resolution.length !== 4) {
			return null;
		}

		const height = parseInt(resolution[1], 10);
		const width = parseInt(resolution[3], 10);

		const pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');

		if (!pixels) {
			return null;
		}

		return {
			width: width,
			height: height,
			levels: [pixels]
		};
	}

	_readPixels(readStream, width, height, flipY) {
		if (width < 8 || width > 0x7fff) {
			return this._readPixelsFlat(readStream, width, height);
		}

		const rgbe = [0, 0, 0, 0];
		readStream.readArray(rgbe);

		if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
			readStream.skip(-4);
			return this._readPixelsFlat(readStream, width, height);
		}

		const buffer = new ArrayBuffer(width * height * 4);
		const view = new Uint8Array(buffer);
		let scanstart = flipY ? 0 : width * 4 * (height - 1);
		let x, y, i, channel, count, value;

		for (y = 0; y < height; ++y) {
			if (y) {
				readStream.readArray(rgbe);
			}

			if ((rgbe[2] << 8) + rgbe[3] !== width) {
				return null;
			}

			for (channel = 0; channel < 4; ++channel) {
				x = 0;

				while (x < width) {
					count = readStream.readU8();

					if (count > 128) {
						count -= 128;

						if (x + count > width) {
							return null;
						}

						value = readStream.readU8();

						for (i = 0; i < count; ++i) {
							view[scanstart + channel + 4 * x++] = value;
						}
					} else {
						if (count === 0 || x + count > width) {
							return null;
						}

						for (i = 0; i < count; ++i) {
							view[scanstart + channel + 4 * x++] = readStream.readU8();
						}
					}
				}
			}

			scanstart += width * 4 * (flipY ? 1 : -1);
		}

		return view;
	}

	_readPixelsFlat(readStream, width, height) {
		return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
	}

}

const JSON_ADDRESS_MODE = {
	"repeat": ADDRESS_REPEAT,
	"clamp": ADDRESS_CLAMP_TO_EDGE,
	"mirror": ADDRESS_MIRRORED_REPEAT
};
const JSON_FILTER_MODE = {
	"nearest": FILTER_NEAREST,
	"linear": FILTER_LINEAR,
	"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
	"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
	"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
	"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
};
const JSON_TEXTURE_TYPE = {
	"default": TEXTURETYPE_DEFAULT,
	"rgbm": TEXTURETYPE_RGBM,
	"rgbe": TEXTURETYPE_RGBE,
	"swizzleGGGR": TEXTURETYPE_SWIZZLEGGGR
};

const _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
	const requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

	const isHtmlElement = function isHtmlElement(object) {
		return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
	};

	if (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
		return;
	}

	const downsample = function downsample(width, height, data) {
		const sampledWidth = Math.max(1, width >> 1);
		const sampledHeight = Math.max(1, height >> 1);
		const sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
		const xs = Math.floor(width / sampledWidth);
		const ys = Math.floor(height / sampledHeight);
		const xsys = xs * ys;

		for (let y = 0; y < sampledHeight; ++y) {
			for (let x = 0; x < sampledWidth; ++x) {
				for (let e = 0; e < 4; ++e) {
					let sum = 0;

					for (let sy = 0; sy < ys; ++sy) {
						for (let sx = 0; sx < xs; ++sx) {
							sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
						}
					}

					sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
				}
			}
		}

		return sampledData;
	};

	for (let level = texture._levels.length; level < requiredMipLevels; ++level) {
		const width = Math.max(1, texture._width >> level - 1);
		const height = Math.max(1, texture._height >> level - 1);

		if (texture._cubemap) {
			const mips = [];

			for (let face = 0; face < 6; ++face) {
				mips.push(downsample(width, height, texture._levels[level - 1][face]));
			}

			texture._levels.push(mips);
		} else {
			texture._levels.push(downsample(width, height, texture._levels[level - 1]));
		}
	}

	texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
};

class TextureHandler {
	constructor(device, assets, loader) {
		this._device = device;
		this._assets = assets;
		this._loader = loader;
		this.imgParser = new ImgParser(assets);
		this.parsers = {
			dds: new DdsParser(assets),
			ktx: new KtxParser(assets),
			ktx2: new Ktx2Parser(assets, device),
			basis: new BasisParser(assets, device),
			hdr: new HdrParser(assets)
		};
	}

	set crossOrigin(value) {
		this.imgParser.crossOrigin = value;
	}

	get crossOrigin() {
		return this.imgParser.crossOrigin;
	}

	set maxRetries(value) {
		this.imgParser.maxRetries = value;

		for (const parser in this.parsers) {
			if (this.parsers.hasOwnProperty(parser)) {
				this.parsers[parser].maxRetries = value;
			}
		}
	}

	get maxRetries() {
		return this.imgParser.maxRetries;
	}

	_getUrlWithoutParams(url) {
		return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	}

	_getParser(url) {
		const ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
		return this.parsers[ext] || this.imgParser;
	}

	load(url, callback, asset) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		this._getParser(url.original).load(url, callback, asset);
	}

	open(url, data, asset) {
		if (!url) return;

		let texture = this._getParser(url).open(url, data, this._device);

		if (texture === null) {
			texture = new Texture(this._device, {
				width: 4,
				height: 4,
				format: PIXELFORMAT_R8_G8_B8
			});
		} else {
			_completePartialMipmapChain(texture);

			if (data.unswizzledGGGR) {
				asset.file.variants.basis.opt &= ~8;
			}
		}

		return texture;
	}

	patch(asset, assets) {
		const texture = asset.resource;

		if (!texture) {
			return;
		}

		if (asset.name && asset.name.length > 0) {
			texture.name = asset.name;
		}

		const assetData = asset.data;

		if (assetData.hasOwnProperty('minfilter')) {
			texture.minFilter = JSON_FILTER_MODE[assetData.minfilter];
		}

		if (assetData.hasOwnProperty('magfilter')) {
			texture.magFilter = JSON_FILTER_MODE[assetData.magfilter];
		}

		if (!texture.cubemap) {
			if (assetData.hasOwnProperty('addressu')) {
				texture.addressU = JSON_ADDRESS_MODE[assetData.addressu];
			}

			if (assetData.hasOwnProperty('addressv')) {
				texture.addressV = JSON_ADDRESS_MODE[assetData.addressv];
			}
		}

		if (assetData.hasOwnProperty('mipmaps')) {
			texture.mipmaps = assetData.mipmaps;
		}

		if (assetData.hasOwnProperty('anisotropy')) {
			texture.anisotropy = assetData.anisotropy;
		}

		if (assetData.hasOwnProperty('flipY')) {
			texture.flipY = !!assetData.flipY;
		}

		if (assetData.hasOwnProperty('type')) {
			texture.type = JSON_TEXTURE_TYPE[assetData.type];
		} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
			texture.type = TEXTURETYPE_RGBM;
		} else if (asset.file && (asset.file.opt & 8) !== 0) {
			texture.type = TEXTURETYPE_SWIZZLEGGGR;
		}
	}

}

class TagsCache {
	constructor(key = null) {
		this._index = {};
		this._key = key;
	}

	addItem(item) {
		const tags = item.tags._list;

		for (const tag of tags) this.add(tag, item);
	}

	removeItem(item) {
		const tags = item.tags._list;

		for (const tag of tags) this.remove(tag, item);
	}

	add(tag, item) {
		if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;

		if (!this._index[tag]) {
			this._index[tag] = {
				list: []
			};
			if (this._key) this._index[tag].keys = {};
		}

		this._index[tag].list.push(item);

		if (this._key) this._index[tag].keys[item[this._key]] = item;
	}

	remove(tag, item) {
		if (!this._index[tag]) return;

		if (this._key) {
			if (!this._index[tag].keys[item[this._key]]) return;
		}

		const ind = this._index[tag].list.indexOf(item);

		if (ind === -1) return;

		this._index[tag].list.splice(ind, 1);

		if (this._key) delete this._index[tag].keys[item[this._key]];
		if (this._index[tag].list.length === 0) delete this._index[tag];
	}

	find(args) {
		const index = {};
		const items = [];
		let item, tag, tags, tagsRest, missingIndex;

		const sort = (a, b) => {
			return this._index[a].list.length - this._index[b].list.length;
		};

		for (let i = 0; i < args.length; i++) {
			tag = args[i];

			if (tag instanceof Array) {
				if (tag.length === 0) continue;

				if (tag.length === 1) {
					tag = tag[0];
				} else {
					missingIndex = false;

					for (let t = 0; t < tag.length; t++) {
						if (!this._index[tag[t]]) {
							missingIndex = true;
							break;
						}
					}

					if (missingIndex) continue;
					tags = tag.slice(0).sort(sort);
					tagsRest = tags.slice(1);
					if (tagsRest.length === 1) tagsRest = tagsRest[0];

					for (let n = 0; n < this._index[tags[0]].list.length; n++) {
						item = this._index[tags[0]].list[n];

						if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
							if (this._key) index[item[this._key]] = true;
							items.push(item);
						}
					}

					continue;
				}
			}

			if (tag && typeof tag === 'string' && this._index[tag]) {
				for (let n = 0; n < this._index[tag].list.length; n++) {
					item = this._index[tag].list[n];

					if (this._key) {
						if (!index[item[this._key]]) {
							index[item[this._key]] = true;
							items.push(item);
						}
					} else if (items.indexOf(item) === -1) {
						items.push(item);
					}
				}
			}
		}

		return items;
	}

}

class AssetRegistry extends EventHandler {
	constructor(loader) {
		super();
		this._loader = loader;
		this._assets = [];
		this._cache = {};
		this._names = {};
		this._tags = new TagsCache('_id');
		this._urls = {};
		this.prefix = null;
	}

	list(filters) {
		filters = filters || {};
		return this._assets.filter(asset => {
			let include = true;

			if (filters.preload !== undefined) {
				include = asset.preload === filters.preload;
			}

			return include;
		});
	}

	add(asset) {
		const index = this._assets.push(asset) - 1;
		let url;
		this._cache[asset.id] = index;
		if (!this._names[asset.name]) this._names[asset.name] = [];

		this._names[asset.name].push(index);

		if (asset.file) {
			url = asset.file.url;
			this._urls[url] = index;
		}

		asset.registry = this;

		this._tags.addItem(asset);

		asset.tags.on('add', this._onTagAdd, this);
		asset.tags.on('remove', this._onTagRemove, this);
		this.fire("add", asset);
		this.fire("add:" + asset.id, asset);
		if (url) this.fire("add:url:" + url, asset);
		if (asset.preload) this.load(asset);
	}

	remove(asset) {
		const idx = this._cache[asset.id];
		const url = asset.file ? asset.file.url : null;

		if (idx !== undefined) {
			this._assets.splice(idx, 1);

			delete this._cache[asset.id];
			this._names = {};
			this._urls = [];

			for (let i = 0, l = this._assets.length; i < l; i++) {
				const a = this._assets[i];
				this._cache[a.id] = i;

				if (!this._names[a.name]) {
					this._names[a.name] = [];
				}

				this._names[a.name].push(i);

				if (a.file) {
					this._urls[a.file.url] = i;
				}
			}

			this._tags.removeItem(asset);

			asset.tags.off('add', this._onTagAdd, this);
			asset.tags.off('remove', this._onTagRemove, this);
			asset.fire("remove", asset);
			this.fire("remove", asset);
			this.fire("remove:" + asset.id, asset);
			if (url) this.fire("remove:url:" + url, asset);
			return true;
		}

		return false;
	}

	get(id) {
		const idx = this._cache[id];
		return this._assets[idx];
	}

	getByUrl(url) {
		const idx = this._urls[url];
		return this._assets[idx];
	}

	load(asset) {
		if (asset.loading || asset.loaded) {
			return;
		}

		const file = asset.file;

		const _opened = resource => {
			if (resource instanceof Array) {
				asset.resources = resource;
			} else {
				asset.resource = resource;
			}

			this._loader.patch(asset, this);

			this.fire("load", asset);
			this.fire("load:" + asset.id, asset);
			if (file && file.url) this.fire("load:url:" + file.url, asset);
			asset.fire("load", asset);
		};

		const _loaded = (err, resource, extra) => {
			asset.loaded = true;
			asset.loading = false;

			if (err) {
				this.fire("error", err, asset);
				this.fire("error:" + asset.id, err, asset);
				asset.fire("error", err, asset);
			} else {
				if (!script.legacy && asset.type === 'script') {
					const handler = this._loader.getHandler('script');

					if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
						document.head.removeChild(handler._cache[asset.id]);
					}

					handler._cache[asset.id] = extra;
				}

				_opened(resource);
			}
		};

		if (file || asset.type === 'cubemap') {
			this.fire("load:start", asset);
			this.fire("load:" + asset.id + ":start", asset);
			asset.loading = true;

			this._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);
		} else {
			const resource = this._loader.open(asset.type, asset.data);

			asset.loaded = true;

			_opened(resource);
		}
	}

	loadFromUrl(url, type, callback) {
		this.loadFromUrlAndFilename(url, null, type, callback);
	}

	loadFromUrlAndFilename(url, filename, type, callback) {
		const name = path.getBasename(filename || url);
		const file = {
			filename: filename || name,
			url: url
		};
		let asset = this.getByUrl(url);

		if (!asset) {
			asset = new Asset(name, type, file);
			this.add(asset);
		} else if (asset.loaded) {
			callback(asset.loadFromUrlError || null, asset);
			return;
		}

		const startLoad = asset => {
			asset.once("load", loadedAsset => {
				if (type === 'material') {
					this._loadTextures(loadedAsset, (err, textures) => {
						callback(err, loadedAsset);
					});
				} else {
					callback(null, loadedAsset);
				}
			});
			asset.once("error", err => {
				if (err) {
					this.loadFromUrlError = err;
				}

				callback(err, asset);
			});
			this.load(asset);
		};

		if (asset.resource) {
			callback(null, asset);
		} else if (type === 'model') {
			this._loadModel(asset, startLoad);
		} else {
			startLoad(asset);
		}
	}

	_loadModel(modelAsset, continuation) {
		const url = modelAsset.getFileUrl();
		const ext = path.getExtension(url);

		if (ext === '.json' || ext === '.glb') {
			const dir = path.getDirectory(url);
			const basename = path.getBasename(url);
			const mappingUrl = path.join(dir, basename.replace(ext, ".mapping.json"));

			this._loader.load(mappingUrl, 'json', (err, data) => {
				if (err) {
					modelAsset.data = {
						mapping: []
					};
					continuation(modelAsset);
				} else {
					this._loadMaterials(modelAsset, data, (e, materials) => {
						modelAsset.data = data;
						continuation(modelAsset);
					});
				}
			});
		} else {
			continuation(modelAsset);
		}
	}

	_loadMaterials(modelAsset, mapping, callback) {
		const materials = [];
		let count = 0;

		const onMaterialLoaded = (err, materialAsset) => {
			this._loadTextures(materialAsset, (err, textures) => {
				materials.push(materialAsset);

				if (materials.length === count) {
					callback(null, materials);
				}
			});
		};

		for (let i = 0; i < mapping.mapping.length; i++) {
			const path = mapping.mapping[i].path;

			if (path) {
				count++;
				const url = modelAsset.getAbsoluteUrl(path);
				this.loadFromUrl(url, "material", onMaterialLoaded);
			}
		}

		if (count === 0) {
			callback(null, materials);
		}
	}

	_loadTextures(materialAsset, callback) {
		const textures = [];
		let count = 0;
		const data = materialAsset.data;

		if (data.mappingFormat !== 'path') {
			callback(null, textures);
			return;
		}

		const onTextureLoaded = (err, texture) => {
			if (err) console.error(err);
			textures.push(texture);

			if (textures.length === count) {
				callback(null, textures);
			}
		};

		const texParams = standardMaterialTextureParameters;

		for (let i = 0; i < texParams.length; i++) {
			const path = data[texParams[i]];

			if (path && typeof path === 'string') {
				count++;
				const url = materialAsset.getAbsoluteUrl(path);
				this.loadFromUrl(url, "texture", onTextureLoaded);
			}
		}

		if (count === 0) {
			callback(null, textures);
		}
	}

	findAll(name, type) {
		const idxs = this._names[name];

		if (idxs) {
			const assets = idxs.map(idx => {
				return this._assets[idx];
			});

			if (type) {
				return assets.filter(asset => {
					return asset.type === type;
				});
			}

			return assets;
		}

		return [];
	}

	_onTagAdd(tag, asset) {
		this._tags.add(tag, asset);
	}

	_onTagRemove(tag, asset) {
		this._tags.remove(tag, asset);
	}

	findByTag() {
		return this._tags.find(arguments);
	}

	filter(callback) {
		return this._assets.filter(asset => callback(asset));
	}

	find(name, type) {
		const asset = this.findAll(name, type);
		return asset.length > 0 ? asset[0] : null;
	}

}

class BundleRegistry {
	constructor(assets) {
		this._assets = assets;
		this._bundleAssets = {};
		this._assetsInBundles = {};
		this._urlsInBundles = {};
		this._fileRequests = {};

		this._assets.on('add', this._onAssetAdded, this);

		this._assets.on('remove', this._onAssetRemoved, this);
	}

	_onAssetAdded(asset) {
		if (asset.type === 'bundle') {
			this._bundleAssets[asset.id] = asset;

			this._registerBundleEventListeners(asset.id);

			for (let i = 0, len = asset.data.assets.length; i < len; i++) {
				this._indexAssetInBundle(asset.data.assets[i], asset);
			}
		} else {
			if (this._assetsInBundles[asset.id]) {
				this._indexAssetFileUrls(asset);
			}
		}
	}

	_registerBundleEventListeners(bundleAssetId) {
		this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);

		this._assets.on('error:' + bundleAssetId, this._onBundleError, this);
	}

	_unregisterBundleEventListeners(bundleAssetId) {
		this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);

		this._assets.off('error:' + bundleAssetId, this._onBundleError, this);
	}

	_indexAssetInBundle(assetId, bundleAsset) {
		if (!this._assetsInBundles[assetId]) {
			this._assetsInBundles[assetId] = [bundleAsset];
		} else {
			const bundles = this._assetsInBundles[assetId];
			const idx = bundles.indexOf(bundleAsset);

			if (idx === -1) {
				bundles.push(bundleAsset);
			}
		}

		const asset = this._assets.get(assetId);

		if (asset) {
			this._indexAssetFileUrls(asset);
		}
	}

	_indexAssetFileUrls(asset) {
		const urls = this._getAssetFileUrls(asset);

		if (!urls) return;

		for (let i = 0, len = urls.length; i < len; i++) {
			const url = urls[i];
			this._urlsInBundles[url] = this._assetsInBundles[asset.id];
		}
	}

	_getAssetFileUrls(asset) {
		let url = asset.getFileUrl();
		if (!url) return null;
		url = this._normalizeUrl(url);
		const urls = [url];

		if (asset.type === 'font') {
			const numFiles = asset.data.info.maps.length;

			for (let i = 1; i < numFiles; i++) {
				urls.push(url.replace('.png', i + '.png'));
			}
		}

		return urls;
	}

	_normalizeUrl(url) {
		return url && url.split('?')[0];
	}

	_onAssetRemoved(asset) {
		if (asset.type === 'bundle') {
			delete this._bundleAssets[asset.id];

			this._unregisterBundleEventListeners(asset.id);

			for (const id in this._assetsInBundles) {
				const array = this._assetsInBundles[id];
				const idx = array.indexOf(asset);

				if (idx !== -1) {
					array.splice(idx, 1);

					if (!array.length) {
						delete this._assetsInBundles[id];

						for (const url in this._urlsInBundles) {
							if (this._urlsInBundles[url] === array) {
								delete this._urlsInBundles[url];
							}
						}
					}
				}
			}

			this._onBundleError(`Bundle ${asset.id} was removed`, asset);
		} else if (this._assetsInBundles[asset.id]) {
			delete this._assetsInBundles[asset.id];

			const urls = this._getAssetFileUrls(asset);

			for (let i = 0, len = urls.length; i < len; i++) {
				delete this._urlsInBundles[urls[i]];
			}
		}
	}

	_onBundleLoaded(bundleAsset) {
		if (!bundleAsset.resource) {
			this._onBundleError(`Bundle ${bundleAsset.id} failed to load`, bundleAsset);

			return;
		}

		requestAnimationFrame(() => {
			if (!this._fileRequests) {
				return;
			}

			for (const url in this._fileRequests) {
				const bundles = this._urlsInBundles[url];
				if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;
				const decodedUrl = decodeURIComponent(url);
				let err = null;

				if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
					err = `Bundle ${bundleAsset.id} does not contain URL ${url}`;
				}

				const requests = this._fileRequests[url];

				for (let i = 0, len = requests.length; i < len; i++) {
					if (err) {
						requests[i](err);
					} else {
						requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
					}
				}

				delete this._fileRequests[url];
			}
		});
	}

	_onBundleError(err, bundleAsset) {
		for (const url in this._fileRequests) {
			const bundle = this._findLoadedOrLoadingBundleForUrl(url);

			if (!bundle) {
				const requests = this._fileRequests[url];

				for (let i = 0, len = requests.length; i < len; i++) {
					requests[i](err);
				}

				delete this._fileRequests[url];
			}
		}
	}

	_findLoadedOrLoadingBundleForUrl(url) {
		const bundles = this._urlsInBundles[url];
		if (!bundles) return null;
		const len = bundles.length;

		for (let i = 0; i < len; i++) {
			if (bundles[i].loaded && bundles[i].resource) {
				return bundles[i];
			}
		}

		for (let i = 0; i < len; i++) {
			if (bundles[i].loading) {
				return bundles[i];
			}
		}

		return null;
	}

	listBundlesForAsset(asset) {
		return this._assetsInBundles[asset.id] || null;
	}

	list() {
		const result = [];

		for (const id in this._bundleAssets) {
			result.push(this._bundleAssets[id]);
		}

		return result;
	}

	hasUrl(url) {
		return !!this._urlsInBundles[url];
	}

	canLoadUrl(url) {
		return !!this._findLoadedOrLoadingBundleForUrl(url);
	}

	loadUrl(url, callback) {
		const bundle = this._findLoadedOrLoadingBundleForUrl(url);

		if (!bundle) {
			callback(`URL ${url} not found in any bundles`);
			return;
		}

		if (bundle.loaded) {
			const decodedUrl = decodeURIComponent(url);

			if (!bundle.resource.hasBlobUrl(decodedUrl)) {
				callback(`Bundle ${bundle.id} does not contain URL ${url}`);
				return;
			}

			callback(null, bundle.resource.getBlobUrl(decodedUrl));
		} else if (this._fileRequests.hasOwnProperty(url)) {
			this._fileRequests[url].push(callback);
		} else {
			this._fileRequests[url] = [callback];
		}
	}

	destroy() {
		this._assets.off('add', this._onAssetAdded, this);

		this._assets.off('remove', this._onAssetRemoved, this);

		for (const id in this._bundleAssets) {
			this._unregisterBundleEventListeners(id);
		}

		this._assets = null;
		this._bundleAssets = null;
		this._assetsInBundles = null;
		this._urlsInBundles = null;
		this._fileRequests = null;
	}

}

const components = ['x', 'y', 'z', 'w'];
const vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];

function rawToValue(app, args, value, old) {
	switch (args.type) {
		case 'boolean':
			return !!value;

		case 'number':
			if (typeof value === 'number') {
				return value;
			} else if (typeof value === 'string') {
				const v = parseInt(value, 10);
				if (isNaN(v)) return null;
				return v;
			} else if (typeof value === 'boolean') {
				return 0 + value;
			}

			return null;

		case 'json':
			{
				const result = {};

				if (Array.isArray(args.schema)) {
					if (!value || typeof value !== 'object') {
						value = {};
					}

					for (let i = 0; i < args.schema.length; i++) {
						const field = args.schema[i];
						if (!field.name) continue;

						if (field.array) {
							result[field.name] = [];
							const arr = Array.isArray(value[field.name]) ? value[field.name] : [];

							for (let j = 0; j < arr.length; j++) {
								result[field.name].push(rawToValue(app, field, arr[j]));
							}
						} else {
							const val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
							result[field.name] = rawToValue(app, field, val);
						}
					}
				}

				return result;
			}

		case 'asset':
			if (value instanceof Asset) {
				return value;
			} else if (typeof value === 'number') {
				return app.assets.get(value) || null;
			} else if (typeof value === 'string') {
				return app.assets.get(parseInt(value, 10)) || null;
			}

			return null;

		case 'entity':
			if (value instanceof GraphNode) {
				return value;
			} else if (typeof value === 'string') {
				return app.getEntityFromIndex(value);
			}

			return null;

		case 'rgb':
		case 'rgba':
			if (value instanceof Color) {
				if (old instanceof Color) {
					old.copy(value);
					return old;
				}

				return value.clone();
			} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
				for (let i = 0; i < value.length; i++) {
					if (typeof value[i] !== 'number') return null;
				}

				if (!old) old = new Color();
				old.r = value[0];
				old.g = value[1];
				old.b = value[2];
				old.a = value.length === 3 ? 1 : value[3];
				return old;
			} else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
				if (!old) old = new Color();
				old.fromString(value);
				return old;
			}

			return null;

		case 'vec2':
		case 'vec3':
		case 'vec4':
			{
				const len = parseInt(args.type.slice(3), 10);
				const vecType = vecLookup[len];

				if (value instanceof vecType) {
					if (old instanceof vecType) {
						old.copy(value);
						return old;
					}

					return value.clone();
				} else if (value instanceof Array && value.length === len) {
					for (let i = 0; i < value.length; i++) {
						if (typeof value[i] !== 'number') return null;
					}

					if (!old) old = new vecType();

					for (let i = 0; i < len; i++) old[components[i]] = value[i];

					return old;
				}

				return null;
			}

		case 'curve':
			if (value) {
				let curve;

				if (value instanceof Curve || value instanceof CurveSet) {
					curve = value.clone();
				} else {
					const CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
					curve = new CurveType(value.keys);
					curve.type = value.type;
				}

				return curve;
			}

			break;
	}

	return value;
}

class ScriptAttributes {
	constructor(scriptType) {
		this.scriptType = scriptType;
		this.index = {};
	}

	add(name, args) {
		if (this.index[name]) {
			return;
		} else if (ScriptAttributes.reservedNames.has(name)) {
			return;
		}

		this.index[name] = args;
		Object.defineProperty(this.scriptType.prototype, name, {
			get: function () {
				return this.__attributes[name];
			},
			set: function (raw) {
				const evt = 'attr';
				const evtName = 'attr:' + name;
				const old = this.__attributes[name];
				let oldCopy = old;

				if (old && args.type !== 'json' && old.clone) {
					if (this._callbacks[evt] || this._callbacks[evtName]) {
						oldCopy = old.clone();
					}
				}

				if (args.array) {
					this.__attributes[name] = [];

					if (raw) {
						for (let i = 0, len = raw.length; i < len; i++) {
							this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
						}
					}
				} else {
					this.__attributes[name] = rawToValue(this.app, args, raw, old);
				}

				this.fire(evt, name, this.__attributes[name], oldCopy);
				this.fire(evtName, this.__attributes[name], oldCopy);
			}
		});
	}

	remove(name) {
		if (!this.index[name]) return false;
		delete this.index[name];
		delete this.scriptType.prototype[name];
		return true;
	}

	has(name) {
		return !!this.index[name];
	}

	get(name) {
		return this.index[name] || null;
	}

}

ScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

class Component extends EventHandler {
	constructor(system, entity) {
		super();
		this.system = system;
		this.entity = entity;

		if (this.system.schema && !this._accessorsBuilt) {
			this.buildAccessors(this.system.schema);
		}

		this.on("set", function (name, oldValue, newValue) {
			this.fire("set_" + name, name, oldValue, newValue);
		});
		this.on('set_enabled', this.onSetEnabled, this);
	}

	static _buildAccessors(obj, schema) {
		schema.forEach(function (descriptor) {
			const name = typeof descriptor === 'object' ? descriptor.name : descriptor;
			Object.defineProperty(obj, name, {
				get: function () {
					return this.data[name];
				},
				set: function (value) {
					const data = this.data;
					const oldValue = data[name];
					data[name] = value;
					this.fire('set', name, oldValue, value);
				},
				configurable: true
			});
		});
		obj._accessorsBuilt = true;
	}

	buildAccessors(schema) {
		Component._buildAccessors(this, schema);
	}

	onSetEnabled(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.entity.enabled) {
				if (newValue) {
					this.onEnable();
				} else {
					this.onDisable();
				}
			}
		}
	}

	onEnable() {}

	onDisable() {}

	onPostStateChange() {}

	get data() {
		const record = this.system.store[this.entity.getGuid()];
		return record ? record.data : null;
	}

}

class ScriptComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._scripts = [];
		this._updateList = new SortedLoopArray({
			sortBy: '__executionOrder'
		});
		this._postUpdateList = new SortedLoopArray({
			sortBy: '__executionOrder'
		});
		this._scriptsIndex = {};
		this._destroyedScripts = [];
		this._destroyed = false;
		this._scriptsData = null;
		this._oldState = true;
		this._enabled = true;
		this._beingEnabled = false;
		this._isLoopingThroughScripts = false;
		this._executionOrder = -1;
		this.on('set_enabled', this._onSetEnabled, this);
	}

	set enabled(value) {
		const oldValue = this._enabled;
		this._enabled = value;
		this.fire('set', 'enabled', oldValue, value);
	}

	get enabled() {
		return this._enabled;
	}

	set scripts(value) {
		this._scriptsData = value;

		for (const key in value) {
			if (!value.hasOwnProperty(key)) continue;
			const script = this._scriptsIndex[key];

			if (script) {
				if (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;

				if (typeof value[key].attributes === 'object') {
					for (const attr in value[key].attributes) {
						if (ScriptAttributes.reservedNames.has(attr)) continue;

						if (!script.__attributes.hasOwnProperty(attr)) {
							const scriptType = this.system.app.scripts.get(key);
							if (scriptType) scriptType.attributes.add(attr, {});
						}

						script[attr] = value[key].attributes[attr];
					}
				}
			} else {
				console.log(this.order);
			}
		}
	}

	get scripts() {
		return this._scripts;
	}

	onEnable() {
		this._beingEnabled = true;

		this._checkState();

		if (!this.entity._beingEnabled) {
			this.onPostStateChange();
		}

		this._beingEnabled = false;
	}

	onDisable() {
		this._checkState();
	}

	onPostStateChange() {
		const wasLooping = this._beginLooping();

		for (let i = 0, len = this.scripts.length; i < len; i++) {
			const script = this.scripts[i];

			if (script._initialized && !script._postInitialized && script.enabled) {
				script._postInitialized = true;
				if (script.postInitialize) this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
			}
		}

		this._endLooping(wasLooping);
	}

	_beginLooping() {
		const looping = this._isLoopingThroughScripts;
		this._isLoopingThroughScripts = true;
		return looping;
	}

	_endLooping(wasLoopingBefore) {
		this._isLoopingThroughScripts = wasLoopingBefore;

		if (!this._isLoopingThroughScripts) {
			this._removeDestroyedScripts();
		}
	}

	_onSetEnabled(prop, old, value) {
		this._beingEnabled = true;

		this._checkState();

		this._beingEnabled = false;
	}

	_checkState() {
		const state = this.enabled && this.entity.enabled;
		if (state === this._oldState) return;
		this._oldState = state;
		this.fire(state ? 'enable' : 'disable');
		this.fire('state', state);

		if (state) {
			this.system._addComponentToEnabled(this);
		} else {
			this.system._removeComponentFromEnabled(this);
		}

		const wasLooping = this._beginLooping();

		for (let i = 0, len = this.scripts.length; i < len; i++) {
			const script = this.scripts[i];
			script.enabled = script._enabled;
		}

		this._endLooping(wasLooping);
	}

	_onBeforeRemove() {
		this.fire('remove');

		const wasLooping = this._beginLooping();

		for (let i = 0; i < this.scripts.length; i++) {
			const script = this.scripts[i];
			if (!script) continue;
			this.destroy(script.__scriptType.__name);
		}

		this._endLooping(wasLooping);
	}

	_removeDestroyedScripts() {
		const len = this._destroyedScripts.length;
		if (!len) return;

		for (let i = 0; i < len; i++) {
			const script = this._destroyedScripts[i];

			this._removeScriptInstance(script);
		}

		this._destroyedScripts.length = 0;

		this._resetExecutionOrder(0, this._scripts.length);
	}

	_onInitializeAttributes() {
		for (let i = 0, len = this.scripts.length; i < len; i++) this.scripts[i].__initializeAttributes();
	}

	_scriptMethod(script, method, arg) {
		script[method](arg);
	}

	_onInitialize() {
		const scripts = this._scripts;

		const wasLooping = this._beginLooping();

		for (let i = 0, len = scripts.length; i < len; i++) {
			const script = scripts[i];

			if (!script._initialized && script.enabled) {
				script._initialized = true;
				if (script.initialize) this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
			}
		}

		this._endLooping(wasLooping);
	}

	_onPostInitialize() {
		this.onPostStateChange();
	}

	_onUpdate(dt) {
		const list = this._updateList;
		if (!list.length) return;

		const wasLooping = this._beginLooping();

		for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
			const script = list.items[list.loopIndex];

			if (script.enabled) {
				this._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
			}
		}

		this._endLooping(wasLooping);
	}

	_onPostUpdate(dt) {
		const list = this._postUpdateList;
		if (!list.length) return;

		const wasLooping = this._beginLooping();

		for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
			const script = list.items[list.loopIndex];

			if (script.enabled) {
				this._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
			}
		}

		this._endLooping(wasLooping);
	}

	_insertScriptInstance(scriptInstance, index, scriptsLength) {
		if (index === -1) {
			this._scripts.push(scriptInstance);

			scriptInstance.__executionOrder = scriptsLength;

			if (scriptInstance.update) {
				this._updateList.append(scriptInstance);
			}

			if (scriptInstance.postUpdate) {
				this._postUpdateList.append(scriptInstance);
			}
		} else {
			this._scripts.splice(index, 0, scriptInstance);

			scriptInstance.__executionOrder = index;

			this._resetExecutionOrder(index + 1, scriptsLength + 1);

			if (scriptInstance.update) {
				this._updateList.insert(scriptInstance);
			}

			if (scriptInstance.postUpdate) {
				this._postUpdateList.insert(scriptInstance);
			}
		}
	}

	_removeScriptInstance(scriptInstance) {
		const idx = this._scripts.indexOf(scriptInstance);

		if (idx === -1) return idx;

		this._scripts.splice(idx, 1);

		if (scriptInstance.update) {
			this._updateList.remove(scriptInstance);
		}

		if (scriptInstance.postUpdate) {
			this._postUpdateList.remove(scriptInstance);
		}

		return idx;
	}

	_resetExecutionOrder(startIndex, scriptsLength) {
		for (let i = startIndex; i < scriptsLength; i++) {
			this._scripts[i].__executionOrder = i;
		}
	}

	_resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
		if (attribute.array) {
			const len = oldValue.length;

			if (!len) {
				return;
			}

			const newGuidArray = oldValue.slice();

			for (let i = 0; i < len; i++) {
				const guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];

				if (duplicatedIdsMap[guid]) {
					newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
				}
			}

			newAttributes[attributeName] = newGuidArray;
		} else {
			if (oldValue instanceof Entity) {
				oldValue = oldValue.getGuid();
			} else if (typeof oldValue !== 'string') {
				return;
			}

			if (duplicatedIdsMap[oldValue]) {
				newAttributes[attributeName] = duplicatedIdsMap[oldValue];
			}
		}
	}

	has(nameOrType) {
		if (typeof nameOrType === 'string') {
			return !!this._scriptsIndex[nameOrType];
		}

		if (!nameOrType) return false;
		const scriptType = nameOrType;
		const scriptName = scriptType.__name;
		const scriptData = this._scriptsIndex[scriptName];
		const scriptInstance = scriptData && scriptData.instance;
		return scriptInstance instanceof scriptType;
	}

	get(nameOrType) {
		if (typeof nameOrType === 'string') {
			const data = this._scriptsIndex[nameOrType];
			return data ? data.instance : null;
		}

		if (!nameOrType) return null;
		const scriptType = nameOrType;
		const scriptName = scriptType.__name;
		const scriptData = this._scriptsIndex[scriptName];
		const scriptInstance = scriptData && scriptData.instance;
		return scriptInstance instanceof scriptType ? scriptInstance : null;
	}

	create(nameOrType, args = {}) {
		const self = this;
		let scriptType = nameOrType;
		let scriptName = nameOrType;

		if (typeof scriptType === 'string') {
			scriptType = this.system.app.scripts.get(scriptType);
		} else if (scriptType) {
			scriptName = scriptType.__name;
		}

		if (scriptType) {
			if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
				const scriptInstance = new scriptType({
					app: this.system.app,
					entity: this.entity,
					enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
					attributes: args.attributes
				});
				const len = this._scripts.length;
				let ind = -1;
				if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;

				this._insertScriptInstance(scriptInstance, ind, len);

				this._scriptsIndex[scriptName] = {
					instance: scriptInstance,
					onSwap: function () {
						self.swap(scriptName);
					}
				};
				this[scriptName] = scriptInstance;
				if (!args.preloading) scriptInstance.__initializeAttributes();
				this.fire('create', scriptName, scriptInstance);
				this.fire('create:' + scriptName, scriptInstance);
				this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);

				if (!args.preloading) {
					if (scriptInstance.enabled && !scriptInstance._initialized) {
						scriptInstance._initialized = true;
						if (scriptInstance.initialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
					}

					if (scriptInstance.enabled && !scriptInstance._postInitialized) {
						scriptInstance._postInitialized = true;
						if (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
					}
				}

				return scriptInstance;
			}

			console.warn(`script '${scriptName}' is already added to entity '${this.entity.name}'`);
		} else {
			this._scriptsIndex[scriptName] = {
				awaiting: true,
				ind: this._scripts.length
			};
			console.warn(`script '${scriptName}' is not found, awaiting it to be added to registry`);
		}

		return null;
	}

	destroy(nameOrType) {
		let scriptName = nameOrType;
		let scriptType = nameOrType;

		if (typeof scriptType === 'string') {
			scriptType = this.system.app.scripts.get(scriptType);
		} else if (scriptType) {
			scriptName = scriptType.__name;
		}

		const scriptData = this._scriptsIndex[scriptName];
		delete this._scriptsIndex[scriptName];
		if (!scriptData) return false;
		const scriptInstance = scriptData.instance;

		if (scriptInstance && !scriptInstance._destroyed) {
			scriptInstance.enabled = false;
			scriptInstance._destroyed = true;

			if (!this._isLoopingThroughScripts) {
				const ind = this._removeScriptInstance(scriptInstance);

				if (ind >= 0) {
					this._resetExecutionOrder(ind, this._scripts.length);
				}
			} else {
				this._destroyedScripts.push(scriptInstance);
			}
		}

		this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);
		delete this[scriptName];
		this.fire('destroy', scriptName, scriptInstance || null);
		this.fire('destroy:' + scriptName, scriptInstance || null);
		if (scriptInstance) scriptInstance.fire('destroy');
		return true;
	}

	swap(nameOrType) {
		let scriptName = nameOrType;
		let scriptType = nameOrType;

		if (typeof scriptType === 'string') {
			scriptType = this.system.app.scripts.get(scriptType);
		} else if (scriptType) {
			scriptName = scriptType.__name;
		}

		const old = this._scriptsIndex[scriptName];
		if (!old || !old.instance) return false;
		const scriptInstanceOld = old.instance;

		const ind = this._scripts.indexOf(scriptInstanceOld);

		const scriptInstance = new scriptType({
			app: this.system.app,
			entity: this.entity,
			enabled: scriptInstanceOld.enabled,
			attributes: scriptInstanceOld.__attributes
		});
		if (!scriptInstance.swap) return false;

		scriptInstance.__initializeAttributes();

		this._scripts[ind] = scriptInstance;
		this._scriptsIndex[scriptName].instance = scriptInstance;
		this[scriptName] = scriptInstance;
		scriptInstance.__executionOrder = ind;

		if (scriptInstanceOld.update) {
			this._updateList.remove(scriptInstanceOld);
		}

		if (scriptInstanceOld.postUpdate) {
			this._postUpdateList.remove(scriptInstanceOld);
		}

		if (scriptInstance.update) {
			this._updateList.insert(scriptInstance);
		}

		if (scriptInstance.postUpdate) {
			this._postUpdateList.insert(scriptInstance);
		}

		this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);

		this.fire('swap', scriptName, scriptInstance);
		this.fire('swap:' + scriptName, scriptInstance);
		return true;
	}

	resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
		const newScriptComponent = this.entity.script;

		for (const scriptName in oldScriptComponent._scriptsIndex) {
			const scriptType = this.system.app.scripts.get(scriptName);

			if (!scriptType) {
				continue;
			}

			const script = oldScriptComponent._scriptsIndex[scriptName];

			if (!script || !script.instance) {
				continue;
			}

			const newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
			const newAttributes = newScriptComponent[scriptName].__attributes;

			if (!newAttributesRaw && !newAttributes) {
				continue;
			}

			const useGuid = !!newAttributesRaw;
			const oldAttributes = script.instance.__attributes;

			for (const attributeName in oldAttributes) {
				if (!oldAttributes[attributeName]) {
					continue;
				}

				const attribute = scriptType.attributes.get(attributeName);

				if (!attribute) {
					continue;
				}

				if (attribute.type === 'entity') {
					this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
				} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
					const oldValue = oldAttributes[attributeName];
					const newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];

					for (let i = 0; i < attribute.schema.length; i++) {
						const field = attribute.schema[i];

						if (field.type !== 'entity') {
							continue;
						}

						if (attribute.array) {
							for (let j = 0; j < oldValue.length; j++) {
								this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
							}
						} else {
							this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
						}
					}
				}
			}
		}
	}

	move(nameOrType, ind) {
		const len = this._scripts.length;
		if (ind >= len || ind < 0) return false;
		let scriptType = nameOrType;
		let scriptName = nameOrType;

		if (typeof scriptName !== 'string') {
			scriptName = nameOrType.__name;
		} else {
			scriptType = null;
		}

		const scriptData = this._scriptsIndex[scriptName];
		if (!scriptData || !scriptData.instance) return false;
		const scriptInstance = scriptData.instance;
		if (scriptType && !(scriptInstance instanceof scriptType)) return false;

		const indOld = this._scripts.indexOf(scriptInstance);

		if (indOld === -1 || indOld === ind) return false;

		this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);

		this._resetExecutionOrder(0, len);

		this._updateList.sort();

		this._postUpdateList.sort();

		this.fire('move', scriptName, scriptInstance, ind, indOld);
		this.fire('move:' + scriptName, scriptInstance, ind, indOld);
		return true;
	}

}

ScriptComponent.scriptMethods = {
	initialize: 'initialize',
	postInitialize: 'postInitialize',
	update: 'update',
	postUpdate: 'postUpdate',
	swap: 'swap'
};

const funcNameRegex = new RegExp('^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*');

class ScriptType extends EventHandler {
	constructor(args) {
		super();
		this.initialize = void 0;
		this.postInitialize = void 0;
		this.update = void 0;
		this.postUpdate = void 0;
		this.swap = void 0;
		this.initScriptType(args);
	}

	set enabled(value) {
		this._enabled = !!value;
		if (this.enabled === this._enabledOld) return;
		this._enabledOld = this.enabled;
		this.fire(this.enabled ? 'enable' : 'disable');
		this.fire('state', this.enabled);

		if (!this._initialized && this.enabled) {
			this._initialized = true;

			this.__initializeAttributes(true);

			if (this.initialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);
		}

		if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
			this._postInitialized = true;
			if (this.postInitialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);
		}
	}

	get enabled() {
		return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
	}

	initScriptType(args) {
		const script = this.constructor;
		this.app = args.app;
		this.entity = args.entity;
		this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
		this._enabledOld = this.enabled;
		this.__destroyed = false;
		this.__attributes = {};
		this.__attributesRaw = args.attributes || {};
		this.__scriptType = script;
		this.__executionOrder = -1;
	}

	static __getScriptName(constructorFn) {
		if (typeof constructorFn !== 'function') return undefined;
		if ('name' in Function.prototype) return constructorFn.name;
		if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
		const match = ("" + constructorFn).match(funcNameRegex);
		return match ? match[1] : undefined;
	}

	static get scriptName() {
		return this.__name;
	}

	static get attributes() {
		if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
		return this.__attributes;
	}

	__initializeAttributes(force) {
		if (!force && !this.__attributesRaw) return;

		for (const key in this.__scriptType.attributes.index) {
			if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
				this[key] = this.__attributesRaw[key];
			} else if (!this.__attributes.hasOwnProperty(key)) {
				if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
					this[key] = this.__scriptType.attributes.index[key].default;
				} else {
					this[key] = null;
				}
			}
		}

		this.__attributesRaw = null;
	}

	static extend(methods) {
		for (const key in methods) {
			if (!methods.hasOwnProperty(key)) continue;
			this.prototype[key] = methods[key];
		}
	}

}

ScriptType.__name = null;

class ScriptRegistry extends EventHandler {
	constructor(app) {
		super();
		this.app = app;
		this._scripts = {};
		this._list = [];
	}

	destroy() {
		this.app = null;
		this.off();
	}

	add(script) {
		const scriptName = script.__name;

		if (this._scripts.hasOwnProperty(scriptName)) {
			setTimeout(() => {
				if (script.prototype.swap) {
					const old = this._scripts[scriptName];

					const ind = this._list.indexOf(old);

					this._list[ind] = script;
					this._scripts[scriptName] = script;
					this.fire('swap', scriptName, script);
					this.fire('swap:' + scriptName, script);
				} else {
					console.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);
				}
			});
			return false;
		}

		this._scripts[scriptName] = script;

		this._list.push(script);

		this.fire('add', scriptName, script);
		this.fire('add:' + scriptName, script);
		setTimeout(() => {
			if (!this._scripts.hasOwnProperty(scriptName)) return;

			if (!this.app || !this.app.systems || !this.app.systems.script) {
				return;
			}

			const components = this.app.systems.script._components;
			let attributes;
			const scriptInstances = [];
			const scriptInstancesInitialized = [];

			for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
				const component = components.items[components.loopIndex];

				if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
					if (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;
					const scriptInstance = component.create(scriptName, {
						preloading: true,
						ind: component._scriptsIndex[scriptName].ind,
						attributes: attributes
					});
					if (scriptInstance) scriptInstances.push(scriptInstance);
				}
			}

			for (let i = 0; i < scriptInstances.length; i++) scriptInstances[i].__initializeAttributes();

			for (let i = 0; i < scriptInstances.length; i++) {
				if (scriptInstances[i].enabled) {
					scriptInstances[i]._initialized = true;
					scriptInstancesInitialized.push(scriptInstances[i]);
					if (scriptInstances[i].initialize) scriptInstances[i].initialize();
				}
			}

			for (let i = 0; i < scriptInstancesInitialized.length; i++) {
				if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {
					continue;
				}

				scriptInstancesInitialized[i]._postInitialized = true;
				if (scriptInstancesInitialized[i].postInitialize) scriptInstancesInitialized[i].postInitialize();
			}
		});
		return true;
	}

	remove(nameOrType) {
		let scriptType = nameOrType;
		let scriptName = nameOrType;

		if (typeof scriptName !== 'string') {
			scriptName = scriptType.__name;
		} else {
			scriptType = this.get(scriptName);
		}

		if (this.get(scriptName) !== scriptType) return false;
		delete this._scripts[scriptName];

		const ind = this._list.indexOf(scriptType);

		this._list.splice(ind, 1);

		this.fire('remove', scriptName, scriptType);
		this.fire('remove:' + scriptName, scriptType);
		return true;
	}

	get(name) {
		return this._scripts[name] || null;
	}

	has(nameOrType) {
		if (typeof nameOrType === 'string') {
			return this._scripts.hasOwnProperty(nameOrType);
		}

		if (!nameOrType) return false;
		const scriptName = nameOrType.__name;
		return this._scripts[scriptName] === nameOrType;
	}

	list() {
		return this._list;
	}

}

class I18nParser {
	_validate(data) {
		if (!data.header) {
			throw new Error('pc.I18n#addData: Missing "header" field');
		}

		if (!data.header.version) {
			throw new Error('pc.I18n#addData: Missing "header.version" field');
		}

		if (data.header.version !== 1) {
			throw new Error('pc.I18n#addData: Invalid "header.version" field');
		}

		if (!data.data) {
			throw new Error('pc.I18n#addData: Missing "data" field');
		} else if (!Array.isArray(data.data)) {
			throw new Error('pc.I18n#addData: "data" field must be an array');
		}

		for (let i = 0, len = data.data.length; i < len; i++) {
			const entry = data.data[i];

			if (!entry.info) {
				throw new Error(`pc.I18n#addData: missing "data[${i}].info" field`);
			}

			if (!entry.info.locale) {
				throw new Error(`pc.I18n#addData: missing "data[${i}].info.locale" field`);
			}

			if (typeof entry.info.locale !== 'string') {
				throw new Error(`pc.I18n#addData: "data[${i}].info.locale" must be a string`);
			}

			if (!entry.messages) {
				throw new Error(`pc.I18n#addData: missing "data[${i}].messages" field`);
			}
		}
	}

	parse(data) {
		return data.data;
	}

}

class I18n extends EventHandler {
	constructor(app) {
		super();
		this.locale = DEFAULT_LOCALE;
		this._translations = {};
		this._availableLangs = {};
		this._app = app;
		this._assets = [];
		this._parser = new I18nParser();
	}

	set assets(value) {
		const index = {};

		for (let _i = 0, len = value.length; _i < len; _i++) {
			const id = value[_i] instanceof Asset ? value[_i].id : value[_i];
			index[id] = true;
		}

		let i = this._assets.length;

		while (i--) {
			const id = this._assets[i];

			if (!index[id]) {
				this._app.assets.off('add:' + id, this._onAssetAdd, this);

				const asset = this._app.assets.get(id);

				if (asset) {
					this._onAssetRemove(asset);
				}

				this._assets.splice(i, 1);
			}
		}

		for (const id in index) {
			const idNum = parseInt(id, 10);
			if (this._assets.indexOf(idNum) !== -1) continue;

			this._assets.push(idNum);

			const asset = this._app.assets.get(idNum);

			if (!asset) {
				this._app.assets.once('add:' + idNum, this._onAssetAdd, this);
			} else {
				this._onAssetAdd(asset);
			}
		}
	}

	get assets() {
		return this._assets;
	}

	set locale(value) {
		if (this._locale === value) {
			return;
		}

		let lang = getLang(value);

		if (lang === 'in') {
			lang = 'id';
			value = replaceLang(value, lang);

			if (this._locale === value) {
				return;
			}
		}

		const old = this._locale;
		this._locale = value;
		this._lang = lang;
		this._pluralFn = getPluralFn(this._lang);
		this.fire('set:locale', value, old);
	}

	get locale() {
		return this._locale;
	}

	static findAvailableLocale(desiredLocale, availableLocales) {
		return findAvailableLocale(desiredLocale, availableLocales);
	}

	findAvailableLocale(desiredLocale) {
		if (this._translations[desiredLocale]) {
			return desiredLocale;
		}

		const lang = getLang(desiredLocale);
		return this._findFallbackLocale(desiredLocale, lang);
	}

	getText(key, locale) {
		let result = key;
		let lang;

		if (!locale) {
			locale = this._locale;
			lang = this._lang;
		}

		let translations = this._translations[locale];

		if (!translations) {
			if (!lang) {
				lang = getLang(locale);
			}

			locale = this._findFallbackLocale(locale, lang);
			translations = this._translations[locale];
		}

		if (translations && translations.hasOwnProperty(key)) {
			result = translations[key];

			if (Array.isArray(result)) {
				result = result[0];
			}

			if (result === null || result === undefined) {
				result = key;
			}
		}

		return result;
	}

	getPluralText(key, n, locale) {
		let result = key;
		let lang;
		let pluralFn;

		if (!locale) {
			locale = this._locale;
			lang = this._lang;
			pluralFn = this._pluralFn;
		} else {
			lang = getLang(locale);
			pluralFn = getPluralFn(lang);
		}

		let translations = this._translations[locale];

		if (!translations) {
			locale = this._findFallbackLocale(locale, lang);
			lang = getLang(locale);
			pluralFn = getPluralFn(lang);
			translations = this._translations[locale];
		}

		if (translations && translations[key] && pluralFn) {
			const index = pluralFn(n);
			result = translations[key][index];

			if (result === null || result === undefined) {
				result = key;
			}
		}

		return result;
	}

	addData(data) {
		let parsed;

		try {
			parsed = this._parser.parse(data);
		} catch (err) {
			console.error(err);
			return;
		}

		for (let i = 0, len = parsed.length; i < len; i++) {
			const entry = parsed[i];
			const locale = entry.info.locale;
			const messages = entry.messages;

			if (!this._translations[locale]) {
				this._translations[locale] = {};
				const lang = getLang(locale);

				if (!this._availableLangs[lang]) {
					this._availableLangs[lang] = locale;
				}
			}

			Object.assign(this._translations[locale], messages);
			this.fire('data:add', locale, messages);
		}
	}

	removeData(data) {
		let parsed;

		try {
			parsed = this._parser.parse(data);
		} catch (err) {
			console.error(err);
			return;
		}

		for (let i = 0, len = parsed.length; i < len; i++) {
			const entry = parsed[i];
			const locale = entry.info.locale;
			const translations = this._translations[locale];
			if (!translations) continue;
			const messages = entry.messages;

			for (const key in messages) {
				delete translations[key];
			}

			if (Object.keys(translations).length === 0) {
				delete this._translations[locale];
				delete this._availableLangs[getLang(locale)];
			}

			this.fire('data:remove', locale, messages);
		}
	}

	destroy() {
		this._translations = null;
		this._availableLangs = null;
		this._assets = null;
		this._parser = null;
		this.off();
	}

	_findFallbackLocale(locale, lang) {
		let result = DEFAULT_LOCALE_FALLBACKS[locale];

		if (result && this._translations[result]) {
			return result;
		}

		result = DEFAULT_LOCALE_FALLBACKS[lang];

		if (result && this._translations[result]) {
			return result;
		}

		result = this._availableLangs[lang];

		if (result && this._translations[result]) {
			return result;
		}

		return DEFAULT_LOCALE;
	}

	_onAssetAdd(asset) {
		asset.on('load', this._onAssetLoad, this);
		asset.on('change', this._onAssetChange, this);
		asset.on('remove', this._onAssetRemove, this);
		asset.on('unload', this._onAssetUnload, this);

		if (asset.resource) {
			this._onAssetLoad(asset);
		}
	}

	_onAssetLoad(asset) {
		this.addData(asset.resource);
	}

	_onAssetChange(asset) {
		if (asset.resource) {
			this.addData(asset.resource);
		}
	}

	_onAssetRemove(asset) {
		asset.off('load', this._onAssetLoad, this);
		asset.off('change', this._onAssetChange, this);
		asset.off('remove', this._onAssetRemove, this);
		asset.off('unload', this._onAssetUnload, this);

		if (asset.resource) {
			this.removeData(asset.resource);
		}

		this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);
	}

	_onAssetUnload(asset) {
		if (asset.resource) {
			this.removeData(asset.resource);
		}
	}

}

const FILLMODE_NONE = 'NONE';
const FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
const FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
const RESOLUTION_AUTO = 'AUTO';
const RESOLUTION_FIXED = 'FIXED';

class VrDisplay extends EventHandler {
	constructor(app, display) {
		super();
		this._app = app;
		this._device = app.graphicsDevice;
		this.id = display.displayId;
		this._frameData = null;

		if (window.VRFrameData) {
			this._frameData = new window.VRFrameData();
		}

		this.display = display;
		this._camera = null;
		this.sitToStandInv = new Mat4();
		this.leftView = new Mat4();
		this.leftProj = new Mat4();
		this.leftViewInv = new Mat4();
		this.leftPos = new Vec3();
		this.rightView = new Mat4();
		this.rightProj = new Mat4();
		this.rightViewInv = new Mat4();
		this.rightPos = new Vec3();
		this.combinedPos = new Vec3();
		this.combinedView = new Mat4();
		this.combinedProj = new Mat4();
		this.combinedViewInv = new Mat4();
		this.combinedFov = 0;
		this.combinedAspect = 0;
		this.presenting = false;

		this._presentChange = event => {
			let display;

			if (event.display) {
				display = event.display;
			} else if (event.detail && event.detail.display) {
				display = event.detail.display;
			} else if (event.detail && event.detail.vrdisplay) {
				display = event.detail.vrdisplay;
			} else {
				display = this.display;
			}

			if (display === this.display) {
				this.presenting = this.display && this.display.isPresenting;

				if (this.presenting) {
					const leftEye = this.display.getEyeParameters("left");
					const rightEye = this.display.getEyeParameters("right");
					const w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;
					const h = Math.max(leftEye.renderHeight, rightEye.renderHeight);

					this._app.graphicsDevice.setResolution(w, h);

					this._app._allowResize = false;
				} else {
					this._app.setCanvasResolution(RESOLUTION_AUTO);

					this._app._allowResize = true;
				}

				this.fire('beforepresentchange', this);
				this.fire('presentchange', this);
			}
		};

		window.addEventListener('vrdisplaypresentchange', this._presentChange, false);
	}

	destroy() {
		window.removeEventListener('vrdisplaypresentchange', this._presentChange);
		if (this._camera) this._camera.vrDisplay = null;
		this._camera = null;
	}

	poll() {
		if (this.display) {
			this.display.getFrameData(this._frameData);
			this.leftProj.data = this._frameData.leftProjectionMatrix;
			this.rightProj.data = this._frameData.rightProjectionMatrix;
			const stage = this.display.stageParameters;

			if (stage) {
				this.sitToStandInv.set(stage.sittingToStandingTransform).invert();
				this.combinedView.set(this._frameData.leftViewMatrix);
				this.leftView.mul2(this.combinedView, this.sitToStandInv);
				this.combinedView.set(this._frameData.rightViewMatrix);
				this.rightView.mul2(this.combinedView, this.sitToStandInv);
			} else {
				this.leftView.set(this._frameData.leftViewMatrix);
				this.rightView.set(this._frameData.rightViewMatrix);
			}

			let nx = this.leftProj.data[3] + this.leftProj.data[0];
			let nz = this.leftProj.data[11] + this.leftProj.data[8];
			let l = 1.0 / Math.sqrt(nx * nx + nz * nz);
			nx *= l;
			nz *= l;
			let maxFov = -Math.atan2(nz, nx);
			nx = this.rightProj.data[3] + this.rightProj.data[0];
			nz = this.rightProj.data[11] + this.rightProj.data[8];
			l = 1.0 / Math.sqrt(nx * nx + nz * nz);
			nx *= l;
			nz *= l;
			maxFov = Math.max(maxFov, -Math.atan2(nz, nx));
			maxFov *= 2.0;
			this.combinedFov = maxFov;
			const aspect = this.rightProj.data[5] / this.rightProj.data[0];
			this.combinedAspect = aspect;
			const view = this.combinedView;
			view.copy(this.leftView);
			view.invert();
			this.leftViewInv.copy(view);
			const pos = this.combinedPos;
			pos.x = this.leftPos.x = view.data[12];
			pos.y = this.leftPos.y = view.data[13];
			pos.z = this.leftPos.z = view.data[14];
			view.copy(this.rightView);
			view.invert();
			this.rightViewInv.copy(view);
			const deltaX = pos.x - view.data[12];
			const deltaY = pos.y - view.data[13];
			const deltaZ = pos.z - view.data[14];
			const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
			this.rightPos.x = view.data[12];
			this.rightPos.y = view.data[13];
			this.rightPos.z = view.data[14];
			pos.x += view.data[12];
			pos.y += view.data[13];
			pos.z += view.data[14];
			pos.x *= 0.5;
			pos.y *= 0.5;
			pos.z *= 0.5;
			const b = Math.PI * 0.5;
			const c = maxFov * 0.5;
			const a = Math.PI - (b + c);
			const offset = dist * 0.5 * Math.sin(a);
			const fwdX = view.data[8];
			const fwdY = view.data[9];
			const fwdZ = view.data[10];
			view.data[12] = pos.x + fwdX * offset;
			view.data[13] = pos.y + fwdY * offset;
			view.data[14] = pos.z + fwdZ * offset;
			this.combinedViewInv.copy(view);
			view.invert();
			this.combinedProj.setPerspective(maxFov * math.RAD_TO_DEG, aspect, this.display.depthNear + offset, this.display.depthFar + offset, true);
		}
	}

	requestPresent(callback) {
		if (!this.display) {
			if (callback) callback(new Error("No VrDisplay to requestPresent"));
			return;
		}

		if (this.presenting) {
			if (callback) callback(new Error("VrDisplay already presenting"));
			return;
		}

		this.display.requestPresent([{
			source: this._device.canvas
		}]).then(function () {
			if (callback) callback();
		}, function (err) {
			if (callback) callback(err);
		});
	}

	exitPresent(callback) {
		if (!this.display) {
			if (callback) callback(new Error("No VrDisplay to exitPresent"));
		}

		if (!this.presenting) {
			if (callback) callback(new Error("VrDisplay not presenting"));
			return;
		}

		this.display.exitPresent().then(function () {
			if (callback) callback();
		}, function () {
			if (callback) callback(new Error("exitPresent failed"));
		});
	}

	requestAnimationFrame(fn) {
		if (this.display) this.display.requestAnimationFrame(fn);
	}

	submitFrame() {
		if (this.display) this.display.submitFrame();
	}

	reset() {
		if (this.display) this.display.resetPose();
	}

	setClipPlanes(n, f) {
		if (this.display) {
			this.display.depthNear = n;
			this.display.depthFar = f;
		}
	}

	getFrameData() {
		if (this.display) return this._frameData;
	}

	get capabilities() {
		if (this.display) return this.display.capabilities;
		return {};
	}

}

class VrManager extends EventHandler {
	constructor(app) {
		super();
		this.isSupported = VrManager.isSupported;
		this._index = {};
		this.displays = [];
		this.display = null;
		this._app = app;
		this._onDisplayConnect = this._onDisplayConnect.bind(this);
		this._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);

		this._attach();

		this._getDisplays((err, displays) => {
			if (err) {
				this.fire('error', err);
			} else {
				for (let i = 0; i < displays.length; i++) {
					this._addDisplay(displays[i]);
				}

				this.fire('ready', this.displays);
			}
		});
	}

	_attach() {
		window.addEventListener('vrdisplayconnect', this._onDisplayConnect);
		window.addEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
	}

	_detach() {
		window.removeEventListener('vrdisplayconnect', this._onDisplayConnect);
		window.removeEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
	}

	destroy() {
		this._detach();
	}

	poll() {
		const l = this.displays.length;
		if (!l) return;

		for (let i = 0; i < l; i++) {
			if (this.displays[i]._camera) this.displays[i].poll();
		}
	}

	_getDisplays(callback) {
		if (navigator.getVRDisplays) {
			navigator.getVRDisplays().then(function (displays) {
				if (callback) callback(null, displays);
			});
		} else {
			if (callback) callback(new Error('WebVR not supported'));
		}
	}

	_addDisplay(vrDisplay) {
		if (this._index[vrDisplay.displayId]) return;
		const display = new VrDisplay(this._app, vrDisplay);
		this._index[display.id] = display;
		this.displays.push(display);
		if (!this.display) this.display = display;
		this.fire('displayconnect', display);
	}

	_onDisplayConnect(e) {
		if (e.detail && e.detail.display) {
			this._addDisplay(e.detail.display);
		} else {
			this._addDisplay(e.display);
		}
	}

	_onDisplayDisconnect(e) {
		let id;

		if (e.detail && e.detail.display) {
			id = e.detail.display.displayId;
		} else {
			id = e.display.displayId;
		}

		const display = this._index[id];
		if (!display) return;
		display.destroy();
		delete this._index[display.id];
		const ind = this.displays.indexOf(display);
		this.displays.splice(ind, 1);

		if (this.display === display) {
			if (this.displays.length) {
				this.display = this.displays[0];
			} else {
				this.display = null;
			}
		}

		this.fire('displaydisconnect', display);
	}

}

VrManager.isSupported = typeof navigator !== 'undefined' ? !!navigator.getVRDisplays : false;

const XRTYPE_INLINE = 'inline';
const XRTYPE_VR = 'immersive-vr';
const XRTYPE_AR = 'immersive-ar';
const XRSPACE_VIEWER = 'viewer';
const XRHAND_LEFT = 'left';
const XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
const XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
const XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';

const poolVec3 = [];
const poolQuat = [];

class XrHitTestSource extends EventHandler {
	constructor(manager, xrHitTestSource, transient) {
		super();
		this.manager = manager;
		this._xrHitTestSource = xrHitTestSource;
		this._transient = transient;
	}

	remove() {
		if (!this._xrHitTestSource) return;
		const sources = this.manager.hitTest.sources;
		const ind = sources.indexOf(this);
		if (ind !== -1) sources.splice(ind, 1);
		this.onStop();
	}

	onStop() {
		this._xrHitTestSource.cancel();

		this._xrHitTestSource = null;
		this.fire('remove');
		this.manager.hitTest.fire('remove', this);
	}

	update(frame) {
		if (this._transient) {
			const transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);

			for (let i = 0; i < transientResults.length; i++) {
				const transientResult = transientResults[i];
				let inputSource;
				if (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
				this.updateHitResults(transientResult.results, inputSource);
			}
		} else {
			this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));
		}
	}

	updateHitResults(results, inputSource) {
		for (let i = 0; i < results.length; i++) {
			const pose = results[i].getPose(this.manager._referenceSpace);
			let position = poolVec3.pop();
			if (!position) position = new Vec3();
			position.copy(pose.transform.position);
			let rotation = poolQuat.pop();
			if (!rotation) rotation = new Quat();
			rotation.copy(pose.transform.orientation);
			this.fire('result', position, rotation, inputSource);
			this.manager.hitTest.fire('result', this, position, rotation, inputSource);
			poolVec3.push(position);
			poolQuat.push(rotation);
		}
	}

}

class XrHitTest extends EventHandler {
	constructor(manager) {
		super();
		this.manager = manager;
		this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);
		this._session = null;
		this.sources = [];

		if (this._supported) {
			this.manager.on('start', this._onSessionStart, this);
			this.manager.on('end', this._onSessionEnd, this);
		}
	}

	_onSessionStart() {
		if (this.manager.type !== XRTYPE_AR) return;
		this._session = this.manager.session;
	}

	_onSessionEnd() {
		if (!this._session) return;
		this._session = null;

		for (let i = 0; i < this.sources.length; i++) {
			this.sources[i].onStop();
		}

		this.sources = [];
	}

	isAvailable(callback, fireError) {
		let err;
		if (!this._supported) err = new Error('XR HitTest is not supported');
		if (!this._session) err = new Error('XR Session is not started (1)');
		if (this.manager.type !== XRTYPE_AR) err = new Error('XR HitTest is available only for AR');

		if (err) {
			if (callback) callback(err);
			if (fireError) fireError.fire('error', err);
			return false;
		}

		return true;
	}

	start(options) {
		options = options || {};
		if (!this.isAvailable(options.callback, this)) return;
		if (!options.profile && !options.spaceType) options.spaceType = XRSPACE_VIEWER;
		let xrRay;
		const offsetRay = options.offsetRay;
		if (offsetRay) xrRay = new XRRay(new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z), new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z));
		const callback = options.callback;

		if (options.spaceType) {
			this._session.requestReferenceSpace(options.spaceType).then(referenceSpace => {
				if (!this._session) {
					const err = new Error('XR Session is not started (2)');
					if (callback) callback(err);
					this.fire('error', err);
					return;
				}

				this._session.requestHitTestSource({
					space: referenceSpace,
					entityTypes: options.entityTypes || undefined,
					offsetRay: xrRay
				}).then(xrHitTestSource => {
					this._onHitTestSource(xrHitTestSource, false, callback);
				}).catch(ex => {
					if (callback) callback(ex);
					this.fire('error', ex);
				});
			}).catch(ex => {
				if (callback) callback(ex);
				this.fire('error', ex);
			});
		} else {
			this._session.requestHitTestSourceForTransientInput({
				profile: options.profile,
				entityTypes: options.entityTypes || undefined,
				offsetRay: xrRay
			}).then(xrHitTestSource => {
				this._onHitTestSource(xrHitTestSource, true, callback);
			}).catch(ex => {
				if (callback) callback(ex);
				this.fire('error', ex);
			});
		}
	}

	_onHitTestSource(xrHitTestSource, transient, callback) {
		if (!this._session) {
			xrHitTestSource.cancel();
			const err = new Error('XR Session is not started (3)');
			if (callback) callback(err);
			this.fire('error', err);
			return;
		}

		const hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);
		this.sources.push(hitTestSource);
		if (callback) callback(null, hitTestSource);
		this.fire('add', hitTestSource);
	}

	update(frame) {
		for (let i = 0; i < this.sources.length; i++) {
			this.sources[i].update(frame);
		}
	}

	get supported() {
		return this._supported;
	}

}

class XrFinger {
	constructor(index, hand) {
		this._index = index;
		this._hand = hand;

		this._hand._fingers.push(this);

		this._joints = [];
		this._tip = null;
	}

	get index() {
		return this._index;
	}

	get hand() {
		return this._hand;
	}

	get joints() {
		return this._joints;
	}

	get tip() {
		return this._tip;
	}

}

const tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];
const tipJointIdsIndex = {};

for (let i = 0; i < tipJointIds.length; i++) {
	tipJointIdsIndex[tipJointIds[i]] = true;
}

class XrJoint {
	constructor(index, id, hand, finger = null) {
		this._index = index;
		this._id = id;
		this._hand = hand;
		this._finger = finger;
		this._wrist = id === 'wrist';
		this._tip = this._finger && !!tipJointIdsIndex[id];
		this._radius = null;
		this._localTransform = new Mat4();
		this._worldTransform = new Mat4();
		this._localPosition = new Vec3();
		this._localRotation = new Quat();
		this._position = new Vec3();
		this._rotation = new Quat();
		this._dirtyLocal = true;
	}

	update(pose) {
		this._dirtyLocal = true;
		this._radius = pose.radius;

		this._localPosition.copy(pose.transform.position);

		this._localRotation.copy(pose.transform.orientation);
	}

	_updateTransforms() {
		if (this._dirtyLocal) {
			this._dirtyLocal = false;

			this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
		}

		const manager = this._hand._manager;
		const parent = manager.camera.parent;

		if (parent) {
			this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
		} else {
			this._worldTransform.copy(this._localTransform);
		}
	}

	getPosition() {
		this._updateTransforms();

		this._worldTransform.getTranslation(this._position);

		return this._position;
	}

	getRotation() {
		this._updateTransforms();

		this._rotation.setFromMat4(this._worldTransform);

		return this._rotation;
	}

	get index() {
		return this._index;
	}

	get hand() {
		return this._hand;
	}

	get finger() {
		return this._finger;
	}

	get wrist() {
		return this._wrist;
	}

	get tip() {
		return this._tip;
	}

	get radius() {
		return this._radius || 0.005;
	}

}

let fingerJointIds = [];
const vecA$2 = new Vec3();
const vecB$2 = new Vec3();
const vecC = new Vec3();

if (platform.browser && window.XRHand) {
	fingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];
}

class XrHand extends EventHandler {
	constructor(inputSource) {
		super();
		const xrHand = inputSource._xrInputSource.hand;
		this._manager = inputSource._manager;
		this._inputSource = inputSource;
		this._tracking = false;
		this._fingers = [];
		this._joints = [];
		this._jointsById = {};
		this._tips = [];
		this._wrist = null;

		if (xrHand.get('wrist')) {
			const joint = new XrJoint(0, 'wrist', this, null);
			this._wrist = joint;

			this._joints.push(joint);

			this._jointsById.wrist = joint;
		}

		for (let f = 0; f < fingerJointIds.length; f++) {
			const finger = new XrFinger(f, this);

			for (let j = 0; j < fingerJointIds[f].length; j++) {
				const jointId = fingerJointIds[f][j];
				if (!xrHand.get(jointId)) continue;
				const joint = new XrJoint(j, jointId, this, finger);

				this._joints.push(joint);

				this._jointsById[jointId] = joint;

				if (joint.tip) {
					this._tips.push(joint);

					finger._tip = joint;
				}

				finger._joints.push(joint);
			}
		}
	}

	update(frame) {
		const xrInputSource = this._inputSource._xrInputSource;

		for (let j = 0; j < this._joints.length; j++) {
			const joint = this._joints[j];
			const jointSpace = xrInputSource.hand.get(joint._id);

			if (jointSpace) {
				let pose;
				if (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);

				if (pose) {
					joint.update(pose);

					if (joint.wrist && !this._tracking) {
						this._tracking = true;
						this.fire('tracking');
					}
				} else if (joint.wrist) {
					if (this._tracking) {
						this._tracking = false;
						this.fire('trackinglost');
					}

					break;
				}
			}
		}

		const j1 = this._jointsById['thumb-metacarpal'];
		const j4 = this._jointsById['thumb-tip'];
		const j6 = this._jointsById['index-finger-phalanx-proximal'];
		const j9 = this._jointsById['index-finger-tip'];
		const j16 = this._jointsById['ring-finger-phalanx-proximal'];
		const j21 = this._jointsById['pinky-finger-phalanx-proximal'];

		if (j1 && j4 && j6 && j9 && j16 && j21) {
			this._inputSource._dirtyRay = true;

			this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);

			let jointL = j1;
			let jointR = j21;

			if (this._inputSource.handedness === XRHAND_LEFT) {
				const t = jointL;
				jointL = jointR;
				jointR = t;
			}

			vecA$2.sub2(jointL._localPosition, this._wrist._localPosition);
			vecB$2.sub2(jointR._localPosition, this._wrist._localPosition);
			vecC.cross(vecA$2, vecB$2).normalize();
			vecA$2.lerp(j6._localPosition, j16._localPosition, 0.5);
			vecA$2.sub(this._wrist._localPosition).normalize();

			this._inputSource._rayLocal.direction.lerp(vecC, vecA$2, 0.5).normalize();
		}

		const squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);

		if (squeezing) {
			if (!this._inputSource._squeezing) {
				this._inputSource._squeezing = true;

				this._inputSource.fire('squeezestart');

				this._manager.input.fire('squeezestart', this._inputSource);
			}
		} else {
			if (this._inputSource._squeezing) {
				this._inputSource._squeezing = false;

				this._inputSource.fire('squeeze');

				this._manager.input.fire('squeeze', this._inputSource);

				this._inputSource.fire('squeezeend');

				this._manager.input.fire('squeezeend', this._inputSource);
			}
		}
	}

	_fingerIsClosed(index) {
		const finger = this._fingers[index];
		vecA$2.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
		vecB$2.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
		return vecA$2.dot(vecB$2) < -0.8;
	}

	getJointById(id) {
		return this._jointsById[id] || null;
	}

	get fingers() {
		return this._fingers;
	}

	get joints() {
		return this._joints;
	}

	get tips() {
		return this._tips;
	}

	get wrist() {
		return this._wrist;
	}

	get tracking() {
		return this._tracking;
	}

}

const quat$1 = new Quat();
let ids$1 = 0;

class XrInputSource extends EventHandler {
	constructor(manager, xrInputSource) {
		super();
		this._id = ++ids$1;
		this._manager = manager;
		this._xrInputSource = xrInputSource;
		this._ray = new Ray();
		this._rayLocal = new Ray();
		this._grip = false;
		this._hand = null;
		if (xrInputSource.hand) this._hand = new XrHand(this);
		this._localTransform = null;
		this._worldTransform = null;
		this._position = new Vec3();
		this._rotation = new Quat();
		this._localPosition = null;
		this._localRotation = null;
		this._dirtyLocal = true;
		this._selecting = false;
		this._squeezing = false;
		this._elementInput = true;
		this._elementEntity = null;
		this._hitTestSources = [];
	}

	get id() {
		return this._id;
	}

	get inputSource() {
		return this._xrInputSource;
	}

	get targetRayMode() {
		return this._xrInputSource.targetRayMode;
	}

	get handedness() {
		return this._xrInputSource.handedness;
	}

	get profiles() {
		return this._xrInputSource.profiles;
	}

	get grip() {
		return this._grip;
	}

	get hand() {
		return this._hand;
	}

	get gamepad() {
		return this._xrInputSource.gamepad || null;
	}

	get selecting() {
		return this._selecting;
	}

	get squeezing() {
		return this._squeezing;
	}

	set elementInput(value) {
		if (this._elementInput === value) return;
		this._elementInput = value;
		if (!this._elementInput) this._elementEntity = null;
	}

	get elementInput() {
		return this._elementInput;
	}

	get elementEntity() {
		return this._elementEntity;
	}

	get hitTestSources() {
		return this._hitTestSources;
	}

	update(frame) {
		if (this._hand) {
			this._hand.update(frame);
		} else {
			if (this._xrInputSource.gripSpace) {
				const gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);

				if (gripPose) {
					if (!this._grip) {
						this._grip = true;
						this._localTransform = new Mat4();
						this._worldTransform = new Mat4();
						this._localPosition = new Vec3();
						this._localRotation = new Quat();
					}

					this._dirtyLocal = true;

					this._localPosition.copy(gripPose.transform.position);

					this._localRotation.copy(gripPose.transform.orientation);
				}
			}

			const targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);

			if (targetRayPose) {
				this._dirtyRay = true;

				this._rayLocal.origin.copy(targetRayPose.transform.position);

				this._rayLocal.direction.set(0, 0, -1);

				quat$1.copy(targetRayPose.transform.orientation);
				quat$1.transformVector(this._rayLocal.direction, this._rayLocal.direction);
			}
		}
	}

	_updateTransforms() {
		if (this._dirtyLocal) {
			this._dirtyLocal = false;

			this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
		}

		const parent = this._manager.camera.parent;

		if (parent) {
			this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
		} else {
			this._worldTransform.copy(this._localTransform);
		}
	}

	_updateRayTransforms() {
		const dirty = this._dirtyRay;
		this._dirtyRay = false;
		const parent = this._manager.camera.parent;

		if (parent) {
			const parentTransform = this._manager.camera.parent.getWorldTransform();

			parentTransform.getTranslation(this._position);

			this._rotation.setFromMat4(parentTransform);

			this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);

			this._ray.origin.add(this._position);

			this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
		} else if (dirty) {
			this._ray.origin.copy(this._rayLocal.origin);

			this._ray.direction.copy(this._rayLocal.direction);
		}
	}

	getPosition() {
		if (!this._position) return null;

		this._updateTransforms();

		this._worldTransform.getTranslation(this._position);

		return this._position;
	}

	getLocalPosition() {
		return this._localPosition;
	}

	getRotation() {
		if (!this._rotation) return null;

		this._updateTransforms();

		this._rotation.setFromMat4(this._worldTransform);

		return this._rotation;
	}

	getLocalRotation() {
		return this._localRotation;
	}

	getOrigin() {
		this._updateRayTransforms();

		return this._ray.origin;
	}

	getDirection() {
		this._updateRayTransforms();

		return this._ray.direction;
	}

	hitTestStart(options = {}) {
		options.profile = this._xrInputSource.profiles[0];
		const callback = options.callback;

		options.callback = (err, hitTestSource) => {
			if (hitTestSource) this.onHitTestSourceAdd(hitTestSource);
			if (callback) callback(err, hitTestSource);
		};

		this._manager.hitTest.start(options);
	}

	onHitTestSourceAdd(hitTestSource) {
		this._hitTestSources.push(hitTestSource);

		this.fire('hittest:add', hitTestSource);
		hitTestSource.on('result', function (position, rotation, inputSource) {
			if (inputSource !== this) return;
			this.fire('hittest:result', hitTestSource, position, rotation);
		}, this);
		hitTestSource.once('remove', function () {
			this.onHitTestSourceRemove(hitTestSource);
			this.fire('hittest:remove', hitTestSource);
		}, this);
	}

	onHitTestSourceRemove(hitTestSource) {
		const ind = this._hitTestSources.indexOf(hitTestSource);

		if (ind !== -1) this._hitTestSources.splice(ind, 1);
	}

}

class XrInput extends EventHandler {
	constructor(manager) {
		super();
		this.manager = manager;
		this._session = null;
		this._inputSources = [];

		this._onInputSourcesChangeEvt = evt => {
			this._onInputSourcesChange(evt);
		};

		this.manager.on('start', this._onSessionStart, this);
		this.manager.on('end', this._onSessionEnd, this);
	}

	_onSessionStart() {
		this._session = this.manager.session;

		this._session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);

		this._session.addEventListener('select', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource.fire('select', evt);
			this.fire('select', inputSource, evt);
		});

		this._session.addEventListener('selectstart', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._selecting = true;
			inputSource.fire('selectstart', evt);
			this.fire('selectstart', inputSource, evt);
		});

		this._session.addEventListener('selectend', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._selecting = false;
			inputSource.fire('selectend', evt);
			this.fire('selectend', inputSource, evt);
		});

		this._session.addEventListener('squeeze', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource.fire('squeeze', evt);
			this.fire('squeeze', inputSource, evt);
		});

		this._session.addEventListener('squeezestart', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._squeezing = true;
			inputSource.fire('squeezestart', evt);
			this.fire('squeezestart', inputSource, evt);
		});

		this._session.addEventListener('squeezeend', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._squeezing = false;
			inputSource.fire('squeezeend', evt);
			this.fire('squeezeend', inputSource, evt);
		});

		const inputSources = this._session.inputSources;

		for (let i = 0; i < inputSources.length; i++) {
			this._addInputSource(inputSources[i]);
		}
	}

	_onSessionEnd() {
		let i = this._inputSources.length;

		while (i--) {
			const inputSource = this._inputSources[i];

			this._inputSources.splice(i, 1);

			inputSource.fire('remove');
			this.fire('remove', inputSource);
		}

		this._session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);

		this._session = null;
	}

	_onInputSourcesChange(evt) {
		for (let i = 0; i < evt.removed.length; i++) {
			this._removeInputSource(evt.removed[i]);
		}

		for (let i = 0; i < evt.added.length; i++) {
			this._addInputSource(evt.added[i]);
		}
	}

	_getByInputSource(xrInputSource) {
		for (let i = 0; i < this._inputSources.length; i++) {
			if (this._inputSources[i].inputSource === xrInputSource) {
				return this._inputSources[i];
			}
		}

		return null;
	}

	_addInputSource(xrInputSource) {
		if (this._getByInputSource(xrInputSource)) return;
		const inputSource = new XrInputSource(this.manager, xrInputSource);

		this._inputSources.push(inputSource);

		this.fire('add', inputSource);
	}

	_removeInputSource(xrInputSource) {
		for (let i = 0; i < this._inputSources.length; i++) {
			if (this._inputSources[i].inputSource !== xrInputSource) continue;
			const inputSource = this._inputSources[i];

			this._inputSources.splice(i, 1);

			let h = inputSource.hitTestSources.length;

			while (h--) {
				inputSource.hitTestSources[h].remove();
			}

			inputSource.fire('remove');
			this.fire('remove', inputSource);
			return;
		}
	}

	update(frame) {
		for (let i = 0; i < this._inputSources.length; i++) {
			this._inputSources[i].update(frame);
		}
	}

	get inputSources() {
		return this._inputSources;
	}

}

const vec3A = new Vec3();
const vec3B = new Vec3();
const mat4A = new Mat4();
const mat4B = new Mat4();

class XrLightEstimation extends EventHandler {
	constructor(manager) {
		super();
		this._manager = manager;
		this._supported = false;
		this._available = false;
		this._lightProbeRequested = false;
		this._lightProbe = null;
		this._intensity = 0;
		this._rotation = new Quat();
		this._color = new Color();
		this._sphericalHarmonics = new Float32Array(27);

		this._manager.on('start', this._onSessionStart, this);

		this._manager.on('end', this._onSessionEnd, this);
	}

	_onSessionStart() {
		const supported = !!this._manager.session.requestLightProbe;
		if (!supported) return;
		this._supported = true;
	}

	_onSessionEnd() {
		this._supported = false;
		this._available = false;
		this._lightProbeRequested = false;
		this._lightProbe = null;
	}

	start() {
		let err;
		if (!this._manager.session) err = new Error('XR session is not running');
		if (!err && this._manager.type !== XRTYPE_AR) err = new Error('XR session type is not AR');
		if (!err && !this._supported) err = new Error('light-estimation is not supported');
		if (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');

		if (err) {
			this.fire('error', err);
			return;
		}

		this._lightProbeRequested = true;

		this._manager.session.requestLightProbe().then(lightProbe => {
			const wasRequested = this._lightProbeRequested;
			this._lightProbeRequested = false;

			if (this._manager.active) {
				if (wasRequested) {
					this._lightProbe = lightProbe;
				}
			} else {
				this.fire('error', new Error('XR session is not active'));
			}
		}).catch(ex => {
			this._lightProbeRequested = false;
			this.fire('error', ex);
		});
	}

	end() {
		this._lightProbeRequested = false;
		this._lightProbe = null;
		this._available = false;
	}

	update(frame) {
		if (!this._lightProbe) return;
		const lightEstimate = frame.getLightEstimate(this._lightProbe);
		if (!lightEstimate) return;

		if (!this._available) {
			this._available = true;
			this.fire('available');
		}

		const pli = lightEstimate.primaryLightIntensity;
		this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
		vec3A.copy(pli).mulScalar(1 / this._intensity);

		this._color.set(vec3A.x, vec3A.y, vec3A.z);

		vec3A.set(0, 0, 0);
		vec3B.copy(lightEstimate.primaryLightDirection);
		mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
		mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
		mat4A.mul(mat4B);

		this._rotation.setFromMat4(mat4A);

		this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._available;
	}

	get intensity() {
		return this._available ? this._intensity : null;
	}

	get color() {
		return this._available ? this._color : null;
	}

	get rotation() {
		return this._available ? this._rotation : null;
	}

	get sphericalHarmonics() {
		return this._available ? this._sphericalHarmonics : null;
	}

}

class XrTrackedImage extends EventHandler {
	constructor(image, width) {
		super();
		this._image = image;
		this._bitmap = null;
		this._width = width;
		this._measuredWidth = 0;
		this._trackable = false;
		this._tracking = false;
		this._emulated = false;
		this._pose = null;
		this._position = new Vec3();
		this._rotation = new Quat();
	}

	get image() {
		return this._image;
	}

	set width(value) {
		this._width = value;
	}

	get width() {
		return this._width;
	}

	get trackable() {
		return this._trackable;
	}

	get tracking() {
		return this._tracking;
	}

	get emulated() {
		return this._emulated;
	}

	prepare() {
		if (this._bitmap) {
			return {
				image: this._bitmap,
				widthInMeters: this._width
			};
		}

		return createImageBitmap(this._image).then(bitmap => {
			this._bitmap = bitmap;
			return {
				image: this._bitmap,
				widthInMeters: this._width
			};
		});
	}

	destroy() {
		this._image = null;
		this._pose = null;

		if (this._bitmap) {
			this._bitmap.close();

			this._bitmap = null;
		}
	}

	getPosition() {
		if (this._pose) this._position.copy(this._pose.transform.position);
		return this._position;
	}

	getRotation() {
		if (this._pose) this._rotation.copy(this._pose.transform.orientation);
		return this._rotation;
	}

}

class XrImageTracking extends EventHandler {
	constructor(manager) {
		super();
		this._manager = manager;
		this._supported = platform.browser && !!window.XRImageTrackingResult;
		this._available = false;
		this._images = [];

		if (this._supported) {
			this._manager.on('start', this._onSessionStart, this);

			this._manager.on('end', this._onSessionEnd, this);
		}
	}

	add(image, width) {
		if (!this._supported || this._manager.active) return null;
		const trackedImage = new XrTrackedImage(image, width);

		this._images.push(trackedImage);

		return trackedImage;
	}

	remove(trackedImage) {
		if (this._manager.active) return;

		const ind = this._images.indexOf(trackedImage);

		if (ind !== -1) {
			trackedImage.destroy();

			this._images.splice(ind, 1);
		}
	}

	_onSessionStart() {
		this._manager.session.getTrackedImageScores().then(images => {
			this._available = true;

			for (let i = 0; i < images.length; i++) {
				this._images[i]._trackable = images[i] === 'trackable';
			}
		}).catch(err => {
			this._available = false;
			this.fire('error', err);
		});
	}

	_onSessionEnd() {
		this._available = false;

		for (let i = 0; i < this._images.length; i++) {
			this._images[i]._pose = null;
			this._images[i]._measuredWidth = 0;

			if (this._images[i]._tracking) {
				this._images[i]._tracking = false;

				this._images[i].fire('untracked');
			}
		}
	}

	prepareImages(callback) {
		if (this._images.length) {
			Promise.all(this._images.map(function (trackedImage) {
				return trackedImage.prepare();
			})).then(function (bitmaps) {
				callback(null, bitmaps);
			}).catch(function (err) {
				callback(err, null);
			});
		} else {
			callback(null, null);
		}
	}

	update(frame) {
		if (!this._available) return;
		const results = frame.getImageTrackingResults();
		const index = {};

		for (let i = 0; i < results.length; i++) {
			index[results[i].index] = results[i];
			const trackedImage = this._images[results[i].index];
			trackedImage._emulated = results[i].trackingState === 'emulated';
			trackedImage._measuredWidth = results[i].measuredWidthInMeters;
			trackedImage._dirtyTransform = true;
			trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
		}

		for (let i = 0; i < this._images.length; i++) {
			if (this._images[i]._tracking && !index[i]) {
				this._images[i]._tracking = false;

				this._images[i].fire('untracked');
			} else if (!this._images[i]._tracking && index[i]) {
				this._images[i]._tracking = true;

				this._images[i].fire('tracked');
			}
		}
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._available;
	}

	get images() {
		return this._images;
	}

}

class XrDomOverlay {
	constructor(manager) {
		this._manager = manager;
		this._supported = platform.browser && !!window.XRDOMOverlayState;
		this._root = null;
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
	}

	get state() {
		if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;
		return this._manager._session.domOverlayState.type;
	}

	set root(value) {
		if (!this._supported || this._manager.active) return;
		this._root = value;
	}

	get root() {
		return this._root;
	}

}

class XrDepthSensing extends EventHandler {
	constructor(manager) {
		super();
		this._manager = manager;
		this._available = false;
		this._depthInfoCpu = null;
		this._depthInfoGpu = null;
		this._usage = null;
		this._dataFormat = null;
		this._matrixDirty = false;
		this._matrix = new Mat4();
		this._emptyBuffer = new Uint8Array(32);
		this._depthBuffer = null;
		this._texture = new Texture(this._manager.app.graphicsDevice, {
			format: PIXELFORMAT_L8_A8,
			mipmaps: false,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			minFilter: FILTER_LINEAR,
			magFilter: FILTER_LINEAR
		});

		if (this.supported) {
			this._manager.on('start', this._onSessionStart, this);

			this._manager.on('end', this._onSessionEnd, this);
		}
	}

	_onSessionStart() {
		const session = this._manager.session;

		try {
			this._usage = session.depthUsage;
			this._dataFormat = session.depthDataFormat;
		} catch (ex) {
			this._usage = null;
			this._dataFormat = null;
			this._available = false;
			this.fire('error', ex);
		}
	}

	_onSessionEnd() {
		this._depthInfoCpu = null;
		this._depthInfoGpu = null;
		this._usage = null;
		this._dataFormat = null;

		if (this._available) {
			this._available = false;
			this.fire('unavailable');
		}

		this._depthBuffer = null;
		this._texture._width = 4;
		this._texture._height = 4;
		this._texture._levels[0] = this._emptyBuffer;

		this._texture.upload();
	}

	_updateTexture() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;

		if (depthInfo) {
			let resized = false;

			if (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {
				this._texture._width = depthInfo.width;
				this._texture._height = depthInfo.height;
				this._matrixDirty = true;
				resized = true;
			}

			if (this._depthInfoCpu) {
				const dataBuffer = this._depthInfoCpu.data;
				this._depthBuffer = new Uint8Array(dataBuffer);
				this._texture._levels[0] = this._depthBuffer;

				this._texture.upload();
			} else if (this._depthInfoGpu) {
				this._texture._levels[0] = this._depthInfoGpu.texture;

				this._texture.upload();
			}

			if (resized) this.fire('resize', depthInfo.width, depthInfo.height);
		} else if (this._depthBuffer) {
			this._depthBuffer = null;
			this._texture._width = 4;
			this._texture._height = 4;
			this._texture._levels[0] = this._emptyBuffer;

			this._texture.upload();
		}
	}

	update(frame, view) {
		if (!this._usage) return;
		let depthInfoCpu = null;
		let depthInfoGpu = null;

		if (this._usage === XRDEPTHSENSINGUSAGE_CPU && view) {
			depthInfoCpu = frame.getDepthInformation(view);
		} else if (this._usage === XRDEPTHSENSINGUSAGE_GPU && view) {
			depthInfoGpu = frame.getDepthInformation(view);
		}

		if (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {
			this._matrixDirty = true;
		}

		this._depthInfoCpu = depthInfoCpu;
		this._depthInfoGpu = depthInfoGpu;

		this._updateTexture();

		if (this._matrixDirty) {
			this._matrixDirty = false;
			const depthInfo = this._depthInfoCpu || this._depthInfoGpu;

			if (depthInfo) {
				this._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);
			} else {
				this._matrix.setIdentity();
			}
		}

		if ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {
			this._available = true;
			this.fire('available');
		} else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {
			this._available = false;
			this.fire('unavailable');
		}
	}

	getDepth(u, v) {
		if (!this._depthInfoCpu) return null;
		return this._depthInfoCpu.getDepthInMeters(u, v);
	}

	get supported() {
		return platform.browser && !!window.XRDepthInformation;
	}

	get available() {
		return this._available;
	}

	get usage() {
		return this._usage;
	}

	get dataFormat() {
		return this._dataFormat;
	}

	get width() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;
		return depthInfo && depthInfo.width || 0;
	}

	get height() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;
		return depthInfo && depthInfo.height || 0;
	}

	get texture() {
		return this._texture;
	}

	get uvMatrix() {
		return this._matrix;
	}

	get rawValueToMeters() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;
		return depthInfo && depthInfo.rawValueToMeters || 0;
	}

}

let ids = 0;

class XrPlane extends EventHandler {
	constructor(planeDetection, xrPlane) {
		super();
		this._id = ++ids;
		this._planeDetection = planeDetection;
		this._manager = this._planeDetection._manager;
		this._xrPlane = xrPlane;
		this._lastChangedTime = this._xrPlane.lastChangedTime;
		this._orientation = this._xrPlane.orientation;
		this._position = new Vec3();
		this._rotation = new Quat();
	}

	destroy() {
		this.fire('remove');
	}

	update(frame) {
		const pose = frame.getPose(this._xrPlane.planeSpace, this._manager._referenceSpace);

		if (pose) {
			this._position.copy(pose.transform.position);

			this._rotation.copy(pose.transform.orientation);
		}

		if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
			this._lastChangedTime = this._xrPlane.lastChangedTime;
			this.fire('change');
		}
	}

	getPosition() {
		return this._position;
	}

	getRotation() {
		return this._rotation;
	}

	get id() {
		return this.id;
	}

	get orientation() {
		return this._orientation;
	}

	get points() {
		return this._xrPlane.polygon;
	}

}

class XrPlaneDetection extends EventHandler {
	constructor(manager) {
		super();
		this._manager = manager;
		this._supported = platform.browser && !!window.XRPlane;
		this._available = false;
		this._planesIndex = new Map();
		this._planes = null;

		if (this._supported) {
			this._manager.on('end', this._onSessionEnd, this);
		}
	}

	_onSessionEnd() {
		if (this._planes) {
			for (let i = 0; i < this._planes.length; i++) {
				this._planes[i].destroy();
			}
		}

		this._planesIndex.clear();

		this._planes = null;

		if (this._available) {
			this._available = false;
			this.fire('unavailable');
		}
	}

	update(frame) {
		let detectedPlanes;

		if (!this._available) {
			try {
				detectedPlanes = frame.detectedPlanes;
				this._planes = [];
				this._available = true;
				this.fire('available');
			} catch (ex) {
				return;
			}
		} else {
			detectedPlanes = frame.detectedPlanes;
		}

		for (const [xrPlane, plane] of this._planesIndex) {
			if (detectedPlanes.has(xrPlane)) continue;

			this._planesIndex.delete(xrPlane);

			this._planes.splice(this._planes.indexOf(plane), 1);

			plane.destroy();
			this.fire('remove', plane);
		}

		for (const xrPlane of detectedPlanes) {
			let plane = this._planesIndex.get(xrPlane);

			if (!plane) {
				plane = new XrPlane(this, xrPlane);

				this._planesIndex.set(xrPlane, plane);

				this._planes.push(plane);

				plane.update(frame);
				this.fire('add', plane);
			} else {
				plane.update(frame);
			}
		}
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._available;
	}

	get planes() {
		return this._planes;
	}

}

class XrManager extends EventHandler {
	constructor(app) {
		super();
		this.app = app;
		this._supported = platform.browser && !!navigator.xr;
		this._available = {};
		this._available[XRTYPE_INLINE] = false;
		this._available[XRTYPE_VR] = false;
		this._available[XRTYPE_AR] = false;
		this._type = null;
		this._spaceType = null;
		this._session = null;
		this._baseLayer = null;
		this._referenceSpace = null;
		this.depthSensing = new XrDepthSensing(this);
		this.domOverlay = new XrDomOverlay(this);
		this.hitTest = new XrHitTest(this);
		this.imageTracking = new XrImageTracking(this);
		this.planeDetection = new XrPlaneDetection(this);
		this.input = new XrInput(this);
		this.lightEstimation = new XrLightEstimation(this);
		this._camera = null;
		this.views = [];
		this.viewsPool = [];
		this._localPosition = new Vec3();
		this._localRotation = new Quat();
		this._depthNear = 0.1;
		this._depthFar = 1000;
		this._width = 0;
		this._height = 0;

		if (this._supported) {
			navigator.xr.addEventListener('devicechange', () => {
				this._deviceAvailabilityCheck();
			});

			this._deviceAvailabilityCheck();
		}
	}

	start(camera, type, spaceType, options) {
		let callback = options;
		if (typeof options === 'object') callback = options.callback;

		if (!this._available[type]) {
			if (callback) callback(new Error('XR is not available'));
			return;
		}

		if (this._session) {
			if (callback) callback(new Error('XR session is already started'));
			return;
		}

		this._camera = camera;
		this._camera.camera.xr = this;
		this._type = type;
		this._spaceType = spaceType;

		this._setClipPlanes(camera.nearClip, camera.farClip);

		const opts = {
			requiredFeatures: [spaceType],
			optionalFeatures: []
		};

		if (type === XRTYPE_AR) {
			opts.optionalFeatures.push('light-estimation');
			opts.optionalFeatures.push('hit-test');

			if (options) {
				if (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');
				if (options.planeDetection) opts.optionalFeatures.push('plane-detection');
			}

			if (this.domOverlay.supported && this.domOverlay.root) {
				opts.optionalFeatures.push('dom-overlay');
				opts.domOverlay = {
					root: this.domOverlay.root
				};
			}

			if (options && options.depthSensing && this.depthSensing.supported) {
				opts.optionalFeatures.push('depth-sensing');
				const usagePreference = [XRDEPTHSENSINGUSAGE_CPU];
				const dataFormatPreference = [XRDEPTHSENSINGFORMAT_L8A8];

				if (options.depthSensing.usagePreference) {
					const ind = usagePreference.indexOf(options.depthSensing.usagePreference);
					if (ind !== -1) usagePreference.splice(ind, 1);
					usagePreference.unshift(options.depthSensing.usagePreference);
				}

				if (options.depthSensing.dataFormatPreference) {
					const ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);
					if (ind !== -1) dataFormatPreference.splice(ind, 1);
					dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
				}

				opts.depthSensing = {
					usagePreference: usagePreference,
					dataFormatPreference: dataFormatPreference
				};
			}
		} else if (type === XRTYPE_VR) {
			opts.optionalFeatures.push('hand-tracking');
		}

		if (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);

		if (this.imageTracking.supported && this.imageTracking.images.length) {
			this.imageTracking.prepareImages((err, trackedImages) => {
				if (err) {
					if (callback) callback(err);
					this.fire('error', err);
					return;
				}

				if (trackedImages !== null) opts.trackedImages = trackedImages;

				this._onStartOptionsReady(type, spaceType, opts, callback);
			});
		} else {
			this._onStartOptionsReady(type, spaceType, opts, callback);
		}
	}

	_onStartOptionsReady(type, spaceType, options, callback) {
		navigator.xr.requestSession(type, options).then(session => {
			this._onSessionStart(session, spaceType, callback);
		}).catch(ex => {
			this._camera.camera.xr = null;
			this._camera = null;
			this._type = null;
			this._spaceType = null;
			if (callback) callback(ex);
			this.fire('error', ex);
		});
	}

	end(callback) {
		if (!this._session) {
			if (callback) callback(new Error('XR Session is not initialized'));
			return;
		}

		if (callback) this.once('end', callback);

		this._session.end();
	}

	isAvailable(type) {
		return this._available[type];
	}

	_deviceAvailabilityCheck() {
		for (const key in this._available) {
			this._sessionSupportCheck(key);
		}
	}

	_sessionSupportCheck(type) {
		navigator.xr.isSessionSupported(type).then(available => {
			if (this._available[type] === available) return;
			this._available[type] = available;
			this.fire('available', type, available);
			this.fire('available:' + type, available);
		}).catch(ex => {
			this.fire('error', ex);
		});
	}

	_onSessionStart(session, spaceType, callback) {
		let failed = false;
		this._session = session;

		const onVisibilityChange = () => {
			this.fire('visibility:change', session.visibilityState);
		};

		const onClipPlanesChange = () => {
			this._setClipPlanes(this._camera.nearClip, this._camera.farClip);
		};

		const onEnd = () => {
			this._session = null;
			this._referenceSpace = null;
			this.views = [];
			this._width = 0;
			this._height = 0;
			this._type = null;
			this._spaceType = null;

			if (this._camera) {
				this._camera.off('set_nearClip', onClipPlanesChange);

				this._camera.off('set_farClip', onClipPlanesChange);

				this._camera.camera.xr = null;
				this._camera = null;
			}

			session.removeEventListener('end', onEnd);
			session.removeEventListener('visibilitychange', onVisibilityChange);
			if (!failed) this.fire('end');
			this.app.tick();
		};

		session.addEventListener('end', onEnd);
		session.addEventListener('visibilitychange', onVisibilityChange);

		this._camera.on('set_nearClip', onClipPlanesChange);

		this._camera.on('set_farClip', onClipPlanesChange);

		this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl);
		session.updateRenderState({
			baseLayer: this._baseLayer,
			depthNear: this._depthNear,
			depthFar: this._depthFar
		});
		session.requestReferenceSpace(spaceType).then(referenceSpace => {
			this._referenceSpace = referenceSpace;
			this.app.tick();
			if (callback) callback(null);
			this.fire('start');
		}).catch(ex => {
			failed = true;
			session.end();
			if (callback) callback(ex);
			this.fire('error', ex);
		});
	}

	_setClipPlanes(near, far) {
		if (this._depthNear === near && this._depthFar === far) return;
		this._depthNear = near;
		this._depthFar = far;
		if (!this._session) return;

		this._session.updateRenderState({
			depthNear: this._depthNear,
			depthFar: this._depthFar
		});
	}

	update(frame) {
		if (!this._session) return;
		const width = frame.session.renderState.baseLayer.framebufferWidth;
		const height = frame.session.renderState.baseLayer.framebufferHeight;

		if (this._width !== width || this._height !== height) {
			this._width = width;
			this._height = height;
			this.app.graphicsDevice.setResolution(width, height);
		}

		const pose = frame.getViewerPose(this._referenceSpace);
		const lengthNew = pose ? pose.views.length : 0;

		if (lengthNew > this.views.length) {
			for (let i = 0; i <= lengthNew - this.views.length; i++) {
				let view = this.viewsPool.pop();

				if (!view) {
					view = {
						viewport: new Vec4(),
						projMat: new Mat4(),
						viewMat: new Mat4(),
						viewOffMat: new Mat4(),
						viewInvMat: new Mat4(),
						viewInvOffMat: new Mat4(),
						projViewOffMat: new Mat4(),
						viewMat3: new Mat3(),
						position: new Float32Array(3),
						rotation: new Quat()
					};
				}

				this.views.push(view);
			}
		} else if (lengthNew <= this.views.length) {
			for (let i = 0; i < this.views.length - lengthNew; i++) {
				this.viewsPool.push(this.views.pop());
			}
		}

		if (pose) {
			const posePosition = pose.transform.position;
			const poseOrientation = pose.transform.orientation;

			this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);

			this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);

			const layer = frame.session.renderState.baseLayer;

			for (let i = 0; i < pose.views.length; i++) {
				const viewRaw = pose.views[i];
				const view = this.views[i];
				const viewport = layer.getViewport(viewRaw);
				view.viewport.x = viewport.x;
				view.viewport.y = viewport.y;
				view.viewport.z = viewport.width;
				view.viewport.w = viewport.height;
				view.projMat.set(viewRaw.projectionMatrix);
				view.viewMat.set(viewRaw.transform.inverse.matrix);
				view.viewInvMat.set(viewRaw.transform.matrix);
			}
		}

		this._camera.camera._node.setLocalPosition(this._localPosition);

		this._camera.camera._node.setLocalRotation(this._localRotation);

		this.input.update(frame);

		if (this._type === XRTYPE_AR) {
			if (this.hitTest.supported) this.hitTest.update(frame);
			if (this.lightEstimation.supported) this.lightEstimation.update(frame);
			if (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);
			if (this.imageTracking.supported) this.imageTracking.update(frame);
			if (this.planeDetection.supported) this.planeDetection.update(frame);
		}

		this.fire('update', frame);
	}

	get supported() {
		return this._supported;
	}

	get active() {
		return !!this._session;
	}

	get type() {
		return this._type;
	}

	get spaceType() {
		return this._spaceType;
	}

	get session() {
		return this._session;
	}

	get camera() {
		return this._camera ? this._camera.entity : null;
	}

	get visibilityState() {
		if (!this._session) return null;
		return this._session.visibilityState;
	}

}

class ComponentSystem extends EventHandler {
	constructor(app) {
		super();
		this.app = app;
		this.store = {};
		this.schema = [];
	}

	addComponent(entity, data = {}) {
		const component = new this.ComponentType(this, entity);
		const componentData = new this.DataType();
		this.store[entity.getGuid()] = {
			entity: entity,
			data: componentData
		};
		entity[this.id] = component;
		entity.c[this.id] = component;
		this.initializeComponentData(component, data, []);
		this.fire('add', entity, component);
		return component;
	}

	removeComponent(entity) {
		const record = this.store[entity.getGuid()];
		const component = entity.c[this.id];
		this.fire('beforeremove', entity, component);
		delete this.store[entity.getGuid()];
		entity[this.id] = undefined;
		delete entity.c[this.id];
		this.fire('remove', entity, record.data);
	}

	cloneComponent(entity, clone) {
		const src = this.store[entity.getGuid()];
		return this.addComponent(clone, src.data);
	}

	initializeComponentData(component, data = {}, properties) {
		for (let i = 0, len = properties.length; i < len; i++) {
			const descriptor = properties[i];
			let name, type;

			if (typeof descriptor === 'object') {
				name = descriptor.name;
				type = descriptor.type;
			} else {
				name = descriptor;
				type = undefined;
			}

			let value = data[name];

			if (value !== undefined) {
				if (type !== undefined) {
					value = convertValue(value, type);
				}

				component[name] = value;
			} else {
				component[name] = component.data[name];
			}
		}

		if (component.enabled && component.entity.enabled) {
			component.onEnable();
		}
	}

	getPropertiesOfType(type) {
		const matchingProperties = [];
		const schema = this.schema || [];
		schema.forEach(function (descriptor) {
			if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
				matchingProperties.push(descriptor);
			}
		});
		return matchingProperties;
	}

	destroy() {
		this.off();
	}

}

function convertValue(value, type) {
	if (!value) {
		return value;
	}

	switch (type) {
		case 'rgb':
			if (value instanceof Color) {
				return value.clone();
			}

			return new Color(value[0], value[1], value[2]);

		case 'rgba':
			if (value instanceof Color) {
				return value.clone();
			}

			return new Color(value[0], value[1], value[2], value[3]);

		case 'vec2':
			if (value instanceof Vec2) {
				return value.clone();
			}

			return new Vec2(value[0], value[1]);

		case 'vec3':
			if (value instanceof Vec3) {
				return value.clone();
			}

			return new Vec3(value[0], value[1], value[2]);

		case 'vec4':
			if (value instanceof Vec4) {
				return value.clone();
			}

			return new Vec4(value[0], value[1], value[2], value[3]);

		case 'boolean':
		case 'number':
		case 'string':
			return value;

		case 'entity':
			return value;

		default:
			throw new Error('Could not convert unhandled type: ' + type);
	}
}

class AnimCache {
	constructor() {
		this._left = Infinity;
		this._right = -Infinity;
		this._len = 0;
		this._recip = 0;
		this._p0 = 0;
		this._p1 = 0;
		this._t = 0;
		this._hermite = {
			valid: false,
			p0: 0,
			m0: 0,
			p1: 0,
			m1: 0
		};
	}

	update(time, input) {
		if (time < this._left || time >= this._right) {
			const len = input.length;

			if (!len) {
				this._left = -Infinity;
				this._right = Infinity;
				this._len = 0;
				this._recip = 0;
				this._p0 = this._p1 = 0;
			} else {
				if (time < input[0]) {
					this._left = -Infinity;
					this._right = input[0];
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = 0;
				} else if (time >= input[len - 1]) {
					this._left = input[len - 1];
					this._right = Infinity;
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = len - 1;
				} else {
					const index = this._findKey(time, input);

					this._left = input[index];
					this._right = input[index + 1];
					this._len = this._right - this._left;
					const diff = 1.0 / this._len;
					this._recip = isFinite(diff) ? diff : 0;
					this._p0 = index;
					this._p1 = index + 1;
				}
			}
		}

		this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
		this._hermite.valid = false;
	}

	_findKey(time, input) {
		let index = 0;

		while (time >= input[index + 1]) {
			index++;
		}

		return index;
	}

	eval(result, interpolation, output) {
		const data = output._data;
		const comp = output._components;
		const idx0 = this._p0 * comp;

		if (interpolation === INTERPOLATION_STEP) {
			for (let i = 0; i < comp; ++i) {
				result[i] = data[idx0 + i];
			}
		} else {
			const t = this._t;
			const idx1 = this._p1 * comp;

			switch (interpolation) {
				case INTERPOLATION_LINEAR:
					for (let i = 0; i < comp; ++i) {
						result[i] = math.lerp(data[idx0 + i], data[idx1 + i], t);
					}

					break;

				case INTERPOLATION_CUBIC:
					{
						const hermite = this._hermite;

						if (!hermite.valid) {
							const t2 = t * t;
							const twot = t + t;
							const omt = 1 - t;
							const omt2 = omt * omt;
							hermite.valid = true;
							hermite.p0 = (1 + twot) * omt2;
							hermite.m0 = t * omt2;
							hermite.p1 = t2 * (3 - twot);
							hermite.m1 = t2 * (t - 1);
						}

						const p0 = (this._p0 * 3 + 1) * comp;
						const m0 = (this._p0 * 3 + 2) * comp;
						const p1 = (this._p1 * 3 + 1) * comp;
						const m1 = (this._p1 * 3 + 0) * comp;

						for (let i = 0; i < comp; ++i) {
							result[i] = hermite.p0 * data[p0 + i] + hermite.m0 * data[m0 + i] * this._len + hermite.p1 * data[p1 + i] + hermite.m1 * data[m1 + i] * this._len;
						}

						break;
					}
			}
		}
	}

}

class AnimSnapshot {
	constructor(animTrack) {
		this._name = animTrack.name + 'Snapshot';
		this._time = -1;
		this._cache = [];
		this._results = [];

		for (let i = 0; i < animTrack._inputs.length; ++i) {
			this._cache[i] = new AnimCache();
		}

		const curves = animTrack._curves;
		const outputs = animTrack._outputs;

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const output = outputs[curve._output];
			const storage = [];

			for (let j = 0; j < output._components; ++j) {
				storage[j] = 0;
			}

			this._results[i] = storage;
		}
	}

}

class AnimClip {
	constructor(track, time, speed, playing, loop, eventHandler) {
		this._name = track.name;
		this._track = track;
		this._snapshot = new AnimSnapshot(track);
		this._playing = playing;
		this._time = time;
		this._speed = speed;
		this._loop = loop;
		this._blendWeight = 1.0;
		this._blendOrder = 0.0;
		this._eventHandler = eventHandler;
		this._eventCursor = 0;

		while (this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time) {
			this._eventCursor++;
		}
	}

	set name(name) {
		this._name = name;
	}

	get name() {
		return this._name;
	}

	get track() {
		return this._track;
	}

	get snapshot() {
		return this._snapshot;
	}

	set time(time) {
		this._time = time;
	}

	get time() {
		return this._time;
	}

	set speed(speed) {
		this._speed = speed;
	}

	get speed() {
		return this._speed;
	}

	set loop(loop) {
		this._loop = loop;
	}

	get loop() {
		return this._loop;
	}

	set blendWeight(blendWeight) {
		this._blendWeight = blendWeight;
	}

	get blendWeight() {
		return this._blendWeight;
	}

	set blendOrder(blendOrder) {
		this._blendOrder = blendOrder;
	}

	get blendOrder() {
		return this._blendOrder;
	}

	set eventCursor(value) {
		this._eventCursor = value;
	}

	get eventCursor() {
		return this._eventCursor;
	}

	activeEventsForFrame(frameStartTime, frameEndTime) {
		if (frameStartTime === 0) {
			this.eventCursor = 0;
		}

		let clippedFrameDuration;

		if (frameEndTime > this.track.duration) {
			clippedFrameDuration = frameEndTime - this.track.duration;
			frameEndTime = this.track.duration;
		}

		while (this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= frameStartTime && (frameEndTime === this.track.duration ? this.track.events[this.eventCursor].time <= frameEndTime : this.track.events[this.eventCursor].time < frameEndTime)) {
			const event = this.track.events[this.eventCursor];

			this._eventHandler.fire(event.name, _extends({
				track: this.track
			}, event));

			this.eventCursor++;
		}

		if (Number.isFinite(clippedFrameDuration)) {
			this.activeEventsForFrame(0, clippedFrameDuration);
		}
	}

	_update(deltaTime) {
		if (this._playing) {
			let time = this._time;
			const duration = this._track.duration;
			const speed = this._speed;
			const loop = this._loop;

			if (this._track.events.length > 0 && duration > 0) {
				this.activeEventsForFrame(time, time + speed * deltaTime);
			}

			time += speed * deltaTime;

			if (speed >= 0) {
				if (time > duration) {
					if (loop) {
						time = time % duration || 0;
					} else {
						time = this._track.duration;
						this.pause();
					}
				}
			} else {
				if (time < 0) {
					if (loop) {
						time = duration + (time % duration || 0);
					} else {
						time = 0;
						this.pause();
					}
				}
			}

			this._time = time;
		}

		if (this._time !== this._snapshot._time) {
			this._track.eval(this._time, this._snapshot);
		}
	}

	play() {
		this._playing = true;
		this._time = 0;
	}

	stop() {
		this._playing = false;
		this._time = 0;
	}

	pause() {
		this._playing = false;
	}

	resume() {
		this._playing = true;
	}

	reset() {
		this._time = 0;
	}

}

const ANIM_INTERRUPTION_NONE = 'NONE';
const ANIM_INTERRUPTION_PREV = 'PREV_STATE';
const ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
const ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
const ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
const ANIM_GREATER_THAN = 'GREATER_THAN';
const ANIM_LESS_THAN = 'LESS_THAN';
const ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
const ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
const ANIM_EQUAL_TO = 'EQUAL_TO';
const ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
const ANIM_PARAMETER_INTEGER = 'INTEGER';
const ANIM_PARAMETER_FLOAT = 'FLOAT';
const ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
const ANIM_PARAMETER_TRIGGER = 'TRIGGER';
const ANIM_BLEND_1D = '1D';
const ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
const ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
const ANIM_BLEND_DIRECT = 'DIRECT';
const ANIM_STATE_START = 'START';
const ANIM_STATE_END = 'END';
const ANIM_STATE_ANY = 'ANY';
const ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];
const ANIM_LAYER_OVERWRITE = 'OVERWRITE';

class AnimTargetValue {
	constructor(component, type) {
		this._component = component;
		this.mask = new Int8Array(component.layers.length);
		this.weights = new Float32Array(component.layers.length);
		this.totalWeight = 0;
		this.counter = 0;
		this.layerCounter = 0;
		this.valueType = type;
		this.dirty = true;
		this.value = [0, 0, 0, 1];
	}

	getWeight(index) {
		if (this.dirty) this.updateWeights();

		if (this.totalWeight === 0 || !this.mask[index]) {
			return 0;
		}

		return this.weights[index] / this.totalWeight;
	}

	setMask(index, value) {
		this.mask[index] = value;

		if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
			this.mask = this.mask.fill(0, 0, index);
		}

		this.dirty = true;
	}

	updateWeights() {
		this.totalWeight = 0;

		for (let i = 0; i < this.weights.length; i++) {
			this.weights[i] = this._component.layers[i].weight;
			this.totalWeight += this.mask[i] * this.weights[i];
		}

		this.dirty = false;
	}

	updateValue(index, value) {
		if (this.counter === 0) {
			this.value[0] = 0;
			this.value[1] = 0;
			this.value[2] = 0;
			this.value[3] = 1;
		}

		if (!this.mask[index]) return;

		if (this.counter === 0) {
			AnimEvaluator._set(this.value, value, this.valueType);
		} else {
			AnimEvaluator._blend(this.value, value, this.getWeight(index), this.valueType);
		}
	}

}

AnimTargetValue.TYPE_QUAT = 'quaternion';
AnimTargetValue.TYPE_VEC3 = 'vector3';

class AnimEvaluator {
	constructor(binder) {
		this._binder = binder;
		this._clips = [];
		this._inputs = [];
		this._outputs = [];
		this._targets = {};
	}

	get clips() {
		return this._clips;
	}

	static _dot(a, b) {
		const len = a.length;
		let result = 0;

		for (let i = 0; i < len; ++i) {
			result += a[i] * b[i];
		}

		return result;
	}

	static _normalize(a) {
		let l = AnimEvaluator._dot(a, a);

		if (l > 0) {
			l = 1.0 / Math.sqrt(l);
			const len = a.length;

			for (let i = 0; i < len; ++i) {
				a[i] *= l;
			}
		}
	}

	static _set(a, b, type) {
		const len = a.length;

		if (type === 'quaternion') {
			let l = AnimEvaluator._dot(b, b);

			if (l > 0) {
				l = 1.0 / Math.sqrt(l);
			}

			for (let i = 0; i < len; ++i) {
				a[i] = b[i] * l;
			}
		} else {
			for (let i = 0; i < len; ++i) {
				a[i] = b[i];
			}
		}
	}

	static _blendVec(a, b, t) {
		const it = 1.0 - t;
		const len = a.length;

		for (let i = 0; i < len; ++i) {
			a[i] = a[i] * it + b[i] * t;
		}
	}

	static _blendQuat(a, b, t) {
		const len = a.length;
		const it = 1.0 - t;

		if (AnimEvaluator._dot(a, b) < 0) {
			t = -t;
		}

		for (let i = 0; i < len; ++i) {
			a[i] = a[i] * it + b[i] * t;
		}

		AnimEvaluator._normalize(a);
	}

	static _blend(a, b, t, type) {
		if (type === 'quaternion') {
			AnimEvaluator._blendQuat(a, b, t);
		} else {
			AnimEvaluator._blendVec(a, b, t);
		}
	}

	static _stableSort(a, lessFunc) {
		const len = a.length;

		for (let i = 0; i < len - 1; ++i) {
			for (let j = i + 1; j < len; ++j) {
				if (lessFunc(a[j], a[i])) {
					const tmp = a[i];
					a[i] = a[j];
					a[j] = tmp;
				}
			}
		}
	}

	addClip(clip) {
		const targets = this._targets;
		const binder = this._binder;
		const curves = clip.track.curves;
		const snapshot = clip.snapshot;
		const inputs = [];
		const outputs = [];

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const paths = curve.paths;

			for (let j = 0; j < paths.length; ++j) {
				const path = paths[j];
				const resolved = binder.resolve(path);
				let target = targets[resolved && resolved.targetPath || null];

				if (!target && resolved) {
					target = {
						target: resolved,
						value: [],
						curves: 0,
						blendCounter: 0
					};

					for (let k = 0; k < target.target.components; ++k) {
						target.value.push(0);
					}

					targets[resolved.targetPath] = target;

					if (binder.animComponent) {
						if (!binder.animComponent.targets[resolved.targetPath]) {
							let type;

							if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
								type = AnimTargetValue.TYPE_QUAT;
							} else {
								type = AnimTargetValue.TYPE_VEC3;
							}

							binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
						}

						binder.animComponent.targets[resolved.targetPath].layerCounter++;
						binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
					}
				}

				if (target) {
					target.curves++;
					inputs.push(snapshot._results[i]);
					outputs.push(target);
				}
			}
		}

		this._clips.push(clip);

		this._inputs.push(inputs);

		this._outputs.push(outputs);
	}

	removeClip(index) {
		const targets = this._targets;
		const binder = this._binder;
		const clips = this._clips;
		const clip = clips[index];
		const curves = clip.track.curves;

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const paths = curve.paths;

			for (let j = 0; j < paths.length; ++j) {
				const path = paths[j];

				const target = this._binder.resolve(path);

				if (target) {
					target.curves--;

					if (target.curves === 0) {
						binder.unresolve(path);
						delete targets[target.targetPath];

						if (binder.animComponent) {
							binder.animComponent.targets[target.targetPath].layerCounter--;
						}
					}
				}
			}
		}

		clips.splice(index, 1);

		this._inputs.splice(index, 1);

		this._outputs.splice(index, 1);
	}

	removeClips() {
		while (this._clips.length > 0) {
			this.removeClip(0);
		}
	}

	findClip(name) {
		const clips = this._clips;

		for (let i = 0; i < clips.length; ++i) {
			const clip = clips[i];

			if (clip.name === name) {
				return clip;
			}
		}

		return null;
	}

	rebind() {
		this._binder.rebind();

		this._targets = {};
		const clips = [...this.clips];
		this.removeClips();
		clips.forEach(clip => {
			this.addClip(clip);
		});
	}

	assignMask(mask) {
		return this._binder.assignMask(mask);
	}

	update(deltaTime) {
		const clips = this._clips;
		const order = clips.map(function (c, i) {
			return i;
		});

		AnimEvaluator._stableSort(order, function (a, b) {
			return clips[a].blendOrder < clips[b].blendOrder;
		});

		for (let i = 0; i < order.length; ++i) {
			const index = order[i];
			const clip = clips[index];
			const inputs = this._inputs[index];
			const outputs = this._outputs[index];
			const blendWeight = clip.blendWeight;

			if (blendWeight > 0.0) {
				clip._update(deltaTime);
			}

			let input;
			let output;
			let value;

			if (blendWeight >= 1.0) {
				for (let j = 0; j < inputs.length; ++j) {
					input = inputs[j];
					output = outputs[j];
					value = output.value;

					AnimEvaluator._set(value, input, output.target.type);

					output.blendCounter++;
				}
			} else if (blendWeight > 0.0) {
				for (let j = 0; j < inputs.length; ++j) {
					input = inputs[j];
					output = outputs[j];
					value = output.value;

					if (output.blendCounter === 0) {
						AnimEvaluator._set(value, input, output.target.type);
					} else {
						AnimEvaluator._blend(value, input, blendWeight, output.target.type);
					}

					output.blendCounter++;
				}
			}
		}

		const targets = this._targets;
		const binder = this._binder;

		for (const path in targets) {
			if (targets.hasOwnProperty(path)) {
				const target = targets[path];

				if (binder.animComponent && target.target.isTransform) {
					const animTarget = binder.animComponent.targets[path];

					if (animTarget.counter === animTarget.layerCounter) {
						animTarget.counter = 0;
					}

					animTarget.updateValue(binder.layerIndex, target.value);
					target.target.func(animTarget.value);
					animTarget.counter++;
				} else {
					target.target.func(target.value);
				}

				target.blendCounter = 0;
			}
		}

		binder.update(deltaTime);
	}

}

class AnimBinder {
	static joinPath(pathSegments, character) {
		character = character || '.';

		const escape = function escape(string) {
			return string.replace(/\\/g, '\\\\').replace(new RegExp('\\' + character, 'g'), '\\' + character);
		};

		return pathSegments.map(escape).join(character);
	}

	static splitPath(path, character) {
		character = character || '.';
		const result = [];
		let curr = "";
		let i = 0;

		while (i < path.length) {
			let c = path[i++];

			if (c === '\\' && i < path.length) {
				c = path[i++];

				if (c === '\\' || c === character) {
					curr += c;
				} else {
					curr += '\\' + c;
				}
			} else if (c === character) {
				result.push(curr);
				curr = '';
			} else {
				curr += c;
			}
		}

		if (curr.length > 0) {
			result.push(curr);
		}

		return result;
	}

	static encode(entityPath, component, propertyPath) {
		return `${Array.isArray(entityPath) ? entityPath.join('/') : entityPath}/${component}/${Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath}`;
	}

	resolve(path) {
		return null;
	}

	unresolve(path) {}

	update(deltaTime) {}

}

class AnimTarget {
	constructor(func, type, components, targetPath) {
		this._func = func;
		this._type = type;
		this._components = components;
		this._targetPath = targetPath;
		this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
	}

	get func() {
		return this._func;
	}

	get type() {
		return this._type;
	}

	get components() {
		return this._components;
	}

	get targetPath() {
		return this._targetPath;
	}

	get isTransform() {
		return this._isTransform;
	}

}

class DefaultAnimBinder {
	constructor(graph) {
		this._isPathInMask = (path, checkMaskValue) => {
			const maskItem = this._mask[path];
			if (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
			return false;
		};

		this.graph = graph;
		if (!graph) return;
		this._mask = null;
		const nodes = {};

		const flatten = function flatten(node) {
			nodes[node.name] = node;

			for (let i = 0; i < node.children.length; ++i) {
				flatten(node.children[i]);
			}
		};

		flatten(graph);
		this.nodes = nodes;
		this.targetCache = {};

		const findMeshInstances = function findMeshInstances(node) {
			let object = node;

			while (object && !(object instanceof Entity)) {
				object = object.parent;
			}

			let meshInstances;

			if (object) {
				if (object.render) {
					meshInstances = object.render.meshInstances;
				} else if (object.model) {
					meshInstances = object.model.meshInstances;
				}
			}

			return meshInstances;
		};

		this.nodeCounts = {};
		this.activeNodes = [];
		this.handlers = {
			'localPosition': function (node) {
				const object = node.localPosition;

				const func = function func(value) {
					object.set(...value);
				};

				return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
			},
			'localRotation': function (node) {
				const object = node.localRotation;

				const func = function func(value) {
					object.set(...value);
				};

				return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
			},
			'localScale': function (node) {
				const object = node.localScale;

				const func = function func(value) {
					object.set(...value);
				};

				return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
			},
			'weights': function (node) {
				const meshInstances = findMeshInstances(node);

				if (meshInstances) {
					const morphInstances = [];

					for (let i = 0; i < meshInstances.length; ++i) {
						if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
							morphInstances.push(meshInstances[i].morphInstance);
						}
					}

					if (morphInstances.length > 0) {
						const func = function func(value) {
							for (let i = 0; i < value.length; ++i) {
								for (let j = 0; j < morphInstances.length; j++) {
									morphInstances[j].setWeight(i, value[i]);
								}
							}
						};

						return DefaultAnimBinder.createAnimTarget(func, 'vector', morphInstances[0].morph._targets.length, node, 'weights');
					}
				}

				return null;
			},
			'materialTexture': (node, textureName) => {
				const meshInstances = findMeshInstances(node);

				if (meshInstances) {
					let meshInstance;

					for (let i = 0; i < meshInstances.length; ++i) {
						if (meshInstances[i].node.name === node.name) {
							meshInstance = meshInstances[i];
							break;
						}
					}

					if (meshInstance) {
						const func = value => {
							const textureAsset = this.animComponent.system.app.assets.get(value[0]);

							if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
								meshInstance.material[textureName] = textureAsset.resource;
								meshInstance.material.update();
							}
						};

						return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
					}
				}

				return null;
			}
		};
	}

	_isPathActive(path) {
		if (!this._mask) return true;
		const rootNodeNames = [path.entityPath[0], this.graph.name];

		for (let j = 0; j < rootNodeNames.length; ++j) {
			let currEntityPath = rootNodeNames[j];
			if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;

			for (let i = 1; i < path.entityPath.length; i++) {
				currEntityPath += '/' + path.entityPath[i];
				if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
			}
		}

		return false;
	}

	findNode(path) {
		if (!this._isPathActive(path)) {
			return null;
		}

		let node;

		if (this.graph) {
			node = this.graph.findByPath(path.entityPath);
		}

		if (!node) {
			node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
		}

		return node;
	}

	static createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
		const targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
		return new AnimTarget(func, type, valueCount, targetPath);
	}

	resolve(path) {
		const encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
		let target = this.targetCache[encodedPath];
		if (target) return target;
		const node = this.findNode(path);

		if (!node) {
			return null;
		}

		const handler = this.handlers[path.propertyPath];

		if (!handler) {
			return null;
		}

		target = handler(node);

		if (!target) {
			return null;
		}

		this.targetCache[encodedPath] = target;

		if (!this.nodeCounts[node.path]) {
			this.activeNodes.push(node);
			this.nodeCounts[node.path] = 1;
		} else {
			this.nodeCounts[node.path]++;
		}

		return target;
	}

	unresolve(path) {
		if (path.component !== 'graph') return;
		const node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
		this.nodeCounts[node.path]--;

		if (this.nodeCounts[node.path] === 0) {
			const activeNodes = this.activeNodes;
			const i = activeNodes.indexOf(node.node);
			const len = activeNodes.length;

			if (i < len - 1) {
				activeNodes[i] = activeNodes[len - 1];
			}

			activeNodes.pop();
		}
	}

	update(deltaTime) {
		const activeNodes = this.activeNodes;

		for (let i = 0; i < activeNodes.length; ++i) {
			activeNodes[i]._dirtifyLocal();
		}
	}

	assignMask(mask) {
		if (mask !== this._mask) {
			this._mask = mask;
			return true;
		}

		return false;
	}

}

class InterpolatedKey {
	constructor() {
		this._written = false;
		this._name = "";
		this._keyFrames = [];
		this._quat = new Quat();
		this._pos = new Vec3();
		this._scale = new Vec3();
		this._targetNode = null;
	}

	getTarget() {
		return this._targetNode;
	}

	setTarget(node) {
		this._targetNode = node;
	}

}

class Skeleton {
	constructor(graph) {
		this.looping = true;
		this._animation = null;
		this._time = 0;
		this._interpolatedKeys = [];
		this._interpolatedKeyDict = {};
		this._currKeyIndices = {};
		this.graph = null;

		const addInterpolatedKeys = node => {
			const interpKey = new InterpolatedKey();
			interpKey._name = node.name;

			this._interpolatedKeys.push(interpKey);

			this._interpolatedKeyDict[node.name] = interpKey;
			this._currKeyIndices[node.name] = 0;

			for (let i = 0; i < node._children.length; i++) addInterpolatedKeys(node._children[i]);
		};

		addInterpolatedKeys(graph);
	}

	set animation(value) {
		this._animation = value;
		this.currentTime = 0;
	}

	get animation() {
		return this._animation;
	}

	set currentTime(value) {
		this._time = value;
		const numNodes = this._interpolatedKeys.length;

		for (let i = 0; i < numNodes; i++) {
			const node = this._interpolatedKeys[i];
			const nodeName = node._name;
			this._currKeyIndices[nodeName] = 0;
		}

		this.addTime(0);
		this.updateGraph();
	}

	get currentTime() {
		return this._time;
	}

	get numNodes() {
		return this._interpolatedKeys.length;
	}

	addTime(delta) {
		if (this._animation !== null) {
			const nodes = this._animation._nodes;
			const duration = this._animation.duration;

			if (this._time === duration && !this.looping) {
				return;
			}

			this._time += delta;

			if (this._time > duration) {
				this._time = this.looping ? 0.0 : duration;

				for (let i = 0; i < nodes.length; i++) {
					const node = nodes[i];
					const nodeName = node._name;
					this._currKeyIndices[nodeName] = 0;
				}
			} else if (this._time < 0) {
				this._time = this.looping ? duration : 0.0;

				for (let i = 0; i < nodes.length; i++) {
					const node = nodes[i];
					const nodeName = node._name;
					this._currKeyIndices[nodeName] = node._keys.length - 2;
				}
			}

			const offset = delta >= 0 ? 1 : -1;

			for (let i = 0; i < nodes.length; i++) {
				const node = nodes[i];
				const nodeName = node._name;
				const keys = node._keys;
				const interpKey = this._interpolatedKeyDict[nodeName];

				if (interpKey === undefined) {
					continue;
				}

				let foundKey = false;

				if (keys.length !== 1) {
					for (let currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
						const k1 = keys[currKeyIndex];
						const k2 = keys[currKeyIndex + 1];

						if (k1.time <= this._time && k2.time >= this._time) {
							const alpha = (this._time - k1.time) / (k2.time - k1.time);

							interpKey._pos.lerp(k1.position, k2.position, alpha);

							interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);

							interpKey._scale.lerp(k1.scale, k2.scale, alpha);

							interpKey._written = true;
							this._currKeyIndices[nodeName] = currKeyIndex;
							foundKey = true;
							break;
						}
					}
				}

				if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
					interpKey._pos.copy(keys[0].position);

					interpKey._quat.copy(keys[0].rotation);

					interpKey._scale.copy(keys[0].scale);

					interpKey._written = true;
				}
			}
		}
	}

	blend(skel1, skel2, alpha) {
		const numNodes = this._interpolatedKeys.length;

		for (let i = 0; i < numNodes; i++) {
			const key1 = skel1._interpolatedKeys[i];
			const key2 = skel2._interpolatedKeys[i];
			const dstKey = this._interpolatedKeys[i];

			if (key1._written && key2._written) {
				dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);

				dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);

				dstKey._scale.lerp(key1._scale, key2._scale, alpha);

				dstKey._written = true;
			} else if (key1._written) {
				dstKey._quat.copy(key1._quat);

				dstKey._pos.copy(key1._pos);

				dstKey._scale.copy(key1._scale);

				dstKey._written = true;
			} else if (key2._written) {
				dstKey._quat.copy(key2._quat);

				dstKey._pos.copy(key2._pos);

				dstKey._scale.copy(key2._scale);

				dstKey._written = true;
			}
		}
	}

	setGraph(graph) {
		this.graph = graph;

		if (graph) {
			for (let i = 0; i < this._interpolatedKeys.length; i++) {
				const interpKey = this._interpolatedKeys[i];
				const graphNode = graph.findByName(interpKey._name);

				this._interpolatedKeys[i].setTarget(graphNode);
			}
		} else {
			for (let i = 0; i < this._interpolatedKeys.length; i++) {
				this._interpolatedKeys[i].setTarget(null);
			}
		}
	}

	updateGraph() {
		if (this.graph) {
			for (let i = 0; i < this._interpolatedKeys.length; i++) {
				const interpKey = this._interpolatedKeys[i];

				if (interpKey._written) {
					const transform = interpKey.getTarget();
					transform.localPosition.copy(interpKey._pos);
					transform.localRotation.copy(interpKey._quat);
					transform.localScale.copy(interpKey._scale);
					if (!transform._dirtyLocal) transform._dirtifyLocal();
					interpKey._written = false;
				}
			}
		}
	}

}

class AnimationComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.animationsIndex = {};
		this.on('set_animations', this.onSetAnimations, this);
		this.on('set_assets', this.onSetAssets, this);
		this.on('set_loop', this.onSetLoop, this);
	}

	set currentTime(currentTime) {
		const data = this.data;

		if (data.skeleton) {
			const skeleton = data.skeleton;
			skeleton.currentTime = currentTime;
			skeleton.addTime(0);
			skeleton.updateGraph();
		}

		if (data.animEvaluator) {
			const animEvaluator = data.animEvaluator;

			for (let i = 0; i < animEvaluator.clips.length; ++i) {
				animEvaluator.clips[i].time = currentTime;
			}
		}
	}

	get currentTime() {
		const data = this.data;

		if (data.skeleton) {
			return this.data.skeleton._time;
		}

		if (data.animEvaluator) {
			const clips = data.animEvaluator.clips;

			if (clips.length > 0) {
				return clips[clips.length - 1].time;
			}
		}

		return 0;
	}

	get duration() {
		return this.data.animations[this.data.currAnim].duration;
	}

	play(name, blendTime = 0) {
		if (!this.enabled || !this.entity.enabled) {
			return;
		}

		const data = this.data;

		if (!data.animations[name]) {
			return;
		}

		data.prevAnim = data.currAnim;
		data.currAnim = name;

		if (data.model) {
			if (!data.skeleton && !data.animEvaluator) {
				this._createAnimationController();
			}

			const prevAnim = data.animations[data.prevAnim];
			const currAnim = data.animations[data.currAnim];
			data.blending = blendTime > 0 && data.prevAnim;

			if (data.blending) {
				data.blend = 0;
				data.blendSpeed = 1.0 / blendTime;
			}

			if (data.skeleton) {
				if (data.blending) {
					data.fromSkel.animation = prevAnim;
					data.fromSkel.addTime(data.skeleton._time);
					data.toSkel.animation = currAnim;
				} else {
					data.skeleton.animation = currAnim;
				}
			}

			if (data.animEvaluator) {
				const animEvaluator = data.animEvaluator;

				if (data.blending) {
					while (animEvaluator.clips.length > 1) {
						animEvaluator.removeClip(0);
					}
				} else {
					data.animEvaluator.removeClips();
				}

				const clip = new AnimClip(data.animations[data.currAnim], 0, 1.0, true, data.loop);
				clip.name = data.currAnim;
				clip.blendWeight = data.blending ? 0 : 1;
				clip.reset();
				data.animEvaluator.addClip(clip);
			}
		}

		data.playing = true;
	}

	getAnimation(name) {
		return this.data.animations[name];
	}

	setModel(model) {
		const data = this.data;

		if (model !== data.model) {
			this._resetAnimationController();

			data.model = model;

			if (data.animations && data.currAnim && data.animations[data.currAnim]) {
				this.play(data.currAnim);
			}
		}
	}

	_resetAnimationController() {
		const data = this.data;
		data.skeleton = null;
		data.fromSkel = null;
		data.toSkel = null;
		data.animEvaluator = null;
	}

	_createAnimationController() {
		const data = this.data;
		const model = data.model;
		const animations = data.animations;
		let hasJson = false;
		let hasGlb = false;

		for (const animation in animations) {
			if (animations.hasOwnProperty(animation)) {
				const anim = animations[animation];

				if (anim.constructor === AnimTrack) {
					hasGlb = true;
				} else {
					hasJson = true;
				}
			}
		}

		const graph = model.getGraph();

		if (hasJson) {
			data.fromSkel = new Skeleton(graph);
			data.toSkel = new Skeleton(graph);
			data.skeleton = new Skeleton(graph);
			data.skeleton.looping = data.loop;
			data.skeleton.setGraph(graph);
		} else if (hasGlb) {
			data.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
		}
	}

	loadAnimationAssets(ids) {
		if (!ids || !ids.length) return;
		const assets = this.system.app.assets;

		const onAssetReady = asset => {
			if (asset.resources.length > 1) {
				for (let i = 0; i < asset.resources.length; i++) {
					this.animations[asset.resources[i].name] = asset.resources[i];
					this.animationsIndex[asset.id] = asset.resources[i].name;
				}
			} else {
				this.animations[asset.name] = asset.resource;
				this.animationsIndex[asset.id] = asset.name;
			}

			this.animations = this.animations;
		};

		const onAssetAdd = asset => {
			asset.off('change', this.onAssetChanged, this);
			asset.on('change', this.onAssetChanged, this);
			asset.off('remove', this.onAssetRemoved, this);
			asset.on('remove', this.onAssetRemoved, this);

			if (asset.resource) {
				onAssetReady(asset);
			} else {
				asset.once('load', onAssetReady, this);
				if (this.enabled && this.entity.enabled) assets.load(asset);
			}
		};

		for (let i = 0, l = ids.length; i < l; i++) {
			const asset = assets.get(ids[i]);

			if (asset) {
				onAssetAdd(asset);
			} else {
				assets.on('add:' + ids[i], onAssetAdd);
			}
		}
	}

	onAssetChanged(asset, attribute, newValue, oldValue) {
		if (attribute === 'resource' || attribute === 'resources') {
			if (attribute === 'resources' && newValue && newValue.length === 0) {
				newValue = null;
			}

			if (newValue) {
				let restarted = false;

				if (newValue.length > 1) {
					if (oldValue && oldValue.length > 1) {
						for (let i = 0; i < oldValue.length; i++) {
							delete this.animations[oldValue[i].name];
						}
					} else {
						delete this.animations[asset.name];
					}

					restarted = false;

					for (let i = 0; i < newValue.length; i++) {
						this.animations[newValue[i].name] = newValue[i];

						if (!restarted && this.data.currAnim === newValue[i].name) {
							if (this.data.playing && this.data.enabled && this.entity.enabled) {
								restarted = true;
								this.play(newValue[i].name);
							}
						}
					}

					if (!restarted) {
						this._stopCurrentAnimation();

						this.onSetAnimations();
					}
				} else {
					if (oldValue && oldValue.length > 1) {
						for (let i = 0; i < oldValue.length; i++) {
							delete this.animations[oldValue[i].name];
						}
					}

					this.animations[asset.name] = newValue[0] || newValue;
					restarted = false;

					if (this.data.currAnim === asset.name) {
						if (this.data.playing && this.data.enabled && this.entity.enabled) {
							restarted = true;
							this.play(asset.name);
						}
					}

					if (!restarted) {
						this._stopCurrentAnimation();

						this.onSetAnimations();
					}
				}

				this.animationsIndex[asset.id] = asset.name;
			} else {
				if (oldValue.length > 1) {
					for (let i = 0; i < oldValue.length; i++) {
						delete this.animations[oldValue[i].name];

						if (this.data.currAnim === oldValue[i].name) {
							this._stopCurrentAnimation();
						}
					}
				} else {
					delete this.animations[asset.name];

					if (this.data.currAnim === asset.name) {
						this._stopCurrentAnimation();
					}
				}

				delete this.animationsIndex[asset.id];
			}
		}
	}

	onAssetRemoved(asset) {
		asset.off('remove', this.onAssetRemoved, this);

		if (this.animations) {
			if (asset.resources.length > 1) {
				for (let i = 0; i < asset.resources.length; i++) {
					delete this.animations[asset.resources[i].name];
					if (this.data.currAnim === asset.resources[i].name) this._stopCurrentAnimation();
				}
			} else {
				delete this.animations[asset.name];
				if (this.data.currAnim === asset.name) this._stopCurrentAnimation();
			}

			delete this.animationsIndex[asset.id];
		}
	}

	_stopCurrentAnimation() {
		const data = this.data;
		data.currAnim = null;
		data.playing = false;

		if (data.skeleton) {
			data.skeleton.currentTime = 0;
			data.skeleton.animation = null;
		}

		if (data.animEvaluator) {
			for (let i = 0; i < data.animEvaluator.clips.length; ++i) {
				data.animEvaluator.clips[i].stop();
			}

			data.animEvaluator.update(0);
			data.animEvaluator.removeClips();
		}
	}

	onSetAnimations(name, oldValue, newValue) {
		const data = this.data;
		const modelComponent = this.entity.model;

		if (modelComponent) {
			const m = modelComponent.model;

			if (m && m !== data.model) {
				this.setModel(m);
			}
		}

		if (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {
			const animationNames = Object.keys(data.animations);

			if (animationNames.length > 0) {
				this.play(animationNames[0]);
			}
		}
	}

	onSetAssets(name, oldValue, newValue) {
		if (oldValue && oldValue.length) {
			for (let i = 0; i < oldValue.length; i++) {
				if (oldValue[i]) {
					const asset = this.system.app.assets.get(oldValue[i]);

					if (asset) {
						asset.off('change', this.onAssetChanged, this);
						asset.off('remove', this.onAssetRemoved, this);
						const animName = this.animationsIndex[asset.id];
						if (this.data.currAnim === animName) this._stopCurrentAnimation();
						delete this.animations[animName];
						delete this.animationsIndex[asset.id];
					}
				}
			}
		}

		const ids = newValue.map(value => {
			return value instanceof Asset ? value.id : value;
		});
		this.loadAnimationAssets(ids);
	}

	onSetLoop(name, oldValue, newValue) {
		const data = this.data;

		if (data.skeleton) {
			data.skeleton.looping = data.loop;
		}

		if (data.animEvaluator) {
			for (let i = 0; i < data.animEvaluator.clips.length; ++i) {
				data.animEvaluator.clips[i].loop = data.loop;
			}
		}
	}

	onSetCurrentTime(name, oldValue, newValue) {
		const data = this.data;

		if (data.skeleton) {
			const skeleton = data.skeleton;
			skeleton.currentTime = newValue;
			skeleton.addTime(0);
			skeleton.updateGraph();
		}

		if (data.animEvaluator) {
			const animEvaluator = data.animEvaluator;

			for (let i = 0; i < animEvaluator.clips.length; ++i) {
				animEvaluator.clips[i].time = newValue;
			}
		}
	}

	onEnable() {
		super.onEnable();
		const data = this.data;
		const assets = data.assets;
		const registry = this.system.app.assets;

		if (assets) {
			for (let i = 0, len = assets.length; i < len; i++) {
				let asset = assets[i];
				if (!(asset instanceof Asset)) asset = registry.get(asset);
				if (asset && !asset.resource) registry.load(asset);
			}
		}

		if (data.activate && !data.currAnim) {
			const animationNames = Object.keys(data.animations);

			if (animationNames.length > 0) {
				this.play(animationNames[0]);
			}
		}
	}

	onBeforeRemove() {
		for (let i = 0; i < this.assets.length; i++) {
			let asset = this.assets[i];

			if (typeof asset === 'number') {
				asset = this.system.app.assets.get(asset);
			}

			if (!asset) continue;
			asset.off('change', this.onAssetChanged, this);
			asset.off('remove', this.onAssetRemoved, this);
		}

		const data = this.data;
		delete data.animation;
		delete data.skeleton;
		delete data.fromSkel;
		delete data.toSkel;
		delete data.animEvaluator;
	}

}

class AnimationComponentData {
	constructor() {
		this.assets = [];
		this.speed = 1.0;
		this.loop = true;
		this.activate = true;
		this.enabled = true;
		this.animations = {};
		this.model = null;
		this.prevAnim = null;
		this.currAnim = null;
		this.blending = false;
		this.blend = 0;
		this.blendSpeed = 0;
		this.playing = false;
		this.skeleton = null;
		this.fromSkel = null;
		this.toSkel = null;
		this.animEvaluator = null;
	}

}

const _schema$l = ['enabled', 'assets', 'speed', 'loop', 'activate', 'animations', 'skeleton', 'model', 'prevAnim', 'currAnim', 'fromSkel', 'toSkel', 'blending', 'blendTimeRemaining', 'playing'];

class AnimationComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'animation';
		this.ComponentType = AnimationComponent;
		this.DataType = AnimationComponentData;
		this.schema = _schema$l;
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		this.addComponent(clone, {});
		clone.animation.assets = entity.animation.assets.slice();
		clone.animation.data.speed = entity.animation.speed;
		clone.animation.data.loop = entity.animation.loop;
		clone.animation.data.activate = entity.animation.activate;
		clone.animation.data.enabled = entity.animation.enabled;
		const clonedAnimations = {};
		const animations = entity.animation.animations;

		for (const key in animations) {
			if (animations.hasOwnProperty(key)) {
				clonedAnimations[key] = animations[key];
			}
		}

		clone.animation.animations = clonedAnimations;
		const clonedAnimationsIndex = {};
		const animationsIndex = entity.animation.animationsIndex;

		for (const key in animationsIndex) {
			if (animationsIndex.hasOwnProperty(key)) {
				clonedAnimationsIndex[key] = animationsIndex[key];
			}
		}

		clone.animation.animationsIndex = clonedAnimationsIndex;
	}

	onBeforeRemove(entity, component) {
		component.onBeforeRemove();
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];
				const componentData = component.data;

				if (componentData.enabled && component.entity.enabled) {
					if (componentData.blending) {
						componentData.blend += dt * componentData.blendSpeed;

						if (componentData.blend >= 1.0) {
							componentData.blend = 1.0;
						}
					}

					if (componentData.playing) {
						const skeleton = componentData.skeleton;

						if (skeleton !== null && componentData.model !== null) {
							if (componentData.blending) {
								skeleton.blend(componentData.fromSkel, componentData.toSkel, componentData.blend);
							} else {
								const delta = dt * componentData.speed;
								skeleton.addTime(delta);

								if (componentData.speed > 0 && skeleton._time === skeleton._animation.duration && !componentData.loop) {
									componentData.playing = false;
								} else if (componentData.speed < 0 && skeleton._time === 0 && !componentData.loop) {
									componentData.playing = false;
								}
							}

							if (componentData.blending && componentData.blend === 1.0) {
								skeleton.animation = componentData.toSkel._animation;
							}

							skeleton.updateGraph();
						}
					}

					const animEvaluator = componentData.animEvaluator;

					if (animEvaluator) {
						for (let i = 0; i < animEvaluator.clips.length; ++i) {
							const clip = animEvaluator.clips[i];
							clip.speed = componentData.speed;

							if (!componentData.playing) {
								clip.pause();
							} else {
								clip.resume();
							}
						}

						if (componentData.blending && animEvaluator.clips.length > 1) {
							animEvaluator.clips[1].blendWeight = componentData.blend;
						}

						animEvaluator.update(dt);
					}

					if (componentData.blending && componentData.blend === 1.0) {
						componentData.blending = false;
					}
				}
			}
		}
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(AnimationComponent.prototype, _schema$l);

class AnimNode {
	constructor(state, parent, name, point, speed = 1) {
		this._state = state;
		this._parent = parent;
		this._name = name;

		if (Array.isArray(point)) {
			this._point = new Vec2(point[0], point[1]);
			this._pointLength = this._point.length();
		} else {
			this._point = point;
			this._pointLength = point;
		}

		this._speed = speed;
		this._weightedSpeed = 1.0;
		this._weight = 1.0;
		this._animTrack = null;
	}

	get parent() {
		return this._parent;
	}

	get name() {
		return this._name;
	}

	get path() {
		return this._parent ? this._parent.path + '.' + this._name : this._name;
	}

	get point() {
		return this._point;
	}

	get pointLength() {
		return this._pointLength;
	}

	set weight(value) {
		this._weight = value;
	}

	get weight() {
		return this._parent ? this._parent.weight * this._weight : this._weight;
	}

	get normalizedWeight() {
		const totalWeight = this._state.totalWeight;
		if (totalWeight === 0.0) return 0.0;
		return this.weight / totalWeight;
	}

	get speed() {
		return this._weightedSpeed * this._speed;
	}

	get absoluteSpeed() {
		return Math.abs(this._speed);
	}

	set weightedSpeed(weightedSpeed) {
		this._weightedSpeed = weightedSpeed;
	}

	get weightedSpeed() {
		return this._weightedSpeed;
	}

	set animTrack(value) {
		this._animTrack = value;
	}

	get animTrack() {
		return this._animTrack;
	}

}

class AnimBlendTree extends AnimNode {
	constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
		super(state, parent, name, point);
		this._parameters = parameters;
		this._parameterValues = new Array(parameters.length);
		this._children = [];
		this._findParameter = findParameter;
		this._syncAnimations = syncAnimations !== false;
		this._pointCache = {};

		for (let i = 0; i < children.length; i++) {
			const child = children[i];

			if (child.children) {
				this._children.push(createTree(child.type, this, null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));
			} else {
				this._children.push(new AnimNode(state, this, child.name, child.point, child.speed));
			}
		}
	}

	get weight() {
		this.calculateWeights();
		return this._parent ? this._parent.weight * this._weight : this._weight;
	}

	get syncAnimations() {
		return this._syncAnimations;
	}

	getChild(name) {
		for (let i = 0; i < this._children.length; i++) {
			if (this._children[i].name === name) return this._children[i];
		}

		return null;
	}

	updateParameterValues() {
		let paramsEqual = true;

		for (let i = 0; i < this._parameterValues.length; i++) {
			const updatedParameter = this._findParameter(this._parameters[i]).value;

			if (this._parameterValues[i] !== updatedParameter) {
				this._parameterValues[i] = updatedParameter;
				paramsEqual = false;
			}
		}

		return paramsEqual;
	}

	getNodeWeightedDuration(i) {
		return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
	}

	getNodeCount() {
		let count = 0;

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];

			if (child.constructor === AnimBlendTree) {
				count += this._children[i].getNodeCount();
			} else {
				count++;
			}
		}

		return count;
	}

}

class AnimBlendTree1D extends AnimBlendTree {
	constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
		children.sort((a, b) => a.point - b.point);
		super(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
	}

	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightedDurationSum = 0.0;
		this._children[0].weight = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			const c1 = this._children[i];

			if (i !== this._children.length - 1) {
				const c2 = this._children[i + 1];

				if (c1.point === c2.point) {
					c1.weight = 0.5;
					c2.weight = 0.5;
				} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
					const child2Distance = Math.abs(c1.point - c2.point);
					const parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
					const weight = (child2Distance - parameterDistance) / child2Distance;
					c1.weight = weight;
					c2.weight = 1.0 - weight;
				} else {
					c2.weight = 0.0;
				}
			}

			if (this._syncAnimations) {
				weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
			}
		}

		if (this._syncAnimations) {
			for (let i = 0; i < this._children.length; i++) {
				const child = this._children[i];
				child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
			}
		}
	}

}

class AnimBlendTreeCartesian2D extends AnimBlendTree {
	pointDistanceCache(i, j) {
		const pointKey = `${i}${j}`;

		if (!this._pointCache[pointKey]) {
			this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
		}

		return this._pointCache[pointKey];
	}

	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightSum, weightedDurationSum;

		AnimBlendTreeCartesian2D._p.set(...this._parameterValues);

		weightSum = 0.0;
		weightedDurationSum = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			const pi = child.point;

			AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);

			let minj = Number.MAX_VALUE;

			for (let j = 0; j < this._children.length; j++) {
				if (i === j) continue;
				const pipj = this.pointDistanceCache(i, j);
				const result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
				if (result < minj) minj = result;
			}

			child.weight = minj;
			weightSum += minj;

			if (this._syncAnimations) {
				weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
			}
		}

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			child.weight = child._weight / weightSum;

			if (this._syncAnimations) {
				child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
			}
		}
	}

}

AnimBlendTreeCartesian2D._p = new Vec2();
AnimBlendTreeCartesian2D._pip = new Vec2();

class AnimBlendTreeDirectional2D extends AnimBlendTree {
	pointCache(i, j) {
		const pointKey = `${i}${j}`;

		if (!this._pointCache[pointKey]) {
			this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
		}

		return this._pointCache[pointKey];
	}

	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightSum, weightedDurationSum;

		AnimBlendTreeDirectional2D._p.set(...this._parameterValues);

		const pLength = AnimBlendTreeDirectional2D._p.length();

		weightSum = 0.0;
		weightedDurationSum = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			const pi = child.point;
			const piLength = child.pointLength;
			let minj = Number.MAX_VALUE;

			for (let j = 0; j < this._children.length; j++) {
				if (i === j) continue;
				const pipj = this.pointCache(i, j);
				const pjLength = this._children[j].pointLength;

				AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);

				const result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
				if (result < minj) minj = result;
			}

			child.weight = minj;
			weightSum += minj;

			if (this._syncAnimations) {
				weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
			}
		}

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			child.weight = child._weight / weightSum;

			if (this._syncAnimations) {
				const weightedChildDuration = child.animTrack.duration / weightedDurationSum * weightSum;
				child.weightedSpeed = child.absoluteSpeed * weightedChildDuration;
			}
		}
	}

}

AnimBlendTreeDirectional2D._p = new Vec2();
AnimBlendTreeDirectional2D._pip = new Vec2();

class AnimBlendTreeDirect extends AnimBlendTree {
	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightSum = 0.0;
		let weightedDurationSum = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			weightSum += Math.max(this._parameterValues[i], 0.0);

			if (this._syncAnimations) {
				const child = this._children[i];
				weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
			}
		}

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			child.weight = Math.max(this._parameterValues[i], 0.0) / weightSum;

			if (this._syncAnimations) {
				child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
			}
		}
	}

}

class AnimState {
	constructor(controller, name, speed, loop, blendTree) {
		this._controller = controller;
		this._name = name;
		this._animations = {};
		this._animationList = [];
		this._speed = speed || 1.0;
		this._loop = loop === undefined ? true : loop;

		const findParameter = this._controller.findParameter.bind(this._controller);

		if (blendTree) {
			this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, findParameter);
		} else {
			this._blendTree = new AnimNode(this, null, name, 1.0, speed);
		}
	}

	_createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
		switch (type) {
			case ANIM_BLEND_1D:
				return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

			case ANIM_BLEND_2D_CARTESIAN:
				return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

			case ANIM_BLEND_2D_DIRECTIONAL:
				return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

			case ANIM_BLEND_DIRECT:
				return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
		}
	}

	_getNodeFromPath(path) {
		let currNode = this._blendTree;

		for (let i = 1; i < path.length; i++) {
			currNode = currNode.getChild(path[i]);
		}

		return currNode;
	}

	addAnimation(path, animTrack) {
		const pathString = path.join('.');

		const indexOfAnimation = this._animationList.findIndex(function (animation) {
			return animation.path === pathString;
		});

		if (indexOfAnimation >= 0) {
			this._animationList[indexOfAnimation].animTrack = animTrack;
		} else {
			const node = this._getNodeFromPath(path);

			node.animTrack = animTrack;

			this._animationList.push(node);
		}
	}

	get name() {
		return this._name;
	}

	set animations(value) {
		this._animationList = value;
	}

	get animations() {
		return this._animationList;
	}

	set speed(value) {
		this._speed = value;
	}

	get speed() {
		return this._speed;
	}

	set loop(value) {
		this._loop = value;
	}

	get loop() {
		return this._loop;
	}

	get nodeCount() {
		if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
		return this._blendTree.getNodeCount();
	}

	get playable() {
		return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
	}

	get looping() {
		if (this.animations.length > 0) {
			const trackClipName = this.name + '.' + this.animations[0].animTrack.name;

			const trackClip = this._controller.animEvaluator.findClip(trackClipName);

			if (trackClip) {
				return trackClip.loop;
			}
		}

		return false;
	}

	get totalWeight() {
		let sum = 0;

		for (let i = 0; i < this.animations.length; i++) {
			sum += this.animations[i].weight;
		}

		return sum;
	}

	get timelineDuration() {
		let duration = 0;

		for (let i = 0; i < this.animations.length; i++) {
			const animation = this.animations[i];

			if (animation.animTrack.duration > duration) {
				duration = animation.animTrack.duration;
			}
		}

		return duration;
	}

}

class AnimTransition {
	constructor({
		from,
		to,
		time = 0,
		priority = 0,
		conditions = [],
		exitTime = null,
		transitionOffset = null,
		interruptionSource = ANIM_INTERRUPTION_NONE
	}) {
		this._from = from;
		this._to = to;
		this._time = time;
		this._priority = priority;
		this._conditions = conditions;
		this._exitTime = exitTime;
		this._transitionOffset = transitionOffset;
		this._interruptionSource = interruptionSource;
	}

	get from() {
		return this._from;
	}

	set to(value) {
		this._to = value;
	}

	get to() {
		return this._to;
	}

	get time() {
		return this._time;
	}

	get priority() {
		return this._priority;
	}

	get conditions() {
		return this._conditions;
	}

	get exitTime() {
		return this._exitTime;
	}

	get transitionOffset() {
		return this._transitionOffset;
	}

	get interruptionSource() {
		return this._interruptionSource;
	}

	get hasExitTime() {
		return !!this.exitTime;
	}

}

class AnimController {
	constructor(animEvaluator, states, transitions, parameters, activate, eventHandler, consumedTriggers) {
		this._animEvaluator = animEvaluator;
		this._states = {};
		this._stateNames = [];
		this._eventHandler = eventHandler;
		this._consumedTriggers = consumedTriggers;

		for (let i = 0; i < states.length; i++) {
			this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);

			this._stateNames.push(states[i].name);
		}

		this._transitions = transitions.map(transition => {
			return new AnimTransition(_extends({}, transition));
		});
		this._findTransitionsFromStateCache = {};
		this._findTransitionsBetweenStatesCache = {};
		this._parameters = parameters;
		this._previousStateName = null;
		this._activeStateName = ANIM_STATE_START;
		this._playing = false;
		this._activate = activate;
		this._currTransitionTime = 1.0;
		this._totalTransitionTime = 1.0;
		this._isTransitioning = false;
		this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
		this._transitionPreviousStates = [];
		this._timeInState = 0;
		this._timeInStateBefore = 0;
	}

	get animEvaluator() {
		return this._animEvaluator;
	}

	set activeState(stateName) {
		this._activeStateName = stateName;
	}

	get activeState() {
		return this._findState(this._activeStateName);
	}

	get activeStateName() {
		return this._activeStateName;
	}

	get activeStateAnimations() {
		return this.activeState.animations;
	}

	set previousState(stateName) {
		this._previousStateName = stateName;
	}

	get previousState() {
		return this._findState(this._previousStateName);
	}

	get previousStateName() {
		return this._previousStateName;
	}

	get playable() {
		let playable = true;

		for (let i = 0; i < this._stateNames.length; i++) {
			if (!this._states[this._stateNames[i]].playable) {
				playable = false;
			}
		}

		return playable;
	}

	set playing(value) {
		this._playing = value;
	}

	get playing() {
		return this._playing;
	}

	get activeStateProgress() {
		return this._getActiveStateProgressForTime(this._timeInState);
	}

	get activeStateDuration() {
		if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END) return 0.0;
		let maxDuration = 0.0;

		for (let i = 0; i < this.activeStateAnimations.length; i++) {
			const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);

			if (activeClip) {
				maxDuration = Math.max(maxDuration, activeClip.track.duration);
			}
		}

		return maxDuration;
	}

	set activeStateCurrentTime(time) {
		this._timeInStateBefore = time;
		this._timeInState = time;

		for (let i = 0; i < this.activeStateAnimations.length; i++) {
			const clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);

			if (clip) {
				clip.time = time;
			}
		}
	}

	get activeStateCurrentTime() {
		return this._timeInState;
	}

	get transitioning() {
		return this._isTransitioning;
	}

	get transitionProgress() {
		return this._currTransitionTime / this._totalTransitionTime;
	}

	get states() {
		return this._stateNames;
	}

	assignMask(mask) {
		return this._animEvaluator.assignMask(mask);
	}

	_findState(stateName) {
		return this._states[stateName];
	}

	_getActiveStateProgressForTime(time) {
		if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) return 1.0;

		const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);

		if (activeClip) {
			return time / activeClip.track.duration;
		}

		return null;
	}

	_findTransitionsFromState(stateName) {
		let transitions = this._findTransitionsFromStateCache[stateName];

		if (!transitions) {
			transitions = this._transitions.filter(function (transition) {
				return transition.from === stateName;
			});
			transitions.sort(function (a, b) {
				return a.priority < b.priority;
			});
			this._findTransitionsFromStateCache[stateName] = transitions;
		}

		return transitions;
	}

	_findTransitionsBetweenStates(sourceStateName, destinationStateName) {
		let transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];

		if (!transitions) {
			transitions = this._transitions.filter(function (transition) {
				return transition.from === sourceStateName && transition.to === destinationStateName;
			});
			transitions.sort(function (a, b) {
				return a.priority < b.priority;
			});
			this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;
		}

		return transitions;
	}

	_transitionHasConditionsMet(transition) {
		const conditions = transition.conditions;

		for (let i = 0; i < conditions.length; i++) {
			const condition = conditions[i];
			const parameter = this.findParameter(condition.parameterName);

			switch (condition.predicate) {
				case ANIM_GREATER_THAN:
					if (!(parameter.value > condition.value)) return false;
					break;

				case ANIM_LESS_THAN:
					if (!(parameter.value < condition.value)) return false;
					break;

				case ANIM_GREATER_THAN_EQUAL_TO:
					if (!(parameter.value >= condition.value)) return false;
					break;

				case ANIM_LESS_THAN_EQUAL_TO:
					if (!(parameter.value <= condition.value)) return false;
					break;

				case ANIM_EQUAL_TO:
					if (!(parameter.value === condition.value)) return false;
					break;

				case ANIM_NOT_EQUAL_TO:
					if (!(parameter.value !== condition.value)) return false;
					break;
			}
		}

		return true;
	}

	_findTransition(from, to) {
		let transitions = [];

		if (from && to) {
			transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
		} else {
			if (!this._isTransitioning) {
				transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
				transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
			} else {
				switch (this._transitionInterruptionSource) {
					case ANIM_INTERRUPTION_PREV:
						transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;

					case ANIM_INTERRUPTION_NEXT:
						transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;

					case ANIM_INTERRUPTION_PREV_NEXT:
						transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
						transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;

					case ANIM_INTERRUPTION_NEXT_PREV:
						transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
						transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;
				}
			}
		}

		transitions = transitions.filter(transition => {
			if (transition.to === this.activeStateName) {
				return false;
			}

			if (transition.hasExitTime) {
				let progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);

				let progress = this._getActiveStateProgressForTime(this._timeInState);

				if (transition.exitTime < 1.0 && this.activeState.loop) {
					progressBefore -= Math.floor(progressBefore);
					progress -= Math.floor(progress);
				}

				if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
					return null;
				}
			}

			return this._transitionHasConditionsMet(transition);
		});

		if (transitions.length > 0) {
			const transition = transitions[0];

			if (transition.to === ANIM_STATE_END) {
				const startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];

				transition.to = startTransition.to;
			}

			return transition;
		}

		return null;
	}

	updateStateFromTransition(transition) {
		let state;
		let animation;
		let clip;
		this.previousState = transition.from ? this.activeStateName : null;
		this.activeState = transition.to;

		for (let i = 0; i < transition.conditions.length; i++) {
			const condition = transition.conditions[i];
			const parameter = this.findParameter(condition.parameterName);

			if (parameter.type === ANIM_PARAMETER_TRIGGER) {
				this._consumedTriggers.add(condition.parameterName);
			}
		}

		if (this.previousState) {
			if (!this._isTransitioning) {
				this._transitionPreviousStates = [];
			}

			this._transitionPreviousStates.push({
				name: this._previousStateName,
				weight: 1
			});

			const interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);

			for (let i = 0; i < this._transitionPreviousStates.length; i++) {
				if (!this._isTransitioning) {
					this._transitionPreviousStates[i].weight = 1.0;
				} else if (i !== this._transitionPreviousStates.length - 1) {
					this._transitionPreviousStates[i].weight *= 1.0 - interpolatedTime;
				} else {
					this._transitionPreviousStates[i].weight = interpolatedTime;
				}

				state = this._findState(this._transitionPreviousStates[i].name);

				for (let j = 0; j < state.animations.length; j++) {
					animation = state.animations[j];
					clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);

					if (!clip) {
						clip = this._animEvaluator.findClip(animation.name);
						clip.name = animation.name + '.previous.' + i;
					}

					if (i !== this._transitionPreviousStates.length - 1) {
						clip.pause();
					}
				}
			}
		}

		this._isTransitioning = true;
		this._totalTransitionTime = transition.time;
		this._currTransitionTime = 0;
		this._transitionInterruptionSource = transition.interruptionSource;
		const activeState = this.activeState;
		const hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
		let timeInState = 0;
		let timeInStateBefore = 0;

		if (hasTransitionOffset) {
			const offsetTime = activeState.timelineDuration * transition.transitionOffset;
			timeInState = offsetTime;
			timeInStateBefore = offsetTime;
		}

		this._timeInState = timeInState;
		this._timeInStateBefore = timeInStateBefore;

		for (let i = 0; i < activeState.animations.length; i++) {
			clip = this._animEvaluator.findClip(activeState.animations[i].name);

			if (!clip) {
				const speed = Number.isFinite(activeState.animations[i].speed) ? activeState.animations[i].speed : activeState.speed;
				clip = new AnimClip(activeState.animations[i].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
				clip.name = activeState.animations[i].name;

				this._animEvaluator.addClip(clip);
			} else {
				clip.reset();
			}

			if (transition.time > 0) {
				clip.blendWeight = 0.0;
			} else {
				clip.blendWeight = activeState.animations[i].normalizedWeight;
			}

			clip.play();

			if (hasTransitionOffset) {
				clip.time = activeState.timelineDuration * transition.transitionOffset;
			} else {
				const startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
				clip.time = startTime;
			}
		}
	}

	_transitionToState(newStateName) {
		if (!this._findState(newStateName)) {
			return;
		}

		let transition = this._findTransition(this._activeStateName, newStateName);

		if (!transition) {
			this._animEvaluator.removeClips();

			transition = new AnimTransition({
				from: null,
				to: newStateName
			});
		}

		this.updateStateFromTransition(transition);
	}

	assignAnimation(pathString, animTrack, speed, loop) {
		const path = pathString.split('.');

		let state = this._findState(path[0]);

		if (!state) {
			state = new AnimState(this, path[0], 1.0);
			this._states[path[0]] = state;

			this._stateNames.push(path[0]);
		}

		state.addAnimation(path, animTrack);

		if (speed !== undefined) {
			state.speed = speed;
		}

		if (loop !== undefined) {
			state.loop = loop;
		}

		if (!this._playing && this._activate && this.playable) {
			this.play();
		}
	}

	removeNodeAnimations(nodeName) {
		if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
			return;
		}

		const state = this._findState(nodeName);

		if (!state) {
			return;
		}

		state.animations = [];
		return true;
	}

	play(stateName) {
		if (stateName) {
			this._transitionToState(stateName);
		}

		this._playing = true;
	}

	pause() {
		this._playing = false;
	}

	reset() {
		this._previousStateName = null;
		this._activeStateName = ANIM_STATE_START;
		this._playing = false;
		this._currTransitionTime = 1.0;
		this._totalTransitionTime = 1.0;
		this._isTransitioning = false;
		this._timeInState = 0;
		this._timeInStateBefore = 0;

		this._animEvaluator.removeClips();
	}

	rebind() {
		this._animEvaluator.rebind();
	}

	update(dt) {
		if (!this._playing) {
			return;
		}

		let state;
		let animation;
		let clip;
		this._timeInStateBefore = this._timeInState;
		this._timeInState += dt;

		const transition = this._findTransition(this._activeStateName);

		if (transition) this.updateStateFromTransition(transition);

		if (this._isTransitioning) {
			this._currTransitionTime += dt;

			if (this._currTransitionTime <= this._totalTransitionTime) {
				const interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;

				for (let i = 0; i < this._transitionPreviousStates.length; i++) {
					state = this._findState(this._transitionPreviousStates[i].name);
					const stateWeight = this._transitionPreviousStates[i].weight;

					for (let j = 0; j < state.animations.length; j++) {
						animation = state.animations[j];
						clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);

						if (clip) {
							clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
						}
					}
				}

				state = this.activeState;

				for (let i = 0; i < state.animations.length; i++) {
					animation = state.animations[i];
					this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
				}
			} else {
				this._isTransitioning = false;
				const activeClips = this.activeStateAnimations.length;
				const totalClips = this._animEvaluator.clips.length;

				for (let i = 0; i < totalClips - activeClips; i++) {
					this._animEvaluator.removeClip(0);
				}

				this._transitionPreviousStates = [];
				state = this.activeState;

				for (let i = 0; i < state.animations.length; i++) {
					animation = state.animations[i];
					clip = this._animEvaluator.findClip(animation.name);

					if (clip) {
						clip.blendWeight = animation.normalizedWeight;
					}
				}
			}
		} else {
			if (this.activeState._blendTree.constructor !== AnimNode) {
				state = this.activeState;

				for (let i = 0; i < state.animations.length; i++) {
					animation = state.animations[i];
					clip = this._animEvaluator.findClip(animation.name);

					if (clip) {
						clip.blendWeight = animation.normalizedWeight;

						if (animation.parent.syncAnimations) {
							clip.speed = animation.speed;
						}
					}
				}
			}
		}

		this._animEvaluator.update(dt);
	}

	findParameter(name) {
		return this._parameters[name];
	}

}

const v2 = new Vec2();
const v3 = new Vec3();
const v4 = new Vec4();
const c = new Color();
const q = new Quat();

class AnimComponentBinder extends DefaultAnimBinder {
	constructor(animComponent, graph, layerName, mask, layerIndex) {
		super(graph);
		this.animComponent = animComponent;
		this._mask = mask;
		this.layerName = layerName;
		this.layerIndex = layerIndex;
	}

	static _packFloat(values) {
		return values[0];
	}

	static _packBoolean(values) {
		return !!values[0];
	}

	static _packVec2(values) {
		v2.x = values[0];
		v2.y = values[1];
		return v2;
	}

	static _packVec3(values) {
		v3.x = values[0];
		v3.y = values[1];
		v3.z = values[2];
		return v3;
	}

	static _packVec4(values) {
		v4.x = values[0];
		v4.y = values[1];
		v4.z = values[2];
		v4.w = values[3];
		return v4;
	}

	static _packColor(values) {
		c.r = values[0];
		c.g = values[1];
		c.b = values[2];
		c.a = values[3];
		return c;
	}

	static _packQuat(values) {
		q.x = values[0];
		q.y = values[1];
		q.z = values[2];
		q.w = values[3];
		return q;
	}

	resolve(path) {
		const encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
		let target = this.targetCache[encodedPath];
		if (target) return target;
		let entity;
		let propertyComponent;
		let targetPath;

		switch (path.component) {
			case 'entity':
				entity = this._getEntityFromHierarchy(path.entityPath);
				targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
				propertyComponent = entity;
				break;

			case 'graph':
				propertyComponent = this.findNode(path);
				if (!propertyComponent) return null;
				targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
				break;

			default:
				entity = this._getEntityFromHierarchy(path.entityPath);
				propertyComponent = entity.findComponent(path.component);
				if (!propertyComponent) return null;
				targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
				break;
		}

		target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
		this.targetCache[encodedPath] = target;
		return target;
	}

	update(deltaTime) {
		const activeNodes = this.activeNodes;

		if (activeNodes) {
			for (let i = 0; i < activeNodes.length; i++) {
				activeNodes[i]._dirtifyLocal();
			}
		}
	}

	_getEntityFromHierarchy(entityHierarchy) {
		if (!this.animComponent.entity.name === entityHierarchy[0]) {
			return null;
		}

		const currEntity = this.animComponent.entity;

		if (entityHierarchy.length === 1) {
			return currEntity;
		}

		return currEntity._parent.findByPath(entityHierarchy);
	}

	_resolvePath(object, path, resolveLeaf) {
		const steps = path.length - (resolveLeaf ? 0 : 1);

		for (let i = 0; i < steps; i++) {
			object = object[path[i]];
		}

		return object;
	}

	_setter(object, path, packFunc) {
		const obj = this._resolvePath(object, path);

		const key = path[path.length - 1];
		const setterFunc = "set" + key.substring(0, 1).toUpperCase() + key.substring(1);

		if (obj[setterFunc]) {
			const func = obj[setterFunc].bind(obj);
			return function (values) {
				func(packFunc(values));
			};
		}

		const prop = obj[key];

		if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
			return function (values) {
				prop.copy(packFunc(values));
			};
		}

		if ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {
			const parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
			const objKey = path[path.length - 2];
			return function (values) {
				obj[key] = packFunc(values);
				parent[objKey] = obj;
			};
		}

		return function (values) {
			obj[key] = packFunc(values);
		};
	}

	_createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
		if (this.handlers && propertyHierarchy[0] === 'weights') {
			return this.handlers.weights(propertyComponent);
		} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
			const materialPropertyName = propertyHierarchy[1];

			if (materialPropertyName.endsWith('Map')) {
				return this.handlers.materialTexture(propertyComponent, materialPropertyName);
			}
		}

		const property = this._resolvePath(propertyComponent, propertyHierarchy, true);

		if (typeof property === 'undefined') return null;
		let setter;
		let animDataType;
		let animDataComponents;

		if (typeof property === 'number') {
			setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
			animDataType = 'vector';
			animDataComponents = 1;
		} else if (typeof property === 'boolean') {
			setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
			animDataType = 'vector';
			animDataComponents = 1;
		} else if (typeof property === 'object') {
			switch (property.constructor) {
				case Vec2:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
					animDataType = 'vector';
					animDataComponents = 2;
					break;

				case Vec3:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
					animDataType = 'vector';
					animDataComponents = 3;
					break;

				case Vec4:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
					animDataType = 'vector';
					animDataComponents = 4;
					break;

				case Color:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
					animDataType = 'vector';
					animDataComponents = 4;
					break;

				case Quat:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
					animDataType = 'quaternion';
					animDataComponents = 4;
					break;

				default:
					return null;
			}
		}

		if (propertyHierarchy.indexOf('material') !== -1) {
			return new AnimTarget(function (values) {
				setter(values);
				propertyComponent.material.update();
			}, animDataType, animDataComponents, targetPath);
		}

		return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
	}

	rebind() {
		this.targetCache = {};

		if (this.animComponent.rootBone) {
			this.graph = this.animComponent.rootBone;
		} else {
			this.graph = this.animComponent.entity;
		}

		const nodes = {};

		const flatten = function flatten(node) {
			nodes[node.name] = node;

			for (let i = 0; i < node.children.length; ++i) {
				flatten(node.children[i]);
			}
		};

		flatten(this.graph);
		this.nodes = nodes;
	}

}

class AnimComponentLayer {
	constructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE) {
		this._name = name;
		this._controller = controller;
		this._component = component;
		this._weight = weight;
		this._blendType = blendType;
		this._mask = null;
	}

	get name() {
		return this._name;
	}

	set playing(value) {
		this._controller.playing = value;
	}

	get playing() {
		return this._controller.playing;
	}

	get playable() {
		return this._controller.playable;
	}

	get activeState() {
		return this._controller.activeStateName;
	}

	get previousState() {
		return this._controller.previousStateName;
	}

	get activeStateProgress() {
		return this._controller.activeStateProgress;
	}

	get activeStateDuration() {
		return this._controller.activeStateDuration;
	}

	set activeStateCurrentTime(time) {
		const controller = this._controller;
		const layerPlaying = controller.playing;
		controller.playing = true;
		controller.activeStateCurrentTime = time;

		if (!layerPlaying) {
			controller.update(0);
		}

		controller.playing = layerPlaying;
	}

	get activeStateCurrentTime() {
		return this._controller.activeStateCurrentTime;
	}

	get transitioning() {
		return this._controller.transitioning;
	}

	get transitionProgress() {
		if (this.transitioning) {
			return this._controller.transitionProgress;
		}

		return null;
	}

	get states() {
		return this._controller.states;
	}

	set weight(value) {
		this._weight = value;

		this._component.dirtifyTargets();
	}

	get weight() {
		return this._weight;
	}

	set blendType(value) {
		if (value !== this._blendType) {
			this._blendType = value;

			this._component.rebind();
		}
	}

	get blendType() {
		return this._blendType;
	}

	set mask(value) {
		if (this._controller.assignMask(value)) {
			this._component.rebind();
		}

		this._mask = value;
	}

	get mask() {
		return this._mask;
	}

	play(name) {
		this._controller.play(name);
	}

	pause() {
		this._controller.pause();
	}

	reset() {
		this._controller.reset();
	}

	rebind() {
		this._controller.rebind();
	}

	update(dt) {
		this._controller.update(dt);
	}

	assignMask(mask) {
		if (this._controller.assignMask(mask)) {
			this._component.rebind();
		}

		this._mask = mask;
	}

	assignAnimation(nodePath, animTrack, speed, loop) {
		if (animTrack.constructor !== AnimTrack) {
			return;
		}

		this._controller.assignAnimation(nodePath, animTrack, speed, loop);

		if (this._controller._transitions.length === 0) {
			this._controller._transitions.push(new AnimTransition({
				from: 'START',
				to: nodePath
			}));
		}

		if (this._component.activate && this._component.playable) {
			this._component.playing = true;
		}
	}

	removeNodeAnimations(nodeName) {
		if (this._controller.removeNodeAnimations(nodeName)) {
			this._component.playing = false;
		}
	}

	getAnimationAsset(stateName) {
		return this._component.animationAssets[`${this.name}:${stateName}`];
	}

	transition(to, time = 0, transitionOffset = null) {
		this._controller.updateStateFromTransition(new AnimTransition({
			from: this._controller.activeStateName,
			to,
			time,
			transitionOffset
		}));
	}

}

class AnimComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._stateGraphAsset = null;
		this._animationAssets = {};
		this._speed = 1.0;
		this._activate = true;
		this._playing = false;
		this._rootBone = null;
		this._stateGraph = null;
		this._layers = [];
		this._layerIndices = {};
		this._parameters = {};
		this._targets = {};
		this._consumedTriggers = new Set();
	}

	set stateGraphAsset(value) {
		if (value === null) {
			this.removeStateGraph();
			return;
		}

		if (this._stateGraphAsset) {
			const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
			stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
		}

		let _id;

		let _asset;

		if (value instanceof Asset) {
			_id = value.id;
			_asset = this.system.app.assets.get(_id);

			if (!_asset) {
				this.system.app.assets.add(value);
				_asset = this.system.app.assets.get(_id);
			}
		} else {
			_id = value;
			_asset = this.system.app.assets.get(_id);
		}

		if (!_asset || this._stateGraphAsset === _id) {
			return;
		}

		if (_asset.resource) {
			this._stateGraph = _asset.resource;
			this.loadStateGraph(this._stateGraph);

			_asset.on('change', this._onStateGraphAssetChangeEvent, this);
		} else {
			_asset.once('load', asset => {
				this._stateGraph = asset.resource;
				this.loadStateGraph(this._stateGraph);
			});

			_asset.on('change', this._onStateGraphAssetChangeEvent, this);

			this.system.app.assets.load(_asset);
		}

		this._stateGraphAsset = _id;
	}

	get stateGraphAsset() {
		return this._stateGraphAsset;
	}

	set animationAssets(value) {
		this._animationAssets = value;
		this.loadAnimationAssets();
	}

	get animationAssets() {
		return this._animationAssets;
	}

	set speed(value) {
		this._speed = value;
	}

	get speed() {
		return this._speed;
	}

	set activate(value) {
		this._activate = value;
	}

	get activate() {
		return this._activate;
	}

	set playing(value) {
		this._playing = value;
	}

	get playing() {
		return this._playing;
	}

	set rootBone(value) {
		if (typeof value === 'string') {
			const entity = this.entity.root.findByGuid(value);
			this._rootBone = entity;
		} else if (value instanceof Entity) {
			this._rootBone = value;
		} else {
			this._rootBone = null;
		}

		this.rebind();
	}

	get rootBone() {
		return this._rootBone;
	}

	set stateGraph(value) {
		this._stateGraph = value;
	}

	get stateGraph() {
		return this._stateGraph;
	}

	get layers() {
		return this._layers;
	}

	set layerIndices(value) {
		this._layerIndices = value;
	}

	get layerIndices() {
		return this._layerIndices;
	}

	set parameters(value) {
		this._parameters = value;
	}

	get parameters() {
		return this._parameters;
	}

	set targets(value) {
		this._targets = value;
	}

	get targets() {
		return this._targets;
	}

	get playable() {
		for (let i = 0; i < this._layers.length; i++) {
			if (!this._layers[i].playable) {
				return false;
			}
		}

		return true;
	}

	get baseLayer() {
		if (this._layers.length > 0) {
			return this._layers[0];
		}

		return null;
	}

	_onStateGraphAssetChangeEvent(asset) {
		const prevAnimationAssets = this.animationAssets;
		const prevMasks = this.layers.map(layer => layer.mask);
		this.removeStateGraph();
		this._stateGraph = new AnimStateGraph(asset._data);
		this.loadStateGraph(this._stateGraph);
		this.animationAssets = prevAnimationAssets;
		this.loadAnimationAssets();
		this.layers.forEach((layer, i) => {
			layer.mask = prevMasks[i];
		});
		this.rebind();
	}

	dirtifyTargets() {
		const targets = Object.values(this._targets);

		for (let i = 0; i < targets.length; i++) {
			targets[i].dirty = true;
		}
	}

	_addLayer({
		name,
		states,
		transitions,
		weight,
		mask,
		blendType
	}) {
		let graph;

		if (this.rootBone) {
			graph = this.rootBone;
		} else {
			graph = this.entity;
		}

		const layerIndex = this._layers.length;
		const animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
		const animEvaluator = new AnimEvaluator(animBinder);
		const controller = new AnimController(animEvaluator, states, transitions, this._parameters, this._activate, this, this._consumedTriggers);

		this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));

		this._layerIndices[name] = layerIndex;
		return this._layers[layerIndex];
	}

	addLayer(name, weight, mask, blendType) {
		const layer = this.findAnimationLayer(name);
		if (layer) return layer;
		const states = [{
			"name": "START",
			"speed": 1
		}];
		const transitions = [];
		return this._addLayer({
			name,
			states,
			transitions,
			weight,
			mask,
			blendType
		});
	}

	loadStateGraph(stateGraph) {
		this._stateGraph = stateGraph;
		this._parameters = {};
		const paramKeys = Object.keys(stateGraph.parameters);

		for (let i = 0; i < paramKeys.length; i++) {
			const paramKey = paramKeys[i];
			this._parameters[paramKey] = {
				type: stateGraph.parameters[paramKey].type,
				value: stateGraph.parameters[paramKey].value
			};
		}

		this._layers = [];

		for (let i = 0; i < stateGraph.layers.length; i++) {
			const layer = stateGraph.layers[i];

			this._addLayer.bind(this)(_extends({}, layer));
		}

		this.setupAnimationAssets();
	}

	setupAnimationAssets() {
		for (let i = 0; i < this._layers.length; i++) {
			const layer = this._layers[i];
			const layerName = layer.name;

			for (let j = 0; j < layer.states.length; j++) {
				const stateName = layer.states[j];

				if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
					const stateKey = layerName + ':' + stateName;

					if (!this._animationAssets[stateKey]) {
						this._animationAssets[stateKey] = {
							asset: null
						};
					}
				}
			}
		}

		this.loadAnimationAssets();
	}

	loadAnimationAssets() {
		for (let i = 0; i < this._layers.length; i++) {
			const layer = this._layers[i];

			for (let j = 0; j < layer.states.length; j++) {
				const stateName = layer.states[j];
				if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
				const animationAsset = this._animationAssets[layer.name + ':' + stateName];

				if (!animationAsset || !animationAsset.asset) {
					this.removeNodeAnimations(stateName, layer.name);
					continue;
				}

				const assetId = animationAsset.asset;
				const asset = this.system.app.assets.get(assetId);

				if (asset) {
					if (asset.resource) {
						this.onAnimationAssetLoaded(layer.name, stateName, asset);
					} else {
						asset.once('load', function (layerName, stateName) {
							return function (asset) {
								this.onAnimationAssetLoaded(layerName, stateName, asset);
							}.bind(this);
						}.bind(this)(layer.name, stateName));
						this.system.app.assets.load(asset);
					}
				}
			}
		}
	}

	onAnimationAssetLoaded(layerName, stateName, asset) {
		const animTrack = asset.resource;

		if (asset.data.events) {
			animTrack.events = new AnimEvents(Object.values(asset.data.events));
		}

		this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
	}

	removeStateGraph() {
		this._stateGraph = null;
		this._stateGraphAsset = null;
		this._animationAssets = {};
		this._layers = [];
		this._layerIndices = {};
		this._parameters = {};
		this._playing = false;
	}

	resetStateGraph() {
		if (this.stateGraphAsset) {
			const stateGraph = this.system.app.assets.get(this.stateGraphAsset).resource;
			this.loadStateGraph(stateGraph);
		} else {
			this.removeStateGraph();
		}
	}

	reset() {
		this._parameters = Object.assign({}, this._stateGraph.parameters);

		for (let i = 0; i < this._layers.length; i++) {
			const layerPlaying = this._layers[i].playing;

			this._layers[i].reset();

			this._layers[i].playing = layerPlaying;
		}
	}

	rebind() {
		this._targets = {};

		for (let i = 0; i < this._layers.length; i++) {
			this._layers[i].rebind();
		}
	}

	findAnimationLayer(name) {
		const layerIndex = this._layerIndices[name];
		return this._layers[layerIndex] || null;
	}

	addAnimationState(nodeName, animTrack, speed = 1, loop = true, layerName = 'Base') {
		if (!this._stateGraph) {
			this.loadStateGraph(new AnimStateGraph({
				"layers": [{
					"name": layerName,
					"states": [{
						"name": "START",
						"speed": 1
					}, {
						"name": nodeName,
						"speed": speed,
						"loop": loop,
						"defaultState": true
					}],
					"transitions": [{
						"from": 'START',
						"to": nodeName
					}]
				}],
				"parameters": {}
			}));
		}

		const layer = this.findAnimationLayer(layerName);

		if (layer) {
			layer.assignAnimation(nodeName, animTrack, speed, loop);
		} else {
			var _this$addLayer;

			(_this$addLayer = this.addLayer(layerName)) == null ? void 0 : _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);
		}
	}

	assignAnimation(nodePath, animTrack, layerName, speed = 1, loop = true) {
		if (!this._stateGraph && nodePath.indexOf('.') === -1) {
			this.loadStateGraph(new AnimStateGraph({
				"layers": [{
					"name": "Base",
					"states": [{
						"name": "START",
						"speed": 1
					}, {
						"name": nodePath,
						"speed": speed,
						"loop": loop,
						"defaultState": true
					}],
					"transitions": [{
						"from": 'START',
						"to": nodePath
					}]
				}],
				"parameters": {}
			}));
			this.baseLayer.assignAnimation(nodePath, animTrack);
			return;
		}

		const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

		if (!layer) {
			return;
		}

		layer.assignAnimation(nodePath, animTrack, speed, loop);
	}

	removeNodeAnimations(nodeName, layerName) {
		const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

		if (!layer) {
			return;
		}

		layer.removeNodeAnimations(nodeName);
	}

	getParameterValue(name, type) {
		const param = this._parameters[name];

		if (param && param.type === type) {
			return param.value;
		}
	}

	setParameterValue(name, type, value) {
		const param = this._parameters[name];

		if (param && param.type === type) {
			param.value = value;
			return;
		}
	}

	getFloat(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
	}

	setFloat(name, value) {
		this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
	}

	getInteger(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
	}

	setInteger(name, value) {
		if (typeof value === 'number' && value % 1 === 0) {
			this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
		}
	}

	getBoolean(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
	}

	setBoolean(name, value) {
		this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
	}

	getTrigger(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
	}

	setTrigger(name, singleFrame = false) {
		this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);

		if (singleFrame) {
			this._consumedTriggers.add(name);
		}
	}

	resetTrigger(name) {
		this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
	}

	onBeforeRemove() {
		if (Number.isFinite(this._stateGraphAsset)) {
			const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
			stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
		}
	}

	update(dt) {
		for (let i = 0; i < this.layers.length; i++) {
			this.layers[i].update(dt * this.speed);
		}

		this._consumedTriggers.forEach(trigger => {
			this.parameters[trigger].value = false;
		});

		this._consumedTriggers.clear();
	}

	resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
		if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
			this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
		} else {
			this.rebind();
		}
	}

}

class AnimComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$k = ['enabled'];

class AnimComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'anim';
		this.ComponentType = AnimComponent;
		this.DataType = AnimComponentData;
		this.schema = _schema$k;
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on('animationUpdate', this.onAnimationUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		super.initializeComponentData(component, data, _schema$k);
		const complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];
		Object.keys(data).forEach(key => {
			if (complexProperties.includes(key)) return;
			component[key] = data[key];
		});

		if (data.stateGraph) {
			component.stateGraph = data.stateGraph;
			component.loadStateGraph(component.stateGraph);
		}

		if (data.layers) {
			data.layers.forEach((layer, i) => {
				layer._controller.states.forEach(stateKey => {
					layer._controller._states[stateKey]._animationList.forEach(node => {
						component.layers[i].assignAnimation(node.name, node.animTrack);
					});
				});
			});
		} else if (data.animationAssets) {
			component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
		}

		if (data.masks) {
			Object.keys(data.masks).forEach(key => {
				if (component.layers[key]) {
					const maskData = data.masks[key].mask;
					const mask = {};
					Object.keys(maskData).forEach(maskKey => {
						mask[decodeURI(maskKey)] = maskData[maskKey];
					});
					component.layers[key].mask = mask;
				}
			});
		}
	}

	onAnimationUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id].entity.anim;
				const componentData = component.data;

				if (componentData.enabled && component.entity.enabled && component.playing) {
					component.update(dt);
				}
			}
		}
	}

	cloneComponent(entity, clone) {
		const data = {
			stateGraphAsset: entity.anim.stateGraphAsset,
			animationAssets: entity.anim.animationAssets,
			speed: entity.anim.speed,
			activate: entity.anim.activate,
			playing: entity.anim.playing,
			rootBone: entity.anim.rootBone,
			stateGraph: entity.anim.stateGraph,
			layers: entity.anim.layers,
			layerIndices: entity.anim.layerIndices,
			parameters: entity.anim.parameters
		};
		this.addComponent(clone, data);
	}

	onBeforeRemove(entity, component) {
		component.onBeforeRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
	}

}

Component._buildAccessors(AnimComponent.prototype, _schema$k);

class AudioListenerComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
	}

	setCurrentListener() {
		if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
			this.system.current = this.entity;
			const position = this.system.current.getPosition();
			this.system.manager.listener.setPosition(position);
		}
	}

	onEnable() {
		this.setCurrentListener();
	}

	onDisable() {
		if (this.system.current === this.entity) {
			this.system.current = null;
		}
	}

}

class AudioListenerComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$j = ['enabled'];

class AudioListenerComponentSystem extends ComponentSystem {
	constructor(app, manager) {
		super(app);
		this.id = "audiolistener";
		this.ComponentType = AudioListenerComponent;
		this.DataType = AudioListenerComponentData;
		this.schema = _schema$j;
		this.manager = manager;
		this.current = null;
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['enabled'];
		super.initializeComponentData(component, data, properties);
	}

	onUpdate(dt) {
		if (this.current) {
			const position = this.current.getPosition();
			this.manager.listener.setPosition(position);
			const wtm = this.current.getWorldTransform();
			this.manager.listener.setOrientation(wtm);
		}
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(AudioListenerComponent.prototype, _schema$j);

class AudioSourceComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.on("set_assets", this.onSetAssets, this);
		this.on("set_loop", this.onSetLoop, this);
		this.on("set_volume", this.onSetVolume, this);
		this.on("set_pitch", this.onSetPitch, this);
		this.on("set_minDistance", this.onSetMinDistance, this);
		this.on("set_maxDistance", this.onSetMaxDistance, this);
		this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
		this.on("set_distanceModel", this.onSetDistanceModel, this);
		this.on("set_3d", this.onSet3d, this);
	}

	play(name) {
		if (!this.enabled || !this.entity.enabled) {
			return;
		}

		if (this.channel) {
			this.stop();
		}

		let channel;
		const componentData = this.data;

		if (componentData.sources[name]) {
			if (!componentData['3d']) {
				channel = this.system.manager.playSound(componentData.sources[name], componentData);
				componentData.currentSource = name;
				componentData.channel = channel;
			} else {
				const pos = this.entity.getPosition();
				channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
				componentData.currentSource = name;
				componentData.channel = channel;
			}
		}
	}

	pause() {
		if (this.channel) {
			this.channel.pause();
		}
	}

	unpause() {
		if (this.channel && this.channel.paused) {
			this.channel.unpause();
		}
	}

	stop() {
		if (this.channel) {
			this.channel.stop();
			this.channel = null;
		}
	}

	onSetAssets(name, oldValue, newValue) {
		const newAssets = [];
		const len = newValue.length;

		if (oldValue && oldValue.length) {
			for (let i = 0; i < oldValue.length; i++) {
				if (oldValue[i]) {
					const asset = this.system.app.assets.get(oldValue[i]);

					if (asset) {
						asset.off('change', this.onAssetChanged, this);
						asset.off('remove', this.onAssetRemoved, this);

						if (this.currentSource === asset.name) {
							this.stop();
						}
					}
				}
			}
		}

		if (len) {
			for (let i = 0; i < len; i++) {
				if (oldValue.indexOf(newValue[i]) < 0) {
					if (newValue[i] instanceof Asset) {
						newAssets.push(newValue[i].id);
					} else {
						newAssets.push(newValue[i]);
					}
				}
			}
		}

		if (!this.system._inTools && newAssets.length) {
			this.loadAudioSourceAssets(newAssets);
		}
	}

	onAssetChanged(asset, attribute, newValue, oldValue) {
		if (attribute === 'resource') {
			const sources = this.data.sources;

			if (sources) {
				this.data.sources[asset.name] = newValue;

				if (this.data.currentSource === asset.name) {
					if (this.channel) {
						if (this.channel.paused) {
							this.play(asset.name);
							this.pause();
						} else {
							this.play(asset.name);
						}
					}
				}
			}
		}
	}

	onAssetRemoved(asset) {
		asset.off('remove', this.onAssetRemoved, this);

		if (this.data.sources[asset.name]) {
			delete this.data.sources[asset.name];

			if (this.data.currentSource === asset.name) {
				this.stop();
				this.data.currentSource = null;
			}
		}
	}

	onSetLoop(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel) {
				this.channel.setLoop(newValue);
			}
		}
	}

	onSetVolume(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel) {
				this.channel.setVolume(newValue);
			}
		}
	}

	onSetPitch(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel) {
				this.channel.setPitch(newValue);
			}
		}
	}

	onSetMaxDistance(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setMaxDistance(newValue);
			}
		}
	}

	onSetMinDistance(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setMinDistance(newValue);
			}
		}
	}

	onSetRollOffFactor(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setRollOffFactor(newValue);
			}
		}
	}

	onSetDistanceModel(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setDistanceModel(newValue);
			}
		}
	}

	onSet3d(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.system.initialized && this.currentSource) {
				let paused = false;
				let suspended = false;

				if (this.channel) {
					paused = this.channel.paused;
					suspended = this.channel.suspended;
				}

				this.play(this.currentSource);

				if (this.channel) {
					this.channel.paused = paused;
					this.channel.suspended = suspended;
				}
			}
		}
	}

	onEnable() {
		const assets = this.data.assets;

		if (assets) {
			const registry = this.system.app.assets;

			for (let i = 0, len = assets.length; i < len; i++) {
				let asset = assets[i];
				if (!(asset instanceof Asset)) asset = registry.get(asset);

				if (asset && !asset.resource) {
					registry.load(asset);
				}
			}
		}

		if (this.system.initialized) {
			if (this.data.activate && !this.channel) {
				this.play(this.currentSource);
			} else {
				this.unpause();
			}
		}
	}

	onDisable() {
		this.pause();
	}

	loadAudioSourceAssets(ids) {
		const assets = ids.map(id => {
			return this.system.app.assets.get(id);
		});
		const sources = {};
		let currentSource = null;
		let count = assets.length;

		const _error = e => {
			count--;
		};

		const _done = () => {
			this.data.sources = sources;
			this.data.currentSource = currentSource;

			if (this.enabled && this.activate && currentSource) {
				this.onEnable();
			}
		};

		assets.forEach((asset, index) => {
			if (asset) {
				currentSource = currentSource || asset.name;
				asset.off('change', this.onAssetChanged, this);
				asset.on('change', this.onAssetChanged, this);
				asset.off('remove', this.onAssetRemoved, this);
				asset.on('remove', this.onAssetRemoved, this);
				asset.off('error', _error, this);
				asset.on('error', _error, this);
				asset.ready(asset => {
					sources[asset.name] = asset.resource;
					count--;

					if (count === 0) {
						_done();
					}
				});
				if (!asset.resource && this.enabled && this.entity.enabled) this.system.app.assets.load(asset);
			} else {
				count--;

				if (count === 0) {
					_done();
				}

				this.system.app.assets.on("add:" + ids[index], asset => {
					asset.ready(asset => {
						this.data.sources[asset.name] = asset.resource;
					});
					if (!asset.resource) this.system.app.assets.load(asset);
				});
			}
		});
	}

}

class AudioSourceComponentData {
	constructor() {
		this.enabled = true;
		this.assets = [];
		this.activate = true;
		this.volume = 1;
		this.pitch = 1;
		this.loop = false;
		this['3d'] = true;
		this.minDistance = 1;
		this.maxDistance = 10000;
		this.rollOffFactor = 1;
		this.distanceModel = DISTANCE_INVERSE;
		this.paused = true;
		this.sources = {};
		this.currentSource = null;
		this.channel = null;
	}

}

const _schema$i = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];

class AudioSourceComponentSystem extends ComponentSystem {
	constructor(app, manager) {
		super(app);
		this.id = "audiosource";
		this.ComponentType = AudioSourceComponent;
		this.DataType = AudioSourceComponentData;
		this.schema = _schema$i;
		this.manager = manager;
		this.initialized = false;
		this.app.systems.on('initialize', this.onInitialize, this);
		this.app.systems.on('update', this.onUpdate, this);
		this.on('remove', this.onRemove, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];
		super.initializeComponentData(component, data, properties);
		component.paused = !(component.enabled && component.activate);
	}

	onInitialize(root) {
		if (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {
			root.audiosource.play(root.audiosource.currentSource);
		}

		const children = root._children;

		for (let i = 0, len = children.length; i < len; i++) {
			if (children[i] instanceof Entity) {
				this.onInitialize(children[i]);
			}
		}

		this.initialized = true;
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];
				const entity = component.entity;
				const componentData = component.data;

				if (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {
					const pos = entity.getPosition();
					componentData.channel.setPosition(pos);
				}
			}
		}
	}

	onRemove(entity, data) {
		if (data.channel) {
			data.channel.stop();
			data.channel = null;
		}
	}

	setVolume(volume) {
		this.manager.setVolume(volume);
	}

	destroy() {
		super.destroy();
		this.app.systems.off('initialize', this.onInitialize, this);
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(AudioSourceComponent.prototype, _schema$i);

class EntityReference extends EventHandler {
	constructor(parentComponent, entityPropertyName, eventConfig) {
		super();

		if (!parentComponent || !(parentComponent instanceof Component)) {
			throw new Error('The parentComponent argument is required and must be a Component');
		} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
			throw new Error('The propertyName argument is required and must be a string');
		} else if (eventConfig && typeof eventConfig !== 'object') {
			throw new Error('If provided, the eventConfig argument must be an object');
		}

		this._parentComponent = parentComponent;
		this._entityPropertyName = entityPropertyName;
		this._entity = null;
		this._app = parentComponent.system.app;

		this._configureEventListeners(eventConfig || {}, {
			'entity#destroy': this._onEntityDestroy
		});

		this._toggleLifecycleListeners('on');
	}

	_configureEventListeners(externalEventConfig, internalEventConfig) {
		const externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);

		const internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);

		this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
		this._listenerStatusFlags = {};
		this._gainListeners = {};
		this._loseListeners = {};
	}

	_parseEventListenerConfig(eventConfig, prefix, scope) {
		return Object.keys(eventConfig).map(function (listenerDescription, index) {
			const listenerDescriptionParts = listenerDescription.split('#');
			const sourceName = listenerDescriptionParts[0];
			const eventName = listenerDescriptionParts[1];
			const callback = eventConfig[listenerDescription];

			if (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {
				throw new Error('Invalid event listener description: `' + listenerDescription + '`');
			}

			if (typeof callback !== 'function') {
				throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');
			}

			return {
				id: prefix + '_' + index + '_' + listenerDescription,
				sourceName: sourceName,
				eventName: eventName,
				callback: callback,
				scope: scope
			};
		}, this);
	}

	_toggleLifecycleListeners(onOrOff) {
		this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);

		this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);

		this._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);

		this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);

		const allComponentSystems = [];

		for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
			const config = this._eventListenerConfigs[i];
			const componentSystem = this._app.systems[config.sourceName];

			if (componentSystem) {
				if (allComponentSystems.indexOf(componentSystem) === -1) {
					allComponentSystems.push(componentSystem);
				}

				if (componentSystem && config.eventName === 'gain') {
					this._gainListeners[config.sourceName] = config;
				}

				if (componentSystem && config.eventName === 'lose') {
					this._loseListeners[config.sourceName] = config;
				}
			}
		}

		for (let i = 0; i < allComponentSystems.length; ++i) {
			allComponentSystems[i][onOrOff]('add', this._onComponentAdd, this);
			allComponentSystems[i][onOrOff]('beforeremove', this._onComponentRemove, this);
		}
	}

	_onSetEntity(name, oldValue, newValue) {
		if (newValue instanceof Entity) {
			this._updateEntityReference();
		} else {
			if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
				console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
				return;
			}

			if (oldValue !== newValue) {
				this._updateEntityReference();
			}
		}
	}

	onParentComponentEnable() {
		if (!this._entity) {
			this._updateEntityReference();
		}
	}

	_onSceneLoaded() {
		this._updateEntityReference();
	}

	_updateEntityReference() {
		let nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
		let nextEntity;

		if (nextEntityGuid instanceof Entity) {
			nextEntity = nextEntityGuid;
			nextEntityGuid = nextEntity.getGuid();
			this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
		} else {
			const root = this._parentComponent.system.app.root;

			const isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);

			nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
		}

		const hasChanged = this._entity !== nextEntity;

		if (hasChanged) {
			if (this._entity) {
				this._onBeforeEntityChange();
			}

			this._entity = nextEntity;

			if (this._entity) {
				this._onAfterEntityChange();
			}

			this.fire('set:entity', this._entity);
		}
	}

	_onBeforeEntityChange() {
		this._toggleEntityListeners('off');

		this._callAllGainOrLoseListeners(this._loseListeners);
	}

	_onAfterEntityChange() {
		this._toggleEntityListeners('on');

		this._callAllGainOrLoseListeners(this._gainListeners);
	}

	_onComponentAdd(entity, component) {
		const componentName = component.system.id;

		if (entity === this._entity) {
			this._callGainOrLoseListener(componentName, this._gainListeners);

			this._toggleComponentListeners('on', componentName);
		}
	}

	_onComponentRemove(entity, component) {
		const componentName = component.system.id;

		if (entity === this._entity) {
			this._callGainOrLoseListener(componentName, this._loseListeners);

			this._toggleComponentListeners('off', componentName, true);
		}
	}

	_callAllGainOrLoseListeners(listenerMap) {
		for (const componentName in this._entity.c) {
			this._callGainOrLoseListener(componentName, listenerMap);
		}
	}

	_callGainOrLoseListener(componentName, listenerMap) {
		if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
			const config = listenerMap[componentName];
			config.callback.call(config.scope);
		}
	}

	_toggleEntityListeners(onOrOff, isDestroying) {
		if (this._entity) {
			for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
				this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
			}
		}
	}

	_toggleComponentListeners(onOrOff, componentName, isDestroying) {
		for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
			const config = this._eventListenerConfigs[i];

			if (config.sourceName === componentName) {
				this._safeToggleListener(onOrOff, config, isDestroying);
			}
		}
	}

	_safeToggleListener(onOrOff, config, isDestroying) {
		const isAdding = onOrOff === 'on';

		if (isAdding && this._listenerStatusFlags[config.id]) {
			return;
		}

		const source = this._getEventSource(config.sourceName, isDestroying);

		if (source) {
			source[onOrOff](config.eventName, config.callback, config.scope);
			this._listenerStatusFlags[config.id] = isAdding;
		}
	}

	_getEventSource(sourceName, isDestroying) {
		if (sourceName === 'entity') {
			return this._entity;
		}

		const component = this._entity[sourceName];

		if (component) {
			return component;
		}

		if (!isDestroying) {
			console.warn('Entity has no component with name ' + sourceName);
		}

		return null;
	}

	_onEntityDestroy(entity) {
		if (this._entity === entity) {
			this._toggleEntityListeners('off', true);

			this._entity = null;
		}
	}

	_onParentComponentRemove(entity, component) {
		if (component === this._parentComponent) {
			this._toggleLifecycleListeners('off');

			this._toggleEntityListeners('off', true);
		}
	}

	hasComponent(componentName) {
		return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
	}

	get entity() {
		return this._entity;
	}

}

const BUTTON_TRANSITION_MODE_TINT = 0;
const BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

const ELEMENTTYPE_GROUP = 'group';
const ELEMENTTYPE_IMAGE = 'image';
const ELEMENTTYPE_TEXT = 'text';

const VisualState = {
	DEFAULT: 'DEFAULT',
	HOVER: 'HOVER',
	PRESSED: 'PRESSED',
	INACTIVE: 'INACTIVE'
};
const STATES_TO_TINT_NAMES = {};
STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
const STATES_TO_SPRITE_ASSET_NAMES = {};
STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
const STATES_TO_SPRITE_FRAME_NAMES = {};
STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';

class ButtonComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._visualState = VisualState.DEFAULT;
		this._isHovering = false;
		this._hoveringCounter = 0;
		this._isPressed = false;
		this._defaultTint = new Color(1, 1, 1, 1);
		this._defaultSpriteAsset = null;
		this._defaultSpriteFrame = 0;
		this._imageReference = new EntityReference(this, 'imageEntity', {
			'element#gain': this._onImageElementGain,
			'element#lose': this._onImageElementLose,
			'element#set:color': this._onSetColor,
			'element#set:opacity': this._onSetOpacity,
			'element#set:spriteAsset': this._onSetSpriteAsset,
			'element#set:spriteFrame': this._onSetSpriteFrame
		});

		this._toggleLifecycleListeners('on', system);
	}

	_toggleLifecycleListeners(onOrOff, system) {
		this[onOrOff]('set_active', this._onSetActive, this);
		this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
		this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
		this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
		this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
		this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
		this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
		this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
		this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
		this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
		this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
		system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
		system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
	}

	_onSetActive(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this._updateVisualState();
		}
	}

	_onSetTransitionMode(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this._cancelTween();

			this._resetToDefaultVisualState(oldValue);

			this._forceReapplyVisualState();
		}
	}

	_onSetTransitionValue(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this._forceReapplyVisualState();
		}
	}

	_onElementComponentRemove(entity) {
		if (this.entity === entity) {
			this._toggleHitElementListeners('off');
		}
	}

	_onElementComponentAdd(entity) {
		if (this.entity === entity) {
			this._toggleHitElementListeners('on');
		}
	}

	_onImageElementLose() {
		this._cancelTween();

		this._resetToDefaultVisualState(this.transitionMode);
	}

	_onImageElementGain() {
		this._storeDefaultVisualState();

		this._forceReapplyVisualState();
	}

	_toggleHitElementListeners(onOrOff) {
		if (this.entity.element) {
			const isAdding = onOrOff === 'on';

			if (isAdding && this._hasHitElementListeners) {
				return;
			}

			this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
			this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
			this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
			this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
			this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
			this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
			this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
			this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
			this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
			this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
			this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
			this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
			this.entity.element[onOrOff]('click', this._onClick, this);
			this._hasHitElementListeners = isAdding;
		}
	}

	_storeDefaultVisualState() {
		if (this._imageReference.hasComponent('element')) {
			const element = this._imageReference.entity.element;

			if (element.type !== ELEMENTTYPE_GROUP) {
				this._storeDefaultColor(element.color);

				this._storeDefaultOpacity(element.opacity);

				this._storeDefaultSpriteAsset(element.spriteAsset);

				this._storeDefaultSpriteFrame(element.spriteFrame);
			}
		}
	}

	_storeDefaultColor(color) {
		this._defaultTint.r = color.r;
		this._defaultTint.g = color.g;
		this._defaultTint.b = color.b;
	}

	_storeDefaultOpacity(opacity) {
		this._defaultTint.a = opacity;
	}

	_storeDefaultSpriteAsset(spriteAsset) {
		this._defaultSpriteAsset = spriteAsset;
	}

	_storeDefaultSpriteFrame(spriteFrame) {
		this._defaultSpriteFrame = spriteFrame;
	}

	_onSetColor(color) {
		if (!this._isApplyingTint) {
			this._storeDefaultColor(color);

			this._forceReapplyVisualState();
		}
	}

	_onSetOpacity(opacity) {
		if (!this._isApplyingTint) {
			this._storeDefaultOpacity(opacity);

			this._forceReapplyVisualState();
		}
	}

	_onSetSpriteAsset(spriteAsset) {
		if (!this._isApplyingSprite) {
			this._storeDefaultSpriteAsset(spriteAsset);

			this._forceReapplyVisualState();
		}
	}

	_onSetSpriteFrame(spriteFrame) {
		if (!this._isApplyingSprite) {
			this._storeDefaultSpriteFrame(spriteFrame);

			this._forceReapplyVisualState();
		}
	}

	_onMouseEnter(event) {
		this._isHovering = true;

		this._updateVisualState();

		this._fireIfActive('mouseenter', event);
	}

	_onMouseLeave(event) {
		this._isHovering = false;
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('mouseleave', event);
	}

	_onMouseDown(event) {
		this._isPressed = true;

		this._updateVisualState();

		this._fireIfActive('mousedown', event);
	}

	_onMouseUp(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('mouseup', event);
	}

	_onTouchStart(event) {
		this._isPressed = true;

		this._updateVisualState();

		this._fireIfActive('touchstart', event);
	}

	_onTouchEnd(event) {
		event.event.preventDefault();
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('touchend', event);
	}

	_onTouchLeave(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('touchleave', event);
	}

	_onTouchCancel(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('touchcancel', event);
	}

	_onSelectStart(event) {
		this._isPressed = true;

		this._updateVisualState();

		this._fireIfActive('selectstart', event);
	}

	_onSelectEnd(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('selectend', event);
	}

	_onSelectEnter(event) {
		this._hoveringCounter++;

		if (this._hoveringCounter === 1) {
			this._isHovering = true;

			this._updateVisualState();
		}

		this._fireIfActive('selectenter', event);
	}

	_onSelectLeave(event) {
		this._hoveringCounter--;

		if (this._hoveringCounter === 0) {
			this._isHovering = false;
			this._isPressed = false;

			this._updateVisualState();
		}

		this._fireIfActive('selectleave', event);
	}

	_onClick(event) {
		this._fireIfActive('click', event);
	}

	_fireIfActive(name, event) {
		if (this.data.active) {
			this.fire(name, event);
		}
	}

	_updateVisualState(force) {
		const oldVisualState = this._visualState;

		const newVisualState = this._determineVisualState();

		if ((oldVisualState !== newVisualState || force) && this.enabled) {
			this._visualState = newVisualState;

			if (oldVisualState === VisualState.HOVER) {
				this._fireIfActive('hoverend');
			}

			if (oldVisualState === VisualState.PRESSED) {
				this._fireIfActive('pressedend');
			}

			if (newVisualState === VisualState.HOVER) {
				this._fireIfActive('hoverstart');
			}

			if (newVisualState === VisualState.PRESSED) {
				this._fireIfActive('pressedstart');
			}

			switch (this.transitionMode) {
				case BUTTON_TRANSITION_MODE_TINT:
					{
						const tintName = STATES_TO_TINT_NAMES[this._visualState];
						const tintColor = this[tintName];

						this._applyTint(tintColor);

						break;
					}

				case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
					{
						const spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
						const spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
						const spriteAsset = this[spriteAssetName];
						const spriteFrame = this[spriteFrameName];

						this._applySprite(spriteAsset, spriteFrame);

						break;
					}
			}
		}
	}

	_forceReapplyVisualState() {
		this._updateVisualState(true);
	}

	_resetToDefaultVisualState(transitionMode) {
		if (this._imageReference.hasComponent('element')) {
			switch (transitionMode) {
				case BUTTON_TRANSITION_MODE_TINT:
					this._cancelTween();

					this._applyTintImmediately(this._defaultTint);

					break;

				case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
					this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);

					break;
			}
		}
	}

	_determineVisualState() {
		if (!this.active) {
			return VisualState.INACTIVE;
		} else if (this._isPressed) {
			return VisualState.PRESSED;
		} else if (this._isHovering) {
			return VisualState.HOVER;
		}

		return VisualState.DEFAULT;
	}

	_applySprite(spriteAsset, spriteFrame) {
		spriteFrame = spriteFrame || 0;

		if (this._imageReference.hasComponent('element')) {
			this._isApplyingSprite = true;

			if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {
				this._imageReference.entity.element.spriteAsset = spriteAsset;
			}

			if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {
				this._imageReference.entity.element.spriteFrame = spriteFrame;
			}

			this._isApplyingSprite = false;
		}
	}

	_applyTint(tintColor) {
		this._cancelTween();

		if (this.fadeDuration === 0) {
			this._applyTintImmediately(tintColor);
		} else {
			this._applyTintWithTween(tintColor);
		}
	}

	_applyTintImmediately(tintColor) {
		if (!tintColor || !this._imageReference.hasComponent('element')) return;
		const color3 = toColor3(tintColor);
		this._isApplyingTint = true;
		if (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;
		if (this._imageReference.entity.element.opacity != tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;
		this._isApplyingTint = false;
	}

	_applyTintWithTween(tintColor) {
		if (!tintColor || !this._imageReference.hasComponent('element')) return;
		const color3 = toColor3(tintColor);
		const color = this._imageReference.entity.element.color;
		const opacity = this._imageReference.entity.element.opacity;
		if (color3.equals(color) && tintColor.a == opacity) return;
		this._tweenInfo = {
			startTime: now(),
			from: new Color(color.r, color.g, color.b, opacity),
			to: tintColor.clone(),
			lerpColor: new Color()
		};
	}

	_updateTintTween() {
		const elapsedTime = now() - this._tweenInfo.startTime;

		let elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
		elapsedProportion = math.clamp(elapsedProportion, 0, 1);

		if (Math.abs(elapsedProportion - 1) > 1e-5) {
			const lerpColor = this._tweenInfo.lerpColor;
			lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);

			this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
		} else {
			this._applyTintImmediately(this._tweenInfo.to);

			this._cancelTween();
		}
	}

	_cancelTween() {
		delete this._tweenInfo;
	}

	onUpdate() {
		if (this._tweenInfo) {
			this._updateTintTween();
		}
	}

	onEnable() {
		this._isHovering = false;
		this._hoveringCounter = 0;
		this._isPressed = false;

		this._imageReference.onParentComponentEnable();

		this._toggleHitElementListeners('on');

		this._forceReapplyVisualState();
	}

	onDisable() {
		this._toggleHitElementListeners('off');

		this._resetToDefaultVisualState(this.transitionMode);
	}

	onRemove() {
		this._toggleLifecycleListeners('off', this.system);

		this.onDisable();
	}

}

function toColor3(color4) {
	return new Color(color4.r, color4.g, color4.b);
}

class ButtonComponentData {
	constructor() {
		this.enabled = true;
		this.active = true;
		this.imageEntity = null;
		this.hitPadding = new Vec4();
		this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
		this.hoverTint = new Color(0.75, 0.75, 0.75);
		this.pressedTint = new Color(0.5, 0.5, 0.5);
		this.inactiveTint = new Color(0.25, 0.25, 0.25);
		this.fadeDuration = 0;
		this.hoverSpriteAsset = null;
		this.hoverSpriteFrame = 0;
		this.pressedSpriteAsset = null;
		this.pressedSpriteFrame = 0;
		this.inactiveSpriteAsset = null;
		this.inactiveSpriteFrame = 0;
	}

}

const _schema$h = ['enabled', 'active', {
	name: 'imageEntity',
	type: 'entity'
}, {
	name: 'hitPadding',
	type: 'vec4'
}, 'transitionMode', {
	name: 'hoverTint',
	type: 'rgba'
}, {
	name: 'pressedTint',
	type: 'rgba'
}, {
	name: 'inactiveTint',
	type: 'rgba'
}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];

class ButtonComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'button';
		this.ComponentType = ButtonComponent;
		this.DataType = ButtonComponentData;
		this.schema = _schema$h;
		this.on('beforeremove', this._onRemoveComponent, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		super.initializeComponentData(component, data, _schema$h);
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			const entity = components[id].entity;
			const component = entity.button;

			if (component.enabled && entity.enabled) {
				component.onUpdate();
			}
		}
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(ButtonComponent.prototype, _schema$h);

let depthLayer$1;

class PostEffect {
	constructor(effect, inputTarget) {
		this.effect = effect;
		this.inputTarget = inputTarget;
		this.outputTarget = null;
		this.name = effect.constructor.name;
	}

}

class PostEffectQueue {
	constructor(app, camera) {
		this.app = app;
		this.camera = camera;
		this.destinationRenderTarget = null;
		this.effects = [];
		this.enabled = false;
		this.depthTarget = null;
		this.renderTargetScale = 1;
		this.resizeTimeout = null;
		this.resizeLast = 0;

		this._resizeTimeoutCallback = () => {
			this.resizeRenderTargets();
		};

		camera.on('set:rect', this.onCameraRectChanged, this);
	}

	_allocateColorBuffer(format, name) {
		const rect = this.camera.rect;
		const width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
		const height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
		const colorBuffer = new Texture(this.app.graphicsDevice, {
			format: format,
			width: width,
			height: height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		colorBuffer.name = name;
		return colorBuffer;
	}

	_createOffscreenTarget(useDepth, hdr) {
		const device = this.app.graphicsDevice;
		const format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;
		const name = this.camera.entity.name + '-posteffect-' + this.effects.length;

		const colorBuffer = this._allocateColorBuffer(format, name);

		const useStencil = this.app.graphicsDevice.supportsStencil;
		const samples = useDepth ? device.samples : 1;
		return new RenderTarget({
			colorBuffer: colorBuffer,
			depth: useDepth,
			stencil: useStencil,
			samples: samples
		});
	}

	_resizeOffscreenTarget(rt) {
		const format = rt.colorBuffer.format;
		const name = rt.colorBuffer.name;
		rt.destroyFrameBuffers();
		rt.destroyTextureBuffers();
		rt._colorBuffer = this._allocateColorBuffer(format, name);
	}

	_destroyOffscreenTarget(rt) {
		rt.destroyTextureBuffers();
		rt.destroy();
	}

	setRenderTargetScale(scale) {
		this.renderTargetScale = scale;
		this.resizeRenderTargets();
	}

	addEffect(effect) {
		const effects = this.effects;
		const isFirstEffect = effects.length === 0;

		const inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);

		const newEntry = new PostEffect(effect, inputTarget);
		effects.push(newEntry);
		this._sourceTarget = newEntry.inputTarget;

		if (effects.length > 1) {
			effects[effects.length - 2].outputTarget = newEntry.inputTarget;
		}

		this._newPostEffect = effect;

		if (effect.needsDepthBuffer) {
			this._requestDepthMap();
		}

		this.enable();
		this._newPostEffect = undefined;
	}

	removeEffect(effect) {
		let index = -1;

		for (let i = 0, len = this.effects.length; i < len; i++) {
			if (this.effects[i].effect === effect) {
				index = i;
				break;
			}
		}

		if (index >= 0) {
			if (index > 0) {
				this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
			} else {
				if (this.effects.length > 1) {
					if (!this.effects[1].inputTarget._depth) {
						this._destroyOffscreenTarget(this.effects[1].inputTarget);

						this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
						this._sourceTarget = this.effects[1].inputTarget;
					}

					this.camera.renderTarget = this.effects[1].inputTarget;
				}
			}

			this._destroyOffscreenTarget(this.effects[index].inputTarget);

			this.effects.splice(index, 1);
		}

		if (this.enabled) {
			if (effect.needsDepthBuffer) {
				this._releaseDepthMap();
			}
		}

		if (this.effects.length === 0) {
			this.disable();
		}
	}

	_requestDepthMaps() {
		for (let i = 0, len = this.effects.length; i < len; i++) {
			const effect = this.effects[i].effect;
			if (this._newPostEffect === effect) continue;

			if (effect.needsDepthBuffer) {
				this._requestDepthMap();
			}
		}
	}

	_releaseDepthMaps() {
		for (let i = 0, len = this.effects.length; i < len; i++) {
			const effect = this.effects[i].effect;

			if (effect.needsDepthBuffer) {
				this._releaseDepthMap();
			}
		}
	}

	_requestDepthMap() {
		if (!depthLayer$1) depthLayer$1 = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
		if (depthLayer$1) depthLayer$1.incrementCounter();
	}

	_releaseDepthMap() {
		if (depthLayer$1) depthLayer$1.decrementCounter();
	}

	destroy() {
		for (let i = 0, len = this.effects.length; i < len; i++) {
			this.effects[i].inputTarget.destroy();
		}

		this.effects.length = 0;
		this.disable();
	}

	enable() {
		if (!this.enabled && this.effects.length) {
			this.enabled = true;

			this._requestDepthMaps();

			this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
			this.destinationRenderTarget = this.camera.renderTarget;
			this.camera.renderTarget = this.effects[0].inputTarget;

			this.camera.onPostprocessing = () => {
				if (this.enabled) {
					let rect = null;
					const len = this.effects.length;

					if (len) {
						for (let i = 0; i < len; i++) {
							const fx = this.effects[i];
							let destTarget = fx.outputTarget;

							if (i === len - 1) {
								rect = this.camera.rect;

								if (this.destinationRenderTarget) {
									destTarget = this.destinationRenderTarget;
								}
							}

							fx.effect.render(fx.inputTarget, destTarget, rect);
						}
					}
				}
			};
		}
	}

	disable() {
		if (this.enabled) {
			this.enabled = false;
			this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);

			this._releaseDepthMaps();

			this._destroyOffscreenTarget(this._sourceTarget);

			this.camera.renderTarget = null;
			this.camera.onPostprocessing = null;
		}
	}

	_onCanvasResized(width, height) {
		const rect = this.camera.rect;
		const device = this.app.graphicsDevice;
		this.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);
		if (this.resizeTimeout) return;

		if (now() - this.resizeLast > 100) {
			this.resizeRenderTargets();
		} else {
			this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);
		}
	}

	resizeRenderTargets() {
		if (this.resizeTimeout) {
			clearTimeout(this.resizeTimeout);
			this.resizeTimeout = null;
		}

		this.resizeLast = now();
		const rect = this.camera.rect;
		const desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
		const desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
		const effects = this.effects;

		for (let i = 0, len = effects.length; i < len; i++) {
			const fx = effects[i];

			if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
				this._resizeOffscreenTarget(fx.inputTarget);
			}
		}
	}

	onCameraRectChanged(name, oldValue, newValue) {
		if (this.enabled) {
			this.resizeRenderTargets();
		}
	}

}

const properties$1 = [{
	name: 'aspectRatio',
	readonly: false
}, {
	name: 'aspectRatioMode',
	readonly: false
}, {
	name: 'calculateProjection',
	readonly: false
}, {
	name: 'calculateTransform',
	readonly: false
}, {
	name: 'clearColor',
	readonly: false
}, {
	name: 'cullFaces',
	readonly: false
}, {
	name: 'farClip',
	readonly: false
}, {
	name: 'flipFaces',
	readonly: false
}, {
	name: 'fov',
	readonly: false
}, {
	name: 'frustumCulling',
	readonly: false
}, {
	name: 'horizontalFov',
	readonly: false
}, {
	name: 'nearClip',
	readonly: false
}, {
	name: 'orthoHeight',
	readonly: false
}, {
	name: 'projection',
	readonly: false
}, {
	name: 'scissorRect',
	readonly: false
}, {
	name: 'vrDisplay',
	readonly: false
}];

class CameraComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.onPostprocessing = null;
		this.onPreRender = null;
		this.onPostRender = null;
		this._camera = new Camera();
		this._camera.node = entity;
		this._priority = 0;
		this._disablePostEffectsLayer = LAYERID_UI;
		this._postEffects = new PostEffectQueue(system.app, this);
	}

	get camera() {
		return this._camera;
	}

	set clearColorBuffer(value) {
		this._camera.clearColorBuffer = value;
		this.dirtyLayerCompositionCameras();
	}

	get clearColorBuffer() {
		return this._camera.clearColorBuffer;
	}

	set clearDepthBuffer(value) {
		this._camera.clearDepthBuffer = value;
		this.dirtyLayerCompositionCameras();
	}

	get clearDepthBuffer() {
		return this._camera.clearDepthBuffer;
	}

	set clearStencilBuffer(value) {
		this._camera.clearStencilBuffer = value;
		this.dirtyLayerCompositionCameras();
	}

	get clearStencilBuffer() {
		return this._camera.clearStencilBuffer;
	}

	set disablePostEffectsLayer(layer) {
		this._disablePostEffectsLayer = layer;
		this.dirtyLayerCompositionCameras();
	}

	get disablePostEffectsLayer() {
		return this._disablePostEffectsLayer;
	}

	get frustum() {
		return this._camera.frustum;
	}

	set layers(newValue) {
		const layers = this._camera.layers;

		for (let i = 0; i < layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(layers[i]);
			if (!layer) continue;
			layer.removeCamera(this);
		}

		this._camera.layers = newValue;
		if (!this.enabled || !this.entity.enabled) return;

		for (let i = 0; i < newValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
			if (!layer) continue;
			layer.addCamera(this);
		}
	}

	get layers() {
		return this._camera.layers;
	}

	get postEffectsEnabled() {
		return this._postEffects.enabled;
	}

	get postEffects() {
		return this._postEffects;
	}

	set priority(newValue) {
		this._priority = newValue;
		this.dirtyLayerCompositionCameras();
	}

	get priority() {
		return this._priority;
	}

	get projectionMatrix() {
		return this._camera.projectionMatrix;
	}

	set rect(value) {
		this._camera.rect = value;
		this.fire('set:rect', this._camera.rect);
	}

	get rect() {
		return this._camera.rect;
	}

	set renderTarget(value) {
		this._camera.renderTarget = value;
		this.dirtyLayerCompositionCameras();
	}

	get renderTarget() {
		return this._camera.renderTarget;
	}

	get viewMatrix() {
		return this._camera.viewMatrix;
	}

	dirtyLayerCompositionCameras() {
		const layerComp = this.system.app.scene.layers;
		layerComp._dirtyCameras = true;
	}

	screenToWorld(screenx, screeny, cameraz, worldCoord) {
		const device = this.system.app.graphicsDevice;
		const w = device.clientRect.width;
		const h = device.clientRect.height;
		return this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);
	}

	worldToScreen(worldCoord, screenCoord) {
		const device = this.system.app.graphicsDevice;
		const w = device.clientRect.width;
		const h = device.clientRect.height;
		return this._camera.worldToScreen(worldCoord, w, h, screenCoord);
	}

	onAppPrerender() {
		this._camera._viewMatDirty = true;
		this._camera._viewProjMatDirty = true;
	}

	addCameraToLayers() {
		const layers = this.layers;

		for (let i = 0; i < layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.addCamera(this);
			}
		}
	}

	removeCameraFromLayers() {
		const layers = this.layers;

		for (let i = 0; i < layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.removeCamera(this);
			}
		}
	}

	onLayersChanged(oldComp, newComp) {
		this.addCameraToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addCamera(this);
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeCamera(this);
	}

	onEnable() {
		const system = this.system;
		const scene = system.app.scene;
		const layers = scene.layers;
		system.addCamera(this);
		scene.on("set:layers", this.onLayersChanged, this);

		if (layers) {
			layers.on("add", this.onLayerAdded, this);
			layers.on("remove", this.onLayerRemoved, this);
		}

		if (this.enabled && this.entity.enabled) {
			this.addCameraToLayers();
		}

		this.postEffects.enable();
	}

	onDisable() {
		const system = this.system;
		const scene = system.app.scene;
		const layers = scene.layers;
		this.postEffects.disable();
		this.removeCameraFromLayers();
		scene.off("set:layers", this.onLayersChanged, this);

		if (layers) {
			layers.off("add", this.onLayerAdded, this);
			layers.off("remove", this.onLayerRemoved, this);
		}

		system.removeCamera(this);
	}

	onRemove() {
		this.onDisable();
		this.off();
	}

	calculateAspectRatio(rt) {
		const src = rt ? rt : this.system.app.graphicsDevice;
		const rect = this.rect;
		return src.width * rect.z / (src.height * rect.w);
	}

	frameBegin(rt) {
		if (this.aspectRatioMode === ASPECT_AUTO) {
			this.aspectRatio = this.calculateAspectRatio(rt);
		}
	}

	frameEnd() {}

	enterVr(display, callback) {
		if (display instanceof Function && !callback) {
			callback = display;
			display = null;
		}

		if (!this.system.app.vr) {
			callback("VrManager not created. Enable VR in project settings.");
			return;
		}

		if (!display) {
			display = this.system.app.vr.display;
		}

		if (display) {
			const self = this;

			if (display.capabilities.canPresent) {
				display.requestPresent(function (err) {
					if (!err) {
						self.vrDisplay = display;
						self.vrDisplay.once('beforepresentchange', function (display) {
							if (!display.presenting) {
								self.vrDisplay = null;
							}
						});
					}

					callback(err);
				});
			} else {
				self.vrDisplay = display;
				callback();
			}
		} else {
			callback("No pc.VrDisplay to present");
		}
	}

	exitVr(callback) {
		if (this.vrDisplay) {
			if (this.vrDisplay.capabilities.canPresent) {
				const display = this.vrDisplay;
				this.vrDisplay = null;
				display.exitPresent(callback);
			} else {
				this.vrDisplay = null;
				callback();
			}
		} else {
			callback("Not presenting VR");
		}
	}

	startXr(type, spaceType, options) {
		this.system.app.xr.start(this, type, spaceType, options);
	}

	endXr(callback) {
		if (!this._camera.xr) {
			if (callback) callback(new Error("Camera is not in XR"));
			return;
		}

		this._camera.xr.end(callback);
	}

	copy(source) {
		properties$1.forEach(property => {
			if (!property.readonly) {
				const name = property.name;
				this[name] = source[name];
			}
		});
		this.clearColorBuffer = source.clearColorBuffer;
		this.clearDepthBuffer = source.clearDepthBuffer;
		this.clearStencilBuffer = source.clearStencilBuffer;
		this.disablePostEffectsLayer = source.disablePostEffectsLayer;
		this.layers = source.layers;
		this.priority = source.priority;
		this.renderTarget = source.renderTarget;
		this.rect = source.rect;
	}

}

properties$1.forEach(function (property) {
	const name = property.name;
	const options = {};

	options.get = function () {
		return this._camera[name];
	};

	if (!property.readonly) {
		options.set = function (newValue) {
			this._camera[name] = newValue;
		};
	}

	Object.defineProperty(CameraComponent.prototype, name, options);
});

class CameraComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$g = ['enabled'];

class CameraComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'camera';
		this.ComponentType = CameraComponent;
		this.DataType = CameraComponentData;
		this.schema = _schema$g;
		this.cameras = [];
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.on('prerender', this.onAppPrerender, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect'];

		for (let i = 0; i < properties.length; i++) {
			const property = properties[i];

			if (data.hasOwnProperty(property)) {
				const value = data[property];

				switch (property) {
					case 'rect':
					case 'scissorRect':
						if (Array.isArray(value)) {
							component[property] = new Vec4(value[0], value[1], value[2], value[3]);
						} else {
							component[property] = value;
						}

						break;

					case 'clearColor':
						if (Array.isArray(value)) {
							component[property] = new Color(value[0], value[1], value[2], value[3]);
						} else {
							component[property] = value;
						}

						break;

					default:
						component[property] = value;
						break;
				}
			}
		}

		super.initializeComponentData(component, data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const c = entity.camera;
		this.addComponent(clone, {
			aspectRatio: c.aspectRatio,
			aspectRatioMode: c.aspectRatioMode,
			calculateProjection: c.calculateProjection,
			calculateTransform: c.calculateTransform,
			clearColor: c.clearColor,
			clearColorBuffer: c.clearColorBuffer,
			clearDepthBuffer: c.clearDepthBuffer,
			clearStencilBuffer: c.clearStencilBuffer,
			cullFaces: c.cullFaces,
			enabled: c.enabled,
			farClip: c.farClip,
			flipFaces: c.flipFaces,
			fov: c.fov,
			frustumCulling: c.frustumCulling,
			horizontalFov: c.horizontalFov,
			layers: c.layers,
			renderTarget: c.renderTarget,
			nearClip: c.nearClip,
			orthoHeight: c.orthoHeight,
			projection: c.projection,
			priority: c.priority,
			rect: c.rect,
			scissorRect: c.scissorRect
		});
	}

	onBeforeRemove(entity, component) {
		this.removeCamera(component);
	}

	onUpdate(dt) {
		if (this.app.vr) {
			const components = this.store;

			for (const id in components) {
				const component = components[id];

				if (component.data.enabled && component.entity.enabled) {
					const cameraComponent = component.entity.camera;
					const vrDisplay = cameraComponent.vrDisplay;

					if (vrDisplay) {
						vrDisplay.setClipPlanes(cameraComponent.nearClip, cameraComponent.farClip);

						if (component.entity) {
							component.entity.localTransform.copy(vrDisplay.combinedViewInv);
							component.entity._dirtyLocal = false;

							component.entity._dirtifyWorld();
						}
					}
				}
			}
		}
	}

	onAppPrerender() {
		for (let i = 0, len = this.cameras.length; i < len; i++) {
			this.cameras[i].onAppPrerender();
		}
	}

	addCamera(camera) {
		this.cameras.push(camera);
		this.sortCamerasByPriority();
	}

	removeCamera(camera) {
		const index = this.cameras.indexOf(camera);

		if (index >= 0) {
			this.cameras.splice(index, 1);
			this.sortCamerasByPriority();
		}
	}

	sortCamerasByPriority() {
		this.cameras.sort(function (a, b) {
			return a.priority - b.priority;
		});
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(CameraComponent.prototype, _schema$g);

class CollisionComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._compoundParent = null;
		this.entity.on('insert', this._onInsert, this);
		this.on('set_type', this.onSetType, this);
		this.on('set_halfExtents', this.onSetHalfExtents, this);
		this.on('set_radius', this.onSetRadius, this);
		this.on('set_height', this.onSetHeight, this);
		this.on('set_axis', this.onSetAxis, this);
		this.on("set_asset", this.onSetAsset, this);
		this.on("set_renderAsset", this.onSetRenderAsset, this);
		this.on("set_model", this.onSetModel, this);
		this.on("set_render", this.onSetRender, this);
	}

	onSetType(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this.system.changeType(this, oldValue, newValue);
		}
	}

	onSetHalfExtents(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && t === 'box') {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetRadius(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetHeight(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetAxis(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				asset.off('remove', this.onAssetRemoved, this);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.asset = newValue.id;
			}

			const asset = assets.get(this.data.asset);

			if (asset) {
				asset.off('remove', this.onAssetRemoved, this);
				asset.on('remove', this.onAssetRemoved, this);
			}
		}

		if (this.data.initialized && this.data.type === 'mesh') {
			if (!newValue) {
				this.data.model = null;
			}

			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetRenderAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				asset.off('remove', this.onRenderAssetRemoved, this);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.renderAsset = newValue.id;
			}

			const asset = assets.get(this.data.renderAsset);

			if (asset) {
				asset.off('remove', this.onRenderAssetRemoved, this);
				asset.on('remove', this.onRenderAssetRemoved, this);
			}
		}

		if (this.data.initialized && this.data.type === 'mesh') {
			if (!newValue) {
				this.data.render = null;
			}

			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetModel(name, oldValue, newValue) {
		if (this.data.initialized && this.data.type === 'mesh') {
			this.system.implementations.mesh.doRecreatePhysicalShape(this);
		}
	}

	onSetRender(name, oldValue, newValue) {
		this.onSetModel(name, oldValue, newValue);
	}

	onAssetRemoved(asset) {
		asset.off('remove', this.onAssetRemoved, this);

		if (this.data.asset === asset.id) {
			this.asset = null;
		}
	}

	onRenderAssetRemoved(asset) {
		asset.off('remove', this.onRenderAssetRemoved, this);

		if (this.data.renderAsset === asset.id) {
			this.renderAsset = null;
		}
	}

	_getCompoundChildShapeIndex(shape) {
		const compound = this.data.shape;
		const shapes = compound.getNumChildShapes();

		for (let i = 0; i < shapes; i++) {
			const childShape = compound.getChildShape(i);

			if (childShape.ptr === shape.ptr) {
				return i;
			}
		}

		return null;
	}

	_onInsert(parent) {
		if (typeof Ammo === 'undefined') return;

		if (this._compoundParent) {
			this.system.recreatePhysicalShapes(this);
		} else if (!this.entity.rigidbody) {
			let ancestor = this.entity.parent;

			while (ancestor) {
				if (ancestor.collision && ancestor.collision.type === 'compound') {
					if (ancestor.collision.shape.getNumChildShapes() === 0) {
						this.system.recreatePhysicalShapes(ancestor.collision);
					} else {
						this.system.recreatePhysicalShapes(this);
					}

					break;
				}

				ancestor = ancestor.parent;
			}
		}
	}

	_updateCompound() {
		const entity = this.entity;

		if (entity._dirtyWorld) {
			let dirty = entity._dirtyLocal;
			let parent = entity;

			while (parent && !dirty) {
				if (parent.collision && parent.collision === this._compoundParent) break;
				if (parent._dirtyLocal) dirty = true;
				parent = parent.parent;
			}

			if (dirty) {
				entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
				const bodyComponent = this._compoundParent.entity.rigidbody;
				if (bodyComponent) bodyComponent.activate();
			}
		}
	}

	onEnable() {
		if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
			const asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);

			if (asset && (!asset.resource || !this.data.shape)) {
				this.system.recreatePhysicalShapes(this);
				return;
			}
		}

		if (this.entity.rigidbody) {
			if (this.entity.rigidbody.enabled) {
				this.entity.rigidbody.enableSimulation();
			}
		} else if (this._compoundParent && this !== this._compoundParent) {
			if (this._compoundParent.shape.getNumChildShapes() === 0) {
				this.system.recreatePhysicalShapes(this._compoundParent);
			} else {
				const transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);

				this._compoundParent.shape.addChildShape(transform, this.data.shape);

				Ammo.destroy(transform);
				if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
			}
		} else if (this.entity.trigger) {
			this.entity.trigger.enable();
		}
	}

	onDisable() {
		if (this.entity.rigidbody) {
			this.entity.rigidbody.disableSimulation();
		} else if (this._compoundParent && this !== this._compoundParent) {
			if (!this._compoundParent.entity._destroying) {
				this.system._removeCompoundChild(this._compoundParent, this.data.shape);

				if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
			}
		} else if (this.entity.trigger) {
			this.entity.trigger.disable();
		}
	}

	onBeforeRemove() {
		if (this.asset) {
			this.asset = null;
		}

		if (this.renderAsset) {
			this.renderAsset = null;
		}

		this.entity.off('insert', this._onInsert, this);
		this.off();
	}

}

class CollisionComponentData {
	constructor() {
		this.enabled = true;
		this.type = 'box';
		this.halfExtents = new Vec3(0.5, 0.5, 0.5);
		this.radius = 0.5;
		this.axis = 1;
		this.height = 2;
		this.asset = null;
		this.renderAsset = null;
		this.shape = null;
		this.model = null;
		this.render = null;
		this.initialized = false;
	}

}

const BODYTYPE_STATIC = 'static';
const BODYTYPE_DYNAMIC = 'dynamic';
const BODYTYPE_KINEMATIC = 'kinematic';
const BODYFLAG_KINEMATIC_OBJECT = 2;
const BODYFLAG_NORESPONSE_OBJECT = 4;
const BODYSTATE_ACTIVE_TAG = 1;
const BODYSTATE_DISABLE_DEACTIVATION = 4;
const BODYSTATE_DISABLE_SIMULATION = 5;
const BODYGROUP_DYNAMIC = 1;
const BODYGROUP_STATIC = 2;
const BODYGROUP_KINEMATIC = 4;
const BODYGROUP_TRIGGER = 16;
const BODYMASK_ALL = 65535;
const BODYMASK_NOT_STATIC = 65535 ^ 2;

let ammoVec1$1, ammoQuat$1, ammoTransform$1;

class Trigger {
	constructor(app, component, data) {
		this.entity = component.entity;
		this.component = component;
		this.app = app;

		if (typeof Ammo !== 'undefined' && !ammoVec1$1) {
			ammoVec1$1 = new Ammo.btVector3();
			ammoQuat$1 = new Ammo.btQuaternion();
			ammoTransform$1 = new Ammo.btTransform();
		}

		this.initialize(data);
	}

	initialize(data) {
		const entity = this.entity;
		const shape = data.shape;

		if (shape && typeof Ammo !== 'undefined') {
			if (entity.trigger) {
				entity.trigger.destroy();
			}

			const mass = 1;
			const pos = entity.getPosition();
			const rot = entity.getRotation();
			ammoVec1$1.setValue(pos.x, pos.y, pos.z);
			ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
			ammoTransform$1.setOrigin(ammoVec1$1);
			ammoTransform$1.setRotation(ammoQuat$1);
			const body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform$1);
			body.setRestitution(0);
			body.setFriction(0);
			body.setDamping(0, 0);
			ammoVec1$1.setValue(0, 0, 0);
			body.setLinearFactor(ammoVec1$1);
			body.setAngularFactor(ammoVec1$1);
			body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
			body.entity = entity;
			this.body = body;

			if (this.component.enabled && entity.enabled) {
				this.enable();
			}
		}
	}

	destroy() {
		const body = this.body;
		if (!body) return;
		this.disable();
		this.app.systems.rigidbody.destroyBody(body);
	}

	_getEntityTransform(transform) {
		const pos = this.entity.getPosition();
		const rot = this.entity.getRotation();
		ammoVec1$1.setValue(pos.x, pos.y, pos.z);
		ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
		transform.setOrigin(ammoVec1$1);
		transform.setRotation(ammoQuat$1);
	}

	updateTransform() {
		this._getEntityTransform(ammoTransform$1);

		const body = this.body;
		body.setWorldTransform(ammoTransform$1);
		body.activate();
	}

	enable() {
		const body = this.body;
		if (!body) return;
		const systems = this.app.systems;
		systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);

		systems.rigidbody._triggers.push(this);

		body.forceActivationState(BODYSTATE_ACTIVE_TAG);
		this.updateTransform();
	}

	disable() {
		const body = this.body;
		if (!body) return;
		const systems = this.app.systems;

		const idx = systems.rigidbody._triggers.indexOf(this);

		if (idx > -1) {
			systems.rigidbody._triggers.splice(idx, 1);
		}

		systems.rigidbody.removeBody(body);
		body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
	}

}

const mat4 = new Mat4();
const vec3 = new Vec3();
const quat = new Quat();
const tempGraphNode = new GraphNode();
const _schema$f = ['enabled', 'type', 'halfExtents', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];

class CollisionSystemImpl {
	constructor(system) {
		this.system = system;
	}

	beforeInitialize(component, data) {
		data.shape = null;
		data.model = new Model();
		data.model.graph = new GraphNode();
	}

	afterInitialize(component, data) {
		this.recreatePhysicalShapes(component);
		component.data.initialized = true;
	}

	reset(component, data) {
		this.beforeInitialize(component, data);
		this.afterInitialize(component, data);
	}

	recreatePhysicalShapes(component) {
		const entity = component.entity;
		const data = component.data;

		if (typeof Ammo !== 'undefined') {
			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}

			if (data.shape) {
				if (component._compoundParent) {
					this.system._removeCompoundChild(component._compoundParent, data.shape);

					if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
				}

				Ammo.destroy(data.shape);
				data.shape = null;
			}

			data.shape = this.createPhysicalShape(component.entity, data);
			const firstCompoundChild = !component._compoundParent;

			if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
				component._compoundParent = component;
				entity.forEach(this._addEachDescendant, component);
			} else if (data.type !== 'compound') {
				if (component._compoundParent && component === component._compoundParent) {
					entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
				}

				if (!component.rigidbody) {
					component._compoundParent = null;
					let parent = entity.parent;

					while (parent) {
						if (parent.collision && parent.collision.type === 'compound') {
							component._compoundParent = parent.collision;
							break;
						}

						parent = parent.parent;
					}
				}
			}

			if (component._compoundParent) {
				if (component !== component._compoundParent) {
					if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
						this.system.recreatePhysicalShapes(component._compoundParent);
					} else {
						this.system.updateCompoundChildTransform(entity);
						if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
					}
				}
			}

			if (entity.rigidbody) {
				entity.rigidbody.disableSimulation();
				entity.rigidbody.createBody();

				if (entity.enabled && entity.rigidbody.enabled) {
					entity.rigidbody.enableSimulation();
				}
			} else if (!component._compoundParent) {
				if (!entity.trigger) {
					entity.trigger = new Trigger(this.system.app, component, data);
				} else {
					entity.trigger.initialize(data);
				}
			}
		}
	}

	createPhysicalShape(entity, data) {
		return undefined;
	}

	updateTransform(component, position, rotation, scale) {
		if (component.entity.trigger) {
			component.entity.trigger.updateTransform();
		}
	}

	beforeRemove(entity, component) {
		if (component.data.shape) {
			if (component._compoundParent && !component._compoundParent.entity._destroying) {
				this.system._removeCompoundChild(component._compoundParent, component.data.shape);

				if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
			}

			component._compoundParent = null;
			Ammo.destroy(component.data.shape);
			component.data.shape = null;
		}
	}

	remove(entity, data) {
		const app = this.system.app;

		if (entity.rigidbody && entity.rigidbody.body) {
			entity.rigidbody.disableSimulation();
		}

		if (entity.trigger) {
			entity.trigger.destroy();
			delete entity.trigger;
		}

		if (app.scene.containsModel(data.model)) {
			app.root.removeChild(data.model.graph);
			app.scene.removeModel(data.model);
		}
	}

	clone(entity, clone) {
		const src = this.system.store[entity.getGuid()];
		const data = {
			enabled: src.data.enabled,
			type: src.data.type,
			halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
			radius: src.data.radius,
			axis: src.data.axis,
			height: src.data.height,
			asset: src.data.asset,
			renderAsset: src.data.renderAsset,
			model: src.data.model,
			render: src.data.render
		};
		return this.system.addComponent(clone, data);
	}

}

class CollisionBoxSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		if (typeof Ammo !== 'undefined') {
			const he = data.halfExtents;
			const ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
			const shape = new Ammo.btBoxShape(ammoHe);
			Ammo.destroy(ammoHe);
			return shape;
		}

		return undefined;
	}

}

class CollisionSphereSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		if (typeof Ammo !== 'undefined') {
			return new Ammo.btSphereShape(data.radius);
		}

		return undefined;
	}

}

class CollisionCapsuleSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		const axis = data.axis !== undefined ? data.axis : 1;
		const radius = data.radius || 0.5;
		const height = Math.max((data.height || 2) - 2 * radius, 0);
		let shape = null;

		if (typeof Ammo !== 'undefined') {
			switch (axis) {
				case 0:
					shape = new Ammo.btCapsuleShapeX(radius, height);
					break;

				case 1:
					shape = new Ammo.btCapsuleShape(radius, height);
					break;

				case 2:
					shape = new Ammo.btCapsuleShapeZ(radius, height);
					break;
			}
		}

		return shape;
	}

}

class CollisionCylinderSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		const axis = data.axis !== undefined ? data.axis : 1;
		const radius = data.radius !== undefined ? data.radius : 0.5;
		const height = data.height !== undefined ? data.height : 1;
		let halfExtents = null;
		let shape = null;

		if (typeof Ammo !== 'undefined') {
			switch (axis) {
				case 0:
					halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
					shape = new Ammo.btCylinderShapeX(halfExtents);
					break;

				case 1:
					halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
					shape = new Ammo.btCylinderShape(halfExtents);
					break;

				case 2:
					halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
					shape = new Ammo.btCylinderShapeZ(halfExtents);
					break;
			}
		}

		if (halfExtents) Ammo.destroy(halfExtents);
		return shape;
	}

}

class CollisionConeSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		const axis = data.axis !== undefined ? data.axis : 1;
		const radius = data.radius !== undefined ? data.radius : 0.5;
		const height = data.height !== undefined ? data.height : 1;
		let shape = null;

		if (typeof Ammo !== 'undefined') {
			switch (axis) {
				case 0:
					shape = new Ammo.btConeShapeX(radius, height);
					break;

				case 1:
					shape = new Ammo.btConeShape(radius, height);
					break;

				case 2:
					shape = new Ammo.btConeShapeZ(radius, height);
					break;
			}
		}

		return shape;
	}

}

class CollisionMeshSystemImpl extends CollisionSystemImpl {
	beforeInitialize(component, data) {}

	createAmmoMesh(mesh, node, shape) {
		let triMesh;

		if (this.system._triMeshCache[mesh.id]) {
			triMesh = this.system._triMeshCache[mesh.id];
		} else {
			const vb = mesh.vertexBuffer;
			const format = vb.getFormat();
			let stride;
			let positions;

			for (let i = 0; i < format.elements.length; i++) {
				const element = format.elements[i];

				if (element.name === SEMANTIC_POSITION) {
					positions = new Float32Array(vb.lock(), element.offset);
					stride = element.stride / 4;
					break;
				}
			}

			const indices = [];
			mesh.getIndices(indices);
			const numTriangles = mesh.primitive[0].count / 3;
			const v1 = new Ammo.btVector3();
			const v2 = new Ammo.btVector3();
			const v3 = new Ammo.btVector3();
			let i1, i2, i3;
			const base = mesh.primitive[0].base;
			triMesh = new Ammo.btTriangleMesh();
			this.system._triMeshCache[mesh.id] = triMesh;

			for (let i = 0; i < numTriangles; i++) {
				i1 = indices[base + i * 3] * stride;
				i2 = indices[base + i * 3 + 1] * stride;
				i3 = indices[base + i * 3 + 2] * stride;
				v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
				v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
				v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
				triMesh.addTriangle(v1, v2, v3, true);
			}

			Ammo.destroy(v1);
			Ammo.destroy(v2);
			Ammo.destroy(v3);
		}

		const useQuantizedAabbCompression = true;
		const triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);

		const scaling = this.system._getNodeScaling(node);

		triMeshShape.setLocalScaling(scaling);
		Ammo.destroy(scaling);

		const transform = this.system._getNodeTransform(node);

		shape.addChildShape(transform, triMeshShape);
		Ammo.destroy(transform);
	}

	createPhysicalShape(entity, data) {
		if (typeof Ammo === 'undefined') return;

		if (data.model || data.render) {
			const shape = new Ammo.btCompoundShape();

			if (data.model) {
				const meshInstances = data.model.meshInstances;

				for (let i = 0; i < meshInstances.length; i++) {
					this.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);
				}
			} else if (data.render) {
				const meshes = data.render.meshes;

				for (let i = 0; i < meshes.length; i++) {
					this.createAmmoMesh(meshes[i], tempGraphNode, shape);
				}
			}

			const entityTransform = entity.getWorldTransform();
			const scale = entityTransform.getScale();
			const vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
			shape.setLocalScaling(vec);
			Ammo.destroy(vec);
			return shape;
		}
	}

	recreatePhysicalShapes(component) {
		const data = component.data;

		if (data.renderAsset || data.asset) {
			if (component.enabled && component.entity.enabled) {
				this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
				return;
			}
		}

		this.doRecreatePhysicalShape(component);
	}

	loadAsset(component, id, property) {
		const data = component.data;
		const assets = this.system.app.assets;
		const asset = assets.get(id);

		if (asset) {
			asset.ready(asset => {
				data[property] = asset.resource;
				this.doRecreatePhysicalShape(component);
			});
			assets.load(asset);
		} else {
			assets.once("add:" + id, asset => {
				asset.ready(asset => {
					data[property] = asset.resource;
					this.doRecreatePhysicalShape(component);
				});
				assets.load(asset);
			});
		}
	}

	doRecreatePhysicalShape(component) {
		const entity = component.entity;
		const data = component.data;

		if (data.model || data.render) {
			this.destroyShape(data);
			data.shape = this.createPhysicalShape(entity, data);

			if (entity.rigidbody) {
				entity.rigidbody.disableSimulation();
				entity.rigidbody.createBody();

				if (entity.enabled && entity.rigidbody.enabled) {
					entity.rigidbody.enableSimulation();
				}
			} else {
				if (!entity.trigger) {
					entity.trigger = new Trigger(this.system.app, component, data);
				} else {
					entity.trigger.initialize(data);
				}
			}
		} else {
			this.beforeRemove(entity, component);
			this.remove(entity, data);
		}
	}

	updateTransform(component, position, rotation, scale) {
		if (component.shape) {
			const entityTransform = component.entity.getWorldTransform();
			const worldScale = entityTransform.getScale();
			const previousScale = component.shape.getLocalScaling();

			if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
				this.doRecreatePhysicalShape(component);
			}
		}

		super.updateTransform(component, position, rotation, scale);
	}

	destroyShape(data) {
		if (!data.shape) return;
		const numShapes = data.shape.getNumChildShapes();

		for (let i = 0; i < numShapes; i++) {
			const shape = data.shape.getChildShape(i);
			Ammo.destroy(shape);
		}

		Ammo.destroy(data.shape);
		data.shape = null;
	}

	remove(entity, data) {
		this.destroyShape(data);
		super.remove(entity, data);
	}

}

class CollisionCompoundSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		if (typeof Ammo !== 'undefined') {
			return new Ammo.btCompoundShape();
		}

		return undefined;
	}

	_addEachDescendant(entity) {
		if (!entity.collision || entity.rigidbody) return;
		entity.collision._compoundParent = this;

		if (entity !== this.entity) {
			entity.collision.system.recreatePhysicalShapes(entity.collision);
		}
	}

	_updateEachDescendant(entity) {
		if (!entity.collision) return;
		if (entity.collision._compoundParent !== this) return;
		entity.collision._compoundParent = null;

		if (entity !== this.entity && !entity.rigidbody) {
			entity.collision.system.recreatePhysicalShapes(entity.collision);
		}
	}

	_updateEachDescendantTransform(entity) {
		if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;
		this.collision.system.updateCompoundChildTransform(entity);
	}

}

class CollisionComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = "collision";
		this.ComponentType = CollisionComponent;
		this.DataType = CollisionComponentData;
		this.schema = _schema$f;
		this.implementations = {};
		this._triMeshCache = {};
		this.on('beforeremove', this.onBeforeRemove, this);
		this.on('remove', this.onRemove, this);
	}

	initializeComponentData(component, _data, properties) {
		properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled'];
		const data = {};

		for (let i = 0, len = properties.length; i < len; i++) {
			const property = properties[i];
			data[property] = _data[property];
		}

		let idx;

		if (_data.hasOwnProperty('asset')) {
			idx = properties.indexOf('model');

			if (idx !== -1) {
				properties.splice(idx, 1);
			}

			idx = properties.indexOf('render');

			if (idx !== -1) {
				properties.splice(idx, 1);
			}
		} else if (_data.hasOwnProperty('model')) {
			idx = properties.indexOf('asset');

			if (idx !== -1) {
				properties.splice(idx, 1);
			}
		}

		if (!data.type) {
			data.type = component.data.type;
		}

		component.data.type = data.type;

		if (data.halfExtents && Array.isArray(data.halfExtents)) {
			data.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);
		}

		const impl = this._createImplementation(data.type);

		impl.beforeInitialize(component, data);
		super.initializeComponentData(component, data, properties);
		impl.afterInitialize(component, data);
	}

	_createImplementation(type) {
		if (this.implementations[type] === undefined) {
			let impl;

			switch (type) {
				case 'box':
					impl = new CollisionBoxSystemImpl(this);
					break;

				case 'sphere':
					impl = new CollisionSphereSystemImpl(this);
					break;

				case 'capsule':
					impl = new CollisionCapsuleSystemImpl(this);
					break;

				case 'cylinder':
					impl = new CollisionCylinderSystemImpl(this);
					break;

				case 'cone':
					impl = new CollisionConeSystemImpl(this);
					break;

				case 'mesh':
					impl = new CollisionMeshSystemImpl(this);
					break;

				case 'compound':
					impl = new CollisionCompoundSystemImpl(this);
					break;
			}

			this.implementations[type] = impl;
		}

		return this.implementations[type];
	}

	_getImplementation(entity) {
		return this.implementations[entity.collision.data.type];
	}

	cloneComponent(entity, clone) {
		return this._getImplementation(entity).clone(entity, clone);
	}

	onBeforeRemove(entity, component) {
		this.implementations[component.data.type].beforeRemove(entity, component);
		component.onBeforeRemove();
	}

	onRemove(entity, data) {
		this.implementations[data.type].remove(entity, data);
	}

	updateCompoundChildTransform(entity) {
		this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);

		if (entity.enabled && entity.collision.enabled) {
			const transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);

			entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);

			Ammo.destroy(transform);
		}
	}

	_removeCompoundChild(collision, shape) {
		if (collision.shape.removeChildShape) {
			collision.shape.removeChildShape(shape);
		} else {
			const ind = collision._getCompoundChildShapeIndex(shape);

			if (ind !== null) {
				collision.shape.removeChildShapeByIndex(ind);
			}
		}
	}

	onTransformChanged(component, position, rotation, scale) {
		this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
	}

	changeType(component, previousType, newType) {
		this.implementations[previousType].beforeRemove(component.entity, component);
		this.implementations[previousType].remove(component.entity, component.data);

		this._createImplementation(newType).reset(component, component.data);
	}

	recreatePhysicalShapes(component) {
		this.implementations[component.data.type].recreatePhysicalShapes(component);
	}

	_calculateNodeRelativeTransform(node, relative) {
		if (node === relative) {
			const scale = node.getWorldTransform().getScale();
			mat4.setScale(scale.x, scale.y, scale.z);
		} else {
			this._calculateNodeRelativeTransform(node.parent, relative);

			mat4.mul(node.getLocalTransform());
		}
	}

	_getNodeScaling(node) {
		const wtm = node.getWorldTransform();
		const scl = wtm.getScale();
		return new Ammo.btVector3(scl.x, scl.y, scl.z);
	}

	_getNodeTransform(node, relative) {
		let pos, rot;

		if (relative) {
			this._calculateNodeRelativeTransform(node, relative);

			pos = vec3;
			rot = quat;
			mat4.getTranslation(pos);
			rot.setFromMat4(mat4);
		} else {
			pos = node.getPosition();
			rot = node.getRotation();
		}

		const transform = new Ammo.btTransform();
		transform.setIdentity();
		const origin = transform.getOrigin();
		origin.setValue(pos.x, pos.y, pos.z);
		const ammoQuat = new Ammo.btQuaternion();
		ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
		transform.setRotation(ammoQuat);
		Ammo.destroy(ammoQuat);
		Ammo.destroy(origin);
		return transform;
	}

	destroy() {
		for (const key in this._triMeshCache) {
			Ammo.destroy(this._triMeshCache[key]);
		}

		this._triMeshCache = null;
		super.destroy();
	}

}

Component._buildAccessors(CollisionComponent.prototype, _schema$f);

class ComponentSystemRegistry extends EventHandler {
	constructor() {
		super();
		this.anim = void 0;
		this.animation = void 0;
		this.audiolistener = void 0;
		this.audiosource = void 0;
		this.button = void 0;
		this.camera = void 0;
		this.collision = void 0;
		this.element = void 0;
		this.joint = void 0;
		this.layoutchild = void 0;
		this.layoutgroup = void 0;
		this.light = void 0;
		this.model = void 0;
		this.particlesystem = void 0;
		this.render = void 0;
		this.rigidbody = void 0;
		this.screen = void 0;
		this.script = void 0;
		this.scrollbar = void 0;
		this.scrollview = void 0;
		this.sound = void 0;
		this.sprite = void 0;
		this.zone = void 0;
		this.list = [];
	}

	add(system) {
		const id = system.id;

		if (this[id]) {
			throw new Error(`ComponentSystem name '${id}' already registered or not allowed`);
		}

		this[id] = system;
		this.list.push(system);
	}

	remove(system) {
		const id = system.id;

		if (!this[id]) {
			throw new Error(`No ComponentSystem named '${id}' registered`);
		}

		delete this[id];
		const index = this.list.indexOf(this[id]);

		if (index !== -1) {
			this.list.splice(index, 1);
		}
	}

	destroy() {
		this.off();

		for (let i = 0; i < this.list.length; i++) {
			this.list[i].destroy();
		}
	}

}

class StencilParameters {
	constructor(options) {
		this.func = options.func === undefined ? FUNC_ALWAYS : options.func;
		this.ref = options.ref || 0;
		this.readMask = options.readMask === undefined ? 0xFF : options.readMask;
		this.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;
		this.fail = options.fail || STENCILOP_KEEP;
		this.zfail = options.zfail || STENCILOP_KEEP;
		this.zpass = options.zpass || STENCILOP_KEEP;
	}

	clone() {
		return new StencilParameters({
			func: this.func,
			ref: this.ref,
			readMask: this.readMask,
			writeMask: this.writeMask,
			fail: this.fail,
			zfail: this.zfail,
			zpass: this.zpass
		});
	}

}

class ImageRenderable {
	constructor(entity, mesh, material) {
		this._entity = entity;
		this._element = entity.element;
		this.model = new Model();
		this.node = new GraphNode();
		this.model.graph = this.node;
		this.mesh = mesh;
		this.meshInstance = new MeshInstance(this.mesh, material, this.node);
		this.meshInstance.name = 'ImageElement: ' + entity.name;
		this.meshInstance.castShadow = false;
		this.meshInstance.receiveShadow = false;
		this._meshDirty = false;
		this.model.meshInstances.push(this.meshInstance);

		this._entity.addChild(this.model.graph);

		this.model._entity = this._entity;
		this.unmaskMeshInstance = null;
	}

	destroy() {
		this.setMaterial(null);

		this._element.removeModelFromLayers(this.model);

		this.model.destroy();
		this.model = null;
		this.node = null;
		this.mesh = null;
		this.meshInstance = null;
		this._entity = null;
		this._element = null;
	}

	setMesh(mesh) {
		if (!this.meshInstance) return;
		this.mesh = mesh;
		this.meshInstance.mesh = mesh;
		this.meshInstance.visible = !!mesh;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.mesh = mesh;
		}

		this.forceUpdateAabb();
	}

	setMask(mask) {
		if (!this.meshInstance) return;

		if (mask) {
			this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
			this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;
			this.unmaskMeshInstance.castShadow = false;
			this.unmaskMeshInstance.receiveShadow = false;
			this.unmaskMeshInstance.pick = false;
			this.model.meshInstances.push(this.unmaskMeshInstance);

			for (const name in this.meshInstance.parameters) {
				this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
			}
		} else {
			const idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);

			if (idx >= 0) {
				this.model.meshInstances.splice(idx, 1);
			}

			this.unmaskMeshInstance = null;
		}

		if (this._entity.enabled && this._element.enabled) {
			this._element.removeModelFromLayers(this.model);

			this._element.addModelToLayers(this.model);
		}
	}

	setMaterial(material) {
		if (!this.meshInstance) return;
		this.meshInstance.material = material;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.material = material;
		}
	}

	setParameter(name, value) {
		if (!this.meshInstance) return;
		this.meshInstance.setParameter(name, value);

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.setParameter(name, value);
		}
	}

	deleteParameter(name) {
		if (!this.meshInstance) return;
		this.meshInstance.deleteParameter(name);

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.deleteParameter(name);
		}
	}

	setUnmaskDrawOrder() {
		if (!this.meshInstance) return;

		const getLastChild = function getLastChild(e) {
			let last;
			const c = e.children;
			const l = c.length;

			if (l) {
				for (let i = 0; i < l; i++) {
					if (c[i].element) {
						last = c[i];
					}
				}

				if (!last) return null;
				const child = getLastChild(last);

				if (child) {
					return child;
				}

				return last;
			}

			return null;
		};

		if (this.unmaskMeshInstance) {
			const lastChild = getLastChild(this._entity);

			if (lastChild && lastChild.element) {
				this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
			} else {
				this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
			}
		}
	}

	setDrawOrder(drawOrder) {
		if (!this.meshInstance) return;
		this.meshInstance.drawOrder = drawOrder;
	}

	setCull(cull) {
		if (!this.meshInstance) return;
		const element = this._element;
		let visibleFn = null;

		if (cull && element._isScreenCulled()) {
			visibleFn = function (camera) {
				return element.isVisibleForCamera(camera);
			};
		}

		this.meshInstance.cull = cull;
		this.meshInstance.isVisibleFunc = visibleFn;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.cull = cull;
			this.unmaskMeshInstance.isVisibleFunc = visibleFn;
		}
	}

	setScreenSpace(screenSpace) {
		if (!this.meshInstance) return;
		this.meshInstance.screenSpace = screenSpace;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.screenSpace = screenSpace;
		}
	}

	setLayer(layer) {
		if (!this.meshInstance) return;
		this.meshInstance.layer = layer;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.layer = layer;
		}
	}

	forceUpdateAabb(mask) {
		if (!this.meshInstance) return;
		this.meshInstance._aabbVer = -1;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance._aabbVer = -1;
		}
	}

	setAabbFunc(fn) {
		if (!this.meshInstance) return;
		this.meshInstance._updateAabbFunc = fn;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance._updateAabbFunc = fn;
		}
	}

}

class ImageElement {
	constructor(element) {
		this._element = element;
		this._entity = element.entity;
		this._system = element.system;
		this._textureAsset = null;
		this._texture = null;
		this._materialAsset = null;
		this._material = null;
		this._spriteAsset = null;
		this._sprite = null;
		this._spriteFrame = 0;
		this._pixelsPerUnit = null;
		this._rect = new Vec4(0, 0, 1, 1);
		this._mask = false;
		this._maskRef = 0;
		this._outerScale = new Vec2();
		this._outerScaleUniform = new Float32Array(2);
		this._innerOffset = new Vec4();
		this._innerOffsetUniform = new Float32Array(4);
		this._atlasRect = new Vec4();
		this._atlasRectUniform = new Float32Array(4);
		this._defaultMesh = this._createMesh();
		this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array([1, 1, 1]);

		this._renderable.setParameter('material_emissive', this._colorUniform);

		this._renderable.setParameter('material_opacity', 1);

		this._updateAabbFunc = this._updateAabb.bind(this);

		this._onScreenChange(this._element.screen);

		this._element.on('resize', this._onParentResizeOrPivotChange, this);

		this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);

		this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);

		this._element.on('set:screen', this._onScreenChange, this);

		this._element.on('set:draworder', this._onDrawOrderChange, this);

		this._element.on('screen:set:resolution', this._onResolutionChange, this);
	}

	destroy() {
		this.textureAsset = null;
		this.spriteAsset = null;
		this.materialAsset = null;

		this._renderable.setMesh(this._defaultMesh);

		this._renderable.destroy();

		this._defaultMesh = null;

		this._element.off('resize', this._onParentResizeOrPivotChange, this);

		this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);

		this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

		this._element.off('set:screen', this._onScreenChange, this);

		this._element.off('set:draworder', this._onDrawOrderChange, this);

		this._element.off('screen:set:resolution', this._onResolutionChange, this);
	}

	_onResolutionChange(res) {}

	_onParentResizeOrPivotChange() {
		if (this._renderable.mesh) {
			this._updateMesh(this._renderable.mesh);
		}
	}

	_onScreenSpaceChange(value) {
		this._updateMaterial(value);
	}

	_onScreenChange(screen, previous) {
		if (screen) {
			this._updateMaterial(screen.screen.screenSpace);
		} else {
			this._updateMaterial(false);
		}
	}

	_onDrawOrderChange(order) {
		this._renderable.setDrawOrder(order);

		if (this.mask && this._element.screen) {
			this._element.screen.screen.once('syncdraworder', function () {
				this._renderable.setUnmaskDrawOrder();
			}, this);
		}
	}

	_hasUserMaterial() {
		return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
	}

	_use9Slicing() {
		return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
	}

	_updateMaterial(screenSpace) {
		const mask = !!this._mask;
		const nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
		const nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);

		if (!this._hasUserMaterial()) {
			this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
		}

		if (this._renderable) {
			this._renderable.setCull(true);

			this._renderable.setMaterial(this._material);

			this._renderable.setScreenSpace(screenSpace);

			this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
		}
	}

	_createMesh() {
		const element = this._element;
		const w = element.calculatedWidth;
		const h = element.calculatedHeight;
		const r = this._rect;
		const vertexData = new ArrayBuffer(4 * 8 * 4);
		const vertexDataF32 = new Float32Array(vertexData);
		vertexDataF32[5] = 1;
		vertexDataF32[6] = r.x;
		vertexDataF32[7] = 1.0 - r.y;
		vertexDataF32[8] = w;
		vertexDataF32[13] = 1;
		vertexDataF32[14] = r.x + r.z;
		vertexDataF32[15] = 1.0 - r.y;
		vertexDataF32[16] = w;
		vertexDataF32[17] = h;
		vertexDataF32[21] = 1;
		vertexDataF32[22] = r.x + r.z;
		vertexDataF32[23] = 1.0 - (r.y + r.w);
		vertexDataF32[25] = h;
		vertexDataF32[29] = 1;
		vertexDataF32[30] = r.x;
		vertexDataF32[31] = 1.0 - (r.y + r.w);
		const vertexDesc = [{
			semantic: SEMANTIC_POSITION,
			components: 3,
			type: TYPE_FLOAT32
		}, {
			semantic: SEMANTIC_NORMAL,
			components: 3,
			type: TYPE_FLOAT32
		}, {
			semantic: SEMANTIC_TEXCOORD0,
			components: 2,
			type: TYPE_FLOAT32
		}];
		const device = this._system.app.graphicsDevice;
		const vertexFormat = new VertexFormat(device, vertexDesc);
		const vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);
		const mesh = new Mesh(device);
		mesh.vertexBuffer = vertexBuffer;
		mesh.primitive[0].type = PRIMITIVE_TRIFAN;
		mesh.primitive[0].base = 0;
		mesh.primitive[0].count = 4;
		mesh.primitive[0].indexed = false;
		mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));

		this._updateMesh(mesh);

		return mesh;
	}

	_updateMesh(mesh) {
		const element = this._element;
		const w = element.calculatedWidth;
		const h = element.calculatedHeight;

		const screenSpace = element._isScreenSpace();

		this._updateMaterial(screenSpace);

		if (this._renderable) this._renderable.forceUpdateAabb();

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			const frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
			const borderWidthScale = 2 / frameData.rect.z;
			const borderHeightScale = 2 / frameData.rect.w;

			this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

			const tex = this.sprite.atlas.texture;

			this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);

			const ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
			const scaleMulX = frameData.rect.z / ppu;
			const scaleMulY = frameData.rect.w / ppu;

			this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));

			let scaleX = scaleMulX;
			let scaleY = scaleMulY;
			this._outerScale.x /= scaleMulX;
			this._outerScale.y /= scaleMulY;
			scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
			scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);

			if (this._renderable) {
				this._innerOffsetUniform[0] = this._innerOffset.x;
				this._innerOffsetUniform[1] = this._innerOffset.y;
				this._innerOffsetUniform[2] = this._innerOffset.z;
				this._innerOffsetUniform[3] = this._innerOffset.w;

				this._renderable.setParameter('innerOffset', this._innerOffsetUniform);

				this._atlasRectUniform[0] = this._atlasRect.x;
				this._atlasRectUniform[1] = this._atlasRect.y;
				this._atlasRectUniform[2] = this._atlasRect.z;
				this._atlasRectUniform[3] = this._atlasRect.w;

				this._renderable.setParameter('atlasRect', this._atlasRectUniform);

				this._outerScaleUniform[0] = this._outerScale.x;
				this._outerScaleUniform[1] = this._outerScale.y;

				this._renderable.setParameter('outerScale', this._outerScaleUniform);

				this._renderable.setAabbFunc(this._updateAabbFunc);

				this._renderable.node.setLocalScale(scaleX, scaleY, 1);

				this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
			}
		} else {
			const vb = mesh.vertexBuffer;
			const vertexDataF32 = new Float32Array(vb.lock());
			const hp = element.pivot.x;
			const vp = element.pivot.y;
			vertexDataF32[0] = 0 - hp * w;
			vertexDataF32[1] = 0 - vp * h;
			vertexDataF32[8] = w - hp * w;
			vertexDataF32[9] = 0 - vp * h;
			vertexDataF32[16] = w - hp * w;
			vertexDataF32[17] = h - vp * h;
			vertexDataF32[24] = 0 - hp * w;
			vertexDataF32[25] = h - vp * h;
			let atlasTextureWidth = 1;
			let atlasTextureHeight = 1;
			let rect = this._rect;

			if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
				const frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];

				if (frame) {
					rect = frame.rect;
					atlasTextureWidth = this._sprite.atlas.texture.width;
					atlasTextureHeight = this._sprite.atlas.texture.height;
				}
			}

			vertexDataF32[6] = rect.x / atlasTextureWidth;
			vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
			vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
			vertexDataF32[15] = 1.0 - rect.y / atlasTextureHeight;
			vertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;
			vertexDataF32[23] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
			vertexDataF32[30] = rect.x / atlasTextureWidth;
			vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
			vb.unlock();
			const min = new Vec3(0 - hp * w, 0 - vp * h, 0);
			const max = new Vec3(w - hp * w, h - vp * h, 0);
			mesh.aabb.setMinMax(min, max);

			if (this._renderable) {
				this._renderable.node.setLocalScale(1, 1, 1);

				this._renderable.node.setLocalPosition(0, 0, 0);

				this._renderable.setAabbFunc(null);
			}
		}

		this._meshDirty = false;
	}

	_updateSprite() {
		let nineSlice = false;
		let mesh = null;

		if (this._sprite && this._sprite.atlas) {
			mesh = this._sprite.meshes[this.spriteFrame];
			nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
		}

		this.mesh = nineSlice ? mesh : this._defaultMesh;

		if (this.mesh) {
			if (!this._element._beingInitialized) {
				this._updateMesh(this.mesh);
			} else {
				this._meshDirty = true;
			}
		}
	}

	_updateAabb(aabb) {
		aabb.center.set(0, 0, 0);
		aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
		aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
		return aabb;
	}

	_toggleMask() {
		this._element._dirtifyMask();

		const screenSpace = this._element._isScreenSpace();

		this._updateMaterial(screenSpace);

		this._renderable.setMask(!!this._mask);
	}

	_onMaterialLoad(asset) {
		this.material = asset.resource;
	}

	_onMaterialAdded(asset) {
		this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);

		if (this._materialAsset === asset.id) {
			this._bindMaterialAsset(asset);
		}
	}

	_bindMaterialAsset(asset) {
		if (!this._entity.enabled) return;
		asset.on("load", this._onMaterialLoad, this);
		asset.on("change", this._onMaterialChange, this);
		asset.on("remove", this._onMaterialRemove, this);

		if (asset.resource) {
			this._onMaterialLoad(asset);
		} else {
			this._system.app.assets.load(asset);
		}
	}

	_unbindMaterialAsset(asset) {
		asset.off("load", this._onMaterialLoad, this);
		asset.off("change", this._onMaterialChange, this);
		asset.off("remove", this._onMaterialRemove, this);
	}

	_onMaterialChange() {}

	_onMaterialRemove() {}

	_onTextureAdded(asset) {
		this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);

		if (this._textureAsset === asset.id) {
			this._bindTextureAsset(asset);
		}
	}

	_bindTextureAsset(asset) {
		if (!this._entity.enabled) return;
		asset.on("load", this._onTextureLoad, this);
		asset.on("change", this._onTextureChange, this);
		asset.on("remove", this._onTextureRemove, this);

		if (asset.resource) {
			this._onTextureLoad(asset);
		} else {
			this._system.app.assets.load(asset);
		}
	}

	_unbindTextureAsset(asset) {
		asset.off("load", this._onTextureLoad, this);
		asset.off("change", this._onTextureChange, this);
		asset.off("remove", this._onTextureRemove, this);
	}

	_onTextureLoad(asset) {
		this.texture = asset.resource;
	}

	_onTextureChange(asset) {}

	_onTextureRemove(asset) {}

	_onSpriteAssetAdded(asset) {
		this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

		if (this._spriteAsset === asset.id) {
			this._bindSpriteAsset(asset);
		}
	}

	_bindSpriteAsset(asset) {
		if (!this._entity.enabled) return;
		asset.on("load", this._onSpriteAssetLoad, this);
		asset.on("change", this._onSpriteAssetChange, this);
		asset.on("remove", this._onSpriteAssetRemove, this);

		if (asset.resource) {
			this._onSpriteAssetLoad(asset);
		} else {
			this._system.app.assets.load(asset);
		}
	}

	_unbindSpriteAsset(asset) {
		asset.off("load", this._onSpriteAssetLoad, this);
		asset.off("change", this._onSpriteAssetChange, this);
		asset.off("remove", this._onSpriteAssetRemove, this);

		if (asset.data.textureAtlasAsset) {
			this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
		}
	}

	_onSpriteAssetLoad(asset) {
		if (!asset || !asset.resource) {
			this.sprite = null;
		} else {
			if (!asset.resource.atlas) {
				const atlasAssetId = asset.data.textureAtlasAsset;

				if (atlasAssetId) {
					const assets = this._system.app.assets;
					assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
				}
			} else {
				this.sprite = asset.resource;
			}
		}
	}

	_onSpriteAssetChange(asset) {
		this._onSpriteAssetLoad(asset);
	}

	_onSpriteAssetRemove(asset) {}

	_bindSprite(sprite) {
		sprite.on('set:meshes', this._onSpriteMeshesChange, this);
		sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
		sprite.on('set:atlas', this._onAtlasTextureChange, this);

		if (sprite.atlas) {
			sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
		}
	}

	_unbindSprite(sprite) {
		sprite.off('set:meshes', this._onSpriteMeshesChange, this);
		sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
		sprite.off('set:atlas', this._onAtlasTextureChange, this);

		if (sprite.atlas) {
			sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
		}
	}

	_onSpriteMeshesChange() {
		if (this._sprite) {
			this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
		}

		this._updateSprite();
	}

	_onSpritePpuChange() {
		if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
			this._updateSprite();
		}
	}

	_onAtlasTextureChange() {
		if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
			this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);

			this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
		} else {
			this._renderable.deleteParameter('texture_emissiveMap');

			this._renderable.deleteParameter('texture_opacityMap');
		}
	}

	_onTextureAtlasLoad(atlasAsset) {
		const spriteAsset = this._spriteAsset;

		if (spriteAsset instanceof Asset) {
			this._onSpriteAssetLoad(spriteAsset);
		} else {
			this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
		}
	}

	onEnable() {
		if (this._materialAsset) {
			const asset = this._system.app.assets.get(this._materialAsset);

			if (asset && asset.resource !== this._material) {
				this._bindMaterialAsset(asset);
			}
		}

		if (this._textureAsset) {
			const asset = this._system.app.assets.get(this._textureAsset);

			if (asset && asset.resource !== this._texture) {
				this._bindTextureAsset(asset);
			}
		}

		if (this._spriteAsset) {
			const asset = this._system.app.assets.get(this._spriteAsset);

			if (asset && asset.resource !== this._sprite) {
				this._bindSpriteAsset(asset);
			}
		}

		this._element.addModelToLayers(this._renderable.model);
	}

	onDisable() {
		this._element.removeModelFromLayers(this._renderable.model);
	}

	_setStencil(stencilParams) {
		this._renderable.meshInstance.stencilFront = stencilParams;
		this._renderable.meshInstance.stencilBack = stencilParams;
		let ref = 0;

		if (this._element.maskedBy) {
			ref = this._element.maskedBy.element._image._maskRef;
		}

		if (this._renderable.unmaskMeshInstance) {
			const sp = new StencilParameters({
				ref: ref + 1,
				func: FUNC_EQUAL,
				zpass: STENCILOP_DECREMENT
			});
			this._renderable.unmaskMeshInstance.stencilFront = sp;
			this._renderable.unmaskMeshInstance.stencilBack = sp;
		}
	}

	set color(value) {
		const r = value.r;
		const g = value.g;
		const b = value.b;

		if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
			this._color.r = r;
			this._color.g = g;
			this._color.b = b;
			this._colorUniform[0] = r;
			this._colorUniform[1] = g;
			this._colorUniform[2] = b;

			this._renderable.setParameter('material_emissive', this._colorUniform);
		}

		if (this._element) {
			this._element.fire('set:color', this._color);
		}
	}

	get color() {
		return this._color;
	}

	set opacity(value) {
		if (value !== this._color.a) {
			this._color.a = value;

			this._renderable.setParameter('material_opacity', value);
		}

		if (this._element) {
			this._element.fire('set:opacity', value);
		}
	}

	get opacity() {
		return this._color.a;
	}

	set rect(value) {
		let x, y, z, w;

		if (value instanceof Vec4) {
			x = value.x;
			y = value.y;
			z = value.z;
			w = value.w;
		} else {
			x = value[0];
			y = value[1];
			z = value[2];
			w = value[3];
		}

		if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
			return;
		}

		this._rect.set(x, y, z, w);

		if (this._renderable.mesh) {
			if (!this._element._beingInitialized) {
				this._updateMesh(this._renderable.mesh);
			} else {
				this._meshDirty = true;
			}
		}
	}

	get rect() {
		return this._rect;
	}

	set material(value) {
		if (this._material === value) return;

		if (!value) {
			const screenSpace = this._element._isScreenSpace();

			if (this.mask) {
				value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
			} else {
				value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
			}
		}

		this._material = value;

		if (value) {
			this._renderable.setMaterial(value);

			if (this._hasUserMaterial()) {
				this._renderable.deleteParameter('material_opacity');

				this._renderable.deleteParameter('material_emissive');
			} else {
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;

				this._renderable.setParameter('material_emissive', this._colorUniform);

				this._renderable.setParameter('material_opacity', this._color.a);
			}
		}
	}

	get material() {
		return this._material;
	}

	set materialAsset(value) {
		const assets = this._system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._materialAsset !== _id) {
			if (this._materialAsset) {
				assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);

				const _prev = assets.get(this._materialAsset);

				if (_prev) {
					_prev.off("load", this._onMaterialLoad, this);

					_prev.off("change", this._onMaterialChange, this);

					_prev.off("remove", this._onMaterialRemove, this);
				}
			}

			this._materialAsset = _id;

			if (this._materialAsset) {
				const asset = assets.get(this._materialAsset);

				if (!asset) {
					this.material = null;
					assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);
				} else {
					this._bindMaterialAsset(asset);
				}
			} else {
				this.material = null;
			}
		}
	}

	get materialAsset() {
		return this._materialAsset;
	}

	set texture(value) {
		if (this._texture === value) return;

		if (this._textureAsset) {
			const textureAsset = this._system.app.assets.get(this._textureAsset);

			if (textureAsset && textureAsset.resource !== value) {
				this.textureAsset = null;
			}
		}

		this._texture = value;

		if (value) {
			if (this._spriteAsset) {
				this.spriteAsset = null;
			}

			this._renderable.setParameter("texture_emissiveMap", this._texture);

			this._renderable.setParameter("texture_opacityMap", this._texture);

			this._colorUniform[0] = this._color.r;
			this._colorUniform[1] = this._color.g;
			this._colorUniform[2] = this._color.b;

			this._renderable.setParameter("material_emissive", this._colorUniform);

			this._renderable.setParameter("material_opacity", this._color.a);
		} else {
			this._renderable.deleteParameter("texture_emissiveMap");

			this._renderable.deleteParameter("texture_opacityMap");
		}
	}

	get texture() {
		return this._texture;
	}

	set textureAsset(value) {
		const assets = this._system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._textureAsset !== _id) {
			if (this._textureAsset) {
				assets.off('add:' + this._textureAsset, this._onTextureAdded, this);

				const _prev = assets.get(this._textureAsset);

				if (_prev) {
					_prev.off("load", this._onTextureLoad, this);

					_prev.off("change", this._onTextureChange, this);

					_prev.off("remove", this._onTextureRemove, this);
				}
			}

			this._textureAsset = _id;

			if (this._textureAsset) {
				const asset = assets.get(this._textureAsset);

				if (!asset) {
					this.texture = null;
					assets.on('add:' + this._textureAsset, this._onTextureAdded, this);
				} else {
					this._bindTextureAsset(asset);
				}
			} else {
				this.texture = null;
			}
		}
	}

	get textureAsset() {
		return this._textureAsset;
	}

	set spriteAsset(value) {
		const assets = this._system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._spriteAsset !== _id) {
			if (this._spriteAsset) {
				assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);

				const _prev = assets.get(this._spriteAsset);

				if (_prev) {
					this._unbindSpriteAsset(_prev);
				}
			}

			this._spriteAsset = _id;

			if (this._spriteAsset) {
				const asset = assets.get(this._spriteAsset);

				if (!asset) {
					this.sprite = null;
					assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
				} else {
					this._bindSpriteAsset(asset);
				}
			} else {
				this.sprite = null;
			}
		}

		if (this._element) {
			this._element.fire('set:spriteAsset', _id);
		}
	}

	get spriteAsset() {
		return this._spriteAsset;
	}

	set sprite(value) {
		if (this._sprite === value) return;

		if (this._sprite) {
			this._unbindSprite(this._sprite);
		}

		if (this._spriteAsset) {
			const spriteAsset = this._system.app.assets.get(this._spriteAsset);

			if (spriteAsset && spriteAsset.resource !== value) {
				this.spriteAsset = null;
			}
		}

		this._sprite = value;

		if (this._sprite) {
			this._bindSprite(this._sprite);

			if (this._textureAsset) {
				this.textureAsset = null;
			}
		}

		if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
			this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture);

			this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture);
		} else {
			this._renderable.deleteParameter("texture_emissiveMap");

			this._renderable.deleteParameter("texture_opacityMap");
		}

		if (this._sprite) {
			this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
		}

		this._updateSprite();
	}

	get sprite() {
		return this._sprite;
	}

	set spriteFrame(value) {
		const oldValue = this._spriteFrame;

		if (this._sprite) {
			this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
		} else {
			this._spriteFrame = value;
		}

		if (this._spriteFrame !== oldValue) {
			this._updateSprite();
		}

		if (this._element) {
			this._element.fire('set:spriteFrame', value);
		}
	}

	get spriteFrame() {
		return this._spriteFrame;
	}

	set mesh(value) {
		this._renderable.setMesh(value);

		if (this._defaultMesh === value) {
			this._renderable.setAabbFunc(null);
		} else {
			this._renderable.setAabbFunc(this._updateAabbFunc);
		}
	}

	get mesh() {
		return this._renderable.mesh;
	}

	set mask(value) {
		if (this._mask !== value) {
			this._mask = value;

			this._toggleMask();
		}
	}

	get mask() {
		return this._mask;
	}

	set pixelsPerUnit(value) {
		if (this._pixelsPerUnit === value) return;
		this._pixelsPerUnit = value;

		if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			this._updateSprite();
		}
	}

	get pixelsPerUnit() {
		return this._pixelsPerUnit;
	}

	get aabb() {
		if (this._renderable.meshInstance) {
			return this._renderable.meshInstance.aabb;
		}

		return null;
	}

}

class LocalizedAsset extends EventHandler {
	constructor(app) {
		super();
		this._app = app;
		app.i18n.on('set:locale', this._onSetLocale, this);
		this._autoLoad = false;
		this._disableLocalization = false;
		this._defaultAsset = null;
		this._localizedAsset = null;
	}

	set defaultAsset(value) {
		const id = value instanceof Asset ? value.id : value;
		if (this._defaultAsset === id) return;

		if (this._defaultAsset) {
			this._unbindDefaultAsset();
		}

		this._defaultAsset = id;

		if (this._defaultAsset) {
			this._bindDefaultAsset();
		}

		this._onSetLocale(this._app.i18n.locale);
	}

	get defaultAsset() {
		return this._defaultAsset;
	}

	set localizedAsset(value) {
		const id = value instanceof Asset ? value.id : value;

		if (this._localizedAsset === id) {
			return;
		}

		if (this._localizedAsset) {
			this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);

			this._unbindLocalizedAsset();

			this._localizedAsset = null;
		}

		this._localizedAsset = id;

		if (this._localizedAsset) {
			const asset = this._app.assets.get(this._localizedAsset);

			if (!asset) {
				this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
			} else {
				this._bindLocalizedAsset();
			}
		}
	}

	get localizedAsset() {
		return this._localizedAsset;
	}

	set autoLoad(value) {
		if (this._autoLoad === value) return;
		this._autoLoad = value;

		if (this._autoLoad && this._localizedAsset) {
			this._unbindLocalizedAsset();

			this._bindLocalizedAsset();
		}
	}

	get autoLoad() {
		return this._autoLoad;
	}

	set disableLocalization(value) {
		if (this._disableLocalization === value) return;
		this._disableLocalization = value;

		this._onSetLocale(this._app.i18n.locale);
	}

	get disableLocalization() {
		return this._disableLocalization;
	}

	_bindDefaultAsset() {
		const asset = this._app.assets.get(this._defaultAsset);

		if (!asset) {
			this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
		} else {
			this._onDefaultAssetAdd(asset);
		}
	}

	_unbindDefaultAsset() {
		if (!this._defaultAsset) return;

		this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);

		const asset = this._app.assets.get(this._defaultAsset);

		if (!asset) return;
		asset.off('add:localized', this._onLocaleAdd, this);
		asset.off('remove:localized', this._onLocaleRemove, this);
		asset.off('remove', this._onDefaultAssetRemove, this);
	}

	_onDefaultAssetAdd(asset) {
		if (this._defaultAsset !== asset.id) return;
		asset.on('add:localized', this._onLocaleAdd, this);
		asset.on('remove:localized', this._onLocaleRemove, this);
		asset.once('remove', this._onDefaultAssetRemove, this);
	}

	_onDefaultAssetRemove(asset) {
		if (this._defaultAsset !== asset.id) return;
		asset.off('add:localized', this._onLocaleAdd, this);
		asset.off('remove:localized', this._onLocaleAdd, this);

		this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
	}

	_bindLocalizedAsset() {
		if (!this._autoLoad) return;

		const asset = this._app.assets.get(this._localizedAsset);

		if (!asset) return;
		asset.on("load", this._onLocalizedAssetLoad, this);
		asset.on("change", this._onLocalizedAssetChange, this);
		asset.on("remove", this._onLocalizedAssetRemove, this);

		if (asset.resource) {
			this._onLocalizedAssetLoad(asset);
		} else {
			this._app.assets.load(asset);
		}
	}

	_unbindLocalizedAsset() {
		const asset = this._app.assets.get(this._localizedAsset);

		if (!asset) return;
		asset.off("load", this._onLocalizedAssetLoad, this);
		asset.off("change", this._onLocalizedAssetChange, this);
		asset.off("remove", this._onLocalizedAssetRemove, this);
	}

	_onLocalizedAssetAdd(asset) {
		if (this._localizedAsset !== asset.id) return;

		this._bindLocalizedAsset();
	}

	_onLocalizedAssetLoad(asset) {
		this.fire('load', asset);
	}

	_onLocalizedAssetChange(asset, name, newValue, oldValue) {
		this.fire('change', asset, name, newValue, oldValue);
	}

	_onLocalizedAssetRemove(asset) {
		if (this._localizedAsset === asset.id) {
			this.localizedAsset = this._defaultAsset;
		}

		this.fire('remove', asset);
	}

	_onLocaleAdd(locale, assetId) {
		if (this._app.i18n.locale !== locale) return;

		this._onSetLocale(locale);
	}

	_onLocaleRemove(locale, assetId) {
		if (this._app.i18n.locale !== locale) return;

		this._onSetLocale(locale);
	}

	_onSetLocale(locale) {
		if (!this._defaultAsset) {
			this.localizedAsset = null;
			return;
		}

		const asset = this._app.assets.get(this._defaultAsset);

		if (!asset || this._disableLocalization) {
			this.localizedAsset = this._defaultAsset;
			return;
		}

		const localizedAssetId = asset.getLocalizedAssetId(locale);

		if (!localizedAssetId) {
			this.localizedAsset = this._defaultAsset;
			return;
		}

		this.localizedAsset = localizedAssetId;
	}

	destroy() {
		this.defaultAsset = null;

		this._app.i18n.off('set:locale', this._onSetLocale, this);

		this.off();
	}

}

const EOF_TOKEN = 0;
const ERROR_TOKEN = 1;
const TEXT_TOKEN = 2;
const OPEN_BRACKET_TOKEN = 3;
const CLOSE_BRACKET_TOKEN = 4;
const EQUALS_TOKEN = 5;
const STRING_TOKEN = 6;
const IDENTIFIER_TOKEN = 7;
const WHITESPACE_TOKEN = 8;
const WHITESPACE_CHARS = " \t\n\r\v\f";
const IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;

class Scanner {
	constructor(symbols) {
		this._symbols = symbols;
		this._index = 0;
		this._last = 0;
		this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
		this._buf = [];
		this._mode = "text";
		this._error = null;
	}

	read() {
		let token = this._read();

		while (token === WHITESPACE_TOKEN) {
			token = this._read();
		}

		if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
			this._last = this._index;
		}

		return token;
	}

	buf() {
		return this._buf;
	}

	last() {
		return this._last;
	}

	error() {
		return this._error;
	}

	debugPrint() {
		const tokenStrings = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
		let token = this.read();
		let result = "";

		while (true) {
			result += (result.length > 0 ? "\n" : "") + tokenStrings[token] + " '" + this.buf().join("") + "'";

			if (token === EOF_TOKEN || token === ERROR_TOKEN) {
				break;
			}

			token = this.read();
		}

		return result;
	}

	_read() {
		this._buf = [];

		if (this._eof()) {
			return EOF_TOKEN;
		}

		return this._mode === "text" ? this._text() : this._tag();
	}

	_text() {
		while (true) {
			switch (this._cur) {
				case null:
					return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;

				case "[":
					this._mode = "tag";
					return this._buf.length > 0 ? TEXT_TOKEN : this._tag();

				case "\\":
					this._next();

					switch (this._cur) {
						case "[":
							this._store();

							break;

						default:
							this._output("\\");

							break;
					}

					break;

				default:
					this._store();

					break;
			}
		}
	}

	_tag() {
		switch (this._cur) {
			case null:
				this._error = "unexpected end of input reading tag";
				return ERROR_TOKEN;

			case "[":
				this._store();

				return OPEN_BRACKET_TOKEN;

			case "]":
				this._store();

				this._mode = "text";
				return CLOSE_BRACKET_TOKEN;

			case "=":
				this._store();

				return EQUALS_TOKEN;

			case " ":
			case "\t":
			case "\n":
			case "\r":
			case "\v":
			case "\f":
				return this._whitespace();

			case "\"":
				return this._string();

			default:
				if (!this._isIdentifierSymbol(this._cur)) {
					this._error = "unrecognized character";
					return ERROR_TOKEN;
				}

				return this._identifier();
		}
	}

	_whitespace() {
		this._store();

		while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
			this._store();
		}

		return WHITESPACE_TOKEN;
	}

	_string() {
		this._next();

		while (true) {
			switch (this._cur) {
				case null:
					this._error = "unexpected end of input reading string";
					return ERROR_TOKEN;

				case "\"":
					this._next();

					return STRING_TOKEN;

				default:
					this._store();

					break;
			}
		}
	}

	_identifier() {
		this._store();

		while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {
			this._store();
		}

		return IDENTIFIER_TOKEN;
	}

	_isIdentifierSymbol(s) {
		return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
	}

	_eof() {
		return this._cur === null;
	}

	_next() {
		if (!this._eof()) {
			this._index++;
			this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
		}

		return this._cur;
	}

	_store() {
		this._buf.push(this._cur);

		return this._next();
	}

	_output(c) {
		this._buf.push(c);
	}

}

class Parser {
	constructor(symbols) {
		this._scanner = new Scanner(symbols);
		this._error = null;
	}

	parse(symbols, tags) {
		while (true) {
			const token = this._scanner.read();

			switch (token) {
				case EOF_TOKEN:
					return true;

				case ERROR_TOKEN:
					return false;

				case TEXT_TOKEN:
					Array.prototype.push.apply(symbols, this._scanner.buf());
					break;

				case OPEN_BRACKET_TOKEN:
					if (!this._parseTag(symbols, tags)) {
						return false;
					}

					break;

				default:
					return false;
			}
		}
	}

	error() {
		return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")";
	}

	_parseTag(symbols, tags) {
		let token = this._scanner.read();

		if (token !== IDENTIFIER_TOKEN) {
			this._error = "expected identifier";
			return false;
		}

		const name = this._scanner.buf().join("");

		if (name[0] === "/") {
			for (let index = tags.length - 1; index >= 0; --index) {
				if (name === "/" + tags[index].name && tags[index].end === null) {
					tags[index].end = symbols.length;
					token = this._scanner.read();

					if (token !== CLOSE_BRACKET_TOKEN) {
						this._error = "expected close bracket";
						return false;
					}

					return true;
				}
			}

			this._error = "failed to find matching tag";
			return false;
		}

		const tag = {
			name: name,
			value: null,
			attributes: {},
			start: symbols.length,
			end: null
		};
		token = this._scanner.read();

		if (token === EQUALS_TOKEN) {
			token = this._scanner.read();

			if (token !== STRING_TOKEN) {
				this._error = "expected string";
				return false;
			}

			tag.value = this._scanner.buf().join("");
			token = this._scanner.read();
		}

		while (true) {
			switch (token) {
				case CLOSE_BRACKET_TOKEN:
					tags.push(tag);
					return true;

				case IDENTIFIER_TOKEN:
					{
						const identifier = this._scanner.buf().join("");

						token = this._scanner.read();

						if (token !== EQUALS_TOKEN) {
							this._error = "expected equals";
							return false;
						}

						token = this._scanner.read();

						if (token !== STRING_TOKEN) {
							this._error = "expected string";
							return false;
						}

						const value = this._scanner.buf().join("");

						tag.attributes[identifier] = value;
						break;
					}

				default:
					this._error = "expected close bracket or identifier";
					return false;
			}

			token = this._scanner.read();
		}
	}

}

function merge(target, source) {
	for (const key in source) {
		if (!source.hasOwnProperty(key)) {
			continue;
		}

		const value = source[key];

		if (value instanceof Object) {
			if (!target.hasOwnProperty(key)) {
				target[key] = {};
			}

			merge(target[key], source[key]);
		} else {
			target[key] = value;
		}
	}
}

function combineTags(tags) {
	if (tags.length === 0) {
		return null;
	}

	const result = {};

	for (let index = 0; index < tags.length; ++index) {
		const tag = tags[index];
		const tmp = {};
		tmp[tag.name] = {
			value: tag.value,
			attributes: tag.attributes
		};
		merge(result, tmp);
	}

	return result;
}

function resolveMarkupTags(tags, numSymbols) {
	if (tags.length === 0) {
		return null;
	}

	const edges = {};

	for (let index = 0; index < tags.length; ++index) {
		const tag = tags[index];

		if (!edges.hasOwnProperty(tag.start)) {
			edges[tag.start] = {
				open: [tag],
				close: null
			};
		} else {
			if (edges[tag.start].open === null) {
				edges[tag.start].open = [tag];
			} else {
				edges[tag.start].open.push(tag);
			}
		}

		if (!edges.hasOwnProperty(tag.end)) {
			edges[tag.end] = {
				open: null,
				close: [tag]
			};
		} else {
			if (edges[tag.end].close === null) {
				edges[tag.end].close = [tag];
			} else {
				edges[tag.end].close.push(tag);
			}
		}
	}

	let tagStack = [];

	function removeTags(tags) {
		tagStack = tagStack.filter(function (tag) {
			return tags.find(function (t) {
				return t === tag;
			}) === undefined;
		});
	}

	function addTags(tags) {
		for (let index = 0; index < tags.length; ++index) {
			tagStack.push(tags[index]);
		}
	}

	const edgeKeys = Object.keys(edges).sort(function (a, b) {
		return a - b;
	});
	const resolvedTags = [];

	for (let index = 0; index < edgeKeys.length; ++index) {
		const edge = edges[edgeKeys[index]];

		if (edge.close !== null) {
			removeTags(edge.close);
		}

		if (edge.open !== null) {
			addTags(edge.open);
		}

		resolvedTags.push({
			start: edgeKeys[index],
			tags: combineTags(tagStack)
		});
	}

	const result = [];
	let prevTag = null;

	for (let index = 0; index < resolvedTags.length; ++index) {
		const resolvedTag = resolvedTags[index];

		while (result.length < resolvedTag.start) {
			result.push(prevTag ? prevTag.tags : null);
		}

		prevTag = resolvedTag;
	}

	while (result.length < numSymbols) {
		result.push(null);
	}

	return result;
}

function evaluateMarkup(symbols) {
	const parser = new Parser(symbols);
	const stripped_symbols = [];
	const tags = [];

	if (!parser.parse(stripped_symbols, tags)) {
		console.warn(parser.error());
		return {
			symbols: symbols,
			tags: null
		};
	}

	const invalidTag = tags.find(function (t) {
		return t.end === null;
	});

	if (invalidTag) {
		console.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);
		return {
			symbols: symbols,
			tags: null
		};
	}

	const resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
	return {
		symbols: stripped_symbols,
		tags: resolved_tags
	};
}

class Markup {
	static evaluate(symbols) {
		return evaluateMarkup(symbols);
	}

}

class MeshInfo {
	constructor() {
		this.count = 0;
		this.quad = 0;
		this.lines = {};
		this.positions = [];
		this.normals = [];
		this.uvs = [];
		this.colors = [];
		this.indices = [];
		this.meshInstance = null;
	}

}

const LINE_BREAK_CHAR = /^[\r\n]$/;
const WHITESPACE_CHAR = /^[ \t]$/;
const WORD_BOUNDARY_CHAR = /^[ \t\-]|[\u200b]$/;
const ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
const CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/;
const NO_LINE_BREAK_CJK_CHAR = /^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/;
const CONTROL_CHARS = ['\u200B', '\u061C', '\u200E', '\u200F', '\u202A', '\u202B', '\u202C', '\u202D', '\u202E', '\u2066', '\u2067', '\u2068', '\u2069'];
const CONTROL_GLYPH_DATA = {
	width: 0,
	height: 0,
	xadvance: 0,
	xoffset: 0,
	yoffset: 0
};

class TextElement {
	constructor(element) {
		this._element = element;
		this._system = element.system;
		this._entity = element.entity;
		this._text = "";
		this._symbols = [];
		this._colorPalette = [];
		this._symbolColors = null;
		this._i18nKey = null;
		this._fontAsset = new LocalizedAsset(this._system.app);
		this._fontAsset.disableLocalization = true;

		this._fontAsset.on('load', this._onFontLoad, this);

		this._fontAsset.on('change', this._onFontChange, this);

		this._fontAsset.on('remove', this._onFontRemove, this);

		this._font = null;
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array(3);
		this._spacing = 1;
		this._fontSize = 32;
		this._fontMinY = 0;
		this._fontMaxY = 0;
		this._originalFontSize = 32;
		this._maxFontSize = 32;
		this._minFontSize = 8;
		this._autoFitWidth = false;
		this._autoFitHeight = false;
		this._maxLines = -1;
		this._lineHeight = 32;
		this._scaledLineHeight = 32;
		this._wrapLines = false;
		this._drawOrder = 0;
		this._alignment = new Vec2(0.5, 0.5);
		this._autoWidth = true;
		this._autoHeight = true;
		this.width = 0;
		this.height = 0;
		this._node = new GraphNode();
		this._model = new Model();
		this._model.graph = this._node;

		this._entity.addChild(this._node);

		this._meshInfo = [];
		this._material = null;
		this._aabbDirty = true;
		this._aabb = new BoundingBox();
		this._noResize = false;
		this._currentMaterialType = null;
		this._maskedMaterialSrc = null;
		this._rtlReorder = false;
		this._unicodeConverter = false;
		this._rtl = false;
		this._outlineColor = new Color(0, 0, 0, 1);
		this._outlineColorUniform = new Float32Array(4);
		this._outlineThicknessScale = 0.2;
		this._outlineThickness = 0.0;
		this._shadowColor = new Color(0, 0, 0, 1);
		this._shadowColorUniform = new Float32Array(4);
		this._shadowOffsetScale = 0.005;
		this._shadowOffset = new Vec2(0, 0);
		this._shadowOffsetUniform = new Float32Array(2);
		this._enableMarkup = false;

		this._onScreenChange(this._element.screen);

		element.on('resize', this._onParentResize, this);
		element.on('set:screen', this._onScreenChange, this);
		element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
		element.on('set:draworder', this._onDrawOrderChange, this);
		element.on('set:pivot', this._onPivotChange, this);

		this._system.app.i18n.on('set:locale', this._onLocaleSet, this);

		this._system.app.i18n.on('data:add', this._onLocalizationData, this);

		this._system.app.i18n.on('data:remove', this._onLocalizationData, this);

		this._rangeStart = 0;
		this._rangeEnd = 0;
	}

	destroy() {
		this._setMaterial(null);

		if (this._model) {
			this._element.removeModelFromLayers(this._model);

			this._model.destroy();

			this._model = null;
		}

		this._fontAsset.destroy();

		this.font = null;

		this._element.off('resize', this._onParentResize, this);

		this._element.off('set:screen', this._onScreenChange, this);

		this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

		this._element.off('set:draworder', this._onDrawOrderChange, this);

		this._element.off('set:pivot', this._onPivotChange, this);

		this._system.app.i18n.off('set:locale', this._onLocaleSet, this);

		this._system.app.i18n.off('data:add', this._onLocalizationData, this);

		this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
	}

	_onParentResize(width, height) {
		if (this._noResize) return;
		if (this._font) this._updateText();
	}

	_onScreenChange(screen) {
		if (screen) {
			this._updateMaterial(screen.screen.screenSpace);
		} else {
			this._updateMaterial(false);
		}
	}

	_onScreenSpaceChange(value) {
		this._updateMaterial(value);
	}

	_onDrawOrderChange(order) {
		this._drawOrder = order;

		if (this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				this._model.meshInstances[i].drawOrder = order;
			}
		}
	}

	_onPivotChange(pivot) {
		if (this._font) this._updateText();
	}

	_onLocaleSet(locale) {
		if (!this._i18nKey) return;

		if (this.fontAsset) {
			const asset = this._system.app.assets.get(this.fontAsset);

			if (!asset || !asset.resource || asset.resource !== this._font) {
				this.font = null;
			}
		}

		this._resetLocalizedText();
	}

	_onLocalizationData(locale, messages) {
		if (this._i18nKey && messages[this._i18nKey]) {
			this._resetLocalizedText();
		}
	}

	_resetLocalizedText() {
		this._setText(this._system.app.i18n.getText(this._i18nKey));
	}

	_setText(text) {
		if (this.unicodeConverter) {
			const unicodeConverterFunc = this._system.getUnicodeConverter();

			if (unicodeConverterFunc) {
				text = unicodeConverterFunc(text);
			} else {
				console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
			}
		}

		if (this._text !== text) {
			if (this._font) {
				this._updateText(text);
			}

			this._text = text;
		}
	}

	_updateText(text) {
		let tags;
		if (text === undefined) text = this._text;
		this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);

		if (this._symbols.length === 0) {
			this._symbols = [" "];
		}

		if (this._enableMarkup) {
			const results = Markup.evaluate(this._symbols);
			this._symbols = results.symbols;
			tags = results.tags;
		}

		if (this._rtlReorder) {
			const rtlReorderFunc = this._system.app.systems.element.getRtlReorder();

			if (rtlReorderFunc) {
				const results = rtlReorderFunc(this._symbols);
				this._rtl = results.rtl;
				this._symbols = results.mapping.map(function (v) {
					return this._symbols[v];
				}, this);

				if (tags) {
					tags = results.mapping.map(function (v) {
						return tags[v];
					});
				}
			} else {
				console.warn('Element created with rtlReorder option but no rtlReorder function registered');
			}
		} else {
			this._rtl = false;
		}

		if (tags) {
			const paletteMap = {};
			this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];
			this._symbolColors = [];
			paletteMap[this._color.toString(false).toLowerCase()] = 0;

			for (let i = 0, len = this._symbols.length; i < len; ++i) {
				const tag = tags[i];
				let color = 0;

				if (tag && tag.color && tag.color.value) {
					const c = tag.color.value;

					if (c.length === 7 && c[0] === "#") {
						const hex = c.substring(1).toLowerCase();

						if (paletteMap.hasOwnProperty(hex)) {
							color = paletteMap[hex];
						} else {
							if (/^([0-9a-f]{2}){3}$/.test(hex)) {
								color = this._colorPalette.length / 3;
								paletteMap[hex] = color;

								this._colorPalette.push(parseInt(hex.substring(0, 2), 16));

								this._colorPalette.push(parseInt(hex.substring(2, 4), 16));

								this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
							}
						}
					}
				}

				this._symbolColors.push(color);
			}
		} else {
			this._colorPalette = [];
			this._symbolColors = null;
		}

		const charactersPerTexture = this._calculateCharsPerTexture();

		let removedModel = false;
		const element = this._element;

		const screenSpace = element._isScreenSpace();

		const screenCulled = element._isScreenCulled();

		const visibleFn = function visibleFn(camera) {
			return element.isVisibleForCamera(camera);
		};

		for (let i = 0, len = this._meshInfo.length; i < len; i++) {
			const l = charactersPerTexture[i] || 0;
			const meshInfo = this._meshInfo[i];

			if (meshInfo.count !== l) {
				if (!removedModel) {
					element.removeModelFromLayers(this._model);
					removedModel = true;
				}

				meshInfo.count = l;
				meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
				meshInfo.indices.length = l * 3 * 2;
				meshInfo.uvs.length = l * 2 * 4;
				meshInfo.colors.length = l * 4 * 4;

				if (meshInfo.meshInstance) {
					this._removeMeshInstance(meshInfo.meshInstance);
				}

				if (l === 0) {
					meshInfo.meshInstance = null;
					continue;
				}

				for (let v = 0; v < l; v++) {
					meshInfo.indices[v * 3 * 2 + 0] = v * 4;
					meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
					meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
					meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
					meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
					meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
					meshInfo.normals[v * 4 * 3 + 0] = 0;
					meshInfo.normals[v * 4 * 3 + 1] = 0;
					meshInfo.normals[v * 4 * 3 + 2] = -1;
					meshInfo.normals[v * 4 * 3 + 3] = 0;
					meshInfo.normals[v * 4 * 3 + 4] = 0;
					meshInfo.normals[v * 4 * 3 + 5] = -1;
					meshInfo.normals[v * 4 * 3 + 6] = 0;
					meshInfo.normals[v * 4 * 3 + 7] = 0;
					meshInfo.normals[v * 4 * 3 + 8] = -1;
					meshInfo.normals[v * 4 * 3 + 9] = 0;
					meshInfo.normals[v * 4 * 3 + 10] = 0;
					meshInfo.normals[v * 4 * 3 + 11] = -1;
				}

				const mesh = createMesh$1(this._system.app.graphicsDevice, meshInfo.positions, {
					uvs: meshInfo.uvs,
					normals: meshInfo.normals,
					colors: meshInfo.colors,
					indices: meshInfo.indices
				});
				const mi = new MeshInstance(mesh, this._material, this._node);
				mi.name = "Text Element: " + this._entity.name;
				mi.castShadow = false;
				mi.receiveShadow = false;
				mi.cull = !screenSpace;
				mi.screenSpace = screenSpace;
				mi.drawOrder = this._drawOrder;

				if (screenCulled) {
					mi.cull = true;
					mi.isVisibleFunc = visibleFn;
				}

				this._setTextureParams(mi, this._font.textures[i]);

				if (this._symbolColors) {
					this._colorUniform[0] = 1;
					this._colorUniform[1] = 1;
					this._colorUniform[2] = 1;
				} else {
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;
				}

				mi.setParameter("material_emissive", this._colorUniform);
				mi.setParameter("material_opacity", this._color.a);
				mi.setParameter("font_sdfIntensity", this._font.intensity);
				mi.setParameter("font_pxrange", this._getPxRange(this._font));
				mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
				this._outlineColorUniform[0] = this._outlineColor.r;
				this._outlineColorUniform[1] = this._outlineColor.g;
				this._outlineColorUniform[2] = this._outlineColor.b;
				this._outlineColorUniform[3] = this._outlineColor.a;
				mi.setParameter("outline_color", this._outlineColorUniform);
				mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
				this._shadowColorUniform[0] = this._shadowColor.r;
				this._shadowColorUniform[1] = this._shadowColor.g;
				this._shadowColorUniform[2] = this._shadowColor.b;
				this._shadowColorUniform[3] = this._shadowColor.a;
				mi.setParameter("shadow_color", this._shadowColorUniform);
				const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
				this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
				this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
				mi.setParameter("shadow_offset", this._shadowOffsetUniform);
				meshInfo.meshInstance = mi;

				this._model.meshInstances.push(mi);
			}
		}

		if (this._element.maskedBy) {
			this._element._setMaskedBy(this._element.maskedBy);
		}

		if (removedModel && this._element.enabled && this._entity.enabled) {
			this._element.addModelToLayers(this._model);
		}

		this._updateMeshes();

		this._rangeStart = 0;
		this._rangeEnd = this._symbols.length;

		this._updateRenderRange();
	}

	_removeMeshInstance(meshInstance) {
		meshInstance.destroy();

		const idx = this._model.meshInstances.indexOf(meshInstance);

		if (idx !== -1) this._model.meshInstances.splice(idx, 1);
	}

	_setMaterial(material) {
		this._material = material;

		if (this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.material = material;
			}
		}
	}

	_updateMaterial(screenSpace) {
		const element = this._element;

		const screenCulled = element._isScreenCulled();

		const visibleFn = function visibleFn(camera) {
			return element.isVisibleForCamera(camera);
		};

		const msdf = this._font && this._font.type === FONT_MSDF;
		this._material = this._system.getTextElementMaterial(screenSpace, msdf);

		if (this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.cull = !screenSpace;
				mi.material = this._material;
				mi.screenSpace = screenSpace;

				if (screenCulled) {
					mi.cull = true;
					mi.isVisibleFunc = visibleFn;
				} else {
					mi.isVisibleFunc = null;
				}
			}
		}
	}

	_isWordBoundary(char) {
		return WORD_BOUNDARY_CHAR.test(char);
	}

	_isValidNextChar(nextchar) {
		return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
	}

	_isNextCJKBoundary(char, nextchar) {
		return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
	}

	_isNextCJKWholeWord(nextchar) {
		return CJK_CHAR.test(nextchar);
	}

	_updateMeshes() {
		const json = this._font.data;
		const self = this;
		const minFont = Math.min(this._minFontSize, this._maxFontSize);
		const maxFont = this._maxFontSize;

		const autoFit = this._shouldAutoFit();

		if (autoFit) {
			this._fontSize = this._maxFontSize;
		}

		const MAGIC = 32;
		const l = this._symbols.length;
		let _x = 0;
		let _y = 0;
		let _z = 0;
		let _xMinusTrailingWhitespace = 0;
		let lines = 1;
		let wordStartX = 0;
		let wordStartIndex = 0;
		let lineStartIndex = 0;
		let numWordsThisLine = 0;
		let numCharsThisLine = 0;
		let numBreaksThisLine = 0;
		const splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
		let maxLineWidth = this._element.calculatedWidth;

		if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
			maxLineWidth = Number.POSITIVE_INFINITY;
		}

		let fontMinY = 0;
		let fontMaxY = 0;
		let char, data, quad, nextchar;

		function breakLine(symbols, lineBreakIndex, lineBreakX) {
			self._lineWidths.push(Math.abs(lineBreakX));

			const sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
			const sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
			const chars = symbols.slice(sliceStart, sliceEnd);

			if (numBreaksThisLine) {
				let i = chars.length;

				while (i-- && numBreaksThisLine > 0) {
					if (LINE_BREAK_CHAR.test(chars[i])) {
						chars.splice(i, 1);
						numBreaksThisLine--;
					}
				}
			}

			self._lineContents.push(chars.join(''));

			_x = 0;
			_y -= self._scaledLineHeight;
			lines++;
			numWordsThisLine = 0;
			numCharsThisLine = 0;
			numBreaksThisLine = 0;
			wordStartX = 0;
			lineStartIndex = lineBreakIndex;
		}

		let retryUpdateMeshes = true;

		while (retryUpdateMeshes) {
			retryUpdateMeshes = false;

			if (autoFit) {
				this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
			} else {
				this._scaledLineHeight = this._lineHeight;
			}

			this.width = 0;
			this.height = 0;
			this._lineWidths = [];
			this._lineContents = [];
			_x = 0;
			_y = 0;
			_z = 0;
			_xMinusTrailingWhitespace = 0;
			lines = 1;
			wordStartX = 0;
			wordStartIndex = 0;
			lineStartIndex = 0;
			numWordsThisLine = 0;
			numCharsThisLine = 0;
			numBreaksThisLine = 0;
			const scale = this._fontSize / MAGIC;
			fontMinY = this._fontMinY * scale;
			fontMaxY = this._fontMaxY * scale;

			for (let i = 0; i < this._meshInfo.length; i++) {
				this._meshInfo[i].quad = 0;
				this._meshInfo[i].lines = {};
			}

			let color_r = 255;
			let color_g = 255;
			let color_b = 255;

			for (let i = 0; i < l; i++) {
				char = this._symbols[i];
				nextchar = i + 1 >= l ? null : this._symbols[i + 1];
				const isLineBreak = LINE_BREAK_CHAR.test(char);

				if (isLineBreak) {
					numBreaksThisLine++;

					if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
						breakLine(this._symbols, i, _xMinusTrailingWhitespace);
						wordStartIndex = i + 1;
						lineStartIndex = i + 1;
					}

					continue;
				}

				let x = 0;
				let y = 0;
				let advance = 0;
				let quadsize = 1;
				let dataScale, size;
				data = json.chars[char];

				if (!data) {
					if (CONTROL_CHARS.indexOf(char) !== -1) {
						data = CONTROL_GLYPH_DATA;
					} else {
						if (json.chars[' ']) {
							data = json.chars[' '];
						} else {
							for (const key in json.chars) {
								data = json.chars[key];
								break;
							}
						}
					}
				}

				if (data) {
					let kerning = 0;

					if (numCharsThisLine > 0) {
						const kernTable = this._font.data.kerning;

						if (kernTable) {
							const kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];

							if (kernLeft) {
								kerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;
							}
						}
					}

					dataScale = data.scale || 1;
					size = (data.width + data.height) / 2;
					quadsize = scale * size / dataScale;
					advance = (data.xadvance + kerning) * scale;
					x = (data.xoffset - kerning) * scale;
					y = data.yoffset * scale;
				} else {
					console.error(`Couldn't substitute missing character: '${char}'`);
				}

				const isWhitespace = WHITESPACE_CHAR.test(char);
				const meshInfo = this._meshInfo[data && data.map || 0];
				const candidateLineWidth = _x + this._spacing * advance;

				if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
					if (this._maxLines < 0 || lines < this._maxLines) {
						if (numWordsThisLine === 0) {
							wordStartIndex = i;
							breakLine(this._symbols, i, _xMinusTrailingWhitespace);
						} else {
							const backtrack = Math.max(i - wordStartIndex, 0);

							if (this._meshInfo.length <= 1) {
								meshInfo.lines[lines - 1] -= backtrack;
								meshInfo.quad -= backtrack;
							} else {
								const backtrackStart = wordStartIndex;
								const backtrackEnd = i;

								for (let j = backtrackStart; j < backtrackEnd; j++) {
									const backChar = this._symbols[j];
									const backCharData = json.chars[backChar];
									const backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
									backMeshInfo.lines[lines - 1] -= 1;
									backMeshInfo.quad -= 1;
								}
							}

							i -= backtrack + 1;
							breakLine(this._symbols, wordStartIndex, wordStartX);
							continue;
						}
					}
				}

				quad = meshInfo.quad;
				meshInfo.lines[lines - 1] = quad;
				let left = _x - x;
				let right = left + quadsize;
				const bottom = _y - y;
				const top = bottom + quadsize;

				if (this._rtl) {
					const shift = quadsize - x - this._spacing * advance - x;
					left -= shift;
					right -= shift;
				}

				meshInfo.positions[quad * 4 * 3 + 0] = left;
				meshInfo.positions[quad * 4 * 3 + 1] = bottom;
				meshInfo.positions[quad * 4 * 3 + 2] = _z;
				meshInfo.positions[quad * 4 * 3 + 3] = right;
				meshInfo.positions[quad * 4 * 3 + 4] = bottom;
				meshInfo.positions[quad * 4 * 3 + 5] = _z;
				meshInfo.positions[quad * 4 * 3 + 6] = right;
				meshInfo.positions[quad * 4 * 3 + 7] = top;
				meshInfo.positions[quad * 4 * 3 + 8] = _z;
				meshInfo.positions[quad * 4 * 3 + 9] = left;
				meshInfo.positions[quad * 4 * 3 + 10] = top;
				meshInfo.positions[quad * 4 * 3 + 11] = _z;
				this.width = Math.max(this.width, candidateLineWidth);
				let fontSize;

				if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
					fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
					fontSize = math.clamp(fontSize, minFont, maxFont);

					if (fontSize !== this._element.fontSize) {
						this._fontSize = fontSize;
						retryUpdateMeshes = true;
						break;
					}
				}

				this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));

				if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
					fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);

					if (fontSize !== this._element.fontSize) {
						this._fontSize = fontSize;
						retryUpdateMeshes = true;
						break;
					}
				}

				_x += this._spacing * advance;

				if (!isWhitespace) {
					_xMinusTrailingWhitespace = _x;
				}

				if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
					numWordsThisLine++;
					wordStartX = _xMinusTrailingWhitespace;
					wordStartIndex = i + 1;
				}

				numCharsThisLine++;

				const uv = this._getUv(char);

				meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
				meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
				meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
				meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
				meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
				meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
				meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
				meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];

				if (this._symbolColors) {
					const colorIdx = this._symbolColors[i] * 3;
					color_r = this._colorPalette[colorIdx];
					color_g = this._colorPalette[colorIdx + 1];
					color_b = this._colorPalette[colorIdx + 2];
				}

				meshInfo.colors[quad * 4 * 4 + 0] = color_r;
				meshInfo.colors[quad * 4 * 4 + 1] = color_g;
				meshInfo.colors[quad * 4 * 4 + 2] = color_b;
				meshInfo.colors[quad * 4 * 4 + 3] = 255;
				meshInfo.colors[quad * 4 * 4 + 4] = color_r;
				meshInfo.colors[quad * 4 * 4 + 5] = color_g;
				meshInfo.colors[quad * 4 * 4 + 6] = color_b;
				meshInfo.colors[quad * 4 * 4 + 7] = 255;
				meshInfo.colors[quad * 4 * 4 + 8] = color_r;
				meshInfo.colors[quad * 4 * 4 + 9] = color_g;
				meshInfo.colors[quad * 4 * 4 + 10] = color_b;
				meshInfo.colors[quad * 4 * 4 + 11] = 255;
				meshInfo.colors[quad * 4 * 4 + 12] = color_r;
				meshInfo.colors[quad * 4 * 4 + 13] = color_g;
				meshInfo.colors[quad * 4 * 4 + 14] = color_b;
				meshInfo.colors[quad * 4 * 4 + 15] = 255;
				meshInfo.quad++;
			}

			if (retryUpdateMeshes) {
				continue;
			}

			if (lineStartIndex < l) {
				breakLine(this._symbols, l, _x);
			}
		}

		this._noResize = true;
		this.autoWidth = this._autoWidth;
		this.autoHeight = this._autoHeight;
		this._noResize = false;
		const hp = this._element.pivot.x;
		const vp = this._element.pivot.y;
		const ha = this._alignment.x;
		const va = this._alignment.y;

		for (let i = 0; i < this._meshInfo.length; i++) {
			if (this._meshInfo[i].count === 0) continue;
			let prevQuad = 0;

			for (const line in this._meshInfo[i].lines) {
				const index = this._meshInfo[i].lines[line];

				const lw = this._lineWidths[parseInt(line, 10)];

				const hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
				const voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);

				for (let _quad = prevQuad; _quad <= index; _quad++) {
					this._meshInfo[i].positions[_quad * 4 * 3] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 3] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 6] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 9] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 1] += voffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 4] += voffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 7] += voffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 10] += voffset;
				}

				if (this._rtl) {
					for (let _quad2 = prevQuad; _quad2 <= index; _quad2++) {
						const idx = _quad2 * 4 * 3;

						for (let vert = 0; vert < 4; ++vert) {
							this._meshInfo[i].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;
						}

						const tmp0 = this._meshInfo[i].positions[idx + 3];
						const tmp1 = this._meshInfo[i].positions[idx + 6];
						this._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];
						this._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];
						this._meshInfo[i].positions[idx + 0] = tmp0;
						this._meshInfo[i].positions[idx + 9] = tmp1;
					}
				}

				prevQuad = index + 1;
			}

			const numVertices = this._meshInfo[i].count * 4;
			const vertMax = this._meshInfo[i].quad * 4;
			const it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);

			for (let v = 0; v < numVertices; v++) {
				if (v >= vertMax) {
					it.element[SEMANTIC_POSITION].set(0, 0, 0);
					it.element[SEMANTIC_TEXCOORD0].set(0, 0);
					it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
				} else {
					it.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);
					it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);
					it.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0], this._meshInfo[i].colors[v * 4 + 1], this._meshInfo[i].colors[v * 4 + 2], this._meshInfo[i].colors[v * 4 + 3]);
				}

				it.next();
			}

			it.end();

			this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);

			this._meshInfo[i].meshInstance._aabbVer = -1;
		}

		this._aabbDirty = true;
	}

	_onFontRender() {
		this.font = this._font;
	}

	_onFontLoad(asset) {
		if (this.font !== asset.resource) {
			this.font = asset.resource;
		}
	}

	_onFontChange(asset, name, _new, _old) {
		if (name === 'data') {
			this._font.data = _new;
			const maps = this._font.data.info.maps.length;

			for (let i = 0; i < maps; i++) {
				if (!this._meshInfo[i]) continue;
				const mi = this._meshInfo[i].meshInstance;

				if (mi) {
					mi.setParameter("font_sdfIntensity", this._font.intensity);
					mi.setParameter("font_pxrange", this._getPxRange(this._font));
					mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
				}
			}
		}
	}

	_onFontRemove(asset) {}

	_setTextureParams(mi, texture) {
		if (this._font) {
			if (this._font.type === FONT_MSDF) {
				mi.deleteParameter("texture_emissiveMap");
				mi.deleteParameter("texture_opacityMap");
				mi.setParameter("texture_msdfMap", texture);
			} else if (this._font.type === FONT_BITMAP) {
				mi.deleteParameter("texture_msdfMap");
				mi.setParameter("texture_emissiveMap", texture);
				mi.setParameter("texture_opacityMap", texture);
			}
		}
	}

	_getPxRange(font) {
		const keys = Object.keys(this._font.data.chars);

		for (let i = 0; i < keys.length; i++) {
			const char = this._font.data.chars[keys[i]];

			if (char.range) {
				return (char.scale || 1) * char.range;
			}
		}

		return 2;
	}

	_getUv(char) {
		const data = this._font.data;

		if (!data.chars[char]) {
			const space = ' ';

			if (data.chars[space]) {
				return this._getUv(space);
			}

			return [0, 0, 0, 0];
		}

		const map = data.chars[char].map;
		const width = data.info.maps[map].width;
		const height = data.info.maps[map].height;
		const x = data.chars[char].x;
		const y = data.chars[char].y;
		const x1 = x;
		const y1 = y;
		const x2 = x + data.chars[char].width;
		const y2 = y - data.chars[char].height;
		const edge = 1 - data.chars[char].height / height;
		return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];
	}

	onEnable() {
		this._fontAsset.autoLoad = true;

		if (this._model) {
			this._element.addModelToLayers(this._model);
		}
	}

	onDisable() {
		this._fontAsset.autoLoad = false;

		if (this._model) {
			this._element.removeModelFromLayers(this._model);
		}
	}

	_setStencil(stencilParams) {
		if (this._model) {
			const instances = this._model.meshInstances;

			for (let i = 0; i < instances.length; i++) {
				instances[i].stencilFront = stencilParams;
				instances[i].stencilBack = stencilParams;
			}
		}
	}

	_shouldAutoFitWidth() {
		return this._autoFitWidth && !this._autoWidth;
	}

	_shouldAutoFitHeight() {
		return this._autoFitHeight && !this._autoHeight;
	}

	_shouldAutoFit() {
		return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
	}

	_calculateCharsPerTexture(symbolIndex) {
		const charactersPerTexture = {};

		if (symbolIndex === undefined) {
			symbolIndex = this._symbols.length;
		}

		for (let i = 0, len = symbolIndex; i < len; i++) {
			const char = this._symbols[i];
			let info = this._font.data.chars[char];

			if (!info) {
				info = this._font.data.chars[' '];

				if (!info) {
					info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
				}
			}

			const map = info.map;

			if (!charactersPerTexture[map]) {
				charactersPerTexture[map] = 1;
			} else {
				charactersPerTexture[map]++;
			}
		}

		return charactersPerTexture;
	}

	_updateRenderRange() {
		const startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
		const endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);

		for (let i = 0, len = this._meshInfo.length; i < len; i++) {
			const start = startChars[i] || 0;
			const end = endChars[i] || 0;
			const instance = this._meshInfo[i].meshInstance;

			if (instance) {
				const mesh = instance.mesh;

				if (mesh) {
					mesh.primitive[0].base = start * 3 * 2;
					mesh.primitive[0].count = (end - start) * 3 * 2;
				}
			}
		}
	}

	set text(value) {
		this._i18nKey = null;
		const str = value != null && value.toString() || "";

		this._setText(str);
	}

	get text() {
		return this._text;
	}

	set key(value) {
		const str = value !== null ? value.toString() : null;

		if (this._i18nKey === str) {
			return;
		}

		this._i18nKey = str;

		if (str) {
			this._fontAsset.disableLocalization = false;

			this._resetLocalizedText();
		} else {
			this._fontAsset.disableLocalization = true;
		}
	}

	get key() {
		return this._i18nKey;
	}

	set color(value) {
		const r = value.r;
		const g = value.g;
		const b = value.b;

		if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
			this._color.r = r;
			this._color.g = g;
			this._color.b = b;

			if (this._symbolColors) {
				if (this._font) {
					this._updateText();
				}
			} else {
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;

				for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
					const mi = this._model.meshInstances[i];
					mi.setParameter('material_emissive', this._colorUniform);
				}
			}
		}

		if (this._element) {
			this._element.fire('set:color', this._color);
		}
	}

	get color() {
		return this._color;
	}

	set opacity(value) {
		if (this._color.a !== value) {
			this._color.a = value;

			if (this._model) {
				for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
					const mi = this._model.meshInstances[i];
					mi.setParameter('material_opacity', value);
				}
			}
		}

		if (this._element) {
			this._element.fire('set:opacity', value);
		}
	}

	get opacity() {
		return this._color.a;
	}

	set lineHeight(value) {
		const _prev = this._lineHeight;
		this._lineHeight = value;
		this._scaledLineHeight = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get lineHeight() {
		return this._lineHeight;
	}

	set wrapLines(value) {
		const _prev = this._wrapLines;
		this._wrapLines = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get wrapLines() {
		return this._wrapLines;
	}

	get lines() {
		return this._lineContents;
	}

	set spacing(value) {
		const _prev = this._spacing;
		this._spacing = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get spacing() {
		return this._spacing;
	}

	set fontSize(value) {
		const _prev = this._fontSize;
		this._fontSize = value;
		this._originalFontSize = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get fontSize() {
		return this._fontSize;
	}

	set fontAsset(value) {
		this._fontAsset.defaultAsset = value;
	}

	get fontAsset() {
		return this._fontAsset.localizedAsset;
	}

	set font(value) {
		let previousFontType;

		if (this._font) {
			previousFontType = this._font.type;
			if (this._font.off) this._font.off('render', this._onFontRender, this);
		}

		this._font = value;
		this._fontMinY = 0;
		this._fontMaxY = 0;
		if (!value) return;
		const json = this._font.data;

		for (const charId in json.chars) {
			const data = json.chars[charId];

			if (data.bounds) {
				this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
				this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
			}
		}

		if (this._font.on) this._font.on('render', this._onFontRender, this);

		if (this._fontAsset.localizedAsset) {
			const asset = this._system.app.assets.get(this._fontAsset.localizedAsset);

			if (asset.resource !== this._font) {
				this._fontAsset.defaultAsset = null;
			}
		}

		if (value.type !== previousFontType) {
			const screenSpace = this._element._isScreenSpace();

			this._updateMaterial(screenSpace);
		}

		for (let i = 0, len = this._font.textures.length; i < len; i++) {
			if (!this._meshInfo[i]) {
				this._meshInfo[i] = new MeshInfo();
			} else {
				const mi = this._meshInfo[i].meshInstance;

				if (mi) {
					mi.setParameter("font_sdfIntensity", this._font.intensity);
					mi.setParameter("font_pxrange", this._getPxRange(this._font));
					mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);

					this._setTextureParams(mi, this._font.textures[i]);
				}
			}
		}

		let removedModel = false;

		for (let i = this._font.textures.length; i < this._meshInfo.length; i++) {
			if (this._meshInfo[i].meshInstance) {
				if (!removedModel) {
					this._element.removeModelFromLayers(this._model);

					removedModel = true;
				}

				this._removeMeshInstance(this._meshInfo[i].meshInstance);
			}
		}

		if (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;

		this._updateText();
	}

	get font() {
		return this._font;
	}

	set alignment(value) {
		if (value instanceof Vec2) {
			this._alignment.set(value.x, value.y);
		} else {
			this._alignment.set(value[0], value[1]);
		}

		if (this._font) this._updateText();
	}

	get alignment() {
		return this._alignment;
	}

	set autoWidth(value) {
		const old = this._autoWidth;
		this._autoWidth = value;

		if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
			this._element.width = this.width;
		}

		if (old !== value) {
			const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

			if (newFontSize !== this._fontSize) {
				this._fontSize = newFontSize;

				if (this._font) {
					this._updateText();
				}
			}
		}
	}

	get autoWidth() {
		return this._autoWidth;
	}

	set autoHeight(value) {
		const old = this._autoHeight;
		this._autoHeight = value;

		if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
			this._element.height = this.height;
		}

		if (old !== value) {
			const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

			if (newFontSize !== this._fontSize) {
				this._fontSize = newFontSize;

				if (this._font) {
					this._updateText();
				}
			}
		}
	}

	get autoHeight() {
		return this._autoHeight;
	}

	set rtlReorder(value) {
		if (this._rtlReorder !== value) {
			this._rtlReorder = value;

			if (this._font) {
				this._updateText();
			}
		}
	}

	get rtlReorder() {
		return this._rtlReorder;
	}

	set unicodeConverter(value) {
		if (this._unicodeConverter !== value) {
			this._unicodeConverter = value;

			this._setText(this._text);
		}
	}

	get unicodeConverter() {
		return this._unicodeConverter;
	}

	get aabb() {
		if (this._aabbDirty) {
			let initialized = false;

			for (let i = 0; i < this._meshInfo.length; i++) {
				if (!this._meshInfo[i].meshInstance) continue;

				if (!initialized) {
					this._aabb.copy(this._meshInfo[i].meshInstance.aabb);

					initialized = true;
				} else {
					this._aabb.add(this._meshInfo[i].meshInstance.aabb);
				}
			}

			this._aabbDirty = false;
		}

		return this._aabb;
	}

	set outlineColor(value) {
		const r = value instanceof Color ? value.r : value[0];
		const g = value instanceof Color ? value.g : value[1];
		const b = value instanceof Color ? value.b : value[2];
		const a = value instanceof Color ? value.a : value[3];

		if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
			return;
		}

		this._outlineColor.r = r;
		this._outlineColor.g = g;
		this._outlineColor.b = b;
		this._outlineColor.a = a;

		if (this._model) {
			this._outlineColorUniform[0] = this._outlineColor.r;
			this._outlineColorUniform[1] = this._outlineColor.g;
			this._outlineColorUniform[2] = this._outlineColor.b;
			this._outlineColorUniform[3] = this._outlineColor.a;

			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.setParameter("outline_color", this._outlineColorUniform);
			}
		}
	}

	get outlineColor() {
		return this._outlineColor;
	}

	set outlineThickness(value) {
		const _prev = this._outlineThickness;
		this._outlineThickness = value;

		if (_prev !== value && this._font) {
			if (this._model) {
				for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
					const mi = this._model.meshInstances[i];
					mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
				}
			}
		}
	}

	get outlineThickness() {
		return this._outlineThickness;
	}

	set shadowColor(value) {
		const r = value instanceof Color ? value.r : value[0];
		const g = value instanceof Color ? value.g : value[1];
		const b = value instanceof Color ? value.b : value[2];
		const a = value instanceof Color ? value.a : value[3];

		if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
			return;
		}

		this._shadowColor.r = r;
		this._shadowColor.g = g;
		this._shadowColor.b = b;
		this._shadowColor.a = a;

		if (this._model) {
			this._shadowColorUniform[0] = this._shadowColor.r;
			this._shadowColorUniform[1] = this._shadowColor.g;
			this._shadowColorUniform[2] = this._shadowColor.b;
			this._shadowColorUniform[3] = this._shadowColor.a;

			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.setParameter("shadow_color", this._shadowColorUniform);
			}
		}
	}

	get shadowColor() {
		return this._shadowColor;
	}

	set shadowOffset(value) {
		const x = value instanceof Vec2 ? value.x : value[0],
					y = value instanceof Vec2 ? value.y : value[1];

		if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
			return;
		}

		this._shadowOffset.set(x, y);

		if (this._font && this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
				this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
				this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
				const mi = this._model.meshInstances[i];
				mi.setParameter("shadow_offset", this._shadowOffsetUniform);
			}
		}
	}

	get shadowOffset() {
		return this._shadowOffset;
	}

	set minFontSize(value) {
		if (this._minFontSize === value) return;
		this._minFontSize = value;

		if (this.font && this._shouldAutoFit()) {
			this._updateText();
		}
	}

	get minFontSize() {
		return this._minFontSize;
	}

	set maxFontSize(value) {
		if (this._maxFontSize === value) return;
		this._maxFontSize = value;

		if (this.font && this._shouldAutoFit()) {
			this._updateText();
		}
	}

	get maxFontSize() {
		return this._maxFontSize;
	}

	set autoFitWidth(value) {
		if (this._autoFitWidth === value) return;
		this._autoFitWidth = value;
		this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

		if (this.font) {
			this._updateText();
		}
	}

	get autoFitWidth() {
		return this._autoFitWidth;
	}

	set autoFitHeight(value) {
		if (this._autoFitHeight === value) return;
		this._autoFitHeight = value;
		this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

		if (this.font) {
			this._updateText();
		}
	}

	get autoFitHeight() {
		return this._autoFitHeight;
	}

	set maxLines(value) {
		if (this._maxLines === value) return;
		if (value === null && this._maxLines === -1) return;
		this._maxLines = value === null ? -1 : value;

		if (this.font && this._wrapLines) {
			this._updateText();
		}
	}

	get maxLines() {
		return this._maxLines;
	}

	set enableMarkup(value) {
		value = !!value;
		if (this._enableMarkup === value) return;
		this._enableMarkup = value;

		if (this.font) {
			this._updateText();
		}
	}

	get enableMarkup() {
		return this._enableMarkup;
	}

	get symbols() {
		return this._symbols;
	}

	get symbolColors() {
		if (this._symbolColors === null) {
			return null;
		}

		return this._symbolColors.map(function (c) {
			return this._colorPalette.slice(c * 3, c * 3 + 3);
		}, this);
	}

	get rtl() {
		return this._rtl;
	}

	set rangeStart(rangeStart) {
		rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));

		if (rangeStart !== this._rangeStart) {
			this._rangeStart = rangeStart;

			this._updateRenderRange();
		}
	}

	get rangeStart() {
		return this._rangeStart;
	}

	set rangeEnd(rangeEnd) {
		rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));

		if (rangeEnd !== this._rangeEnd) {
			this._rangeEnd = rangeEnd;

			this._updateRenderRange();
		}
	}

	get rangeEnd() {
		return this._rangeEnd;
	}

}

const position = new Vec3();
const invParentWtm = new Mat4();
const vecA$1 = new Vec3();
const vecB$1 = new Vec3();
const matA = new Mat4();
const matB = new Mat4();
const matC = new Mat4();
const matD = new Mat4();

class ElementComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._beingInitialized = false;
		this._anchor = new Vec4();
		this._localAnchor = new Vec4();
		this._pivot = new Vec2();
		this._width = this._calculatedWidth = 32;
		this._height = this._calculatedHeight = 32;
		this._margin = new Vec4(0, 0, -32, -32);
		this._modelTransform = new Mat4();
		this._screenToWorld = new Mat4();
		this._anchorTransform = new Mat4();
		this._anchorDirty = true;
		this._parentWorldTransform = new Mat4();
		this._screenTransform = new Mat4();
		this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
		this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
		this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
		this._cornersDirty = true;
		this._canvasCornersDirty = true;
		this._worldCornersDirty = true;
		this.entity.on('insert', this._onInsert, this);

		this._patch();

		this.screen = null;
		this._type = ELEMENTTYPE_GROUP;
		this._image = null;
		this._text = null;
		this._group = null;
		this._drawOrder = 0;
		this._useInput = false;
		this._layers = [LAYERID_UI];
		this._addedModels = [];
		this._batchGroupId = -1;
		this._offsetReadAt = 0;
		this._maskOffset = 0.5;
		this._maskedBy = null;
	}

	get _absLeft() {
		return this._localAnchor.x + this._margin.x;
	}

	get _absRight() {
		return this._localAnchor.z - this._margin.z;
	}

	get _absTop() {
		return this._localAnchor.w - this._margin.w;
	}

	get _absBottom() {
		return this._localAnchor.y + this._margin.y;
	}

	get _hasSplitAnchorsX() {
		return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
	}

	get _hasSplitAnchorsY() {
		return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
	}

	get aabb() {
		if (this._image) return this._image.aabb;
		if (this._text) return this._text.aabb;
		return null;
	}

	set anchor(value) {
		if (value instanceof Vec4) {
			this._anchor.set(value.x, value.y, value.z, value.w);
		} else {
			this._anchor.set(value[0], value[1], value[2], value[3]);
		}

		if (!this.entity._parent && !this.screen) {
			this._calculateLocalAnchors();
		} else {
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
		}

		this._anchorDirty = true;
		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire('set:anchor', this._anchor);
	}

	get anchor() {
		return this._anchor;
	}

	set batchGroupId(value) {
		if (this._batchGroupId === value) return;

		if (this.entity.enabled && this._batchGroupId >= 0) {
			this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
		}

		if (this.entity.enabled && value >= 0) {
			this.system.app.batcher.insert(BatchGroup.ELEMENT, value, this.entity);
		}

		if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
			if (this._image && this._image._renderable.model) {
				this.addModelToLayers(this._image._renderable.model);
			} else if (this._text && this._text._model) {
				this.addModelToLayers(this._text._model);
			}
		}

		this._batchGroupId = value;
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set bottom(value) {
		this._margin.y = value;
		const p = this.entity.getLocalPosition();
		const wt = this._absTop;
		const wb = this._localAnchor.y + value;

		this._setHeight(wt - wb);

		p.y = value + this._calculatedHeight * this._pivot.y;
		this.entity.setLocalPosition(p);
	}

	get bottom() {
		return this._margin.y;
	}

	set calculatedWidth(value) {
		this._setCalculatedWidth(value, true);
	}

	get calculatedWidth() {
		return this._calculatedWidth;
	}

	set calculatedHeight(value) {
		this._setCalculatedHeight(value, true);
	}

	get calculatedHeight() {
		return this._calculatedHeight;
	}

	get canvasCorners() {
		if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;
		const device = this.system.app.graphicsDevice;
		const screenCorners = this.screenCorners;
		const sx = device.canvas.clientWidth / device.width;
		const sy = device.canvas.clientHeight / device.height;

		for (let i = 0; i < 4; i++) {
			this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
		}

		this._canvasCornersDirty = false;
		return this._canvasCorners;
	}

	set drawOrder(value) {
		let priority = 0;

		if (this.screen) {
			priority = this.screen.screen.priority;
		}

		if (value > 0xFFFFFF) {
			value = 0xFFFFFF;
		}

		this._drawOrder = (priority << 24) + value;
		this.fire('set:draworder', this._drawOrder);
	}

	get drawOrder() {
		return this._drawOrder;
	}

	set height(value) {
		this._height = value;

		if (!this._hasSplitAnchorsY) {
			this._setCalculatedHeight(value, true);
		}

		this.fire('set:height', this._height);
	}

	get height() {
		return this._height;
	}

	set layers(value) {
		if (this._addedModels.length) {
			for (let i = 0; i < this._layers.length; i++) {
				const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

				if (layer) {
					for (let j = 0; j < this._addedModels.length; j++) {
						layer.removeMeshInstances(this._addedModels[j].meshInstances);
					}
				}
			}
		}

		this._layers = value;
		if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

			if (layer) {
				for (let j = 0; j < this._addedModels.length; j++) {
					layer.addMeshInstances(this._addedModels[j].meshInstances);
				}
			}
		}
	}

	get layers() {
		return this._layers;
	}

	set left(value) {
		this._margin.x = value;
		const p = this.entity.getLocalPosition();
		const wr = this._absRight;
		const wl = this._localAnchor.x + value;

		this._setWidth(wr - wl);

		p.x = value + this._calculatedWidth * this._pivot.x;
		this.entity.setLocalPosition(p);
	}

	get left() {
		return this._margin.x;
	}

	set margin(value) {
		this._margin.copy(value);

		this._calculateSize(true, true);

		this.fire('set:margin', this._margin);
	}

	get margin() {
		return this._margin;
	}

	get maskedBy() {
		return this._maskedBy;
	}

	set pivot(value) {
		const prevX = this._pivot.x;
		const prevY = this._pivot.y;

		if (value instanceof Vec2) {
			this._pivot.set(value.x, value.y);
		} else {
			this._pivot.set(value[0], value[1]);
		}

		const mx = this._margin.x + this._margin.z;
		const dx = this._pivot.x - prevX;
		this._margin.x += mx * dx;
		this._margin.z -= mx * dx;
		const my = this._margin.y + this._margin.w;
		const dy = this._pivot.y - prevY;
		this._margin.y += my * dy;
		this._margin.w -= my * dy;
		this._anchorDirty = true;
		this._cornersDirty = true;
		this._worldCornersDirty = true;

		this._calculateSize(false, false);

		this._flagChildrenAsDirty();

		this.fire('set:pivot', this._pivot);
	}

	get pivot() {
		return this._pivot;
	}

	set right(value) {
		this._margin.z = value;
		const p = this.entity.getLocalPosition();
		const wl = this._absLeft;
		const wr = this._localAnchor.z - value;

		this._setWidth(wr - wl);

		p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
		this.entity.setLocalPosition(p);
	}

	get right() {
		return this._margin.z;
	}

	get screenCorners() {
		if (!this._cornersDirty || !this.screen) return this._screenCorners;
		const parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];

		this._screenCorners[0].set(this._absLeft, this._absBottom, 0);

		this._screenCorners[1].set(this._absRight, this._absBottom, 0);

		this._screenCorners[2].set(this._absRight, this._absTop, 0);

		this._screenCorners[3].set(this._absLeft, this._absTop, 0);

		const screenSpace = this.screen.screen.screenSpace;

		for (let i = 0; i < 4; i++) {
			this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);

			if (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);

			if (parentBottomLeft) {
				this._screenCorners[i].add(parentBottomLeft);
			}
		}

		this._cornersDirty = false;
		this._canvasCornersDirty = true;
		this._worldCornersDirty = true;
		return this._screenCorners;
	}

	get textWidth() {
		return this._text ? this._text.width : 0;
	}

	get textHeight() {
		return this._text ? this._text.height : 0;
	}

	set top(value) {
		this._margin.w = value;
		const p = this.entity.getLocalPosition();
		const wb = this._absBottom;
		const wt = this._localAnchor.w - value;

		this._setHeight(wt - wb);

		p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
		this.entity.setLocalPosition(p);
	}

	get top() {
		return this._margin.w;
	}

	set type(value) {
		if (value !== this._type) {
			this._type = value;

			if (this._image) {
				this._image.destroy();

				this._image = null;
			}

			if (this._text) {
				this._text.destroy();

				this._text = null;
			}

			if (value === ELEMENTTYPE_IMAGE) {
				this._image = new ImageElement(this);
			} else if (value === ELEMENTTYPE_TEXT) {
				this._text = new TextElement(this);
			}
		}
	}

	get type() {
		return this._type;
	}

	set useInput(value) {
		if (this._useInput === value) return;
		this._useInput = value;

		if (this.system.app.elementInput) {
			if (value) {
				if (this.enabled && this.entity.enabled) {
					this.system.app.elementInput.addElement(this);
				}
			} else {
				this.system.app.elementInput.removeElement(this);
			}
		} else {
			if (this._useInput === true) {
				console.warn("Elements will not get any input events because this.system.app.elementInput is not created");
			}
		}

		this.fire('set:useInput', value);
	}

	get useInput() {
		return this._useInput;
	}

	set width(value) {
		this._width = value;

		if (!this._hasSplitAnchorsX) {
			this._setCalculatedWidth(value, true);
		}

		this.fire('set:width', this._width);
	}

	get width() {
		return this._width;
	}

	get worldCorners() {
		if (!this._worldCornersDirty) {
			return this._worldCorners;
		}

		if (this.screen) {
			const screenCorners = this.screenCorners;

			if (!this.screen.screen.screenSpace) {
				matA.copy(this.screen.screen._screenMatrix);
				matA.data[13] = -matA.data[13];
				matA.mul2(this.screen.getWorldTransform(), matA);

				for (let i = 0; i < 4; i++) {
					matA.transformPoint(screenCorners[i], this._worldCorners[i]);
				}
			}
		} else {
			const localPos = this.entity.getLocalPosition();
			matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
			matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
			matC.setTranslate(localPos.x, localPos.y, localPos.z);
			const entity = this.entity.parent ? this.entity.parent : this.entity;
			matD.copy(entity.getWorldTransform());
			matD.mul(matC).mul(matB).mul(matA);
			vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[0]);
			vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[1]);
			vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[2]);
			vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[3]);
		}

		this._worldCornersDirty = false;
		return this._worldCorners;
	}

	_patch() {
		this.entity._sync = this._sync;
		this.entity.setPosition = this._setPosition;
		this.entity.setLocalPosition = this._setLocalPosition;
	}

	_unpatch() {
		this.entity._sync = Entity.prototype._sync;
		this.entity.setPosition = Entity.prototype.setPosition;
		this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
	}

	_setPosition(x, y, z) {
		if (!this.element.screen) return Entity.prototype.setPosition.call(this, x, y, z);

		if (x instanceof Vec3) {
			position.copy(x);
		} else {
			position.set(x, y, z);
		}

		this.getWorldTransform();
		invParentWtm.copy(this.element._screenToWorld).invert();
		invParentWtm.transformPoint(position, this.localPosition);
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	_setLocalPosition(x, y, z) {
		if (x instanceof Vec3) {
			this.localPosition.copy(x);
		} else {
			this.localPosition.set(x, y, z);
		}

		const element = this.element;
		const p = this.localPosition;
		const pvt = element._pivot;
		element._margin.x = p.x - element._calculatedWidth * pvt.x;
		element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
		element._margin.y = p.y - element._calculatedHeight * pvt.y;
		element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	_sync() {
		const element = this.element;
		const screen = element.screen;

		if (screen) {
			if (element._anchorDirty) {
				let resx = 0;
				let resy = 0;
				let px = 0;
				let py = 1;

				if (this._parent && this._parent.element) {
					resx = this._parent.element.calculatedWidth;
					resy = this._parent.element.calculatedHeight;
					px = this._parent.element.pivot.x;
					py = this._parent.element.pivot.y;
				} else {
					const resolution = screen.screen.resolution;
					resx = resolution.x / screen.screen.scale;
					resy = resolution.y / screen.screen.scale;
				}

				element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);

				element._anchorDirty = false;

				element._calculateLocalAnchors();
			}

			if (element._sizeDirty) {
				element._calculateSize(false, false);
			}
		}

		if (this._dirtyLocal) {
			this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
			const p = this.localPosition;
			const pvt = element._pivot;
			element._margin.x = p.x - element._calculatedWidth * pvt.x;
			element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
			element._margin.y = p.y - element._calculatedHeight * pvt.y;
			element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
			this._dirtyLocal = false;
		}

		if (!screen) {
			if (this._dirtyWorld) {
				element._cornersDirty = true;
				element._canvasCornersDirty = true;
				element._worldCornersDirty = true;
			}

			return Entity.prototype._sync.call(this);
		}

		if (this._dirtyWorld) {
			if (this._parent === null) {
				this.worldTransform.copy(this.localTransform);
			} else {
				if (this._parent.element) {
					element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
				} else {
					element._screenToWorld.copy(element._anchorTransform);
				}

				element._modelTransform.mul2(element._screenToWorld, this.localTransform);

				if (screen) {
					element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);

					if (!screen.screen.screenSpace) {
						element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
					}

					this.worldTransform.mul2(element._screenToWorld, this.localTransform);
					const parentWorldTransform = element._parentWorldTransform;
					parentWorldTransform.setIdentity();
					const parent = this._parent;

					if (parent && parent.element && parent !== screen) {
						matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
						parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
					}

					const depthOffset = vecA$1;
					depthOffset.set(0, 0, this.localPosition.z);
					const pivotOffset = vecB$1;
					pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
					matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
					matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
					matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);

					element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);

					element._cornersDirty = true;
					element._canvasCornersDirty = true;
					element._worldCornersDirty = true;
				} else {
					this.worldTransform.copy(element._modelTransform);
				}
			}

			this._dirtyWorld = false;
		}
	}

	_onInsert(parent) {
		const result = this._parseUpToScreen();

		this.entity._dirtifyWorld();

		this._updateScreen(result.screen);

		this._dirtifyMask();
	}

	_dirtifyMask() {
		let current = this.entity;

		while (current) {
			const next = current.parent;

			if ((next === null || next.screen) && current.element) {
				if (!this.system._prerender || !this.system._prerender.length) {
					this.system._prerender = [];
					this.system.app.once('prerender', this._onPrerender, this);
				}

				const i = this.system._prerender.indexOf(this.entity);

				if (i >= 0) {
					this.system._prerender.splice(i, 1);
				}

				const j = this.system._prerender.indexOf(current);

				if (j < 0) {
					this.system._prerender.push(current);
				}
			}

			current = next;
		}
	}

	_onPrerender() {
		for (let i = 0; i < this.system._prerender.length; i++) {
			const mask = this.system._prerender[i];

			if (mask.element) {
				const depth = 1;
				mask.element.syncMask(depth);
			}
		}

		this.system._prerender.length = 0;
	}

	_bindScreen(screen) {
		screen._bindElement(this);
	}

	_unbindScreen(screen) {
		screen._unbindElement(this);
	}

	_updateScreen(screen) {
		if (this.screen && this.screen !== screen) {
			this._unbindScreen(this.screen.screen);
		}

		const previousScreen = this.screen;
		this.screen = screen;

		if (this.screen) {
			this._bindScreen(this.screen.screen);
		}

		this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

		this.fire('set:screen', this.screen, previousScreen);
		this._anchorDirty = true;
		const children = this.entity.children;

		for (let i = 0, l = children.length; i < l; i++) {
			if (children[i].element) children[i].element._updateScreen(screen);
		}

		if (this.screen) this.screen.screen.syncDrawOrder();
	}

	syncMask(depth) {
		const result = this._parseUpToScreen();

		this._updateMask(result.mask, depth);
	}

	_setMaskedBy(mask) {
		const renderableElement = this._image || this._text;

		if (mask) {
			const ref = mask.element._image._maskRef;
			const sp = new StencilParameters({
				ref: ref,
				func: FUNC_EQUAL
			});

			if (renderableElement && renderableElement._setStencil) {
				renderableElement._setStencil(sp);
			}

			this._maskedBy = mask;
		} else {
			if (renderableElement && renderableElement._setStencil) {
				renderableElement._setStencil(null);
			}

			this._maskedBy = null;
		}
	}

	_updateMask(currentMask, depth) {
		if (currentMask) {
			this._setMaskedBy(currentMask);

			if (this.mask) {
				const ref = currentMask.element._image._maskRef;
				const sp = new StencilParameters({
					ref: ref,
					func: FUNC_EQUAL,
					zpass: STENCILOP_INCREMENT
				});

				this._image._setStencil(sp);

				this._image._maskRef = depth;
				depth++;
				currentMask = this.entity;
			}

			const children = this.entity.children;

			for (let i = 0, l = children.length; i < l; i++) {
				if (children[i].element) {
					children[i].element._updateMask(currentMask, depth);
				}
			}

			if (this.mask) depth--;
		} else {
			this._setMaskedBy(null);

			if (this.mask) {
				const sp = new StencilParameters({
					ref: depth,
					func: FUNC_ALWAYS,
					zpass: STENCILOP_REPLACE
				});

				this._image._setStencil(sp);

				this._image._maskRef = depth;
				depth++;
				currentMask = this.entity;
			}

			const children = this.entity.children;

			for (let i = 0, l = children.length; i < l; i++) {
				if (children[i].element) {
					children[i].element._updateMask(currentMask, depth);
				}
			}

			if (this.mask) depth--;
		}
	}

	_parseUpToScreen() {
		const result = {
			screen: null,
			mask: null
		};
		let parent = this.entity._parent;

		while (parent && !parent.screen) {
			if (parent.element && parent.element.mask) {
				if (!result.mask) result.mask = parent;
			}

			parent = parent.parent;
		}

		if (parent && parent.screen) result.screen = parent;
		return result;
	}

	_onScreenResize(res) {
		this._anchorDirty = true;
		this._cornersDirty = true;
		this._worldCornersDirty = true;

		this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

		this.fire('screen:set:resolution', res);
	}

	_onScreenSpaceChange() {
		this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
	}

	_onScreenRemove() {
		if (this.screen) {
			if (this.screen._destroying) {
				this.screen = null;
			} else {
				this._updateScreen(null);
			}
		}
	}

	_calculateLocalAnchors() {
		let resx = 1000;
		let resy = 1000;
		const parent = this.entity._parent;

		if (parent && parent.element) {
			resx = parent.element.calculatedWidth;
			resy = parent.element.calculatedHeight;
		} else if (this.screen) {
			const res = this.screen.screen.resolution;
			const scale = this.screen.screen.scale;
			resx = res.x / scale;
			resy = res.y / scale;
		}

		this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
	}

	getOffsetPosition(x, y) {
		const p = this.entity.getLocalPosition().clone();
		p.x += x;
		p.y += y;

		this._screenToWorld.transformPoint(p, p);

		return p;
	}

	onLayersChanged(oldComp, newComp) {
		this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;

		if (this._image) {
			layer.addMeshInstances(this._image._renderable.model.meshInstances);
		} else if (this._text) {
			layer.addMeshInstances(this._text._model.meshInstances);
		}
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;

		if (this._image) {
			layer.removeMeshInstances(this._image._renderable.model.meshInstances);
		} else if (this._text) {
			layer.removeMeshInstances(this._text._model.meshInstances);
		}
	}

	onEnable() {
		if (this._image) this._image.onEnable();
		if (this._text) this._text.onEnable();
		if (this._group) this._group.onEnable();

		if (this.useInput && this.system.app.elementInput) {
			this.system.app.elementInput.addElement(this);
		}

		this.system.app.scene.on("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.on("add", this.onLayerAdded, this);
			this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
		}

		if (this._batchGroupId >= 0) {
			this.system.app.batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
		}

		this.fire("enableelement");
	}

	onDisable() {
		this.system.app.scene.off("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.off("add", this.onLayerAdded, this);
			this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this._image) this._image.onDisable();
		if (this._text) this._text.onDisable();
		if (this._group) this._group.onDisable();

		if (this.system.app.elementInput && this.useInput) {
			this.system.app.elementInput.removeElement(this);
		}

		if (this._batchGroupId >= 0) {
			this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
		}

		this.fire("disableelement");
	}

	onRemove() {
		this.entity.off('insert', this._onInsert, this);

		this._unpatch();

		if (this._image) this._image.destroy();
		if (this._text) this._text.destroy();

		if (this.system.app.elementInput && this.useInput) {
			this.system.app.elementInput.removeElement(this);
		}

		if (this.screen && this.screen.screen) {
			this._unbindScreen(this.screen.screen);

			this.screen.screen.syncDrawOrder();
		}

		this.off();
	}

	_calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
		if (!this.entity._parent && !this.screen) return;

		this._calculateLocalAnchors();

		const newWidth = this._absRight - this._absLeft;
		const newHeight = this._absTop - this._absBottom;

		if (propagateCalculatedWidth) {
			this._setWidth(newWidth);
		} else {
			this._setCalculatedWidth(newWidth, false);
		}

		if (propagateCalculatedHeight) {
			this._setHeight(newHeight);
		} else {
			this._setCalculatedHeight(newHeight, false);
		}

		const p = this.entity.getLocalPosition();
		p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
		p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
		this.entity.setLocalPosition(p);
		this._sizeDirty = false;
	}

	_setWidth(w) {
		this._width = w;

		this._setCalculatedWidth(w, false);

		this.fire('set:width', this._width);
	}

	_setHeight(h) {
		this._height = h;

		this._setCalculatedHeight(h, false);

		this.fire('set:height', this._height);
	}

	_setCalculatedWidth(value, updateMargins) {
		if (Math.abs(value - this._calculatedWidth) <= 1e-4) return;
		this._calculatedWidth = value;

		this.entity._dirtifyLocal();

		if (updateMargins) {
			const p = this.entity.getLocalPosition();
			const pvt = this._pivot;
			this._margin.x = p.x - this._calculatedWidth * pvt.x;
			this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
		}

		this._flagChildrenAsDirty();

		this.fire('set:calculatedWidth', this._calculatedWidth);
		this.fire('resize', this._calculatedWidth, this._calculatedHeight);
	}

	_setCalculatedHeight(value, updateMargins) {
		if (Math.abs(value - this._calculatedHeight) <= 1e-4) return;
		this._calculatedHeight = value;

		this.entity._dirtifyLocal();

		if (updateMargins) {
			const p = this.entity.getLocalPosition();
			const pvt = this._pivot;
			this._margin.y = p.y - this._calculatedHeight * pvt.y;
			this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
		}

		this._flagChildrenAsDirty();

		this.fire('set:calculatedHeight', this._calculatedHeight);
		this.fire('resize', this._calculatedWidth, this._calculatedHeight);
	}

	_flagChildrenAsDirty() {
		const c = this.entity._children;

		for (let i = 0, l = c.length; i < l; i++) {
			if (c[i].element) {
				c[i].element._anchorDirty = true;
				c[i].element._sizeDirty = true;
			}
		}
	}

	addModelToLayers(model) {
		this._addedModels.push(model);

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.addMeshInstances(model.meshInstances);
		}
	}

	removeModelFromLayers(model) {
		const idx = this._addedModels.indexOf(model);

		if (idx >= 0) {
			this._addedModels.splice(idx, 1);
		}

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances(model.meshInstances);
		}
	}

	getMaskOffset() {
		const frame = this.system.app.frame;

		if (this._offsetReadAt !== frame) {
			this._maskOffset = 0.5;
			this._offsetReadAt = frame;
		}

		const mo = this._maskOffset;
		this._maskOffset -= 0.001;
		return mo;
	}

	isVisibleForCamera(camera) {
		let clipL, clipR, clipT, clipB;

		if (this.maskedBy) {
			const corners = this.maskedBy.element.screenCorners;
			clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
			clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
			clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
			clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
		} else {
			const sw = this.system.app.graphicsDevice.width;
			const sh = this.system.app.graphicsDevice.height;
			const cameraWidth = camera._rect.z * sw;
			const cameraHeight = camera._rect.w * sh;
			clipL = camera._rect.x * sw;
			clipR = clipL + cameraWidth;
			clipT = (1 - camera._rect.y) * sh;
			clipB = clipT - cameraHeight;
		}

		const hitCorners = this.screenCorners;
		const left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
		const right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
		const bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
		const top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));

		if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
			return false;
		}

		return true;
	}

	_isScreenSpace() {
		if (this.screen && this.screen.screen) {
			return this.screen.screen.screenSpace;
		}

		return false;
	}

	_isScreenCulled() {
		if (this.screen && this.screen.screen) {
			return this.screen.screen.cull;
		}

		return false;
	}

}

function _define(name) {
	Object.defineProperty(ElementComponent.prototype, name, {
		get: function () {
			if (this._text) {
				return this._text[name];
			} else if (this._image) {
				return this._image[name];
			}

			return null;
		},
		set: function (value) {
			if (this._text) {
				this._text[name] = value;
			} else if (this._image) {
				this._image[name] = value;
			}
		}
	});
}

_define("fontSize");

_define("minFontSize");

_define("maxFontSize");

_define("maxLines");

_define("autoFitWidth");

_define("autoFitHeight");

_define("color");

_define("font");

_define("fontAsset");

_define("spacing");

_define("lineHeight");

_define("wrapLines");

_define("lines");

_define("alignment");

_define("autoWidth");

_define("autoHeight");

_define("rtlReorder");

_define("unicodeConverter");

_define("text");

_define("key");

_define("texture");

_define("textureAsset");

_define("material");

_define("materialAsset");

_define("sprite");

_define("spriteAsset");

_define("spriteFrame");

_define("pixelsPerUnit");

_define("opacity");

_define("rect");

_define("mask");

_define("outlineColor");

_define("outlineThickness");

_define("shadowColor");

_define("shadowOffset");

_define("enableMarkup");

_define("rangeStart");

_define("rangeEnd");

class ElementComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$e = ['enabled'];

class ElementComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'element';
		this.ComponentType = ElementComponent;
		this.DataType = ElementComponentData;
		this.schema = _schema$e;
		this._unicodeConverter = null;
		this._rtlReorder = null;
		this._defaultTexture = new Texture(app.graphicsDevice, {
			width: 1,
			height: 1,
			format: PIXELFORMAT_R8_G8_B8_A8
		});
		this._defaultTexture.name = 'element-system';

		const pixels = this._defaultTexture.lock();

		const pixelData = new Uint8Array(4);
		pixelData[0] = 255.0;
		pixelData[1] = 255.0;
		pixelData[2] = 255.0;
		pixelData[3] = 255.0;
		pixels.set(pixelData);

		this._defaultTexture.unlock();

		this.defaultImageMaterial = null;
		this.defaultImage9SlicedMaterial = null;
		this.defaultImage9TiledMaterial = null;
		this.defaultImageMaskMaterial = null;
		this.defaultImage9SlicedMaskMaterial = null;
		this.defaultImage9TiledMaskMaterial = null;
		this.defaultScreenSpaceImageMaterial = null;
		this.defaultScreenSpaceImage9SlicedMaterial = null;
		this.defaultScreenSpaceImage9TiledMaterial = null;
		this.defaultScreenSpaceImageMask9SlicedMaterial = null;
		this.defaultScreenSpaceImageMask9TiledMaterial = null;
		this.defaultScreenSpaceImageMaskMaterial = null;
		this.defaultTextMaterial = null;
		this.defaultBitmapTextMaterial = null;
		this.defaultScreenSpaceTextMaterial = null;
		this.defaultScreenSpaceBitmapTextMaterial = null;
		this.defaultImageMaterials = [];
		this.on('beforeremove', this.onRemoveComponent, this);
	}

	destroy() {
		super.destroy();

		this._defaultTexture.destroy();
	}

	initializeComponentData(component, data, properties) {
		component._beingInitialized = true;

		if (data.anchor !== undefined) {
			if (data.anchor instanceof Vec4) {
				component.anchor.copy(data.anchor);
			} else {
				component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
			}
		}

		if (data.pivot !== undefined) {
			if (data.pivot instanceof Vec2) {
				component.pivot.copy(data.pivot);
			} else {
				component.pivot.set(data.pivot[0], data.pivot[1]);
			}
		}

		const splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
		const splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
		let _marginChange = false;
		let color;

		if (data.margin !== undefined) {
			if (data.margin instanceof Vec4) {
				component.margin.copy(data.margin);
			} else {
				component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
			}

			_marginChange = true;
		}

		if (data.left !== undefined) {
			component._margin.x = data.left;
			_marginChange = true;
		}

		if (data.bottom !== undefined) {
			component._margin.y = data.bottom;
			_marginChange = true;
		}

		if (data.right !== undefined) {
			component._margin.z = data.right;
			_marginChange = true;
		}

		if (data.top !== undefined) {
			component._margin.w = data.top;
			_marginChange = true;
		}

		if (_marginChange) {
			component.margin = component._margin;
		}

		let shouldForceSetAnchor = false;

		if (data.width !== undefined && !splitHorAnchors) {
			component.width = data.width;
		} else if (splitHorAnchors) {
			shouldForceSetAnchor = true;
		}

		if (data.height !== undefined && !splitVerAnchors) {
			component.height = data.height;
		} else if (splitVerAnchors) {
			shouldForceSetAnchor = true;
		}

		if (shouldForceSetAnchor) {
			component.anchor = component.anchor;
		}

		if (data.enabled !== undefined) {
			component.enabled = data.enabled;
		}

		if (data.useInput !== undefined) {
			component.useInput = data.useInput;
		}

		component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

		if (data.layers && Array.isArray(data.layers)) {
			component.layers = data.layers.slice(0);
		}

		if (data.type !== undefined) {
			component.type = data.type;
		}

		if (component.type === ELEMENTTYPE_IMAGE) {
			if (data.rect !== undefined) {
				component.rect = data.rect;
			}

			if (data.color !== undefined) {
				color = data.color;

				if (!(color instanceof Color)) {
					color = new Color(data.color[0], data.color[1], data.color[2]);
				}

				component.color = color;
			}

			if (data.opacity !== undefined) component.opacity = data.opacity;
			if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
			if (data.texture) component.texture = data.texture;
			if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
			if (data.sprite) component.sprite = data.sprite;
			if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
			if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
			if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
			if (data.material) component.material = data.material;

			if (data.mask !== undefined) {
				component.mask = data.mask;
			}
		} else if (component.type === ELEMENTTYPE_TEXT) {
			if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
			if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
			if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
			if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;

			if (data.text !== null && data.text !== undefined) {
				component.text = data.text;
			} else if (data.key !== null && data.key !== undefined) {
				component.key = data.key;
			}

			if (data.color !== undefined) {
				color = data.color;

				if (!(color instanceof Color)) {
					color = new Color(color[0], color[1], color[2]);
				}

				component.color = color;
			}

			if (data.opacity !== undefined) {
				component.opacity = data.opacity;
			}

			if (data.spacing !== undefined) component.spacing = data.spacing;

			if (data.fontSize !== undefined) {
				component.fontSize = data.fontSize;
				if (!data.lineHeight) component.lineHeight = data.fontSize;
			}

			if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
			if (data.maxLines !== undefined) component.maxLines = data.maxLines;
			if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
			if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
			if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
			if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
			if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
			if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
			if (data.font !== undefined) component.font = data.font;
			if (data.alignment !== undefined) component.alignment = data.alignment;
			if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
			if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
			if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
			if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
			if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
		}

		const result = component._parseUpToScreen();

		if (result.screen) {
			component._updateScreen(result.screen);
		}

		super.initializeComponentData(component, data, properties);
		component._beingInitialized = false;

		if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
			component._image._updateMesh(component._image.mesh);
		}
	}

	onRemoveComponent(entity, component) {
		component.onRemove();
	}

	cloneComponent(entity, clone) {
		const source = entity.element;
		const data = {
			enabled: source.enabled,
			width: source.width,
			height: source.height,
			anchor: source.anchor.clone(),
			pivot: source.pivot.clone(),
			margin: source.margin.clone(),
			alignment: source.alignment && source.alignment.clone() || source.alignment,
			autoWidth: source.autoWidth,
			autoHeight: source.autoHeight,
			type: source.type,
			rect: source.rect && source.rect.clone() || source.rect,
			rtlReorder: source.rtlReorder,
			unicodeConverter: source.unicodeConverter,
			materialAsset: source.materialAsset,
			material: source.material,
			color: source.color && source.color.clone() || source.color,
			opacity: source.opacity,
			textureAsset: source.textureAsset,
			texture: source.texture,
			spriteAsset: source.spriteAsset,
			sprite: source.sprite,
			spriteFrame: source.spriteFrame,
			pixelsPerUnit: source.pixelsPerUnit,
			spacing: source.spacing,
			lineHeight: source.lineHeight,
			wrapLines: source.wrapLines,
			layers: source.layers,
			fontSize: source.fontSize,
			minFontSize: source.minFontSize,
			maxFontSize: source.maxFontSize,
			autoFitWidth: source.autoFitWidth,
			autoFitHeight: source.autoFitHeight,
			maxLines: source.maxLines,
			fontAsset: source.fontAsset,
			font: source.font,
			useInput: source.useInput,
			batchGroupId: source.batchGroupId,
			mask: source.mask,
			outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
			outlineThickness: source.outlineThickness,
			shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
			shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
			enableMarkup: source.enableMarkup
		};

		if (source.key !== undefined && source.key !== null) {
			data.key = source.key;
		} else {
			data.text = source.text;
		}

		return this.addComponent(clone, data);
	}

	getTextElementMaterial(screenSpace, msdf) {
		if (screenSpace) {
			if (msdf) {
				if (!this.defaultScreenSpaceTextMaterial) {
					this.defaultScreenSpaceTextMaterial = new StandardMaterial();
					this.defaultScreenSpaceTextMaterial.name = "defaultScreenSpaceTextMaterial";
					this.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture;
					this.defaultScreenSpaceTextMaterial.useLighting = false;
					this.defaultScreenSpaceTextMaterial.useGammaTonemap = false;
					this.defaultScreenSpaceTextMaterial.useFog = false;
					this.defaultScreenSpaceTextMaterial.useSkybox = false;
					this.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0);
					this.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1);
					this.defaultScreenSpaceTextMaterial.opacity = 0.5;
					this.defaultScreenSpaceTextMaterial.blendType = BLEND_PREMULTIPLIED;
					this.defaultScreenSpaceTextMaterial.depthWrite = false;
					this.defaultScreenSpaceTextMaterial.depthTest = false;
					this.defaultScreenSpaceTextMaterial.emissiveVertexColor = true;
					this.defaultScreenSpaceTextMaterial.update();
				}

				return this.defaultScreenSpaceTextMaterial;
			}

			if (!this.defaultScreenSpaceBitmapTextMaterial) {
				this.defaultScreenSpaceBitmapTextMaterial = new StandardMaterial();
				this.defaultScreenSpaceBitmapTextMaterial.name = "defaultScreenSpaceBitmapTextMaterial";
				this.defaultScreenSpaceBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
				this.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture;
				this.defaultScreenSpaceBitmapTextMaterial.emissiveTint = true;
				this.defaultScreenSpaceBitmapTextMaterial.opacity = 0.5;
				this.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture;
				this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = 'a';
				this.defaultScreenSpaceBitmapTextMaterial.useLighting = false;
				this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = false;
				this.defaultScreenSpaceBitmapTextMaterial.useFog = false;
				this.defaultScreenSpaceBitmapTextMaterial.useSkybox = false;
				this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0);
				this.defaultScreenSpaceBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
				this.defaultScreenSpaceBitmapTextMaterial.depthWrite = false;
				this.defaultScreenSpaceBitmapTextMaterial.depthTest = false;
				this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = true;
				this.defaultScreenSpaceBitmapTextMaterial.update();
			}

			return this.defaultScreenSpaceBitmapTextMaterial;
		}

		if (msdf) {
			if (!this.defaultTextMaterial) {
				this.defaultTextMaterial = new StandardMaterial();
				this.defaultTextMaterial.name = "defaultTextMaterial";
				this.defaultTextMaterial.msdfMap = this._defaultTexture;
				this.defaultTextMaterial.useLighting = false;
				this.defaultTextMaterial.useGammaTonemap = false;
				this.defaultTextMaterial.useFog = false;
				this.defaultTextMaterial.useSkybox = false;
				this.defaultTextMaterial.diffuse.set(0, 0, 0);
				this.defaultTextMaterial.emissive.set(1, 1, 1);
				this.defaultTextMaterial.opacity = 0.5;
				this.defaultTextMaterial.blendType = BLEND_PREMULTIPLIED;
				this.defaultTextMaterial.depthWrite = false;
				this.defaultTextMaterial.emissiveVertexColor = true;
				this.defaultTextMaterial.update();
			}

			return this.defaultTextMaterial;
		}

		if (!this.defaultBitmapTextMaterial) {
			this.defaultBitmapTextMaterial = new StandardMaterial();
			this.defaultBitmapTextMaterial.name = "defaultBitmapTextMaterial";
			this.defaultBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
			this.defaultBitmapTextMaterial.emissiveTint = true;
			this.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture;
			this.defaultBitmapTextMaterial.opacity = 0.5;
			this.defaultBitmapTextMaterial.opacityMap = this._defaultTexture;
			this.defaultBitmapTextMaterial.opacityMapChannel = 'a';
			this.defaultBitmapTextMaterial.useLighting = false;
			this.defaultBitmapTextMaterial.useGammaTonemap = false;
			this.defaultBitmapTextMaterial.useFog = false;
			this.defaultBitmapTextMaterial.useSkybox = false;
			this.defaultBitmapTextMaterial.diffuse.set(0, 0, 0);
			this.defaultBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
			this.defaultBitmapTextMaterial.depthWrite = false;
			this.defaultBitmapTextMaterial.emissiveVertexColor = true;
			this.defaultBitmapTextMaterial.update();
		}

		return this.defaultBitmapTextMaterial;
	}

	_createBaseImageMaterial() {
		const material = new StandardMaterial();
		material.diffuse.set(0, 0, 0);
		material.emissive.set(0.5, 0.5, 0.5);
		material.emissiveMap = this._defaultTexture;
		material.emissiveTint = true;
		material.opacityMap = this._defaultTexture;
		material.opacityMapChannel = "a";
		material.opacityTint = true;
		material.opacity = 0;
		material.useLighting = false;
		material.useGammaTonemap = false;
		material.useFog = false;
		material.useSkybox = false;
		material.blendType = BLEND_PREMULTIPLIED;
		material.depthWrite = false;
		return material;
	}

	getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
		if (screenSpace) {
			if (mask) {
				if (nineSliced) {
					if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
						this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial";
						this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
						this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
					}

					return this.defaultScreenSpaceImageMask9SlicedMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
						this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
						this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial";
						this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
						this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
					}

					return this.defaultScreenSpaceImageMask9TiledMaterial;
				} else {
					if (!this.defaultScreenSpaceImageMaskMaterial) {
						this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial";
						this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
						this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
						this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
					}

					return this.defaultScreenSpaceImageMaskMaterial;
				}
			} else {
				if (nineSliced) {
					if (!this.defaultScreenSpaceImage9SlicedMaterial) {
						this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial";
						this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
						this.defaultScreenSpaceImage9SlicedMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
					}

					return this.defaultScreenSpaceImage9SlicedMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultScreenSpaceImage9TiledMaterial) {
						this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial";
						this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
						this.defaultScreenSpaceImage9TiledMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
					}

					return this.defaultScreenSpaceImage9TiledMaterial;
				} else {
					if (!this.defaultScreenSpaceImageMaterial) {
						this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial";
						this.defaultScreenSpaceImageMaterial.depthTest = false;
						this.defaultScreenSpaceImageMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
					}

					return this.defaultScreenSpaceImageMaterial;
				}
			}
		} else {
			if (mask) {
				if (nineSliced) {
					if (!this.defaultImage9SlicedMaskMaterial) {
						this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
						this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial";
						this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
						this.defaultImage9SlicedMaskMaterial.redWrite = false;
						this.defaultImage9SlicedMaskMaterial.greenWrite = false;
						this.defaultImage9SlicedMaskMaterial.blueWrite = false;
						this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
						this.defaultImage9SlicedMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
					}

					return this.defaultImage9SlicedMaskMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultImage9TiledMaskMaterial) {
						this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
						this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial";
						this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultImage9TiledMaskMaterial.alphaTest = 1;
						this.defaultImage9TiledMaskMaterial.redWrite = false;
						this.defaultImage9TiledMaskMaterial.greenWrite = false;
						this.defaultImage9TiledMaskMaterial.blueWrite = false;
						this.defaultImage9TiledMaskMaterial.alphaWrite = false;
						this.defaultImage9TiledMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
					}

					return this.defaultImage9TiledMaskMaterial;
				} else {
					if (!this.defaultImageMaskMaterial) {
						this.defaultImageMaskMaterial = this._createBaseImageMaterial();
						this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial";
						this.defaultImageMaskMaterial.alphaTest = 1;
						this.defaultImageMaskMaterial.redWrite = false;
						this.defaultImageMaskMaterial.greenWrite = false;
						this.defaultImageMaskMaterial.blueWrite = false;
						this.defaultImageMaskMaterial.alphaWrite = false;
						this.defaultImageMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
					}

					return this.defaultImageMaskMaterial;
				}
			} else {
				if (nineSliced) {
					if (!this.defaultImage9SlicedMaterial) {
						this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
						this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial";
						this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultImage9SlicedMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
					}

					return this.defaultImage9SlicedMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultImage9TiledMaterial) {
						this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
						this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial";
						this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultImage9TiledMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
					}

					return this.defaultImage9TiledMaterial;
				} else {
					if (!this.defaultImageMaterial) {
						this.defaultImageMaterial = this._createBaseImageMaterial();
						this.defaultImageMaterial.name = "defaultImageMaterial";
						this.defaultImageMaterial.update();
						this.defaultImageMaterials.push(this.defaultImageMaterial);
					}

					return this.defaultImageMaterial;
				}
			}
		}
	}

	registerUnicodeConverter(func) {
		this._unicodeConverter = func;
	}

	registerRtlReorder(func) {
		this._rtlReorder = func;
	}

	getUnicodeConverter() {
		return this._unicodeConverter;
	}

	getRtlReorder() {
		return this._rtlReorder;
	}

}

Component._buildAccessors(ElementComponent.prototype, _schema$e);

const MOTION_FREE = 'free';
const MOTION_LIMITED = 'limited';
const MOTION_LOCKED = 'locked';

const properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];

class JointComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._constraint = null;
		this._entityA = null;
		this._entityB = null;
		this._breakForce = 3.4e+38;
		this._enableCollision = true;
		this._linearMotionX = MOTION_LOCKED;
		this._linearLimitsX = new Vec2(0, 0);
		this._linearSpringX = false;
		this._linearStiffnessX = 0;
		this._linearDampingX = 1;
		this._linearEquilibriumX = 0;
		this._linearMotionY = MOTION_LOCKED;
		this._linearLimitsY = new Vec2(0, 0);
		this._linearSpringY = false;
		this._linearStiffnessY = 0;
		this._linearDampingY = 1;
		this._linearEquilibriumY = 0;
		this._linearMotionZ = MOTION_LOCKED;
		this._linearLimitsZ = new Vec2(0, 0);
		this._linearSpringZ = false;
		this._linearStiffnessZ = 0;
		this._linearDampingZ = 1;
		this._linearEquilibriumZ = 0;
		this._angularMotionX = MOTION_LOCKED;
		this._angularLimitsX = new Vec2(0, 0);
		this._angularSpringX = false;
		this._angularStiffnessX = 0;
		this._angularDampingX = 1;
		this._angularEquilibriumX = 0;
		this._angularMotionY = MOTION_LOCKED;
		this._angularLimitsY = new Vec2(0, 0);
		this._angularSpringY = false;
		this._angularStiffnessY = 0;
		this._angularDampingY = 1;
		this._angularEquilibriumY = 0;
		this._angularMotionZ = MOTION_LOCKED;
		this._angularLimitsZ = new Vec2(0, 0);
		this._angularSpringZ = false;
		this._angularEquilibriumZ = 0;
		this._angularDampingZ = 1;
		this._angularStiffnessZ = 0;
		this.on('set_enabled', this._onSetEnabled, this);
	}

	set entityA(body) {
		this._destroyConstraint();

		this._entityA = body;

		this._createConstraint();
	}

	get entityA() {
		return this._entityA;
	}

	set entityB(body) {
		this._destroyConstraint();

		this._entityB = body;

		this._createConstraint();
	}

	get entityB() {
		return this._entityB;
	}

	set breakForce(force) {
		if (this._constraint && this._breakForce !== force) {
			this._constraint.setBreakingImpulseThreshold(force);

			this._breakForce = force;
		}
	}

	get breakForce() {
		return this._breakForce;
	}

	set enableCollision(enableCollision) {
		this._destroyConstraint();

		this._enableCollision = enableCollision;

		this._createConstraint();
	}

	get enableCollision() {
		return this._enableCollision;
	}

	set angularLimitsX(limits) {
		if (!this._angularLimitsX.equals(limits)) {
			this._angularLimitsX.copy(limits);

			this._updateAngularLimits();
		}
	}

	get angularLimitsX() {
		return this._angularLimitsX;
	}

	set angularMotionX(value) {
		if (this._angularMotionX !== value) {
			this._angularMotionX = value;

			this._updateAngularLimits();
		}
	}

	get angularMotionX() {
		return this._angularMotionX;
	}

	set angularLimitsY(limits) {
		if (!this._angularLimitsY.equals(limits)) {
			this._angularLimitsY.copy(limits);

			this._updateAngularLimits();
		}
	}

	get angularLimitsY() {
		return this._angularLimitsY;
	}

	set angularMotionY(value) {
		if (this._angularMotionY !== value) {
			this._angularMotionY = value;

			this._updateAngularLimits();
		}
	}

	get angularMotionY() {
		return this._angularMotionY;
	}

	set angularLimitsZ(limits) {
		if (!this._angularLimitsZ.equals(limits)) {
			this._angularLimitsZ.copy(limits);

			this._updateAngularLimits();
		}
	}

	get angularLimitsZ() {
		return this._angularLimitsZ;
	}

	set angularMotionZ(value) {
		if (this._angularMotionZ !== value) {
			this._angularMotionZ = value;

			this._updateAngularLimits();
		}
	}

	get angularMotionZ() {
		return this._angularMotionZ;
	}

	set linearLimitsX(limits) {
		if (!this._linearLimitsX.equals(limits)) {
			this._linearLimitsX.copy(limits);

			this._updateLinearLimits();
		}
	}

	get linearLimitsX() {
		return this._linearLimitsX;
	}

	set linearMotionX(value) {
		if (this._linearMotionX !== value) {
			this._linearMotionX = value;

			this._updateLinearLimits();
		}
	}

	get linearMotionX() {
		return this._linearMotionX;
	}

	set linearLimitsY(limits) {
		if (!this._linearLimitsY.equals(limits)) {
			this._linearLimitsY.copy(limits);

			this._updateLinearLimits();
		}
	}

	get linearLimitsY() {
		return this._linearLimitsY;
	}

	set linearMotionY(value) {
		if (this._linearMotionY !== value) {
			this._linearMotionY = value;

			this._updateLinearLimits();
		}
	}

	get linearMotionY() {
		return this._linearMotionY;
	}

	set linearLimitsZ(limits) {
		if (!this._linearLimitsZ.equals(limits)) {
			this._linearLimitsZ.copy(limits);

			this._updateLinearLimits();
		}
	}

	get linearLimitsZ() {
		return this._linearLimitsZ;
	}

	set linearMotionZ(value) {
		if (this._linearMotionZ !== value) {
			this._linearMotionZ = value;

			this._updateLinearLimits();
		}
	}

	get linearMotionZ() {
		return this._linearMotionZ;
	}

	_convertTransform(pcTransform, ammoTransform) {
		const pos = pcTransform.getTranslation();
		const rot = new Quat();
		rot.setFromMat4(pcTransform);
		const ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
		const ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
		ammoTransform.setOrigin(ammoVec);
		ammoTransform.setRotation(ammoQuat);
		Ammo.destroy(ammoVec);
		Ammo.destroy(ammoQuat);
	}

	_updateAngularLimits() {
		const constraint = this._constraint;

		if (constraint) {
			let lx, ly, lz, ux, uy, uz;

			if (this._angularMotionX === MOTION_LIMITED) {
				lx = this._angularLimitsX.x * math.DEG_TO_RAD;
				ux = this._angularLimitsX.y * math.DEG_TO_RAD;
			} else if (this._angularMotionX === MOTION_FREE) {
				lx = 1;
				ux = 0;
			} else {
				lx = ux = 0;
			}

			if (this._angularMotionY === MOTION_LIMITED) {
				ly = this._angularLimitsY.x * math.DEG_TO_RAD;
				uy = this._angularLimitsY.y * math.DEG_TO_RAD;
			} else if (this._angularMotionY === MOTION_FREE) {
				ly = 1;
				uy = 0;
			} else {
				ly = uy = 0;
			}

			if (this._angularMotionZ === MOTION_LIMITED) {
				lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
				uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
			} else if (this._angularMotionZ === MOTION_FREE) {
				lz = 1;
				uz = 0;
			} else {
				lz = uz = 0;
			}

			const limits = new Ammo.btVector3(lx, ly, lz);
			constraint.setAngularLowerLimit(limits);
			limits.setValue(ux, uy, uz);
			constraint.setAngularUpperLimit(limits);
			Ammo.destroy(limits);
		}
	}

	_updateLinearLimits() {
		const constraint = this._constraint;

		if (constraint) {
			let lx, ly, lz, ux, uy, uz;

			if (this._linearMotionX === MOTION_LIMITED) {
				lx = this._linearLimitsX.x;
				ux = this._linearLimitsX.y;
			} else if (this._linearMotionX === MOTION_FREE) {
				lx = 1;
				ux = 0;
			} else {
				lx = ux = 0;
			}

			if (this._linearMotionY === MOTION_LIMITED) {
				ly = this._linearLimitsY.x;
				uy = this._linearLimitsY.y;
			} else if (this._linearMotionY === MOTION_FREE) {
				ly = 1;
				uy = 0;
			} else {
				ly = uy = 0;
			}

			if (this._linearMotionZ === MOTION_LIMITED) {
				lz = this._linearLimitsZ.x;
				uz = this._linearLimitsZ.y;
			} else if (this._linearMotionZ === MOTION_FREE) {
				lz = 1;
				uz = 0;
			} else {
				lz = uz = 0;
			}

			const limits = new Ammo.btVector3(lx, ly, lz);
			constraint.setLinearLowerLimit(limits);
			limits.setValue(ux, uy, uz);
			constraint.setLinearUpperLimit(limits);
			Ammo.destroy(limits);
		}
	}

	_createConstraint() {
		if (this._entityA && this._entityA.rigidbody) {
			this._destroyConstraint();

			const mat = new Mat4();
			const bodyA = this._entityA.rigidbody.body;
			bodyA.activate();
			const jointWtm = this.entity.getWorldTransform();

			const entityAWtm = this._entityA.getWorldTransform();

			const invEntityAWtm = entityAWtm.clone().invert();
			mat.mul2(invEntityAWtm, jointWtm);
			const frameA = new Ammo.btTransform();

			this._convertTransform(mat, frameA);

			if (this._entityB && this._entityB.rigidbody) {
				const bodyB = this._entityB.rigidbody.body;
				bodyB.activate();

				const entityBWtm = this._entityB.getWorldTransform();

				const invEntityBWtm = entityBWtm.clone().invert();
				mat.mul2(invEntityBWtm, jointWtm);
				const frameB = new Ammo.btTransform();

				this._convertTransform(mat, frameB);

				this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
				Ammo.destroy(frameB);
			} else {
				this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
			}

			Ammo.destroy(frameA);
			const axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];

			for (let i = 0; i < 6; i++) {
				const type = i < 3 ? '_linear' : '_angular';

				this._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);

				this._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);

				this._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);

				this._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);
			}

			this._constraint.setBreakingImpulseThreshold(this._breakForce);

			this._updateLinearLimits();

			this._updateAngularLimits();

			const app = this.system.app;
			const dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
			dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
		}
	}

	_destroyConstraint() {
		if (this._constraint) {
			const app = this.system.app;
			const dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
			dynamicsWorld.removeConstraint(this._constraint);
			Ammo.destroy(this._constraint);
			this._constraint = null;
		}
	}

	initFromData(data) {
		for (const prop of properties) {
			if (data.hasOwnProperty(prop)) {
				if (data[prop] instanceof Vec2) {
					this['_' + prop].copy(data[prop]);
				} else {
					this['_' + prop] = data[prop];
				}
			}
		}

		this._createConstraint();
	}

	onEnable() {
		this._createConstraint();
	}

	onDisable() {
		this._destroyConstraint();
	}

	_onSetEnabled(prop, old, value) {}

	_onBeforeRemove() {
		this.fire('remove');
	}

}

const functionMap = {
	Damping: 'setDamping',
	Equilibrium: 'setEquilibriumPoint',
	Spring: 'enableSpring',
	Stiffness: 'setStiffness'
};
['linear', 'angular'].forEach(type => {
	['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(name => {
		['X', 'Y', 'Z'].forEach(axis => {
			const prop = type + name + axis;
			const propInternal = '_' + prop;
			let index = type === 'linear' ? 0 : 3;
			if (axis === 'Y') index += 1;
			if (axis === 'Z') index += 2;
			Object.defineProperty(JointComponent.prototype, prop, {
				get: function () {
					return this[propInternal];
				},
				set: function (value) {
					if (this[propInternal] !== value) {
						this[propInternal] = value;

						this._constraint[functionMap[name]](index, value);
					}
				}
			});
		});
	});
});

class JointComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$d = ['enabled'];

class JointComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'joint';
		this.app = app;
		this.ComponentType = JointComponent;
		this.DataType = JointComponentData;
		this.schema = _schema$d;
	}

	initializeComponentData(component, data, properties) {
		component.initFromData(data);
	}

}

Component._buildAccessors(JointComponent.prototype, _schema$d);

class LayoutChildComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._minWidth = 0;
		this._minHeight = 0;
		this._maxWidth = null;
		this._maxHeight = null;
		this._fitWidthProportion = 0;
		this._fitHeightProportion = 0;
		this._excludeFromLayout = false;
	}

	set minWidth(value) {
		if (value !== this._minWidth) {
			this._minWidth = value;
			this.fire('resize');
		}
	}

	get minWidth() {
		return this._minWidth;
	}

	set minHeight(value) {
		if (value !== this._minHeight) {
			this._minHeight = value;
			this.fire('resize');
		}
	}

	get minHeight() {
		return this._minHeight;
	}

	set maxWidth(value) {
		if (value !== this._maxWidth) {
			this._maxWidth = value;
			this.fire('resize');
		}
	}

	get maxWidth() {
		return this._maxWidth;
	}

	set maxHeight(value) {
		if (value !== this._maxHeight) {
			this._maxHeight = value;
			this.fire('resize');
		}
	}

	get maxHeight() {
		return this._maxHeight;
	}

	set fitWidthProportion(value) {
		if (value !== this._fitWidthProportion) {
			this._fitWidthProportion = value;
			this.fire('resize');
		}
	}

	get fitWidthProportion() {
		return this._fitWidthProportion;
	}

	set fitHeightProportion(value) {
		if (value !== this._fitHeightProportion) {
			this._fitHeightProportion = value;
			this.fire('resize');
		}
	}

	get fitHeightProportion() {
		return this._fitHeightProportion;
	}

	set excludeFromLayout(value) {
		if (value !== this._excludeFromLayout) {
			this._excludeFromLayout = value;
			this.fire('resize');
		}
	}

	get excludeFromLayout() {
		return this._excludeFromLayout;
	}

}

class LayoutChildComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$c = ['enabled'];

class LayoutChildComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'layoutchild';
		this.ComponentType = LayoutChildComponent;
		this.DataType = LayoutChildComponentData;
		this.schema = _schema$c;
	}

	initializeComponentData(component, data, properties) {
		if (data.enabled !== undefined) component.enabled = data.enabled;
		if (data.minWidth !== undefined) component.minWidth = data.minWidth;
		if (data.minHeight !== undefined) component.minHeight = data.minHeight;
		if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
		if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
		if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
		if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
		if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const layoutChild = entity.layoutchild;
		return this.addComponent(clone, {
			enabled: layoutChild.enabled,
			minWidth: layoutChild.minWidth,
			minHeight: layoutChild.minHeight,
			maxWidth: layoutChild.maxWidth,
			maxHeight: layoutChild.maxHeight,
			fitWidthProportion: layoutChild.fitWidthProportion,
			fitHeightProportion: layoutChild.fitHeightProportion,
			excludeFromLayout: layoutChild.excludeFromLayout
		});
	}

}

Component._buildAccessors(LayoutChildComponent.prototype, _schema$c);

const FITTING_NONE = 0;
const FITTING_STRETCH = 1;
const FITTING_SHRINK = 2;
const FITTING_BOTH = 3;

const AXIS_MAPPINGS = {};
AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
	axis: 'x',
	size: 'width',
	calculatedSize: 'calculatedWidth',
	minSize: 'minWidth',
	maxSize: 'maxWidth',
	fitting: 'widthFitting',
	fittingProportion: 'fitWidthProportion'
};
AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
	axis: 'y',
	size: 'height',
	calculatedSize: 'calculatedHeight',
	minSize: 'minHeight',
	maxSize: 'maxHeight',
	fitting: 'heightFitting',
	fittingProportion: 'fitHeightProportion'
};
const OPPOSITE_ORIENTATION = {};
OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
const PROPERTY_DEFAULTS = {
	minWidth: 0,
	minHeight: 0,
	maxWidth: Number.POSITIVE_INFINITY,
	maxHeight: Number.POSITIVE_INFINITY,
	width: null,
	height: null,
	fitWidthProportion: 0,
	fitHeightProportion: 0
};
const FITTING_ACTION = {
	NONE: 'NONE',
	APPLY_STRETCHING: 'APPLY_STRETCHING',
	APPLY_SHRINKING: 'APPLY_SHRINKING'
};
const availableSpace = new Vec2();

function createCalculator(orientation) {
	let options;
	const a = AXIS_MAPPINGS[orientation];
	const b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];

	function minExtentA(element, size) {
		return -size[a.size] * element.pivot[a.axis];
	}

	function minExtentB(element, size) {
		return -size[b.size] * element.pivot[b.axis];
	}

	function maxExtentA(element, size) {
		return size[a.size] * (1 - element.pivot[a.axis]);
	}

	function calculateAll(allElements, layoutOptions) {
		allElements = allElements.filter(shouldIncludeInLayout);
		options = layoutOptions;
		availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
		availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
		resetAnchors(allElements);
		const lines = reverseLinesIfRequired(splitLines(allElements));
		const sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
		const positions = calculateBasePositions(lines, sizes);
		applyAlignmentAndPadding(lines, sizes, positions);
		applySizesAndPositions(lines, sizes, positions);
		return createLayoutInfo(lines);
	}

	function shouldIncludeInLayout(element) {
		const layoutChildComponent = element.entity.layoutchild;
		return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
	}

	function resetAnchors(allElements) {
		for (let i = 0; i < allElements.length; ++i) {
			const element = allElements[i];
			const anchor = element.anchor;

			if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
				element.anchor = Vec4.ZERO;
			}
		}
	}

	function splitLines(allElements) {
		if (!options.wrap) {
			return [allElements];
		}

		const lines = [[]];
		const sizes = getElementSizeProperties(allElements);
		let runningSize = 0;
		const allowOverrun = options[a.fitting] === FITTING_SHRINK;

		for (let i = 0; i < allElements.length; ++i) {
			if (lines[lines.length - 1].length > 0) {
				runningSize += options.spacing[a.axis];
			}

			const idealElementSize = sizes[i][a.size];
			runningSize += idealElementSize;

			if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
				runningSize = idealElementSize;
				lines.push([]);
			}

			lines[lines.length - 1].push(allElements[i]);

			if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
				runningSize = 0;
				lines.push([]);
			}
		}

		return lines;
	}

	function reverseLinesIfRequired(lines) {
		const reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
		const reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;

		if (reverseAxisA) {
			for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				if (reverseAxisA) {
					lines[lineIndex].reverse();
				}
			}
		}

		if (reverseAxisB) {
			lines.reverse();
		}

		return lines;
	}

	function calculateSizesOnAxisA(lines) {
		const sizesAllLines = [];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			const sizesThisLine = getElementSizeProperties(line);
			const idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
			const fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);

			if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
				stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
			} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
				shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
			}

			sizesAllLines.push(sizesThisLine);
		}

		return sizesAllLines;
	}

	function calculateSizesOnAxisB(lines, sizesAllLines) {
		const largestElementsForEachLine = [];
		const largestSizesForEachLine = [];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			line.largestElement = null;
			line.largestSize = {
				width: Number.NEGATIVE_INFINITY,
				height: Number.NEGATIVE_INFINITY
			};

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const sizesThisElement = sizesAllLines[lineIndex][elementIndex];

				if (sizesThisElement[b.size] > line.largestSize[b.size]) {
					line.largestElement = line[elementIndex];
					line.largestSize = sizesThisElement;
				}
			}

			largestElementsForEachLine.push(line.largestElement);
			largestSizesForEachLine.push(line.largestSize);
		}

		const idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
		const fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);

		if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
			stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
		} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
			shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
		}

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const sizesForThisElement = sizesAllLines[lineIndex][elementIndex];
				const currentSize = sizesForThisElement[b.size];
				const availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];
				const elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);

				if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
					sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
				} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
					sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
				}
			}
		}

		return sizesAllLines;
	}

	function determineFittingAction(fittingMode, currentSize, availableSize) {
		switch (fittingMode) {
			case FITTING_NONE:
				return FITTING_ACTION.NONE;

			case FITTING_STRETCH:
				if (currentSize < availableSize) {
					return FITTING_ACTION.APPLY_STRETCHING;
				}

				return FITTING_ACTION.NONE;

			case FITTING_SHRINK:
				if (currentSize >= availableSize) {
					return FITTING_ACTION.APPLY_SHRINKING;
				}

				return FITTING_ACTION.NONE;

			case FITTING_BOTH:
				if (currentSize < availableSize) {
					return FITTING_ACTION.APPLY_STRETCHING;
				}

				return FITTING_ACTION.APPLY_SHRINKING;

			default:
				throw new Error(`Unrecognized fitting mode: ${fittingMode}`);
		}
	}

	function calculateTotalSpace(sizes, axis) {
		const totalSizes = sumValues(sizes, axis.size);
		const totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
		return totalSizes + totalSpacing;
	}

	function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
		const ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
		const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
		const fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
		let remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;

		for (let i = 0; i < sizesThisLine.length; ++i) {
			const index = ascendingMaxSizeOrder[i];
			const targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
			const targetSize = sizesThisLine[index][axis.size] + targetIncrease;
			const maxSize = sizesThisLine[index][axis.maxSize];
			const actualSize = Math.min(targetSize, maxSize);
			sizesThisLine[index][axis.size] = actualSize;
			const actualIncrease = Math.max(targetSize - actualSize, 0);
			const appliedIncrease = targetIncrease - actualIncrease;
			remainingUndershoot -= appliedIncrease;
		}
	}

	function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
		const descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
		const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
		const inverseFittingProportions = invertNormalizedValues(fittingProportions);
		const inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
		let remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];

		for (let i = 0; i < sizesThisLine.length; ++i) {
			const index = descendingMinSizeOrder[i];
			const targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
			const targetSize = sizesThisLine[index][axis.size] - targetReduction;
			const minSize = sizesThisLine[index][axis.minSize];
			const actualSize = Math.max(targetSize, minSize);
			sizesThisLine[index][axis.size] = actualSize;
			const actualReduction = Math.max(actualSize - targetSize, 0);
			const appliedReduction = targetReduction - actualReduction;
			remainingOvershoot -= appliedReduction;
		}
	}

	function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
		const proportion = fittingProportions[index];
		const sumOfRemainingProportions = fittingProportionSums[index];

		if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
			return remainingAdjustment;
		}

		return remainingAdjustment * proportion / sumOfRemainingProportions;
	}

	function calculateBasePositions(lines, sizes) {
		const cursor = {};
		cursor[a.axis] = 0;
		cursor[b.axis] = 0;
		lines[a.size] = Number.NEGATIVE_INFINITY;
		const positionsAllLines = [];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];

			if (line.length === 0) {
				positionsAllLines.push([]);
				continue;
			}

			const positionsThisLine = [];
			const sizesThisLine = sizes[lineIndex];

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const element = line[elementIndex];
				const sizesThisElement = sizesThisLine[elementIndex];
				cursor[b.axis] -= minExtentB(element, sizesThisElement);
				cursor[a.axis] -= minExtentA(element, sizesThisElement);
				positionsThisLine[elementIndex] = {};
				positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
				positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
				cursor[b.axis] += minExtentB(element, sizesThisElement);
				cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
			}

			line[a.size] = cursor[a.axis] - options.spacing[a.axis];
			line[b.size] = line.largestSize[b.size];
			lines[a.size] = Math.max(lines[a.size], line[a.size]);
			cursor[a.axis] = 0;
			cursor[b.axis] += line[b.size] + options.spacing[b.axis];
			positionsAllLines.push(positionsThisLine);
		}

		lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
		return positionsAllLines;
	}

	function applyAlignmentAndPadding(lines, sizes, positions) {
		const alignmentA = options.alignment[a.axis];
		const alignmentB = options.alignment[b.axis];
		const paddingA = options.padding[a.axis];
		const paddingB = options.padding[b.axis];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			const sizesThisLine = sizes[lineIndex];
			const positionsThisLine = positions[lineIndex];
			const axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
			const axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
				positionsThisLine[elementIndex][a.axis] += axisAOffset;
				positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
			}
		}
	}

	function applySizesAndPositions(lines, sizes, positions) {
		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			const sizesThisLine = sizes[lineIndex];
			const positionsThisLine = positions[lineIndex];

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const element = line[elementIndex];
				element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
				element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];

				if (options.orientation === ORIENTATION_HORIZONTAL) {
					element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
				} else {
					element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
				}
			}
		}
	}

	function createLayoutInfo(lines) {
		const layoutWidth = lines.width;
		const layoutHeight = lines.height;
		const xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
		const yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
		return {
			bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
		};
	}

	function getElementSizeProperties(elements) {
		const sizeProperties = [];

		for (let i = 0; i < elements.length; ++i) {
			const element = elements[i];
			const minWidth = Math.max(getProperty(element, 'minWidth'), 0);
			const minHeight = Math.max(getProperty(element, 'minHeight'), 0);
			const maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
			const maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
			const width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
			const height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
			const fitWidthProportion = getProperty(element, 'fitWidthProportion');
			const fitHeightProportion = getProperty(element, 'fitHeightProportion');
			sizeProperties.push({
				minWidth: minWidth,
				minHeight: minHeight,
				maxWidth: maxWidth,
				maxHeight: maxHeight,
				width: width,
				height: height,
				fitWidthProportion: fitWidthProportion,
				fitHeightProportion: fitHeightProportion
			});
		}

		return sizeProperties;
	}

	function getProperty(element, propertyName) {
		const layoutChildComponent = element.entity.layoutchild;

		if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
			return layoutChildComponent[propertyName];
		} else if (element[propertyName] !== undefined) {
			return element[propertyName];
		}

		return PROPERTY_DEFAULTS[propertyName];
	}

	function clamp(value, min, max) {
		return Math.min(Math.max(value, min), max);
	}

	function sumValues(items, propertyName) {
		return items.reduce(function (accumulator, current) {
			return accumulator + current[propertyName];
		}, 0);
	}

	function getNormalizedValues(items, propertyName) {
		const sum = sumValues(items, propertyName);
		const normalizedValues = [];
		const numItems = items.length;

		if (sum === 0) {
			for (let i = 0; i < numItems; ++i) {
				normalizedValues.push(1 / numItems);
			}
		} else {
			for (let i = 0; i < numItems; ++i) {
				normalizedValues.push(items[i][propertyName] / sum);
			}
		}

		return normalizedValues;
	}

	function invertNormalizedValues(values) {
		if (values.length === 1) {
			return [1];
		}

		const invertedValues = [];
		const numValues = values.length;

		for (let i = 0; i < numValues; ++i) {
			invertedValues.push((1 - values[i]) / (numValues - 1));
		}

		return invertedValues;
	}

	function getTraversalOrder(items, orderBy, descending) {
		items.forEach(assignIndex);
		return items.slice().sort(function (itemA, itemB) {
			return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
		}).map(getIndex);
	}

	function assignIndex(item, index) {
		item.index = index;
	}

	function getIndex(item) {
		return item.index;
	}

	function createSumArray(values, order) {
		const sumArray = [];
		sumArray[order[values.length - 1]] = values[order[values.length - 1]];

		for (let i = values.length - 2; i >= 0; --i) {
			sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
		}

		return sumArray;
	}

	return calculateAll;
}

const CALCULATE_FNS = {};
CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);

class LayoutCalculator {
	calculateLayout(elements, options) {
		const calculateFn = CALCULATE_FNS[options.orientation];

		if (!calculateFn) {
			throw new Error('Unrecognized orientation value: ' + options.orientation);
		} else {
			return calculateFn(elements, options);
		}
	}

}

function getElement(entity) {
	return entity.element;
}

function isEnabledAndHasEnabledElement(entity) {
	return entity.enabled && entity.element && entity.element.enabled;
}

class LayoutGroupComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._orientation = ORIENTATION_HORIZONTAL;
		this._reverseX = false;
		this._reverseY = true;
		this._alignment = new Vec2(0, 1);
		this._padding = new Vec4();
		this._spacing = new Vec2();
		this._widthFitting = FITTING_NONE;
		this._heightFitting = FITTING_NONE;
		this._wrap = false;
		this._layoutCalculator = new LayoutCalculator();

		this._listenForReflowEvents(this.entity, 'on');

		this.entity.children.forEach(child => {
			this._listenForReflowEvents(child, 'on');
		});
		this.entity.on('childinsert', this._onChildInsert, this);
		this.entity.on('childremove', this._onChildRemove, this);
		system.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);
		system.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
		system.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);
		system.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
	}

	set orientation(value) {
		if (value !== this._orientation) {
			this._orientation = value;

			this._scheduleReflow();
		}
	}

	get orientation() {
		return this._orientation;
	}

	set reverseX(value) {
		if (value !== this._reverseX) {
			this._reverseX = value;

			this._scheduleReflow();
		}
	}

	get reverseX() {
		return this._reverseX;
	}

	set reverseY(value) {
		if (value !== this._reverseY) {
			this._reverseY = value;

			this._scheduleReflow();
		}
	}

	get reverseY() {
		return this._reverseY;
	}

	set alignment(value) {
		if (!value.equals(this._alignment)) {
			this._alignment.copy(value);

			this._scheduleReflow();
		}
	}

	get alignment() {
		return this._alignment;
	}

	set padding(value) {
		if (!value.equals(this._padding)) {
			this._padding.copy(value);

			this._scheduleReflow();
		}
	}

	get padding() {
		return this._padding;
	}

	set spacing(value) {
		if (!value.equals(this._spacing)) {
			this._spacing.copy(value);

			this._scheduleReflow();
		}
	}

	get spacing() {
		return this._spacing;
	}

	set widthFitting(value) {
		if (value !== this._widthFitting) {
			this._widthFitting = value;

			this._scheduleReflow();
		}
	}

	get widthFitting() {
		return this._widthFitting;
	}

	set heightFitting(value) {
		if (value !== this._heightFitting) {
			this._heightFitting = value;

			this._scheduleReflow();
		}
	}

	get heightFitting() {
		return this._heightFitting;
	}

	set wrap(value) {
		if (value !== this._wrap) {
			this._wrap = value;

			this._scheduleReflow();
		}
	}

	get wrap() {
		return this._wrap;
	}

	_isSelfOrChild(entity) {
		return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
	}

	_listenForReflowEvents(target, onOff) {
		if (target.element) {
			target.element[onOff]('enableelement', this._scheduleReflow, this);
			target.element[onOff]('disableelement', this._scheduleReflow, this);
			target.element[onOff]('resize', this._scheduleReflow, this);
			target.element[onOff]('set:pivot', this._scheduleReflow, this);
		}

		if (target.layoutchild) {
			target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
			target.layoutchild[onOff]('resize', this._scheduleReflow, this);
		}
	}

	_onElementOrLayoutComponentAdd(entity) {
		if (this._isSelfOrChild(entity)) {
			this._listenForReflowEvents(entity, 'on');

			this._scheduleReflow();
		}
	}

	_onElementOrLayoutComponentRemove(entity) {
		if (this._isSelfOrChild(entity)) {
			this._listenForReflowEvents(entity, 'off');

			this._scheduleReflow();
		}
	}

	_onChildInsert(child) {
		this._listenForReflowEvents(child, 'on');

		this._scheduleReflow();
	}

	_onChildRemove(child) {
		this._listenForReflowEvents(child, 'off');

		this._scheduleReflow();
	}

	_scheduleReflow() {
		if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
			this.system.scheduleReflow(this);
		}
	}

	reflow() {
		const container = getElement(this.entity);
		const elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);

		if (!container || elements.length === 0) {
			return;
		}

		const containerWidth = Math.max(container.calculatedWidth, 0);
		const containerHeight = Math.max(container.calculatedHeight, 0);
		const options = {
			orientation: this._orientation,
			reverseX: this._reverseX,
			reverseY: this._reverseY,
			alignment: this._alignment,
			padding: this._padding,
			spacing: this._spacing,
			widthFitting: this._widthFitting,
			heightFitting: this._heightFitting,
			wrap: this._wrap,
			containerSize: new Vec2(containerWidth, containerHeight)
		};
		this._isPerformingReflow = true;

		const layoutInfo = this._layoutCalculator.calculateLayout(elements, options);

		this._isPerformingReflow = false;
		this.fire('reflow', layoutInfo);
	}

	onEnable() {
		this._scheduleReflow();
	}

	onRemove() {
		this.entity.off('childinsert', this._onChildInsert, this);
		this.entity.off('childremove', this._onChildRemove, this);

		this._listenForReflowEvents(this.entity, 'off');

		this.entity.children.forEach(child => {
			this._listenForReflowEvents(child, 'off');
		});
		this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
		this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
		this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
		this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
	}

}

class LayoutGroupComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$b = ['enabled'];
const MAX_ITERATIONS = 100;

class LayoutGroupComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'layoutgroup';
		this.ComponentType = LayoutGroupComponent;
		this.DataType = LayoutGroupComponentData;
		this.schema = _schema$b;
		this._reflowQueue = [];
		this.on('beforeremove', this._onRemoveComponent, this);
		this.app.systems.on('postUpdate', this._onPostUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		if (data.enabled !== undefined) component.enabled = data.enabled;
		if (data.orientation !== undefined) component.orientation = data.orientation;
		if (data.reverseX !== undefined) component.reverseX = data.reverseX;
		if (data.reverseY !== undefined) component.reverseY = data.reverseY;

		if (data.alignment !== undefined) {
			component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
		}

		if (data.padding !== undefined) {
			component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
		}

		if (data.spacing !== undefined) {
			component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
		}

		if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
		if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
		if (data.wrap !== undefined) component.wrap = data.wrap;
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const layoutGroup = entity.layoutgroup;
		return this.addComponent(clone, {
			enabled: layoutGroup.enabled,
			orientation: layoutGroup.orientation,
			reverseX: layoutGroup.reverseX,
			reverseY: layoutGroup.reverseY,
			alignment: layoutGroup.alignment,
			padding: layoutGroup.padding,
			spacing: layoutGroup.spacing,
			widthFitting: layoutGroup.widthFitting,
			heightFitting: layoutGroup.heightFitting,
			wrap: layoutGroup.wrap
		});
	}

	scheduleReflow(component) {
		if (this._reflowQueue.indexOf(component) === -1) {
			this._reflowQueue.push(component);
		}
	}

	_onPostUpdate() {
		this._processReflowQueue();
	}

	_processReflowQueue() {
		if (this._reflowQueue.length === 0) {
			return;
		}

		let iterationCount = 0;

		while (this._reflowQueue.length > 0) {
			const queue = this._reflowQueue.slice();

			this._reflowQueue.length = 0;
			queue.sort(function (componentA, componentB) {
				return componentA.entity.graphDepth - componentB.entity.graphDepth;
			});

			for (let i = 0; i < queue.length; ++i) {
				queue[i].reflow();
			}

			if (++iterationCount >= MAX_ITERATIONS) {
				console.warn('Max reflow iterations limit reached, bailing.');
				break;
			}
		}
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('postUpdate', this._onPostUpdate, this);
	}

}

Component._buildAccessors(LayoutGroupComponent.prototype, _schema$b);

const _lightProps = [];
const _lightPropsDefault = [];

class LightComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._cookieAsset = null;
		this._cookieAssetId = null;
		this._cookieAssetAdd = false;
		this._cookieMatrix = null;
	}

	addLightToLayers() {
		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

			if (layer) {
				layer.addLight(this);
			}
		}
	}

	removeLightFromLayers() {
		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

			if (layer) {
				layer.removeLight(this);
			}
		}
	}

	onLayersChanged(oldComp, newComp) {
		if (this.enabled && this.entity.enabled) {
			this.addLightToLayers();
		}

		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);

		if (index >= 0 && this.enabled && this.entity.enabled) {
			layer.addLight(this);
		}
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);

		if (index >= 0) {
			layer.removeLight(this);
		}
	}

	refreshProperties() {
		for (let i = 0; i < _lightProps.length; i++) {
			const name = _lightProps[i];
			this[name] = this[name];
		}

		if (this.enabled && this.entity.enabled) this.onEnable();
	}

	updateShadow() {
		this.light.updateShadow();
	}

	onCookieAssetSet() {
		let forceLoad = false;

		if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
			this._cookieAsset.loadFaces = true;
			forceLoad = true;
		}

		if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
		if (this._cookieAsset.resource) this.onCookieAssetLoad();
	}

	onCookieAssetAdd(asset) {
		if (this._cookieAssetId !== asset.id) return;
		this._cookieAsset = asset;
		if (this.light.enabled) this.onCookieAssetSet();

		this._cookieAsset.on('load', this.onCookieAssetLoad, this);

		this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
	}

	onCookieAssetLoad() {
		if (!this._cookieAsset || !this._cookieAsset.resource) return;
		this.cookie = this._cookieAsset.resource;
	}

	onCookieAssetRemove() {
		if (!this._cookieAssetId) return;

		if (this._cookieAssetAdd) {
			this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
			this._cookieAssetAdd = false;
		}

		if (this._cookieAsset) {
			this._cookieAsset.off('load', this.onCookieAssetLoad, this);

			this._cookieAsset.off('remove', this.onCookieAssetRemove, this);

			this._cookieAsset = null;
		}

		this.cookie = null;
	}

	onEnable() {
		this.light.enabled = true;
		this.system.app.scene.on("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.on("add", this.onLayerAdded, this);
			this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
		}

		if (this.enabled && this.entity.enabled) {
			this.addLightToLayers();
		}

		if (this._cookieAsset && !this.cookie) this.onCookieAssetSet();
	}

	onDisable() {
		this.light.enabled = false;
		this.system.app.scene.off("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.off("add", this.onLayerAdded, this);
			this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
		}

		this.removeLightFromLayers();
	}

	onRemove() {
		this.onDisable();
		this.light.destroy();
		this.cookieAsset = null;
	}

}

function _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {
	const c = LightComponent.prototype;

	_lightProps.push(name);

	_lightPropsDefault.push(defaultValue);

	Object.defineProperty(c, name, {
		get: function () {
			return this.data[name];
		},
		set: function (value) {
			const data = this.data;
			const oldValue = data[name];
			if (!skipEqualsCheck && oldValue === value) return;
			data[name] = value;
			if (setFunc) setFunc.call(this, value, oldValue);
		},
		configurable: true
	});
}

function _defineProps() {
	_defineProperty("enabled", true, function (newValue, oldValue) {
		this.onSetEnabled(null, oldValue, newValue);
	});

	_defineProperty("light", null);

	_defineProperty("type", 'directional', function (newValue, oldValue) {
		this.system.changeType(this, oldValue, newValue);
		this.refreshProperties();
	});

	_defineProperty("color", new Color(1, 1, 1), function (newValue, oldValue) {
		this.light.setColor(newValue);
	}, true);

	_defineProperty("intensity", 1, function (newValue, oldValue) {
		this.light.intensity = newValue;
	});

	_defineProperty("shape", LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {
		this.light.shape = newValue;
	});

	_defineProperty("castShadows", false, function (newValue, oldValue) {
		this.light.castShadows = newValue;
	});

	_defineProperty("shadowDistance", 40, function (newValue, oldValue) {
		this.light.shadowDistance = newValue;
	});

	_defineProperty("shadowResolution", 1024, function (newValue, oldValue) {
		this.light.shadowResolution = newValue;
	});

	_defineProperty("shadowBias", 0.05, function (newValue, oldValue) {
		this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
	});

	_defineProperty("numCascades", 1, function (newValue, oldValue) {
		this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
	});

	_defineProperty("bakeNumSamples", 1, function (newValue, oldValue) {
		this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
	});

	_defineProperty("bakeArea", 0, function (newValue, oldValue) {
		this.light.bakeArea = math.clamp(newValue, 0, 180);
	});

	_defineProperty("cascadeDistribution", 0.5, function (newValue, oldValue) {
		this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
	});

	_defineProperty("normalOffsetBias", 0, function (newValue, oldValue) {
		this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
	});

	_defineProperty("range", 10, function (newValue, oldValue) {
		this.light.attenuationEnd = newValue;
	});

	_defineProperty("innerConeAngle", 40, function (newValue, oldValue) {
		this.light.innerConeAngle = newValue;
	});

	_defineProperty("outerConeAngle", 45, function (newValue, oldValue) {
		this.light.outerConeAngle = newValue;
	});

	_defineProperty("falloffMode", LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {
		this.light.falloffMode = newValue;
	});

	_defineProperty("shadowType", SHADOW_PCF3, function (newValue, oldValue) {
		this.light.shadowType = newValue;
	});

	_defineProperty("vsmBlurSize", 11, function (newValue, oldValue) {
		this.light.vsmBlurSize = newValue;
	});

	_defineProperty("vsmBlurMode", BLUR_GAUSSIAN, function (newValue, oldValue) {
		this.light.vsmBlurMode = newValue;
	});

	_defineProperty("vsmBias", 0.01 * 0.25, function (newValue, oldValue) {
		this.light.vsmBias = math.clamp(newValue, 0, 1);
	});

	_defineProperty("cookieAsset", null, function (newValue, oldValue) {
		if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;
		this.onCookieAssetRemove();
		this._cookieAssetId = null;

		if (newValue instanceof Asset) {
			this.data.cookieAsset = newValue.id;
			this._cookieAssetId = newValue.id;
			this.onCookieAssetAdd(newValue);
		} else if (typeof newValue === 'number') {
			this._cookieAssetId = newValue;
			const asset = this.system.app.assets.get(newValue);

			if (asset) {
				this.onCookieAssetAdd(asset);
			} else {
				this._cookieAssetAdd = true;
				this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
			}
		}
	});

	_defineProperty("cookie", null, function (newValue, oldValue) {
		this.light.cookie = newValue;
	});

	_defineProperty("cookieIntensity", 1, function (newValue, oldValue) {
		this.light.cookieIntensity = math.clamp(newValue, 0, 1);
	});

	_defineProperty("cookieFalloff", true, function (newValue, oldValue) {
		this.light.cookieFalloff = newValue;
	});

	_defineProperty("cookieChannel", "rgb", function (newValue, oldValue) {
		this.light.cookieChannel = newValue;
	});

	_defineProperty("cookieAngle", 0, function (newValue, oldValue) {
		if (newValue !== 0 || this.cookieScale !== null) {
			if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
			let scx = 1;
			let scy = 1;

			if (this.cookieScale) {
				scx = this.cookieScale.x;
				scy = this.cookieScale.y;
			}

			const c = Math.cos(newValue * math.DEG_TO_RAD);
			const s = Math.sin(newValue * math.DEG_TO_RAD);

			this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

			this.light.cookieTransform = this._cookieMatrix;
		} else {
			this.light.cookieTransform = null;
		}
	});

	_defineProperty("cookieScale", null, function (newValue, oldValue) {
		if (newValue !== null || this.cookieAngle !== 0) {
			if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
			const scx = newValue.x;
			const scy = newValue.y;
			const c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
			const s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);

			this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

			this.light.cookieTransform = this._cookieMatrix;
		} else {
			this.light.cookieTransform = null;
		}
	}, true);

	_defineProperty("cookieOffset", null, function (newValue, oldValue) {
		this.light.cookieOffset = newValue;
	}, true);

	_defineProperty("shadowUpdateMode", SHADOWUPDATE_REALTIME, function (newValue, oldValue) {
		this.light.shadowUpdateMode = newValue;
	}, true);

	_defineProperty("mask", 1, function (newValue, oldValue) {
		this.light.mask = newValue;
	});

	_defineProperty("affectDynamic", true, function (newValue, oldValue) {
		if (newValue) {
			this.light.mask |= MASK_AFFECT_DYNAMIC;
		} else {
			this.light.mask &= ~MASK_AFFECT_DYNAMIC;
		}

		this.light.layersDirty();
	});

	_defineProperty("affectLightmapped", false, function (newValue, oldValue) {
		if (newValue) {
			this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
			if (this.bake) this.light.mask &= ~MASK_BAKE;
		} else {
			this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
			if (this.bake) this.light.mask |= MASK_BAKE;
		}
	});

	_defineProperty("bake", false, function (newValue, oldValue) {
		if (newValue) {
			this.light.mask |= MASK_BAKE;
			if (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
		} else {
			this.light.mask &= ~MASK_BAKE;
			if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
		}

		this.light.layersDirty();
	});

	_defineProperty("bakeDir", true, function (newValue, oldValue) {
		this.light.bakeDir = newValue;
	});

	_defineProperty("isStatic", false, function (newValue, oldValue) {
		this.light.isStatic = newValue;
	});

	_defineProperty("layers", [LAYERID_WORLD], function (newValue, oldValue) {
		for (let i = 0; i < oldValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
			if (!layer) continue;
			layer.removeLight(this);
		}

		for (let i = 0; i < newValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
			if (!layer) continue;

			if (this.enabled && this.entity.enabled) {
				layer.addLight(this);
			}
		}
	});
}

_defineProps();

class LightComponentData {
	constructor() {
		const _props = _lightProps;
		const _propsDefault = _lightPropsDefault;

		for (let i = 0; i < _props.length; i++) {
			const value = _propsDefault[i];

			if (value && value.clone) {
				this[_props[i]] = value.clone();
			} else {
				this[_props[i]] = value;
			}
		}
	}

}

const lightTypes = {
	'directional': LIGHTTYPE_DIRECTIONAL,
	'omni': LIGHTTYPE_OMNI,
	'point': LIGHTTYPE_OMNI,
	'spot': LIGHTTYPE_SPOT
};

class LightComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'light';
		this.ComponentType = LightComponent;
		this.DataType = LightComponentData;
		this.on('beforeremove', this._onRemoveComponent, this);
	}

	initializeComponentData(component, _data) {
		const properties = _lightProps;
		const data = {};

		for (let i = 0, len = properties.length; i < len; i++) {
			const property = properties[i];
			data[property] = _data[property];
		}

		if (!data.type) data.type = component.data.type;
		component.data.type = data.type;

		if (data.layers && Array.isArray(data.layers)) {
			data.layers = data.layers.slice(0);
		}

		if (data.color && Array.isArray(data.color)) data.color = new Color(data.color[0], data.color[1], data.color[2]);
		if (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
		if (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);

		if (data.enable) {
			console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
			data.enabled = data.enable;
		}

		if (!data.shape) {
			data.shape = LIGHTSHAPE_PUNCTUAL;
		}

		const light = new Light(this.app.graphicsDevice);
		light.type = lightTypes[data.type];
		light._node = component.entity;
		light._scene = this.app.scene;
		component.data.light = light;
		super.initializeComponentData(component, data, properties);
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	cloneComponent(entity, clone) {
		const light = entity.light;
		const data = [];
		let name;
		const _props = _lightProps;

		for (let i = 0; i < _props.length; i++) {
			name = _props[i];
			if (name === "light") continue;

			if (light[name] && light[name].clone) {
				data[name] = light[name].clone();
			} else {
				data[name] = light[name];
			}
		}

		this.addComponent(clone, data);
	}

	changeType(component, oldValue, newValue) {
		if (oldValue !== newValue) {
			component.light.type = lightTypes[newValue];
		}
	}

}

class ModelComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._type = 'asset';
		this._asset = null;
		this._model = null;
		this._mapping = {};
		this._castShadows = true;
		this._receiveShadows = true;
		this._materialAsset = null;
		this._material = system.defaultMaterial;
		this._castShadowsLightmap = true;
		this._lightmapped = false;
		this._lightmapSizeMultiplier = 1;
		this._isStatic = false;
		this._layers = [LAYERID_WORLD];
		this._batchGroupId = -1;
		this._customAabb = null;
		this._area = null;
		this._assetOld = 0;
		this._materialEvents = null;
		this._dirtyModelAsset = false;
		this._dirtyMaterialAsset = false;
		this._clonedModel = false;
		entity.on('remove', this.onRemoveChild, this);
		entity.on('removehierarchy', this.onRemoveChild, this);
		entity.on('insert', this.onInsertChild, this);
		entity.on('inserthierarchy', this.onInsertChild, this);
	}

	set meshInstances(value) {
		if (!this._model) return;
		this._model.meshInstances = value;
	}

	get meshInstances() {
		if (!this._model) return null;
		return this._model.meshInstances;
	}

	set customAabb(value) {
		this._customAabb = value;

		if (this._model) {
			const mi = this._model.meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].setCustomAabb(this._customAabb);
				}
			}
		}
	}

	get customAabb() {
		return this._customAabb;
	}

	set type(value) {
		if (this._type === value) return;
		this._area = null;
		this._type = value;

		if (value === 'asset') {
			if (this._asset !== null) {
				this._bindModelAsset(this._asset);
			} else {
				this.model = null;
			}
		} else {
			const primData = getShapePrimitive(this.system.app.graphicsDevice, value);
			this._area = primData.area;
			const mesh = primData.mesh;
			const node = new GraphNode();
			const model = new Model();
			model.graph = node;
			model.meshInstances = [new MeshInstance(mesh, this._material, node)];
			this.model = model;
			this._asset = null;
		}
	}

	get type() {
		return this._type;
	}

	set asset(value) {
		const assets = this.system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._asset !== _id) {
			if (this._asset) {
				assets.off('add:' + this._asset, this._onModelAssetAdded, this);

				const _prev = assets.get(this._asset);

				if (_prev) {
					this._unbindModelAsset(_prev);
				}
			}

			this._asset = _id;

			if (this._asset) {
				const asset = assets.get(this._asset);

				if (!asset) {
					this.model = null;
					assets.on('add:' + this._asset, this._onModelAssetAdded, this);
				} else {
					this._bindModelAsset(asset);
				}
			} else {
				this.model = null;
			}
		}
	}

	get asset() {
		return this._asset;
	}

	set model(value) {
		if (this._model === value) return;

		if (value && value._immutable) {
			return;
		}

		if (this._model) {
			this._model._immutable = false;
			this.removeModelFromLayers();
			this.entity.removeChild(this._model.getGraph());
			delete this._model._entity;

			if (this._clonedModel) {
				this._model.destroy();

				this._clonedModel = false;
			}
		}

		this._model = value;

		if (this._model) {
			this._model._immutable = true;
			const meshInstances = this._model.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i].castShadow = this._castShadows;
				meshInstances[i].receiveShadow = this._receiveShadows;
				meshInstances[i].isStatic = this._isStatic;
				meshInstances[i].setCustomAabb(this._customAabb);
			}

			this.lightmapped = this._lightmapped;
			this.entity.addChild(this._model.graph);

			if (this.enabled && this.entity.enabled) {
				this.addModelToLayers();
			}

			this._model._entity = this.entity;
			if (this.entity.animation) this.entity.animation.setModel(this._model);

			if (this.entity.anim) {
				if (this.entity.anim.playing) {
					this.entity.anim.rebind();
				} else {
					this.entity.anim.resetStateGraph();
				}
			}

			if (this.type === 'asset') {
				this.mapping = this._mapping;
			} else {
				this._unsetMaterialEvents();
			}
		}
	}

	get model() {
		return this._model;
	}

	set lightmapped(value) {
		if (value !== this._lightmapped) {
			this._lightmapped = value;

			if (this._model) {
				const mi = this._model.meshInstances;

				for (let i = 0; i < mi.length; i++) {
					mi[i].setLightmapped(value);
				}
			}
		}
	}

	get lightmapped() {
		return this._lightmapped;
	}

	set castShadows(value) {
		if (this._castShadows === value) return;
		const model = this._model;

		if (model) {
			const layers = this.layers;
			const scene = this.system.app.scene;

			if (this._castShadows && !value) {
				for (let i = 0; i < layers.length; i++) {
					const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
					if (!layer) continue;
					layer.removeShadowCasters(model.meshInstances);
				}
			}

			const meshInstances = model.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i].castShadow = value;
			}

			if (!this._castShadows && value) {
				for (let i = 0; i < layers.length; i++) {
					const layer = scene.layers.getLayerById(layers[i]);
					if (!layer) continue;
					layer.addShadowCasters(model.meshInstances);
				}
			}
		}

		this._castShadows = value;
	}

	get castShadows() {
		return this._castShadows;
	}

	set receiveShadows(value) {
		if (this._receiveShadows === value) return;
		this._receiveShadows = value;

		if (this._model) {
			const meshInstances = this._model.meshInstances;

			for (let i = 0, len = meshInstances.length; i < len; i++) {
				meshInstances[i].receiveShadow = value;
			}
		}
	}

	get receiveShadows() {
		return this._receiveShadows;
	}

	set castShadowsLightmap(value) {
		this._castShadowsLightmap = value;
	}

	get castShadowsLightmap() {
		return this._castShadowsLightmap;
	}

	set lightmapSizeMultiplier(value) {
		this._lightmapSizeMultiplier = value;
	}

	get lightmapSizeMultiplier() {
		return this._lightmapSizeMultiplier;
	}

	set isStatic(value) {
		if (this._isStatic === value) return;
		this._isStatic = value;

		if (this._model) {
			const rcv = this._model.meshInstances;

			for (let i = 0; i < rcv.length; i++) {
				const m = rcv[i];
				m.isStatic = value;
			}
		}
	}

	get isStatic() {
		return this._isStatic;
	}

	set layers(value) {
		const layers = this.system.app.scene.layers;

		if (this.meshInstances) {
			for (let i = 0; i < this._layers.length; i++) {
				const layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.meshInstances);
			}
		}

		this._layers.length = 0;

		for (let i = 0; i < value.length; i++) {
			this._layers[i] = value[i];
		}

		if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);
			if (!layer) continue;
			layer.addMeshInstances(this.meshInstances);
		}
	}

	get layers() {
		return this._layers;
	}

	set batchGroupId(value) {
		if (this._batchGroupId === value) return;
		const batcher = this.system.app.batcher;

		if (this.entity.enabled && this._batchGroupId >= 0) {
			batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
		}

		if (this.entity.enabled && value >= 0) {
			batcher.insert(BatchGroup.MODEL, value, this.entity);
		}

		if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
			this.addModelToLayers();
		}

		this._batchGroupId = value;
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set materialAsset(value) {
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		const assets = this.system.app.assets;

		if (_id !== this._materialAsset) {
			if (this._materialAsset) {
				assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);

				const _prev = assets.get(this._materialAsset);

				if (_prev) {
					this._unbindMaterialAsset(_prev);
				}
			}

			this._materialAsset = _id;

			if (this._materialAsset) {
				const asset = assets.get(this._materialAsset);

				if (!asset) {
					this._setMaterial(this.system.defaultMaterial);

					assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
				} else {
					this._bindMaterialAsset(asset);
				}
			} else {
				this._setMaterial(this.system.defaultMaterial);
			}
		}
	}

	get materialAsset() {
		return this._materialAsset;
	}

	set material(value) {
		if (this._material === value) return;
		this.materialAsset = null;

		this._setMaterial(value);
	}

	get material() {
		return this._material;
	}

	set mapping(value) {
		if (this._type !== 'asset') return;

		this._unsetMaterialEvents();

		if (!value) value = {};
		this._mapping = value;
		if (!this._model) return;
		const meshInstances = this._model.meshInstances;
		const modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
		const assetMapping = modelAsset ? modelAsset.data.mapping : null;
		let asset = null;

		for (let i = 0, len = meshInstances.length; i < len; i++) {
			if (value[i] !== undefined) {
				if (value[i]) {
					asset = this.system.app.assets.get(value[i]);

					this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
				} else {
					meshInstances[i].material = this.system.defaultMaterial;
				}
			} else if (assetMapping) {
				if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
					if (assetMapping[i].material !== undefined) {
						asset = this.system.app.assets.get(assetMapping[i].material);
					} else if (assetMapping[i].path !== undefined) {
						const url = this._getMaterialAssetUrl(assetMapping[i].path);

						if (url) {
							asset = this.system.app.assets.getByUrl(url);
						}
					}

					this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
				} else {
					meshInstances[i].material = this.system.defaultMaterial;
				}
			}
		}
	}

	get mapping() {
		return this._mapping;
	}

	addModelToLayers() {
		const layers = this.system.app.scene.layers;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(this.meshInstances);
			}
		}
	}

	removeModelFromLayers() {
		const layers = this.system.app.scene.layers;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances(this.meshInstances);
		}
	}

	onRemoveChild() {
		if (this._model) this.removeModelFromLayers();
	}

	onInsertChild() {
		if (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();
	}

	onRemove() {
		this.asset = null;
		this.model = null;
		this.materialAsset = null;

		this._unsetMaterialEvents();

		this.entity.off('remove', this.onRemoveChild, this);
		this.entity.off('insert', this.onInsertChild, this);
	}

	onLayersChanged(oldComp, newComp) {
		this.addModelToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addMeshInstances(this.meshInstances);
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances(this.meshInstances);
	}

	_setMaterialEvent(index, event, id, handler) {
		const evt = event + ':' + id;
		this.system.app.assets.on(evt, handler, this);
		if (!this._materialEvents) this._materialEvents = [];
		if (!this._materialEvents[index]) this._materialEvents[index] = {};
		this._materialEvents[index][evt] = {
			id: id,
			handler: handler
		};
	}

	_unsetMaterialEvents() {
		const assets = this.system.app.assets;
		const events = this._materialEvents;
		if (!events) return;

		for (let i = 0, len = events.length; i < len; i++) {
			if (!events[i]) continue;
			const evt = events[i];

			for (const key in evt) {
				assets.off(key, evt[key].handler, this);
			}
		}

		this._materialEvents = null;
	}

	_getAssetByIdOrPath(idOrPath) {
		let asset = null;
		const isPath = isNaN(parseInt(idOrPath, 10));

		if (!isPath) {
			asset = this.system.app.assets.get(idOrPath);
		} else if (this.asset) {
			const url = this._getMaterialAssetUrl(idOrPath);

			if (url) asset = this.system.app.assets.getByUrl(url);
		}

		return asset;
	}

	_getMaterialAssetUrl(path) {
		if (!this.asset) return null;
		const modelAsset = this.system.app.assets.get(this.asset);
		return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
	}

	_loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
		const assets = this.system.app.assets;
		if (!materialAsset) return;

		if (materialAsset.resource) {
			meshInstance.material = materialAsset.resource;

			this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
				meshInstance.material = this.system.defaultMaterial;
			});
		} else {
			this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
				meshInstance.material = asset.resource;

				this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
					meshInstance.material = this.system.defaultMaterial;
				});
			});

			if (this.enabled && this.entity.enabled) assets.load(materialAsset);
		}
	}

	onEnable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.on("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.on("add", this.onLayerAdded, this);
			scene.layers.on("remove", this.onLayerRemoved, this);
		}

		const isAsset = this._type === 'asset';
		let asset;

		if (this._model) {
			this.addModelToLayers();
		} else if (isAsset && this._asset) {
			asset = app.assets.get(this._asset);

			if (asset && asset.resource !== this._model) {
				this._bindModelAsset(asset);
			}
		}

		if (this._materialAsset) {
			asset = app.assets.get(this._materialAsset);

			if (asset && asset.resource !== this._material) {
				this._bindMaterialAsset(asset);
			}
		}

		if (isAsset) {
			if (this._mapping) {
				for (const index in this._mapping) {
					if (this._mapping[index]) {
						asset = this._getAssetByIdOrPath(this._mapping[index]);

						if (asset && !asset.resource) {
							app.assets.load(asset);
						}
					}
				}
			}
		}

		if (this._batchGroupId >= 0) {
			app.batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
		}
	}

	onDisable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.off("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.off("add", this.onLayerAdded, this);
			scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this._batchGroupId >= 0) {
			app.batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
		}

		if (this._model) {
			this.removeModelFromLayers();
		}
	}

	hide() {
		if (this._model) {
			const instances = this._model.meshInstances;

			for (let i = 0, l = instances.length; i < l; i++) {
				instances[i].visible = false;
			}
		}
	}

	show() {
		if (this._model) {
			const instances = this._model.meshInstances;

			for (let i = 0, l = instances.length; i < l; i++) {
				instances[i].visible = true;
			}
		}
	}

	_bindMaterialAsset(asset) {
		asset.on('load', this._onMaterialAssetLoad, this);
		asset.on('unload', this._onMaterialAssetUnload, this);
		asset.on('remove', this._onMaterialAssetRemove, this);
		asset.on('change', this._onMaterialAssetChange, this);

		if (asset.resource) {
			this._onMaterialAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindMaterialAsset(asset) {
		asset.off('load', this._onMaterialAssetLoad, this);
		asset.off('unload', this._onMaterialAssetUnload, this);
		asset.off('remove', this._onMaterialAssetRemove, this);
		asset.off('change', this._onMaterialAssetChange, this);
	}

	_onMaterialAssetAdd(asset) {
		this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);

		if (this._materialAsset === asset.id) {
			this._bindMaterialAsset(asset);
		}
	}

	_onMaterialAssetLoad(asset) {
		this._setMaterial(asset.resource);
	}

	_onMaterialAssetUnload(asset) {
		this._setMaterial(this.system.defaultMaterial);
	}

	_onMaterialAssetRemove(asset) {
		this._onMaterialAssetUnload(asset);
	}

	_onMaterialAssetChange(asset) {}

	_bindModelAsset(asset) {
		this._unbindModelAsset(asset);

		asset.on('load', this._onModelAssetLoad, this);
		asset.on('unload', this._onModelAssetUnload, this);
		asset.on('change', this._onModelAssetChange, this);
		asset.on('remove', this._onModelAssetRemove, this);

		if (asset.resource) {
			this._onModelAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindModelAsset(asset) {
		asset.off('load', this._onModelAssetLoad, this);
		asset.off('unload', this._onModelAssetUnload, this);
		asset.off('change', this._onModelAssetChange, this);
		asset.off('remove', this._onModelAssetRemove, this);
	}

	_onModelAssetAdded(asset) {
		this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);

		if (asset.id === this._asset) {
			this._bindModelAsset(asset);
		}
	}

	_onModelAssetLoad(asset) {
		this.model = asset.resource.clone();
		this._clonedModel = true;
	}

	_onModelAssetUnload(asset) {
		this.model = null;
	}

	_onModelAssetChange(asset, attr, _new, _old) {
		if (attr === 'data') {
			this.mapping = this._mapping;
		}
	}

	_onModelAssetRemove(asset) {
		this.model = null;
	}

	_setMaterial(material) {
		if (this._material === material) return;
		this._material = material;
		const model = this._model;

		if (model && this._type !== 'asset') {
			const meshInstances = model.meshInstances;

			for (let i = 0, len = meshInstances.length; i < len; i++) {
				meshInstances[i].material = material;
			}
		}
	}

}

class ModelComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$a = ['enabled'];

class ModelComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'model';
		this.ComponentType = ModelComponent;
		this.DataType = ModelComponentData;
		this.schema = _schema$a;
		this.defaultMaterial = DefaultMaterial.get(app.graphicsDevice);
		this.on('beforeremove', this.onRemove, this);
	}

	initializeComponentData(component, _data, properties) {
		properties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];

		if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
			_data.batchGroupId = -1;
		}

		if (_data.layers && _data.layers.length) {
			_data.layers = _data.layers.slice(0);
		}

		for (let i = 0; i < properties.length; i++) {
			if (_data.hasOwnProperty(properties[i])) {
				component[properties[i]] = _data[properties[i]];
			}
		}

		if (_data.aabbCenter && _data.aabbHalfExtents) {
			component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
		}

		super.initializeComponentData(component, _data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const data = {
			type: entity.model.type,
			asset: entity.model.asset,
			castShadows: entity.model.castShadows,
			receiveShadows: entity.model.receiveShadows,
			castShadowsLightmap: entity.model.castShadowsLightmap,
			lightmapped: entity.model.lightmapped,
			lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
			isStatic: entity.model.isStatic,
			enabled: entity.model.enabled,
			layers: entity.model.layers,
			batchGroupId: entity.model.batchGroupId,
			mapping: extend({}, entity.model.mapping)
		};
		let materialAsset = entity.model.materialAsset;

		if (!(materialAsset instanceof Asset) && materialAsset != null) {
			materialAsset = this.app.assets.get(materialAsset);
		}

		const material = entity.model.material;

		if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
			data.materialAsset = materialAsset;
		}

		const component = this.addComponent(clone, data);

		if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
			component.model = entity.model.model.clone();
			component._clonedModel = true;
		}

		if (!data.materialAsset) component.material = material;

		if (entity.model.model) {
			const meshInstances = entity.model.model.meshInstances;
			const meshInstancesClone = component.model.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstancesClone[i].mask = meshInstances[i].mask;
				meshInstancesClone[i].material = meshInstances[i].material;
				meshInstancesClone[i].layer = meshInstances[i].layer;
				meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
			}
		}

		if (entity.model.customAabb) {
			component.customAabb = entity.model.customAabb.clone();
		}
	}

	onRemove(entity, component) {
		component.onRemove();
	}

}

Component._buildAccessors(ModelComponent.prototype, _schema$a);

class RenderComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._type = 'asset';
		this._castShadows = true;
		this._receiveShadows = true;
		this._castShadowsLightmap = true;
		this._lightmapped = false;
		this._lightmapSizeMultiplier = 1;
		this._isStatic = false;
		this._batchGroupId = -1;
		this._meshInstances = [];
		this._layers = [LAYERID_WORLD];
		this._renderStyle = RENDERSTYLE_SOLID;
		this._customAabb = null;
		this._area = null;
		this._rootBone = new EntityReference(this, 'rootBone');

		this._rootBone.on('set:entity', this._onSetRootBone, this);

		this._assetReference = new AssetReference('asset', this, system.app.assets, {
			add: this._onRenderAssetAdded,
			load: this._onRenderAssetLoad,
			remove: this._onRenderAssetRemove,
			unload: this._onRenderAssetUnload
		}, this);
		this._material = system.defaultMaterial;
		this._materialReferences = [];
		entity.on('remove', this.onRemoveChild, this);
		entity.on('removehierarchy', this.onRemoveChild, this);
		entity.on('insert', this.onInsertChild, this);
		entity.on('inserthierarchy', this.onInsertChild, this);
	}

	set renderStyle(renderStyle) {
		if (this._renderStyle !== renderStyle) {
			this._renderStyle = renderStyle;

			MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
		}
	}

	get renderStyle() {
		return this._renderStyle;
	}

	set customAabb(value) {
		this._customAabb = value;
		const mi = this._meshInstances;

		if (mi) {
			for (let i = 0; i < mi.length; i++) {
				mi[i].setCustomAabb(this._customAabb);
			}
		}
	}

	get customAabb() {
		return this._customAabb;
	}

	set type(value) {
		if (this._type !== value) {
			this._area = null;
			this._type = value;
			this.destroyMeshInstances();

			if (value !== 'asset') {
				let material = this._material;

				if (!material || material === this.system.defaultMaterial) {
					material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
				}

				const primData = getShapePrimitive(this.system.app.graphicsDevice, value);
				this._area = primData.area;
				this.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];
			}
		}
	}

	get type() {
		return this._type;
	}

	set meshInstances(value) {
		this.destroyMeshInstances();
		this._meshInstances = value;

		if (this._meshInstances) {
			const mi = this._meshInstances;

			for (let i = 0; i < mi.length; i++) {
				if (!mi[i].node) {
					mi[i].node = this.entity;
				}

				mi[i].castShadow = this._castShadows;
				mi[i].receiveShadow = this._receiveShadows;
				mi[i].isStatic = this._isStatic;
				mi[i].renderStyle = this._renderStyle;
				mi[i].setLightmapped(this._lightmapped);
				mi[i].setCustomAabb(this._customAabb);
			}

			if (this.enabled && this.entity.enabled) {
				this.addToLayers();
			}
		}
	}

	get meshInstances() {
		return this._meshInstances;
	}

	set lightmapped(value) {
		if (value !== this._lightmapped) {
			this._lightmapped = value;
			const mi = this._meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].setLightmapped(value);
				}
			}
		}
	}

	get lightmapped() {
		return this._lightmapped;
	}

	set castShadows(value) {
		if (this._castShadows !== value) {
			const mi = this._meshInstances;

			if (mi) {
				const layers = this.layers;
				const scene = this.system.app.scene;

				if (this._castShadows && !value) {
					for (let i = 0; i < layers.length; i++) {
						const layer = scene.layers.getLayerById(this.layers[i]);

						if (layer) {
							layer.removeShadowCasters(mi);
						}
					}
				}

				for (let i = 0; i < mi.length; i++) {
					mi[i].castShadow = value;
				}

				if (!this._castShadows && value) {
					for (let i = 0; i < layers.length; i++) {
						const layer = scene.layers.getLayerById(layers[i]);

						if (layer) {
							layer.addShadowCasters(mi);
						}
					}
				}
			}

			this._castShadows = value;
		}
	}

	get castShadows() {
		return this._castShadows;
	}

	set receiveShadows(value) {
		if (this._receiveShadows !== value) {
			this._receiveShadows = value;
			const mi = this._meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].receiveShadow = value;
				}
			}
		}
	}

	get receiveShadows() {
		return this._receiveShadows;
	}

	set castShadowsLightmap(value) {
		this._castShadowsLightmap = value;
	}

	get castShadowsLightmap() {
		return this._castShadowsLightmap;
	}

	set lightmapSizeMultiplier(value) {
		this._lightmapSizeMultiplier = value;
	}

	get lightmapSizeMultiplier() {
		return this._lightmapSizeMultiplier;
	}

	set isStatic(value) {
		if (this._isStatic !== value) {
			this._isStatic = value;
			const mi = this._meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].isStatic = value;
				}
			}
		}
	}

	get isStatic() {
		return this._isStatic;
	}

	set layers(value) {
		const layers = this.system.app.scene.layers;
		let layer;

		if (this._meshInstances) {
			for (let i = 0; i < this._layers.length; i++) {
				layer = layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.removeMeshInstances(this._meshInstances);
				}
			}
		}

		this._layers.length = 0;

		for (let i = 0; i < value.length; i++) {
			this._layers[i] = value[i];
		}

		if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;

		for (let i = 0; i < this._layers.length; i++) {
			layer = layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(this._meshInstances);
			}
		}
	}

	get layers() {
		return this._layers;
	}

	set batchGroupId(value) {
		if (this._batchGroupId !== value) {
			const batcher = this.system.app.batcher;

			if (this.entity.enabled && this._batchGroupId >= 0) {
				batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}

			if (this.entity.enabled && value >= 0) {
				batcher.insert(BatchGroup.RENDER, value, this.entity);
			}

			if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
				this.addToLayers();
			}

			this._batchGroupId = value;
		}
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set material(value) {
		if (this._material !== value) {
			this._material = value;

			if (this._meshInstances && this._type !== 'asset') {
				for (let i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].material = value;
				}
			}
		}
	}

	get material() {
		return this._material;
	}

	set materialAssets(value = []) {
		if (this._materialReferences.length > value.length) {
			for (let i = value.length; i < this._materialReferences.length; i++) {
				this._materialReferences[i].id = null;
			}

			this._materialReferences.length = value.length;
		}

		for (let i = 0; i < value.length; i++) {
			if (!this._materialReferences[i]) {
				this._materialReferences.push(new AssetReference(i, this, this.system.app.assets, {
					add: this._onMaterialAdded,
					load: this._onMaterialLoad,
					remove: this._onMaterialRemove,
					unload: this._onMaterialUnload
				}, this));
			}

			if (value[i]) {
				const id = value[i] instanceof Asset ? value[i].id : value[i];

				if (this._materialReferences[i].id !== id) {
					this._materialReferences[i].id = id;
				}

				if (this._materialReferences[i].asset) {
					this._onMaterialAdded(i, this, this._materialReferences[i].asset);
				}
			} else {
				this._materialReferences[i].id = null;

				if (this._meshInstances[i]) {
					this._meshInstances[i].material = this.system.defaultMaterial;
				}
			}
		}
	}

	get materialAssets() {
		return this._materialReferences.map(function (ref) {
			return ref.id;
		});
	}

	set asset(value) {
		const id = value instanceof Asset ? value.id : value;
		if (this._assetReference.id === id) return;

		if (this._assetReference.asset && this._assetReference.asset.resource) {
			this._onRenderAssetRemove();
		}

		this._assetReference.id = id;

		if (this._assetReference.asset) {
			this._onRenderAssetAdded();
		}
	}

	get asset() {
		return this._assetReference.id;
	}

	_onSetRootBone(entity) {
		if (entity) {
			this._onRootBoneChanged();
		}
	}

	_onRootBoneChanged() {
		this._clearSkinInstances();

		if (this.enabled && this.entity.enabled) {
			this._cloneSkinInstances();
		}
	}

	destroyMeshInstances() {
		const meshInstances = this._meshInstances;

		if (meshInstances) {
			this.removeFromLayers();

			this._clearSkinInstances();

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i].destroy();
			}

			this._meshInstances.length = 0;
		}
	}

	addToLayers() {
		const layers = this.system.app.scene.layers;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(this._meshInstances);
			}
		}
	}

	removeFromLayers() {
		if (this._meshInstances && this._meshInstances.length) {
			const layers = this.system.app.scene.layers;

			for (let i = 0; i < this._layers.length; i++) {
				const layer = layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.removeMeshInstances(this._meshInstances);
				}
			}
		}
	}

	onRemoveChild() {
		this.removeFromLayers();
	}

	onInsertChild() {
		if (this._meshInstances && this.enabled && this.entity.enabled) {
			this.addToLayers();
		}
	}

	onRemove() {
		this.destroyMeshInstances();
		this.asset = null;
		this.materialAsset = null;
		this.entity.off('remove', this.onRemoveChild, this);
		this.entity.off('insert', this.onInsertChild, this);
	}

	onLayersChanged(oldComp, newComp) {
		this.addToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addMeshInstances(this._meshInstances);
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances(this._meshInstances);
	}

	onEnable() {
		const app = this.system.app;
		const scene = app.scene;

		this._rootBone.onParentComponentEnable();

		this._cloneSkinInstances();

		scene.on("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.on("add", this.onLayerAdded, this);
			scene.layers.on("remove", this.onLayerRemoved, this);
		}

		const isAsset = this._type === 'asset';

		if (this._meshInstances && this._meshInstances.length) {
			this.addToLayers();
		} else if (isAsset && this.asset) {
			this._onRenderAssetAdded();
		}

		for (let i = 0; i < this._materialReferences.length; i++) {
			if (this._materialReferences[i].asset) {
				this.system.app.assets.load(this._materialReferences[i].asset);
			}
		}

		if (this._batchGroupId >= 0) {
			app.batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
		}
	}

	onDisable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.off("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.off("add", this.onLayerAdded, this);
			scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this._batchGroupId >= 0) {
			app.batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
		}

		this.removeFromLayers();
	}

	hide() {
		if (this._meshInstances) {
			for (let i = 0; i < this._meshInstances.length; i++) {
				this._meshInstances[i].visible = false;
			}
		}
	}

	show() {
		if (this._meshInstances) {
			for (let i = 0; i < this._meshInstances.length; i++) {
				this._meshInstances[i].visible = true;
			}
		}
	}

	_onRenderAssetAdded() {
		if (!this._assetReference.asset) return;

		if (this._assetReference.asset.resource) {
			this._onRenderAssetLoad();
		} else if (this.enabled && this.entity.enabled) {
			this.system.app.assets.load(this._assetReference.asset);
		}
	}

	_onRenderAssetLoad() {
		this.destroyMeshInstances();

		if (this._assetReference.asset) {
			const render = this._assetReference.asset.resource;
			render.off('set:meshes', this._onSetMeshes, this);
			render.on('set:meshes', this._onSetMeshes, this);

			if (render.meshes) {
				this._onSetMeshes(render.meshes);
			}
		}
	}

	_onSetMeshes(meshes) {
		this._cloneMeshes(meshes);
	}

	_clearSkinInstances() {
		for (let i = 0; i < this._meshInstances.length; i++) {
			const meshInstance = this._meshInstances[i];
			SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
			meshInstance.skinInstance = null;
		}
	}

	_cloneSkinInstances() {
		if (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {
			for (let i = 0; i < this._meshInstances.length; i++) {
				const meshInstance = this._meshInstances[i];
				const mesh = meshInstance.mesh;

				if (mesh.skin && !mesh.skinInstance) {
					meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);
				}
			}
		}
	}

	_cloneMeshes(meshes) {
		if (meshes && meshes.length) {
			const meshInstances = [];

			for (let i = 0; i < meshes.length; i++) {
				const mesh = meshes[i];
				const material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
				const meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
				meshInstances.push(meshInst);

				if (mesh.morph) {
					meshInst.morphInstance = new MorphInstance(mesh.morph);
				}
			}

			this.meshInstances = meshInstances;

			this._cloneSkinInstances();
		}
	}

	_onRenderAssetUnload() {
		if (this._type === 'asset') {
			this.destroyMeshInstances();
		}
	}

	_onRenderAssetRemove() {
		if (this._assetReference.asset && this._assetReference.asset.resource) {
			this._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);
		}

		this._onRenderAssetUnload();
	}

	_onMaterialAdded(index, component, asset) {
		if (asset.resource) {
			this._onMaterialLoad(index, component, asset);
		} else {
			if (this.enabled && this.entity.enabled) {
				this.system.app.assets.load(asset);
			}
		}
	}

	_updateMainMaterial(index, material) {
		if (index === 0) {
			this.material = material;
		}
	}

	_onMaterialLoad(index, component, asset) {
		if (this._meshInstances[index]) {
			this._meshInstances[index].material = asset.resource;
		}

		this._updateMainMaterial(index, asset.resource);
	}

	_onMaterialRemove(index, component, asset) {
		if (this._meshInstances[index]) {
			this._meshInstances[index].material = this.system.defaultMaterial;
		}

		this._updateMainMaterial(index, this.system.defaultMaterial);
	}

	_onMaterialUnload(index, component, asset) {
		if (this._meshInstances[index]) {
			this._meshInstances[index].material = this.system.defaultMaterial;
		}

		this._updateMainMaterial(index, this.system.defaultMaterial);
	}

	resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
		if (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {
			this.rootBone = duplicatedIdsMap[oldRender.rootBone];
		}

		this._clearSkinInstances();
	}

}

class RenderComponentData {
	constructor() {
		this.enabled = true;
		this.rootBone = null;
	}

}

const _schema$9 = [{
	name: 'rootBone',
	type: 'entity'
}, 'enabled'];
const _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];

class RenderComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'render';
		this.ComponentType = RenderComponent;
		this.DataType = RenderComponentData;
		this.schema = _schema$9;
		this.defaultMaterial = DefaultMaterial.get(app.graphicsDevice);
		this.on('beforeremove', this.onRemove, this);
	}

	initializeComponentData(component, _data, properties) {
		if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
			_data.batchGroupId = -1;
		}

		if (_data.layers && _data.layers.length) {
			_data.layers = _data.layers.slice(0);
		}

		for (let i = 0; i < _properties.length; i++) {
			if (_data.hasOwnProperty(_properties[i])) {
				component[_properties[i]] = _data[_properties[i]];
			}
		}

		if (_data.aabbCenter && _data.aabbHalfExtents) {
			component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
		}

		super.initializeComponentData(component, _data, _schema$9);
	}

	cloneComponent(entity, clone) {
		const data = {};

		for (let i = 0; i < _properties.length; i++) {
			data[_properties[i]] = entity.render[_properties[i]];
		}

		delete data.meshInstances;
		const component = this.addComponent(clone, data);
		const srcMeshInstances = entity.render.meshInstances;
		const meshes = srcMeshInstances.map(mi => mi.mesh);

		component._onSetMeshes(meshes);

		for (let m = 0; m < srcMeshInstances.length; m++) {
			component.meshInstances[m].material = srcMeshInstances[m].material;
		}

		if (entity.render.customAabb) {
			component.customAabb = entity.render.customAabb.clone();
		}
	}

	onRemove(entity, component) {
		component.onRemove();
	}

}

Component._buildAccessors(RenderComponent.prototype, _schema$9);

const SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];
const COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];
const GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];
const ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];
let depthLayer;

class ParticleSystemComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
		this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
		this.on("set_meshAsset", this.onSetMeshAsset, this);
		this.on("set_mesh", this.onSetMesh, this);
		this.on("set_renderAsset", this.onSetRenderAsset, this);
		this.on("set_loop", this.onSetLoop, this);
		this.on("set_blendType", this.onSetBlendType, this);
		this.on("set_depthSoftening", this.onSetDepthSoftening, this);
		this.on("set_layers", this.onSetLayers, this);
		SIMPLE_PROPERTIES.forEach(prop => {
			this.on(`set_${prop}`, this.onSetSimpleProperty, this);
		});
		COMPLEX_PROPERTIES.forEach(prop => {
			this.on(`set_${prop}`, this.onSetComplexProperty, this);
		});
		GRAPH_PROPERTIES.forEach(prop => {
			this.on(`set_${prop}`, this.onSetGraphProperty, this);
		});
		this._requestedDepth = false;
		this._drawOrder = 0;
	}

	set drawOrder(drawOrder) {
		this._drawOrder = drawOrder;

		if (this.emitter) {
			this.emitter.drawOrder = drawOrder;
		}
	}

	get drawOrder() {
		return this._drawOrder;
	}

	addMeshInstanceToLayers() {
		if (!this.emitter) return;

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.addMeshInstances([this.emitter.meshInstance]);
			this.emitter._layer = layer;
		}
	}

	removeMeshInstanceFromLayers() {
		if (!this.emitter) return;

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances([this.emitter.meshInstance]);
		}
	}

	onSetLayers(name, oldValue, newValue) {
		if (!this.emitter) return;

		for (let i = 0; i < oldValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
			if (!layer) continue;
			layer.removeMeshInstances([this.emitter.meshInstance]);
		}

		if (!this.enabled || !this.entity.enabled) return;

		for (let i = 0; i < newValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
			if (!layer) continue;
			layer.addMeshInstances([this.emitter.meshInstance]);
		}
	}

	onLayersChanged(oldComp, newComp) {
		this.addMeshInstanceToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		if (!this.emitter) return;
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addMeshInstances([this.emitter.meshInstance]);
	}

	onLayerRemoved(layer) {
		if (!this.emitter) return;
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances([this.emitter.meshInstance]);
	}

	_bindColorMapAsset(asset) {
		asset.on('load', this._onColorMapAssetLoad, this);
		asset.on('unload', this._onColorMapAssetUnload, this);
		asset.on('remove', this._onColorMapAssetRemove, this);
		asset.on('change', this._onColorMapAssetChange, this);

		if (asset.resource) {
			this._onColorMapAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindColorMapAsset(asset) {
		asset.off('load', this._onColorMapAssetLoad, this);
		asset.off('unload', this._onColorMapAssetUnload, this);
		asset.off('remove', this._onColorMapAssetRemove, this);
		asset.off('change', this._onColorMapAssetChange, this);
	}

	_onColorMapAssetLoad(asset) {
		this.colorMap = asset.resource;
	}

	_onColorMapAssetUnload(asset) {
		this.colorMap = null;
	}

	_onColorMapAssetRemove(asset) {
		this._onColorMapAssetUnload(asset);
	}

	_onColorMapAssetChange(asset) {}

	onSetColorMapAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindColorMapAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.colorMapAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindColorMapAsset(asset);
			} else {
				assets.once("add:" + newValue, asset => {
					this._bindColorMapAsset(asset);
				});
			}
		} else {
			this.colorMap = null;
		}
	}

	_bindNormalMapAsset(asset) {
		asset.on('load', this._onNormalMapAssetLoad, this);
		asset.on('unload', this._onNormalMapAssetUnload, this);
		asset.on('remove', this._onNormalMapAssetRemove, this);
		asset.on('change', this._onNormalMapAssetChange, this);

		if (asset.resource) {
			this._onNormalMapAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindNormalMapAsset(asset) {
		asset.off('load', this._onNormalMapAssetLoad, this);
		asset.off('unload', this._onNormalMapAssetUnload, this);
		asset.off('remove', this._onNormalMapAssetRemove, this);
		asset.off('change', this._onNormalMapAssetChange, this);
	}

	_onNormalMapAssetLoad(asset) {
		this.normalMap = asset.resource;
	}

	_onNormalMapAssetUnload(asset) {
		this.normalMap = null;
	}

	_onNormalMapAssetRemove(asset) {
		this._onNormalMapAssetUnload(asset);
	}

	_onNormalMapAssetChange(asset) {}

	onSetNormalMapAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindNormalMapAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.normalMapAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindNormalMapAsset(asset);
			} else {
				assets.once("add:" + newValue, asset => {
					this._bindNormalMapAsset(asset);
				});
			}
		} else {
			this.normalMap = null;
		}
	}

	_bindMeshAsset(asset) {
		asset.on('load', this._onMeshAssetLoad, this);
		asset.on('unload', this._onMeshAssetUnload, this);
		asset.on('remove', this._onMeshAssetRemove, this);
		asset.on('change', this._onMeshAssetChange, this);

		if (asset.resource) {
			this._onMeshAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindMeshAsset(asset) {
		asset.off('load', this._onMeshAssetLoad, this);
		asset.off('unload', this._onMeshAssetUnload, this);
		asset.off('remove', this._onMeshAssetRemove, this);
		asset.off('change', this._onMeshAssetChange, this);
	}

	_onMeshAssetLoad(asset) {
		this._onMeshChanged(asset.resource);
	}

	_onMeshAssetUnload(asset) {
		this.mesh = null;
	}

	_onMeshAssetRemove(asset) {
		this._onMeshAssetUnload(asset);
	}

	_onMeshAssetChange(asset) {}

	onSetMeshAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindMeshAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.meshAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindMeshAsset(asset);
			}
		} else {
			this._onMeshChanged(null);
		}
	}

	onSetMesh(name, oldValue, newValue) {
		if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
			this.meshAsset = newValue;
		} else {
			this._onMeshChanged(newValue);
		}
	}

	_onMeshChanged(mesh) {
		if (mesh && !(mesh instanceof Mesh)) {
			if (mesh.meshInstances[0]) {
				mesh = mesh.meshInstances[0].mesh;
			} else {
				mesh = null;
			}
		}

		this.data.mesh = mesh;

		if (this.emitter) {
			this.emitter.mesh = mesh;
			this.emitter.resetMaterial();
			this.rebuild();
		}
	}

	onSetRenderAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindRenderAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.renderAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindRenderAsset(asset);
			}
		} else {
			this._onRenderChanged(null);
		}
	}

	_bindRenderAsset(asset) {
		asset.on('load', this._onRenderAssetLoad, this);
		asset.on('unload', this._onRenderAssetUnload, this);
		asset.on('remove', this._onRenderAssetRemove, this);

		if (asset.resource) {
			this._onRenderAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindRenderAsset(asset) {
		asset.off('load', this._onRenderAssetLoad, this);
		asset.off('unload', this._onRenderAssetUnload, this);
		asset.off('remove', this._onRenderAssetRemove, this);

		if (asset.resource) {
			asset.resource.off('set:meshes', this._onRenderSetMeshes, this);
		}
	}

	_onRenderAssetLoad(asset) {
		this._onRenderChanged(asset.resource);
	}

	_onRenderAssetUnload(asset) {
		this._onRenderChanged(null);
	}

	_onRenderAssetRemove(asset) {
		this._onRenderAssetUnload(asset);
	}

	_onRenderChanged(render) {
		if (!render) {
			this._onMeshChanged(null);

			return;
		}

		render.off('set:meshes', this._onRenderSetMeshes, this);
		render.on('set:meshes', this._onRenderSetMeshes, this);

		if (render.meshes) {
			this._onRenderSetMeshes(render.meshes);
		}
	}

	_onRenderSetMeshes(meshes) {
		this._onMeshChanged(meshes && meshes[0]);
	}

	onSetLoop(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.resetTime();
		}
	}

	onSetBlendType(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.material.blendType = newValue;
			this.emitter.resetMaterial();
			this.rebuild();
		}
	}

	_requestDepth() {
		if (this._requestedDepth) return;
		if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);

		if (depthLayer) {
			depthLayer.incrementCounter();
			this._requestedDepth = true;
		}
	}

	_releaseDepth() {
		if (!this._requestedDepth) return;

		if (depthLayer) {
			depthLayer.decrementCounter();
			this._requestedDepth = false;
		}
	}

	onSetDepthSoftening(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (newValue) {
				if (this.enabled && this.entity.enabled) this._requestDepth();
				if (this.emitter) this.emitter[name] = newValue;
			} else {
				if (this.enabled && this.entity.enabled) this._releaseDepth();
				if (this.emitter) this.emitter[name] = newValue;
			}

			if (this.emitter) {
				this.reset();
				this.emitter.resetMaterial();
				this.rebuild();
			}
		}
	}

	onSetSimpleProperty(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.resetMaterial();
		}
	}

	onSetComplexProperty(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.resetMaterial();
			this.rebuild();
			this.reset();
		}
	}

	onSetGraphProperty(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.rebuildGraphs();
			this.emitter.resetMaterial();
		}
	}

	onEnable() {
		const data = this.data;

		for (let i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
			let asset = data[ASSET_PROPERTIES[i]];

			if (asset) {
				if (!(asset instanceof Asset)) {
					const id = parseInt(asset, 10);

					if (id >= 0) {
						asset = this.system.app.assets.get(asset);
					} else {
						continue;
					}
				}

				if (asset && !asset.resource) {
					this.system.app.assets.load(asset);
				}
			}
		}

		if (!this.emitter) {
			let mesh = data.mesh;
			if (!(mesh instanceof Mesh)) mesh = null;
			this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
				numParticles: data.numParticles,
				emitterExtents: data.emitterExtents,
				emitterExtentsInner: data.emitterExtentsInner,
				emitterRadius: data.emitterRadius,
				emitterRadiusInner: data.emitterRadiusInner,
				emitterShape: data.emitterShape,
				initialVelocity: data.initialVelocity,
				wrap: data.wrap,
				localSpace: data.localSpace,
				screenSpace: data.screenSpace,
				wrapBounds: data.wrapBounds,
				lifetime: data.lifetime,
				rate: data.rate,
				rate2: data.rate2,
				orientation: data.orientation,
				particleNormal: data.particleNormal,
				animTilesX: data.animTilesX,
				animTilesY: data.animTilesY,
				animStartFrame: data.animStartFrame,
				animNumFrames: data.animNumFrames,
				animNumAnimations: data.animNumAnimations,
				animIndex: data.animIndex,
				randomizeAnimIndex: data.randomizeAnimIndex,
				animSpeed: data.animSpeed,
				animLoop: data.animLoop,
				startAngle: data.startAngle,
				startAngle2: data.startAngle2,
				scaleGraph: data.scaleGraph,
				scaleGraph2: data.scaleGraph2,
				colorGraph: data.colorGraph,
				colorGraph2: data.colorGraph2,
				alphaGraph: data.alphaGraph,
				alphaGraph2: data.alphaGraph2,
				localVelocityGraph: data.localVelocityGraph,
				localVelocityGraph2: data.localVelocityGraph2,
				velocityGraph: data.velocityGraph,
				velocityGraph2: data.velocityGraph2,
				rotationSpeedGraph: data.rotationSpeedGraph,
				rotationSpeedGraph2: data.rotationSpeedGraph2,
				radialSpeedGraph: data.radialSpeedGraph,
				radialSpeedGraph2: data.radialSpeedGraph2,
				colorMap: data.colorMap,
				normalMap: data.normalMap,
				loop: data.loop,
				preWarm: data.preWarm,
				sort: data.sort,
				stretch: data.stretch,
				alignToMotion: data.alignToMotion,
				lighting: data.lighting,
				halfLambert: data.halfLambert,
				intensity: data.intensity,
				depthSoftening: data.depthSoftening,
				scene: this.system.app.scene,
				mesh: mesh,
				depthWrite: data.depthWrite,
				noFog: data.noFog,
				node: this.entity,
				blendType: data.blendType
			});
			this.emitter.meshInstance.node = this.entity;
			this.emitter.drawOrder = this.drawOrder;

			if (!data.autoPlay) {
				this.pause();
				this.emitter.meshInstance.visible = false;
			}
		}

		if (this.emitter.colorMap) {
			this.addMeshInstanceToLayers();
		}

		this.system.app.scene.on("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.on("add", this.onLayerAdded, this);
			this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
		}

		if (this.enabled && this.entity.enabled && data.depthSoftening) {
			this._requestDepth();
		}
	}

	onDisable() {
		this.system.app.scene.off("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.off("add", this.onLayerAdded, this);
			this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this.emitter) {
			this.removeMeshInstanceFromLayers();
			if (this.data.depthSoftening) this._releaseDepth();
			this.emitter.camera = null;
		}
	}

	onBeforeRemove() {
		if (this.enabled) {
			this.enabled = false;
		}

		if (this.emitter) {
			this.emitter.destroy();
			this.emitter = null;
		}

		for (let i = 0; i < ASSET_PROPERTIES.length; i++) {
			const prop = ASSET_PROPERTIES[i];

			if (this.data[prop]) {
				this[prop] = null;
			}
		}

		this.off();
	}

	reset() {
		if (this.emitter) {
			this.emitter.reset();
		}
	}

	stop() {
		if (this.emitter) {
			this.emitter.loop = false;
			this.emitter.resetTime();
			this.emitter.addTime(0, true);
		}
	}

	pause() {
		this.data.paused = true;
	}

	unpause() {
		this.data.paused = false;
	}

	play() {
		this.data.paused = false;

		if (this.emitter) {
			this.emitter.meshInstance.visible = true;
			this.emitter.loop = this.data.loop;
			this.emitter.resetTime();
		}
	}

	isPlaying() {
		if (this.data.paused) {
			return false;
		}

		if (this.emitter && this.emitter.loop) {
			return true;
		}

		return Date.now() <= this.emitter.endTime;
	}

	rebuild() {
		const enabled = this.enabled;
		this.enabled = false;

		if (this.emitter) {
			this.emitter.rebuild();
			this.emitter.meshInstance.node = this.entity;
		}

		this.enabled = enabled;
	}

}

class ParticleSystemComponentData {
	constructor() {
		this.numParticles = 1;
		this.rate = 1;
		this.rate2 = null;
		this.startAngle = 0;
		this.startAngle2 = null;
		this.lifetime = 50;
		this.emitterExtents = new Vec3();
		this.emitterExtentsInner = new Vec3();
		this.emitterRadius = 0;
		this.emitterRadiusInner = 0;
		this.emitterShape = EMITTERSHAPE_BOX;
		this.initialVelocity = 0;
		this.wrapBounds = new Vec3();
		this.localSpace = false;
		this.screenSpace = false;
		this.colorMap = null;
		this.colorMapAsset = null;
		this.normalMap = null;
		this.normalMapAsset = null;
		this.loop = true;
		this.preWarm = false;
		this.sort = 0;
		this.mode = PARTICLEMODE_GPU;
		this.scene = null;
		this.lighting = false;
		this.halfLambert = false;
		this.intensity = 1;
		this.stretch = 0.0;
		this.alignToMotion = false;
		this.depthSoftening = 0;
		this.meshAsset = null;
		this.mesh = null;
		this.depthWrite = false;
		this.noFog = false;
		this.orientation = PARTICLEORIENTATION_SCREEN;
		this.particleNormal = new Vec3(0, 1, 0);
		this.animTilesX = 1;
		this.animTilesY = 1;
		this.animStartFrame = 0;
		this.animNumFrames = 1;
		this.animNumAnimations = 1;
		this.animIndex = 0;
		this.randomizeAnimIndex = false;
		this.animSpeed = 1;
		this.animLoop = true;
		this.scaleGraph = null;
		this.scaleGraph2 = null;
		this.colorGraph = null;
		this.colorGraph2 = null;
		this.alphaGraph = null;
		this.alphaGraph2 = null;
		this.localVelocityGraph = null;
		this.localVelocityGraph2 = null;
		this.velocityGraph = null;
		this.velocityGraph2 = null;
		this.rotationSpeedGraph = null;
		this.rotationSpeedGraph2 = null;
		this.radialSpeedGraph = null;
		this.radialSpeedGraph2 = null;
		this.blendType = BLEND_NORMAL;
		this.enabled = true;
		this.paused = false;
		this.autoPlay = true;
		this.layers = [LAYERID_WORLD];
	}

}

const _schema$8 = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];

class ParticleSystemComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'particlesystem';
		this.ComponentType = ParticleSystemComponent;
		this.DataType = ParticleSystemComponentData;
		this.schema = _schema$8;
		this.propertyTypes = {
			emitterExtents: 'vec3',
			emitterExtentsInner: 'vec3',
			particleNormal: 'vec3',
			wrapBounds: 'vec3',
			localVelocityGraph: 'curveset',
			localVelocityGraph2: 'curveset',
			velocityGraph: 'curveset',
			velocityGraph2: 'curveset',
			colorGraph: 'curveset',
			colorGraph2: 'curveset',
			alphaGraph: 'curve',
			alphaGraph2: 'curve',
			rotationSpeedGraph: 'curve',
			rotationSpeedGraph2: 'curve',
			radialSpeedGraph: 'curve',
			radialSpeedGraph2: 'curve',
			scaleGraph: 'curve',
			scaleGraph2: 'curve'
		};
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, _data, properties) {
		const data = {};
		properties = [];
		const types = this.propertyTypes;

		if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
			_data.meshAsset = _data.mesh;
			delete _data.mesh;
		}

		for (const prop in _data) {
			if (_data.hasOwnProperty(prop)) {
				properties.push(prop);
				data[prop] = _data[prop];
			}

			if (types[prop] === 'vec3') {
				if (Array.isArray(data[prop])) {
					data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
				}
			} else if (types[prop] === 'curve') {
				if (!(data[prop] instanceof Curve)) {
					const t = data[prop].type;
					data[prop] = new Curve(data[prop].keys);
					data[prop].type = t;
				}
			} else if (types[prop] === 'curveset') {
				if (!(data[prop] instanceof CurveSet)) {
					const t = data[prop].type;
					data[prop] = new CurveSet(data[prop].keys);
					data[prop].type = t;
				}
			}

			if (data.layers && Array.isArray(data.layers)) {
				data.layers = data.layers.slice(0);
			}
		}

		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const source = entity.particlesystem.data;
		const schema = this.schema;
		const data = {};

		for (let i = 0, len = schema.length; i < len; i++) {
			const prop = schema[i];
			let sourceProp = source[prop];

			if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
				sourceProp = sourceProp.clone();
				data[prop] = sourceProp;
			} else if (prop === "layers") {
				data.layers = source.layers.slice(0);
			} else {
				if (sourceProp !== null && sourceProp !== undefined) {
					data[prop] = sourceProp;
				}
			}
		}

		return this.addComponent(clone, data);
	}

	onUpdate(dt) {
		const components = this.store;
		let numSteps;
		const stats = this.app.stats.particles;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];
				const entity = component.entity;
				const data = component.data;

				if (data.enabled && entity.enabled) {
					const emitter = entity.particlesystem.emitter;
					if (!emitter.meshInstance.visible) continue;

					if (emitter.lighting) {
						const layers = data.layers;
						let lightCube;

						for (let i = 0; i < layers.length; i++) {
							const layer = this.app.scene.layers.getLayerById(layers[i]);
							if (!layer) continue;

							if (!layer._lightCube) {
								layer._lightCube = new Float32Array(6 * 3);
							}

							lightCube = layer._lightCube;

							for (let j = 0; j < 6; j++) {
								lightCube[j * 3] = this.app.scene.ambientLight.r;
								lightCube[j * 3 + 1] = this.app.scene.ambientLight.g;
								lightCube[j * 3 + 2] = this.app.scene.ambientLight.b;
							}

							const dirs = layer._splitLights[LIGHTTYPE_DIRECTIONAL];

							for (let j = 0; j < dirs.length; j++) {
								for (let c = 0; c < 6; c++) {
									const weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;

									lightCube[c * 3] += dirs[j]._color.r * weight;
									lightCube[c * 3 + 1] += dirs[j]._color.g * weight;
									lightCube[c * 3 + 2] += dirs[j]._color.b * weight;
								}
							}
						}

						emitter.constantLightCube.setValue(lightCube);
					}

					if (!data.paused) {
						emitter.simTime += dt;

						if (emitter.simTime > emitter.fixedTimeStep) {
							numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
							emitter.simTime -= numSteps * emitter.fixedTimeStep;
						}

						if (numSteps) {
							numSteps = Math.min(numSteps, emitter.maxSubSteps);

							for (let i = 0; i < numSteps; i++) {
								emitter.addTime(emitter.fixedTimeStep, false);
							}

							stats._updatesPerFrame += numSteps;
							stats._frameTime += emitter._addTimeTime;
							emitter._addTimeTime = 0;
						}

						emitter.finishFrame();
					}
				}
			}
		}
	}

	onBeforeRemove(entity, component) {
		component.onBeforeRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(ParticleSystemComponent.prototype, _schema$8);

class ObjectPool {
	constructor(constructorFunc, size) {
		this._constructor = constructorFunc;
		this._pool = [];
		this._count = 0;

		this._resize(size);
	}

	_resize(size) {
		if (size > this._pool.length) {
			for (let i = this._pool.length; i < size; i++) {
				this._pool[i] = new this._constructor();
			}
		}
	}

	allocate() {
		if (this._count >= this._pool.length) {
			this._resize(this._pool.length * 2);
		}

		return this._pool[this._count++];
	}

	freeAll() {
		this._count = 0;
	}

}

let ammoTransform;
let ammoVec1, ammoVec2, ammoQuat, ammoOrigin;

class RigidBodyComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._angularDamping = 0;
		this._angularFactor = new Vec3(1, 1, 1);
		this._angularVelocity = new Vec3();
		this._body = null;
		this._friction = 0.5;
		this._group = BODYGROUP_STATIC;
		this._linearDamping = 0;
		this._linearFactor = new Vec3(1, 1, 1);
		this._linearVelocity = new Vec3();
		this._mask = BODYMASK_NOT_STATIC;
		this._mass = 1;
		this._restitution = 0;
		this._rollingFriction = 0;
		this._simulationEnabled = false;
		this._type = BODYTYPE_STATIC;
	}

	static onLibraryLoaded() {
		if (typeof Ammo !== 'undefined' && !ammoTransform) {
			ammoTransform = new Ammo.btTransform();
			ammoVec1 = new Ammo.btVector3();
			ammoVec2 = new Ammo.btVector3();
			ammoQuat = new Ammo.btQuaternion();
			ammoOrigin = new Ammo.btVector3(0, 0, 0);
		}
	}

	set angularDamping(damping) {
		if (this._angularDamping !== damping) {
			this._angularDamping = damping;

			if (this._body) {
				this._body.setDamping(this._linearDamping, damping);
			}
		}
	}

	get angularDamping() {
		return this._angularDamping;
	}

	set angularFactor(factor) {
		if (!this._angularFactor.equals(factor)) {
			this._angularFactor.copy(factor);

			if (this._body && this._type === BODYTYPE_DYNAMIC) {
				ammoVec1.setValue(factor.x, factor.y, factor.z);

				this._body.setAngularFactor(ammoVec1);
			}
		}
	}

	get angularFactor() {
		return this._angularFactor;
	}

	set angularVelocity(velocity) {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			this._body.activate();

			ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

			this._body.setAngularVelocity(ammoVec1);

			this._angularVelocity.copy(velocity);
		}
	}

	get angularVelocity() {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			const velocity = this._body.getAngularVelocity();

			this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
		}

		return this._angularVelocity;
	}

	set body(body) {
		if (this._body !== body) {
			this._body = body;

			if (body && this._simulationEnabled) {
				body.activate();
			}
		}
	}

	get body() {
		return this._body;
	}

	set friction(friction) {
		if (this._friction !== friction) {
			this._friction = friction;

			if (this._body) {
				this._body.setFriction(friction);
			}
		}
	}

	get friction() {
		return this._friction;
	}

	set group(group) {
		if (this._group !== group) {
			this._group = group;

			if (this.enabled && this.entity.enabled) {
				this.disableSimulation();
				this.enableSimulation();
			}
		}
	}

	get group() {
		return this._group;
	}

	set linearDamping(damping) {
		if (this._linearDamping !== damping) {
			this._linearDamping = damping;

			if (this._body) {
				this._body.setDamping(damping, this._angularDamping);
			}
		}
	}

	get linearDamping() {
		return this._linearDamping;
	}

	set linearFactor(factor) {
		if (!this._linearFactor.equals(factor)) {
			this._linearFactor.copy(factor);

			if (this._body && this._type === BODYTYPE_DYNAMIC) {
				ammoVec1.setValue(factor.x, factor.y, factor.z);

				this._body.setLinearFactor(ammoVec1);
			}
		}
	}

	get linearFactor() {
		return this._linearFactor;
	}

	set linearVelocity(velocity) {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			this._body.activate();

			ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

			this._body.setLinearVelocity(ammoVec1);

			this._linearVelocity.copy(velocity);
		}
	}

	get linearVelocity() {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			const velocity = this._body.getLinearVelocity();

			this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
		}

		return this._linearVelocity;
	}

	set mask(mask) {
		if (this._mask !== mask) {
			this._mask = mask;

			if (this.enabled && this.entity.enabled) {
				this.disableSimulation();
				this.enableSimulation();
			}
		}
	}

	get mask() {
		return this._mask;
	}

	set mass(mass) {
		if (this._mass !== mass) {
			this._mass = mass;

			if (this._body && this._type === BODYTYPE_DYNAMIC) {
				const enabled = this.enabled && this.entity.enabled;

				if (enabled) {
					this.disableSimulation();
				}

				this._body.getCollisionShape().calculateLocalInertia(mass, ammoVec1);

				this._body.setMassProps(mass, ammoVec1);

				this._body.updateInertiaTensor();

				if (enabled) {
					this.enableSimulation();
				}
			}
		}
	}

	get mass() {
		return this._mass;
	}

	set restitution(restitution) {
		if (this._restitution !== restitution) {
			this._restitution = restitution;

			if (this._body) {
				this._body.setRestitution(restitution);
			}
		}
	}

	get restitution() {
		return this._restitution;
	}

	set rollingFriction(friction) {
		if (this._rollingFriction !== friction) {
			this._rollingFriction = friction;

			if (this._body) {
				this._body.setRollingFriction(friction);
			}
		}
	}

	get rollingFriction() {
		return this._rollingFriction;
	}

	set type(type) {
		if (this._type !== type) {
			this._type = type;
			this.disableSimulation();

			switch (type) {
				case BODYTYPE_DYNAMIC:
					this._group = BODYGROUP_DYNAMIC;
					this._mask = BODYMASK_ALL;
					break;

				case BODYTYPE_KINEMATIC:
					this._group = BODYGROUP_KINEMATIC;
					this._mask = BODYMASK_ALL;
					break;

				case BODYTYPE_STATIC:
				default:
					this._group = BODYGROUP_STATIC;
					this._mask = BODYMASK_NOT_STATIC;
					break;
			}

			this.createBody();
		}
	}

	get type() {
		return this._type;
	}

	createBody() {
		const entity = this.entity;
		let shape;

		if (entity.collision) {
			shape = entity.collision.shape;

			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}
		}

		if (shape) {
			if (this._body) this.system.onRemove(entity, this);
			const mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;

			this._getEntityTransform(ammoTransform);

			const body = this.system.createBody(mass, shape, ammoTransform);
			body.setRestitution(this._restitution);
			body.setFriction(this._friction);
			body.setRollingFriction(this._rollingFriction);
			body.setDamping(this._linearDamping, this._angularDamping);

			if (this._type === BODYTYPE_DYNAMIC) {
				const linearFactor = this._linearFactor;
				ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
				body.setLinearFactor(ammoVec1);
				const angularFactor = this._angularFactor;
				ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
				body.setAngularFactor(ammoVec1);
			} else if (this._type === BODYTYPE_KINEMATIC) {
				body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
				body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
			}

			body.entity = entity;
			this.body = body;

			if (this.enabled && entity.enabled) {
				this.enableSimulation();
			}
		}
	}

	isActive() {
		return this._body ? this._body.isActive() : false;
	}

	activate() {
		if (this._body) {
			this._body.activate();
		}
	}

	enableSimulation() {
		const entity = this.entity;

		if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
			const body = this._body;

			if (body) {
				this.system.addBody(body, this._group, this._mask);

				switch (this._type) {
					case BODYTYPE_DYNAMIC:
						this.system._dynamic.push(this);

						body.forceActivationState(BODYSTATE_ACTIVE_TAG);
						this.syncEntityToBody();
						break;

					case BODYTYPE_KINEMATIC:
						this.system._kinematic.push(this);

						body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
						break;

					case BODYTYPE_STATIC:
						body.forceActivationState(BODYSTATE_ACTIVE_TAG);
						this.syncEntityToBody();
						break;
				}

				if (entity.collision.type === 'compound') {
					this.system._compounds.push(entity.collision);
				}

				body.activate();
				this._simulationEnabled = true;
			}
		}
	}

	disableSimulation() {
		const body = this._body;

		if (body && this._simulationEnabled) {
			const system = this.system;

			let idx = system._compounds.indexOf(this.entity.collision);

			if (idx > -1) {
				system._compounds.splice(idx, 1);
			}

			idx = system._dynamic.indexOf(this);

			if (idx > -1) {
				system._dynamic.splice(idx, 1);
			}

			idx = system._kinematic.indexOf(this);

			if (idx > -1) {
				system._kinematic.splice(idx, 1);
			}

			system.removeBody(body);
			body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
			this._simulationEnabled = false;
		}
	}

	applyForce() {
		let x, y, z;
		let px, py, pz;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 2:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				px = arguments[1].x;
				py = arguments[1].y;
				pz = arguments[1].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			case 6:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				px = arguments[3];
				py = arguments[4];
				pz = arguments[5];
				break;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);

			if (px !== undefined) {
				ammoVec2.setValue(px, py, pz);
				body.applyForce(ammoVec1, ammoVec2);
			} else {
				body.applyForce(ammoVec1, ammoOrigin);
			}
		}
	}

	applyTorque() {
		let x, y, z;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			default:
				return;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);
			body.applyTorque(ammoVec1);
		}
	}

	applyImpulse() {
		let x, y, z;
		let px, py, pz;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 2:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				px = arguments[1].x;
				py = arguments[1].y;
				pz = arguments[1].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			case 6:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				px = arguments[3];
				py = arguments[4];
				pz = arguments[5];
				break;

			default:
				return;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);

			if (px !== undefined) {
				ammoVec2.setValue(px, py, pz);
				body.applyImpulse(ammoVec1, ammoVec2);
			} else {
				body.applyImpulse(ammoVec1, ammoOrigin);
			}
		}
	}

	applyTorqueImpulse() {
		let x, y, z;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			default:
				return;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);
			body.applyTorqueImpulse(ammoVec1);
		}
	}

	isStatic() {
		return this._type === BODYTYPE_STATIC;
	}

	isStaticOrKinematic() {
		return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
	}

	isKinematic() {
		return this._type === BODYTYPE_KINEMATIC;
	}

	_getEntityTransform(transform) {
		const entity = this.entity;
		const pos = entity.getPosition();
		const rot = entity.getRotation();
		ammoVec1.setValue(pos.x, pos.y, pos.z);
		ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
		transform.setOrigin(ammoVec1);
		transform.setRotation(ammoQuat);
	}

	syncEntityToBody() {
		const body = this._body;

		if (body) {
			this._getEntityTransform(ammoTransform);

			body.setWorldTransform(ammoTransform);

			if (this._type === BODYTYPE_KINEMATIC) {
				const motionState = body.getMotionState();

				if (motionState) {
					motionState.setWorldTransform(ammoTransform);
				}
			}

			body.activate();
		}
	}

	_updateDynamic() {
		const body = this._body;

		if (body.isActive()) {
			const motionState = body.getMotionState();

			if (motionState) {
				motionState.getWorldTransform(ammoTransform);
				const p = ammoTransform.getOrigin();
				const q = ammoTransform.getRotation();
				this.entity.setPosition(p.x(), p.y(), p.z());
				this.entity.setRotation(q.x(), q.y(), q.z(), q.w());
			}
		}
	}

	_updateKinematic() {
		const motionState = this._body.getMotionState();

		if (motionState) {
			this._getEntityTransform(ammoTransform);

			motionState.setWorldTransform(ammoTransform);
		}
	}

	teleport() {
		if (arguments.length < 3) {
			if (arguments[0]) {
				this.entity.setPosition(arguments[0]);
			}

			if (arguments[1]) {
				if (arguments[1] instanceof Quat) {
					this.entity.setRotation(arguments[1]);
				} else {
					this.entity.setEulerAngles(arguments[1]);
				}
			}
		} else {
			if (arguments.length === 6) {
				this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);
			}

			this.entity.setPosition(arguments[0], arguments[1], arguments[2]);
		}

		this.syncEntityToBody();
	}

	onEnable() {
		if (!this._body) {
			this.createBody();
		}

		this.enableSimulation();
	}

	onDisable() {
		this.disableSimulation();
	}

}

class RigidBodyComponentData {
	constructor() {
		this.enabled = true;
	}

}

let ammoRayStart, ammoRayEnd;

class RaycastResult {
	constructor(entity, point, normal) {
		this.entity = entity;
		this.point = point;
		this.normal = normal;
	}

}

class SingleContactResult {
	constructor(a, b, contactPoint) {
		if (arguments.length === 0) {
			this.a = null;
			this.b = null;
			this.impulse = 0;
			this.localPointA = new Vec3();
			this.localPointB = new Vec3();
			this.pointA = new Vec3();
			this.pointB = new Vec3();
			this.normal = new Vec3();
		} else {
			this.a = a;
			this.b = b;
			this.impulse = contactPoint.impulse;
			this.localPointA = contactPoint.localPoint;
			this.localPointB = contactPoint.localPointOther;
			this.pointA = contactPoint.point;
			this.pointB = contactPoint.pointOther;
			this.normal = contactPoint.normal;
		}
	}

}

class ContactPoint {
	constructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0) {
		this.localPoint = localPoint;
		this.localPointOther = localPointOther;
		this.point = point;
		this.pointOther = pointOther;
		this.normal = normal;
		this.impulse = impulse;
	}

}

class ContactResult {
	constructor(other, contacts) {
		this.other = other;
		this.contacts = contacts;
	}

}

const _schema$7 = ['enabled'];

class RigidBodyComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'rigidbody';
		this._stats = app.stats.frame;
		this.ComponentType = RigidBodyComponent;
		this.DataType = RigidBodyComponentData;
		this.contactPointPool = null;
		this.contactResultPool = null;
		this.singleContactResultPool = null;
		this.schema = _schema$7;
		this.maxSubSteps = 10;
		this.fixedTimeStep = 1 / 60;
		this.gravity = new Vec3(0, -9.81, 0);
		this._dynamic = [];
		this._kinematic = [];
		this._triggers = [];
		this._compounds = [];
		this.collisions = {};
		this.frameCollisions = {};
		this.on('beforeremove', this.onBeforeRemove, this);
		this.on('remove', this.onRemove, this);
	}

	onLibraryLoaded() {
		if (typeof Ammo !== 'undefined') {
			this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
			this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
			this.overlappingPairCache = new Ammo.btDbvtBroadphase();
			this.solver = new Ammo.btSequentialImpulseConstraintSolver();
			this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);

			if (this.dynamicsWorld.setInternalTickCallback) {
				const checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
				this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
			}

			ammoRayStart = new Ammo.btVector3();
			ammoRayEnd = new Ammo.btVector3();
			RigidBodyComponent.onLibraryLoaded();
			this.contactPointPool = new ObjectPool(ContactPoint, 1);
			this.contactResultPool = new ObjectPool(ContactResult, 1);
			this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
			this.app.systems.on('update', this.onUpdate, this);
		} else {
			this.app.systems.off('update', this.onUpdate, this);
		}
	}

	initializeComponentData(component, data, properties) {
		const props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];

		for (const property of props) {
			if (data.hasOwnProperty(property)) {
				const value = data[property];

				if (Array.isArray(value)) {
					component[property] = new Vec3(value[0], value[1], value[2]);
				} else {
					component[property] = value;
				}
			}
		}

		super.initializeComponentData(component, data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const rigidbody = entity.rigidbody;
		const data = {
			enabled: rigidbody.enabled,
			mass: rigidbody.mass,
			linearDamping: rigidbody.linearDamping,
			angularDamping: rigidbody.angularDamping,
			linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],
			angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],
			friction: rigidbody.friction,
			rollingFriction: rigidbody.rollingFriction,
			restitution: rigidbody.restitution,
			type: rigidbody.type,
			group: rigidbody.group,
			mask: rigidbody.mask
		};
		this.addComponent(clone, data);
	}

	onBeforeRemove(entity, component) {
		if (component.enabled) {
			component.enabled = false;
		}
	}

	onRemove(entity, component) {
		const body = component.body;

		if (body) {
			this.removeBody(body);
			this.destroyBody(body);
			component.body = null;
		}
	}

	addBody(body, group, mask) {
		if (group !== undefined && mask !== undefined) {
			this.dynamicsWorld.addRigidBody(body, group, mask);
		} else {
			this.dynamicsWorld.addRigidBody(body);
		}
	}

	removeBody(body) {
		this.dynamicsWorld.removeRigidBody(body);
	}

	createBody(mass, shape, transform) {
		const localInertia = new Ammo.btVector3(0, 0, 0);

		if (mass !== 0) {
			shape.calculateLocalInertia(mass, localInertia);
		}

		const motionState = new Ammo.btDefaultMotionState(transform);
		const bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
		const body = new Ammo.btRigidBody(bodyInfo);
		Ammo.destroy(bodyInfo);
		Ammo.destroy(localInertia);
		return body;
	}

	destroyBody(body) {
		const motionState = body.getMotionState();

		if (motionState) {
			Ammo.destroy(motionState);
		}

		Ammo.destroy(body);
	}

	raycastFirst(start, end) {
		let result = null;
		ammoRayStart.setValue(start.x, start.y, start.z);
		ammoRayEnd.setValue(end.x, end.y, end.z);
		const rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
		this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

		if (rayCallback.hasHit()) {
			const collisionObj = rayCallback.get_m_collisionObject();
			const body = Ammo.castObject(collisionObj, Ammo.btRigidBody);

			if (body) {
				const point = rayCallback.get_m_hitPointWorld();
				const normal = rayCallback.get_m_hitNormalWorld();
				result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));

				if (arguments.length > 2) {
					const callback = arguments[2];
					callback(result);
				}
			}
		}

		Ammo.destroy(rayCallback);
		return result;
	}

	raycastAll(start, end) {
		const results = [];
		ammoRayStart.setValue(start.x, start.y, start.z);
		ammoRayEnd.setValue(end.x, end.y, end.z);
		const rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
		this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

		if (rayCallback.hasHit()) {
			const collisionObjs = rayCallback.get_m_collisionObjects();
			const points = rayCallback.get_m_hitPointWorld();
			const normals = rayCallback.get_m_hitNormalWorld();
			const numHits = collisionObjs.size();

			for (let i = 0; i < numHits; i++) {
				const body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);

				if (body) {
					const point = points.at(i);
					const normal = normals.at(i);
					const result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));
					results.push(result);
				}
			}
		}

		Ammo.destroy(rayCallback);
		return results;
	}

	_storeCollision(entity, other) {
		let isNewCollision = false;
		const guid = entity.getGuid();
		this.collisions[guid] = this.collisions[guid] || {
			others: [],
			entity: entity
		};

		if (this.collisions[guid].others.indexOf(other) < 0) {
			this.collisions[guid].others.push(other);
			isNewCollision = true;
		}

		this.frameCollisions[guid] = this.frameCollisions[guid] || {
			others: [],
			entity: entity
		};
		this.frameCollisions[guid].others.push(other);
		return isNewCollision;
	}

	_createContactPointFromAmmo(contactPoint) {
		const localPointA = contactPoint.get_m_localPointA();
		const localPointB = contactPoint.get_m_localPointB();
		const positionWorldOnA = contactPoint.getPositionWorldOnA();
		const positionWorldOnB = contactPoint.getPositionWorldOnB();
		const normalWorldOnB = contactPoint.get_m_normalWorldOnB();
		const contact = this.contactPointPool.allocate();
		contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
		contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
		contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
		contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
		contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
		contact.impulse = contactPoint.getAppliedImpulse();
		return contact;
	}

	_createReverseContactPointFromAmmo(contactPoint) {
		const localPointA = contactPoint.get_m_localPointA();
		const localPointB = contactPoint.get_m_localPointB();
		const positionWorldOnA = contactPoint.getPositionWorldOnA();
		const positionWorldOnB = contactPoint.getPositionWorldOnB();
		const normalWorldOnB = contactPoint.get_m_normalWorldOnB();
		const contact = this.contactPointPool.allocate();
		contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
		contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
		contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
		contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
		contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
		contact.impulse = contactPoint.getAppliedImpulse();
		return contact;
	}

	_createSingleContactResult(a, b, contactPoint) {
		const result = this.singleContactResultPool.allocate();
		result.a = a;
		result.b = b;
		result.localPointA = contactPoint.localPoint;
		result.localPointB = contactPoint.localPointOther;
		result.pointA = contactPoint.point;
		result.pointB = contactPoint.pointOther;
		result.normal = contactPoint.normal;
		result.impulse = contactPoint.impulse;
		return result;
	}

	_createContactResult(other, contacts) {
		const result = this.contactResultPool.allocate();
		result.other = other;
		result.contacts = contacts;
		return result;
	}

	_cleanOldCollisions() {
		for (const guid in this.collisions) {
			if (this.collisions.hasOwnProperty(guid)) {
				const frameCollision = this.frameCollisions[guid];
				const collision = this.collisions[guid];
				const entity = collision.entity;
				const entityCollision = entity.collision;
				const entityRigidbody = entity.rigidbody;
				const others = collision.others;
				const length = others.length;
				let i = length;

				while (i--) {
					const other = others[i];

					if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
						others.splice(i, 1);

						if (entity.trigger) {
							if (entityCollision) {
								entityCollision.fire("triggerleave", other);
							}

							if (other.rigidbody) {
								other.rigidbody.fire('triggerleave', entity);
							}
						} else if (!other.trigger) {
							if (entityRigidbody) {
								entityRigidbody.fire("collisionend", other);
							}

							if (entityCollision) {
								entityCollision.fire("collisionend", other);
							}
						}
					}
				}

				if (others.length === 0) {
					delete this.collisions[guid];
				}
			}
		}
	}

	_hasContactEvent(entity) {
		const c = entity.collision;

		if (c && (c.hasEvent("collisionstart") || c.hasEvent("collisionend") || c.hasEvent("contact"))) {
			return true;
		}

		const r = entity.rigidbody;
		return r && (r.hasEvent("collisionstart") || r.hasEvent("collisionend") || r.hasEvent("contact"));
	}

	_checkForCollisions(world, timeStep) {
		const dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
		const dispatcher = dynamicsWorld.getDispatcher();
		const numManifolds = dispatcher.getNumManifolds();
		this.frameCollisions = {};

		for (let i = 0; i < numManifolds; i++) {
			const manifold = dispatcher.getManifoldByIndexInternal(i);
			const body0 = manifold.getBody0();
			const body1 = manifold.getBody1();
			const wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
			const wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
			const e0 = wb0.entity;
			const e1 = wb1.entity;

			if (!e0 || !e1) {
				continue;
			}

			const flags0 = wb0.getCollisionFlags();
			const flags1 = wb1.getCollisionFlags();
			const numContacts = manifold.getNumContacts();
			const forwardContacts = [];
			const reverseContacts = [];
			let newCollision;

			if (numContacts > 0) {
				if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
					const e0Events = e0.collision && (e0.collision.hasEvent("triggerenter") || e0.collision.hasEvent("triggerleave"));
					const e1Events = e1.collision && (e1.collision.hasEvent("triggerenter") || e1.collision.hasEvent("triggerleave"));
					const e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent("triggerenter") || e0.rigidbody.hasEvent("triggerleave"));
					const e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent("triggerenter") || e1.rigidbody.hasEvent("triggerleave"));

					if (e0Events) {
						newCollision = this._storeCollision(e0, e1);

						if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
							e0.collision.fire("triggerenter", e1);
						}
					}

					if (e1Events) {
						newCollision = this._storeCollision(e1, e0);

						if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
							e1.collision.fire("triggerenter", e0);
						}
					}

					if (e0BodyEvents) {
						if (!newCollision) {
							newCollision = this._storeCollision(e1, e0);
						}

						if (newCollision) {
							e0.rigidbody.fire("triggerenter", e1);
						}
					}

					if (e1BodyEvents) {
						if (!newCollision) {
							newCollision = this._storeCollision(e0, e1);
						}

						if (newCollision) {
							e1.rigidbody.fire("triggerenter", e0);
						}
					}
				} else {
					const e0Events = this._hasContactEvent(e0);

					const e1Events = this._hasContactEvent(e1);

					const globalEvents = this.hasEvent("contact");

					if (globalEvents || e0Events || e1Events) {
						for (let j = 0; j < numContacts; j++) {
							const btContactPoint = manifold.getContactPoint(j);

							const contactPoint = this._createContactPointFromAmmo(btContactPoint);

							if (e0Events || e1Events) {
								forwardContacts.push(contactPoint);

								const reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);

								reverseContacts.push(reverseContactPoint);
							}

							if (globalEvents) {
								const result = this._createSingleContactResult(e0, e1, contactPoint);

								this.fire("contact", result);
							}
						}

						if (e0Events) {
							const forwardResult = this._createContactResult(e1, forwardContacts);

							newCollision = this._storeCollision(e0, e1);

							if (e0.collision) {
								e0.collision.fire("contact", forwardResult);

								if (newCollision) {
									e0.collision.fire("collisionstart", forwardResult);
								}
							}

							if (e0.rigidbody) {
								e0.rigidbody.fire("contact", forwardResult);

								if (newCollision) {
									e0.rigidbody.fire("collisionstart", forwardResult);
								}
							}
						}

						if (e1Events) {
							const reverseResult = this._createContactResult(e0, reverseContacts);

							newCollision = this._storeCollision(e1, e0);

							if (e1.collision) {
								e1.collision.fire("contact", reverseResult);

								if (newCollision) {
									e1.collision.fire("collisionstart", reverseResult);
								}
							}

							if (e1.rigidbody) {
								e1.rigidbody.fire("contact", reverseResult);

								if (newCollision) {
									e1.rigidbody.fire("collisionstart", reverseResult);
								}
							}
						}
					}
				}
			}
		}

		this._cleanOldCollisions();

		this.contactPointPool.freeAll();
		this.contactResultPool.freeAll();
		this.singleContactResultPool.freeAll();
	}

	onUpdate(dt) {
		let i, len;
		const gravity = this.dynamicsWorld.getGravity();

		if (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {
			gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
			this.dynamicsWorld.setGravity(gravity);
		}

		const triggers = this._triggers;

		for (i = 0, len = triggers.length; i < len; i++) {
			triggers[i].updateTransform();
		}

		const compounds = this._compounds;

		for (i = 0, len = compounds.length; i < len; i++) {
			compounds[i]._updateCompound();
		}

		const kinematic = this._kinematic;

		for (i = 0, len = kinematic.length; i < len; i++) {
			kinematic[i]._updateKinematic();
		}

		this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
		const dynamic = this._dynamic;

		for (i = 0, len = dynamic.length; i < len; i++) {
			dynamic[i]._updateDynamic();
		}

		if (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);

		if (typeof Ammo !== 'undefined') {
			Ammo.destroy(this.dynamicsWorld);
			Ammo.destroy(this.solver);
			Ammo.destroy(this.overlappingPairCache);
			Ammo.destroy(this.dispatcher);
			Ammo.destroy(this.collisionConfiguration);
			this.dynamicsWorld = null;
			this.solver = null;
			this.overlappingPairCache = null;
			this.dispatcher = null;
			this.collisionConfiguration = null;
		}
	}

}

Component._buildAccessors(RigidBodyComponent.prototype, _schema$7);

const SCALEMODE_NONE = "none";
const SCALEMODE_BLEND = "blend";

const _transform = new Mat4();

class ScreenComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._resolution = new Vec2(640, 320);
		this._referenceResolution = new Vec2(640, 320);
		this._scaleMode = SCALEMODE_NONE;
		this.scale = 1;
		this._scaleBlend = 0.5;
		this._priority = 0;
		this._screenSpace = false;
		this.cull = this._screenSpace;
		this._screenMatrix = new Mat4();
		this._elements = new Set();
		system.app.graphicsDevice.on("resizecanvas", this._onResize, this);
	}

	syncDrawOrder() {
		this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
	}

	_recurseDrawOrderSync(e, i) {
		if (!(e instanceof Entity)) {
			return i;
		}

		if (e.element) {
			const prevDrawOrder = e.element.drawOrder;
			e.element.drawOrder = i++;

			if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
				this.system.app.batcher.markGroupDirty(e.element._batchGroupId);
			}
		}

		if (e.particlesystem) {
			e.particlesystem.drawOrder = i++;
		}

		const children = e.children;

		for (let j = 0; j < children.length; j++) {
			i = this._recurseDrawOrderSync(children[j], i);
		}

		return i;
	}

	_processDrawOrderSync() {
		const i = 1;

		this._recurseDrawOrderSync(this.entity, i);

		this.fire('syncdraworder');
	}

	_calcProjectionMatrix() {
		const w = this._resolution.x / this.scale;
		const h = this._resolution.y / this.scale;
		const left = 0;
		const right = w;
		const bottom = -h;
		const top = 0;
		const near = 1;
		const far = -1;

		this._screenMatrix.setOrtho(left, right, bottom, top, near, far);

		if (!this._screenSpace) {
			_transform.setScale(0.5 * w, 0.5 * h, 1);

			this._screenMatrix.mul2(_transform, this._screenMatrix);
		}
	}

	_updateScale() {
		this.scale = this._calcScale(this._resolution, this.referenceResolution);
	}

	_calcScale(resolution, referenceResolution) {
		const lx = Math.log2(resolution.x / referenceResolution.x);
		const ly = Math.log2(resolution.y / referenceResolution.y);
		return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
	}

	_onResize(width, height) {
		if (this._screenSpace) {
			this._resolution.set(width, height);

			this.resolution = this._resolution;
		}
	}

	_bindElement(element) {
		this._elements.add(element);
	}

	_unbindElement(element) {
		this._elements.delete(element);
	}

	onRemove() {
		this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
		this.fire('remove');

		this._elements.forEach(element => element._onScreenRemove());

		this._elements.clear();

		this.off();
	}

	set resolution(value) {
		if (!this._screenSpace) {
			this._resolution.set(value.x, value.y);
		} else {
			this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
		}

		this._updateScale();

		this._calcProjectionMatrix();

		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire("set:resolution", this._resolution);

		this._elements.forEach(element => element._onScreenResize(this._resolution));
	}

	get resolution() {
		return this._resolution;
	}

	set referenceResolution(value) {
		this._referenceResolution.set(value.x, value.y);

		this._updateScale();

		this._calcProjectionMatrix();

		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire("set:referenceresolution", this._resolution);

		this._elements.forEach(element => element._onScreenResize(this._resolution));
	}

	get referenceResolution() {
		if (this._scaleMode === SCALEMODE_NONE) {
			return this._resolution;
		}

		return this._referenceResolution;
	}

	set screenSpace(value) {
		this._screenSpace = value;

		if (this._screenSpace) {
			this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
		}

		this.resolution = this._resolution;
		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire('set:screenspace', this._screenSpace);

		this._elements.forEach(element => element._onScreenSpaceChange());
	}

	get screenSpace() {
		return this._screenSpace;
	}

	set scaleMode(value) {
		if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
			value = SCALEMODE_NONE;
		}

		if (!this._screenSpace && value !== SCALEMODE_NONE) {
			value = SCALEMODE_NONE;
		}

		this._scaleMode = value;
		this.resolution = this._resolution;
		this.fire("set:scalemode", this._scaleMode);
	}

	get scaleMode() {
		return this._scaleMode;
	}

	set scaleBlend(value) {
		this._scaleBlend = value;

		this._updateScale();

		this._calcProjectionMatrix();

		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire("set:scaleblend", this._scaleBlend);

		this._elements.forEach(element => element._onScreenResize(this._resolution));
	}

	get scaleBlend() {
		return this._scaleBlend;
	}

	set priority(value) {
		if (value > 0xFF) {
			value = 0xFF;
		}

		this._priority = value;
	}

	get priority() {
		return this._priority;
	}

}

class ScreenComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$6 = ['enabled'];

class ScreenComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'screen';
		this.ComponentType = ScreenComponent;
		this.DataType = ScreenComponentData;
		this.schema = _schema$6;
		this.windowResolution = new Vec2();
		this._drawOrderSyncQueue = new IndexedList();
		this.app.graphicsDevice.on("resizecanvas", this._onResize, this);
		this.app.systems.on('update', this._onUpdate, this);
		this.on('beforeremove', this.onRemoveComponent, this);
	}

	initializeComponentData(component, data, properties) {
		if (data.priority !== undefined) component.priority = data.priority;
		if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
		component.cull = component.screenSpace;
		if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
		if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;

		if (data.resolution !== undefined) {
			if (data.resolution instanceof Vec2) {
				component._resolution.copy(data.resolution);
			} else {
				component._resolution.set(data.resolution[0], data.resolution[1]);
			}

			component.resolution = component._resolution;
		}

		if (data.referenceResolution !== undefined) {
			if (data.referenceResolution instanceof Vec2) {
				component._referenceResolution.copy(data.referenceResolution);
			} else {
				component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
			}

			component.referenceResolution = component._referenceResolution;
		}

		component.syncDrawOrder();
		super.initializeComponentData(component, data, properties);
	}

	destroy() {
		super.destroy();
		this.app.graphicsDevice.off("resizecanvas", this._onResize, this);
		this.app.systems.off('update', this._onUpdate, this);
	}

	_onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
		}
	}

	_onResize(width, height) {
		this.windowResolution.x = width;
		this.windowResolution.y = height;
	}

	cloneComponent(entity, clone) {
		const screen = entity.screen;
		return this.addComponent(clone, {
			enabled: screen.enabled,
			screenSpace: screen.screenSpace,
			scaleMode: screen.scaleMode,
			resolution: screen.resolution.clone(),
			referenceResolution: screen.referenceResolution.clone()
		});
	}

	onRemoveComponent(entity, component) {
		component.onRemove();
	}

	processDrawOrderSyncQueue() {
		const list = this._drawOrderSyncQueue.list();

		for (let i = 0; i < list.length; i++) {
			const item = list[i];
			item.callback.call(item.scope);
		}

		this._drawOrderSyncQueue.clear();
	}

	queueDrawOrderSync(id, fn, scope) {
		if (!this._drawOrderSyncQueue.list().length) {
			this.app.once('prerender', this.processDrawOrderSyncQueue, this);
		}

		if (!this._drawOrderSyncQueue.has(id)) {
			this._drawOrderSyncQueue.push(id, {
				callback: fn,
				scope: scope
			});
		}
	}

}

Component._buildAccessors(ScreenComponent.prototype, _schema$6);

class ScriptComponentData {
	constructor() {
		this.enabled = true;
	}

}

const METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
const METHOD_INITIALIZE = '_onInitialize';
const METHOD_POST_INITIALIZE = '_onPostInitialize';
const METHOD_UPDATE = '_onUpdate';
const METHOD_POST_UPDATE = '_onPostUpdate';
let executionOrderCounter = 0;

class ScriptComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'script';
		this.ComponentType = ScriptComponent;
		this.DataType = ScriptComponentData;
		this._components = new SortedLoopArray({
			sortBy: '_executionOrder'
		});
		this._enabledComponents = new SortedLoopArray({
			sortBy: '_executionOrder'
		});
		this.preloading = true;
		this.on('beforeremove', this._onBeforeRemove, this);
		this.app.systems.on('initialize', this._onInitialize, this);
		this.app.systems.on('postInitialize', this._onPostInitialize, this);
		this.app.systems.on('update', this._onUpdate, this);
		this.app.systems.on('postUpdate', this._onPostUpdate, this);
	}

	initializeComponentData(component, data) {
		component._executionOrder = executionOrderCounter++;

		this._components.append(component);

		if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
			this._resetExecutionOrder();
		}

		component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

		if (component.enabled && component.entity.enabled) {
			this._enabledComponents.append(component);
		}

		if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
			component._scriptsData = data.scripts;

			for (let i = 0; i < data.order.length; i++) {
				component.create(data.order[i], {
					enabled: data.scripts[data.order[i]].enabled,
					attributes: data.scripts[data.order[i]].attributes,
					preloading: this.preloading
				});
			}
		}
	}

	cloneComponent(entity, clone) {
		const order = [];
		const scripts = {};

		for (let i = 0; i < entity.script._scripts.length; i++) {
			const scriptInstance = entity.script._scripts[i];
			const scriptName = scriptInstance.__scriptType.__name;
			order.push(scriptName);
			const attributes = {};

			for (const key in scriptInstance.__attributes) attributes[key] = scriptInstance.__attributes[key];

			scripts[scriptName] = {
				enabled: scriptInstance._enabled,
				attributes: attributes
			};
		}

		for (const key in entity.script._scriptsIndex) {
			if (key.awaiting) {
				order.splice(key.ind, 0, key);
			}
		}

		const data = {
			enabled: entity.script.enabled,
			order: order,
			scripts: scripts
		};
		return this.addComponent(clone, data);
	}

	_resetExecutionOrder() {
		executionOrderCounter = 0;

		for (let i = 0, len = this._components.length; i < len; i++) {
			this._components.items[i]._executionOrder = executionOrderCounter++;
		}
	}

	_callComponentMethod(components, name, dt) {
		for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
			components.items[components.loopIndex][name](dt);
		}
	}

	_onInitialize() {
		this.preloading = false;

		this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);

		this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
	}

	_onPostInitialize() {
		this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
	}

	_onUpdate(dt) {
		this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
	}

	_onPostUpdate(dt) {
		this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
	}

	_addComponentToEnabled(component) {
		this._enabledComponents.insert(component);
	}

	_removeComponentFromEnabled(component) {
		this._enabledComponents.remove(component);
	}

	_onBeforeRemove(entity, component) {
		const ind = this._components.items.indexOf(component);

		if (ind >= 0) {
			component._onBeforeRemove();
		}

		this._removeComponentFromEnabled(component);

		this._components.remove(component);
	}

	destroy() {
		super.destroy();
		this.app.systems.off('initialize', this._onInitialize, this);
		this.app.systems.off('postInitialize', this._onPostInitialize, this);
		this.app.systems.off('update', this._onUpdate, this);
		this.app.systems.off('postUpdate', this._onPostUpdate, this);
	}

}

class ScriptLegacyComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.on("set_scripts", this.onSetScripts, this);
	}

	send(name, functionName) {
		const args = Array.prototype.slice.call(arguments, 2);
		const instances = this.entity.script.instances;
		let fn;

		if (instances && instances[name]) {
			fn = instances[name].instance[functionName];

			if (fn) {
				return fn.apply(instances[name].instance, args);
			}
		}
	}

	onEnable() {
		if (this.data.areScriptsLoaded && !this.system.preloading) {
			if (!this.data.initialized) {
				this.system._initializeScriptComponent(this);
			} else {
				this.system._enableScriptComponent(this);
			}

			if (!this.data.postInitialized) {
				this.system._postInitializeScriptComponent(this);
			}
		}
	}

	onDisable() {
		this.system._disableScriptComponent(this);
	}

	onSetScripts(name, oldValue, newValue) {
		if (!this.system._inTools || this.runInTools) {
			if (this._updateScriptAttributes(oldValue, newValue)) {
				return;
			}

			if (this.enabled) {
				this.system._disableScriptComponent(this);
			}

			this.system._destroyScriptComponent(this);

			this.data.areScriptsLoaded = false;
			const scripts = newValue;
			const urls = scripts.map(function (s) {
				return s.url;
			});

			if (this._loadFromCache(urls)) {
				return;
			}

			this._loadScripts(urls);
		}
	}

	_updateScriptAttributes(oldValue, newValue) {
		let onlyUpdateAttributes = true;

		if (oldValue.length !== newValue.length) {
			onlyUpdateAttributes = false;
		} else {
			for (let i = 0, len = newValue.length; i < len; i++) {
				if (oldValue[i].url !== newValue[i].url) {
					onlyUpdateAttributes = false;
					break;
				}
			}
		}

		if (onlyUpdateAttributes) {
			for (const key in this.instances) {
				if (this.instances.hasOwnProperty(key)) {
					this.system._updateAccessors(this.entity, this.instances[key]);
				}
			}
		}

		return onlyUpdateAttributes;
	}

	_loadFromCache(urls) {
		const cached = [];
		const prefix = this.system.app._scriptPrefix || "";
		const regex = /^http(s)?:\/\//i;

		for (let i = 0, len = urls.length; i < len; i++) {
			let url = urls[i];

			if (!regex.test(url)) {
				url = path.join(prefix, url);
			}

			const type = this.system.app.loader.getFromCache(url, 'script');

			if (!type) {
				return false;
			}

			cached.push(type);
		}

		for (let i = 0, len = cached.length; i < len; i++) {
			const ScriptType = cached[i];

			if (ScriptType === true) {
				continue;
			}

			if (ScriptType && this.entity.script) {
				if (!this.entity.script.instances[ScriptType._pcScriptName]) {
					const instance = new ScriptType(this.entity);

					this.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);
				}
			}
		}

		if (this.data) {
			this.data.areScriptsLoaded = true;
		}

		if (!this.system.preloading) {
			this.system.onInitialize(this.entity);
			this.system.onPostInitialize(this.entity);
		}

		return true;
	}

	_loadScripts(urls) {
		let count = urls.length;
		const prefix = this.system.app._scriptPrefix || "";
		urls.forEach(url => {
			let _url = null;
			let _unprefixed = null;

			if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
				_unprefixed = url;
				_url = url;
			} else {
				_unprefixed = url;
				_url = path.join(prefix, url);
			}

			this.system.app.loader.load(_url, "script", (err, ScriptType) => {
				count--;

				if (!err) {
					if (ScriptType && this.entity.script) {
						if (!this.entity.script.instances[ScriptType._pcScriptName]) {
							const instance = new ScriptType(this.entity);

							this.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);
						}
					}
				} else {
					console.error(err);
				}

				if (count === 0) {
					this.data.areScriptsLoaded = true;

					if (!this.system.preloading) {
						this.system.onInitialize(this.entity);
						this.system.onPostInitialize(this.entity);
					}
				}
			});
		});
	}

}

class ScriptLegacyComponentData {
	constructor() {
		this.scripts = [];
		this.enabled = true;
		this.instances = {};
		this._instances = {};
		this.runInTools = false;
		this.attributes = {};
		this.initialized = false;
		this.postInitialized = false;
		this.areScriptsLoaded = false;
	}

}

const _schema$5 = ['enabled', 'scripts', 'instances', 'runInTools'];
const INITIALIZE = "initialize";
const POST_INITIALIZE = "postInitialize";
const UPDATE = "update";
const POST_UPDATE = "postUpdate";
const FIXED_UPDATE = "fixedUpdate";
const TOOLS_UPDATE = "toolsUpdate";
const ON_ENABLE = 'onEnable';
const ON_DISABLE = 'onDisable';

class ScriptLegacyComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'script';
		this.ComponentType = ScriptLegacyComponent;
		this.DataType = ScriptLegacyComponentData;
		this.schema = _schema$5;
		this.preloading = false;
		this.instancesWithUpdate = [];
		this.instancesWithFixedUpdate = [];
		this.instancesWithPostUpdate = [];
		this.instancesWithToolsUpdate = [];
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on(INITIALIZE, this.onInitialize, this);
		this.app.systems.on(POST_INITIALIZE, this.onPostInitialize, this);
		this.app.systems.on(UPDATE, this.onUpdate, this);
		this.app.systems.on(FIXED_UPDATE, this.onFixedUpdate, this);
		this.app.systems.on(POST_UPDATE, this.onPostUpdate, this);
		this.app.systems.on(TOOLS_UPDATE, this.onToolsUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['runInTools', 'enabled', 'scripts'];

		if (data.scripts && data.scripts.length) {
			data.scripts.forEach(function (script) {
				if (script.attributes && Array.isArray(script.attributes)) {
					const dict = {};

					for (let i = 0; i < script.attributes.length; i++) {
						dict[script.attributes[i].name] = script.attributes[i];
					}

					script.attributes = dict;
				}
			});
		}

		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const src = this.store[entity.getGuid()];
		const data = {
			runInTools: src.data.runInTools,
			scripts: [],
			enabled: src.data.enabled
		};
		const scripts = src.data.scripts;

		for (let i = 0, len = scripts.length; i < len; i++) {
			const attributes = scripts[i].attributes;

			if (attributes) {
				delete scripts[i].attributes;
			}

			data.scripts.push(extend({}, scripts[i]));

			if (attributes) {
				data.scripts[i].attributes = this._cloneAttributes(attributes);
				scripts[i].attributes = attributes;
			}
		}

		return this.addComponent(clone, data);
	}

	onBeforeRemove(entity, component) {
		if (component.enabled) {
			this._disableScriptComponent(component);
		}

		this._destroyScriptComponent(component);
	}

	onInitialize(root) {
		this._registerInstances(root);

		if (root.enabled) {
			if (root.script && root.script.enabled) {
				this._initializeScriptComponent(root.script);
			}

			const children = root._children;

			for (let i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this.onInitialize(children[i]);
				}
			}
		}
	}

	onPostInitialize(root) {
		if (root.enabled) {
			if (root.script && root.script.enabled) {
				this._postInitializeScriptComponent(root.script);
			}

			const children = root._children;

			for (let i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this.onPostInitialize(children[i]);
				}
			}
		}
	}

	_callInstancesMethod(script, method) {
		const instances = script.data.instances;

		for (const name in instances) {
			if (instances.hasOwnProperty(name)) {
				const instance = instances[name].instance;

				if (instance[method]) {
					instance[method]();
				}
			}
		}
	}

	_initializeScriptComponent(script) {
		this._callInstancesMethod(script, INITIALIZE);

		script.data.initialized = true;

		if (script.enabled && script.entity.enabled) {
			this._enableScriptComponent(script);
		}
	}

	_enableScriptComponent(script) {
		this._callInstancesMethod(script, ON_ENABLE);
	}

	_disableScriptComponent(script) {
		this._callInstancesMethod(script, ON_DISABLE);
	}

	_destroyScriptComponent(script) {
		const instances = script.data.instances;

		for (const name in instances) {
			if (instances.hasOwnProperty(name)) {
				const instance = instances[name].instance;

				if (instance.destroy) {
					instance.destroy();
				}

				if (instance.update) {
					const index = this.instancesWithUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithUpdate.splice(index, 1);
					}
				}

				if (instance.fixedUpdate) {
					const index = this.instancesWithFixedUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithFixedUpdate.splice(index, 1);
					}
				}

				if (instance.postUpdate) {
					const index = this.instancesWithPostUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithPostUpdate.splice(index, 1);
					}
				}

				if (instance.toolsUpdate) {
					const index = this.instancesWithToolsUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithToolsUpdate.splice(index, 1);
					}
				}

				if (script.instances[name].instance === script[name]) {
					delete script[name];
				}

				delete script.instances[name];
			}
		}
	}

	_postInitializeScriptComponent(script) {
		this._callInstancesMethod(script, POST_INITIALIZE);

		script.data.postInitialized = true;
	}

	_updateInstances(method, updateList, dt) {
		for (let i = 0, len = updateList.length; i < len; i++) {
			const item = updateList[i];

			if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
				item[method](dt);
			}
		}
	}

	onUpdate(dt) {
		this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
	}

	onFixedUpdate(dt) {
		this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
	}

	onPostUpdate(dt) {
		this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
	}

	onToolsUpdate(dt) {
		this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
	}

	broadcast(name, functionName) {
		const args = Array.prototype.slice.call(arguments, 2);
		const dataStore = this.store;

		for (const id in dataStore) {
			if (dataStore.hasOwnProperty(id)) {
				const data = dataStore[id].data;

				if (data.instances[name]) {
					const fn = data.instances[name].instance[functionName];

					if (fn) {
						fn.apply(data.instances[name].instance, args);
					}
				}
			}
		}
	}

	_preRegisterInstance(entity, url, name, instance) {
		if (entity.script) {
			entity.script.data._instances = entity.script.data._instances || {};

			if (entity.script.data._instances[name]) {
				throw Error(`Script name collision '${name}'. Scripts from '${url}' and '${entity.script.data._instances[name].url}' {${entity.getGuid()}}`);
			}

			entity.script.data._instances[name] = {
				url: url,
				name: name,
				instance: instance
			};
		}
	}

	_registerInstances(entity) {
		if (entity.script) {
			if (entity.script.data._instances) {
				entity.script.instances = entity.script.data._instances;

				for (const instanceName in entity.script.instances) {
					const preRegistered = entity.script.instances[instanceName];
					const instance = preRegistered.instance;
					events.attach(instance);

					if (instance.update) {
						this.instancesWithUpdate.push(instance);
					}

					if (instance.fixedUpdate) {
						this.instancesWithFixedUpdate.push(instance);
					}

					if (instance.postUpdate) {
						this.instancesWithPostUpdate.push(instance);
					}

					if (instance.toolsUpdate) {
						this.instancesWithToolsUpdate.push(instance);
					}

					if (entity.script.scripts) {
						this._createAccessors(entity, preRegistered);
					}

					if (entity.script[instanceName]) {
						throw Error(`Script with name '${instanceName}' is already attached to Script Component`);
					} else {
						entity.script[instanceName] = instance;
					}
				}

				delete entity.script.data._instances;
			}
		}

		const children = entity._children;

		for (let i = 0, len = children.length; i < len; i++) {
			if (children[i] instanceof Entity) {
				this._registerInstances(children[i]);
			}
		}
	}

	_cloneAttributes(attributes) {
		const result = {};

		for (const key in attributes) {
			if (!attributes.hasOwnProperty(key)) continue;

			if (attributes[key].type !== 'entity') {
				result[key] = extend({}, attributes[key]);
			} else {
				const val = attributes[key].value;
				delete attributes[key].value;
				result[key] = extend({}, attributes[key]);
				result[key].value = val;
				attributes[key].value = val;
			}
		}

		return result;
	}

	_createAccessors(entity, instance) {
		const len = entity.script.scripts.length;
		const url = instance.url;

		for (let i = 0; i < len; i++) {
			const script = entity.script.scripts[i];

			if (script.url === url) {
				const attributes = script.attributes;

				if (script.name && attributes) {
					for (const key in attributes) {
						if (attributes.hasOwnProperty(key)) {
							this._createAccessor(attributes[key], instance);
						}
					}

					entity.script.data.attributes[script.name] = this._cloneAttributes(attributes);
				}

				break;
			}
		}
	}

	_createAccessor(attribute, instance) {
		const self = this;
		attribute = {
			name: attribute.name,
			value: attribute.value,
			type: attribute.type
		};

		this._convertAttributeValue(attribute);

		Object.defineProperty(instance.instance, attribute.name, {
			get: function () {
				return attribute.value;
			},
			set: function (value) {
				const oldValue = attribute.value;
				attribute.value = value;

				self._convertAttributeValue(attribute);

				instance.instance.fire("set", attribute.name, oldValue, attribute.value);
			},
			configurable: true
		});
	}

	_updateAccessors(entity, instance) {
		const len = entity.script.scripts.length;
		const url = instance.url;

		for (let i = 0; i < len; i++) {
			const scriptComponent = entity.script;
			const script = scriptComponent.scripts[i];

			if (script.url === url) {
				const name = script.name;
				const attributes = script.attributes;

				if (name) {
					if (attributes) {
						for (const key in attributes) {
							if (attributes.hasOwnProperty(key)) {
								this._createAccessor(attributes[key], instance);
							}
						}
					}

					const previousAttributes = scriptComponent.data.attributes[name];

					if (previousAttributes) {
						for (const key in previousAttributes) {
							const oldAttribute = previousAttributes[key];

							if (!(key in attributes)) {
								delete instance.instance[oldAttribute.name];
							} else {
								if (attributes[key].value !== oldAttribute.value) {
									if (instance.instance.onAttributeChanged) {
										instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);
									}
								}
							}
						}
					}

					if (attributes) {
						scriptComponent.data.attributes[name] = this._cloneAttributes(attributes);
					} else {
						delete scriptComponent.data.attributes[name];
					}
				}

				break;
			}
		}
	}

	_convertAttributeValue(attribute) {
		if (attribute.type === 'rgb' || attribute.type === 'rgba') {
			if (Array.isArray(attribute.value)) {
				attribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
			}
		} else if (attribute.type === 'vec2') {
			if (Array.isArray(attribute.value)) attribute.value = new Vec2(attribute.value[0], attribute.value[1]);
		} else if (attribute.type === 'vec3' || attribute.type === 'vector') {
			if (Array.isArray(attribute.value)) attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);
		} else if (attribute.type === 'vec4') {
			if (Array.isArray(attribute.value)) attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
		} else if (attribute.type === 'entity') {
			if (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);
		} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
			const curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;
			attribute.value = new curveType(attribute.value.keys);
			attribute.value.type = attribute.value.type;
		}
	}

	destroy() {
		super.destroy();
		this.app.systems.off(INITIALIZE, this.onInitialize, this);
		this.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);
		this.app.systems.off(UPDATE, this.onUpdate, this);
		this.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);
		this.app.systems.off(POST_UPDATE, this.onPostUpdate, this);
		this.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);
	}

}

Component._buildAccessors(ScriptLegacyComponent.prototype, _schema$5);

const _inputScreenPosition = new Vec2();

const _inputWorldPosition = new Vec3();

const _rayOrigin = new Vec3();

const _rayDirection = new Vec3();

const _planeOrigin = new Vec3();

const _planeNormal = new Vec3();

const _entityRotation = new Quat();

const OPPOSITE_AXIS = {
	x: 'y',
	y: 'x'
};

class ElementDragHelper extends EventHandler {
	constructor(element, axis) {
		super();

		if (!element || !(element instanceof ElementComponent)) {
			throw new Error('Element was null or not an ElementComponent');
		}

		if (axis && axis !== 'x' && axis !== 'y') {
			throw new Error('Unrecognized axis: ' + axis);
		}

		this._element = element;
		this._app = element.system.app;
		this._axis = axis || null;
		this._enabled = true;
		this._dragScale = new Vec3();
		this._dragStartMousePosition = new Vec3();
		this._dragStartHandlePosition = new Vec3();
		this._deltaMousePosition = new Vec3();
		this._deltaHandlePosition = new Vec3();
		this._isDragging = false;

		this._toggleLifecycleListeners('on');
	}

	_toggleLifecycleListeners(onOrOff) {
		this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);

		this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
	}

	_toggleDragListeners(onOrOff) {
		const isOn = onOrOff === 'on';
		const addOrRemoveEventListener = isOn ? 'addEventListener' : 'removeEventListener';

		if (this._hasDragListeners && isOn) {
			return;
		}

		if (!this._handleMouseUpOrTouchEnd) {
			this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);
		}

		if (this._app.mouse) {
			this._app.mouse[onOrOff]('mousemove', this._onMove, this);

			window[addOrRemoveEventListener]('mouseup', this._handleMouseUpOrTouchEnd, false);
		}

		if (platform.touch) {
			this._app.touch[onOrOff]('touchmove', this._onMove, this);

			window[addOrRemoveEventListener]('touchend', this._handleMouseUpOrTouchEnd, false);
			window[addOrRemoveEventListener]('touchcancel', this._handleMouseUpOrTouchEnd, false);
		}

		this._hasDragListeners = isOn;
	}

	_onMouseDownOrTouchStart(event) {
		if (this._element && !this._isDragging && this.enabled) {
			this._dragCamera = event.camera;

			this._calculateDragScale();

			const currentMousePosition = this._screenToLocal(event);

			if (currentMousePosition) {
				this._toggleDragListeners('on');

				this._isDragging = true;

				this._dragStartMousePosition.copy(currentMousePosition);

				this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());

				this.fire('drag:start');
			}
		}
	}

	_onMouseUpOrTouchEnd() {
		if (this._isDragging) {
			this._isDragging = false;

			this._toggleDragListeners('off');

			this.fire('drag:end');
		}
	}

	_screenToLocal(event) {
		this._determineInputPosition(event);

		this._chooseRayOriginAndDirection();

		_planeOrigin.copy(this._element.entity.getPosition());

		_planeNormal.copy(this._element.entity.forward).mulScalar(-1);

		const denominator = _planeNormal.dot(_rayDirection);

		if (Math.abs(denominator) > 0) {
			const rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);

			const collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;

			const position = _rayOrigin.add(_rayDirection.mulScalar(collisionDistance));

			_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);

			position.mul(this._dragScale);
			return position;
		}

		return null;
	}

	_determineInputPosition(event) {
		const devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;

		if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
			_inputScreenPosition.x = event.x * devicePixelRatio;
			_inputScreenPosition.y = event.y * devicePixelRatio;
		} else if (event.changedTouches) {
			_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
			_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
		} else {
			console.warn('Could not determine position from input event');
		}
	}

	_chooseRayOriginAndDirection() {
		if (this._element.screen && this._element.screen.screen.screenSpace) {
			_rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);

			_rayDirection.set(0, 0, -1);
		} else {
			_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));

			_rayOrigin.copy(this._dragCamera.entity.getPosition());

			_rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();
		}
	}

	_calculateDragScale() {
		let current = this._element.entity.parent;
		const screen = this._element.screen && this._element.screen.screen;
		const isWithin2DScreen = screen && screen.screenSpace;
		const screenScale = isWithin2DScreen ? screen.scale : 1;
		const dragScale = this._dragScale;
		dragScale.set(screenScale, screenScale, screenScale);

		while (current) {
			dragScale.mul(current.getLocalScale());
			current = current.parent;

			if (isWithin2DScreen && current.screen) {
				break;
			}
		}

		dragScale.x = 1 / dragScale.x;
		dragScale.y = 1 / dragScale.y;
		dragScale.z = 1 / dragScale.z;
	}

	_onMove(event) {
		if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {
			const currentMousePosition = this._screenToLocal(event);

			if (this._dragStartMousePosition && currentMousePosition) {
				this._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);

				this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);

				if (this._axis) {
					const currentPosition = this._element.entity.getLocalPosition();

					const constrainedAxis = OPPOSITE_AXIS[this._axis];
					this._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
				}

				this._element.entity.setLocalPosition(this._deltaHandlePosition);

				this.fire('drag:move', this._deltaHandlePosition);
			}
		}
	}

	destroy() {
		this._toggleLifecycleListeners('off');

		this._toggleDragListeners('off');
	}

	set enabled(value) {
		this._enabled = value;
	}

	get enabled() {
		return this._enabled;
	}

	get isDragging() {
		return this._isDragging;
	}

}

const SCROLL_MODE_CLAMP = 0;
const SCROLL_MODE_BOUNCE = 1;
const SCROLL_MODE_INFINITE = 2;
const SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
const SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;
const EVENT_MOUSEDOWN = "mousedown";
const EVENT_MOUSEMOVE = "mousemove";
const EVENT_MOUSEUP = "mouseup";
const EVENT_MOUSEWHEEL = "mousewheel";
const EVENT_TOUCHSTART = 'touchstart';
const EVENT_TOUCHEND = 'touchend';
const EVENT_TOUCHMOVE = 'touchmove';
const EVENT_TOUCHCANCEL = 'touchcancel';
const MOUSEBUTTON_NONE = -1;
const MOUSEBUTTON_LEFT = 0;

const _tempScrollValue = new Vec2();

class ScrollViewComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._viewportReference = new EntityReference(this, 'viewportEntity', {
			'element#gain': this._onViewportElementGain,
			'element#resize': this._onSetContentOrViewportSize
		});
		this._contentReference = new EntityReference(this, 'contentEntity', {
			'element#gain': this._onContentElementGain,
			'element#lose': this._onContentElementLose,
			'element#resize': this._onSetContentOrViewportSize
		});
		this._scrollbarUpdateFlags = {};
		this._scrollbarReferences = {};
		this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(this, 'horizontalScrollbarEntity', {
			'scrollbar#set:value': this._onSetHorizontalScrollbarValue,
			'scrollbar#gain': this._onHorizontalScrollbarGain
		});
		this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(this, 'verticalScrollbarEntity', {
			'scrollbar#set:value': this._onSetVerticalScrollbarValue,
			'scrollbar#gain': this._onVerticalScrollbarGain
		});
		this._prevContentSizes = {};
		this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
		this._prevContentSizes[ORIENTATION_VERTICAL] = null;
		this._scroll = new Vec2();
		this._velocity = new Vec3();
		this._dragStartPosition = new Vec3();
		this._disabledContentInput = false;
		this._disabledContentInputEntities = [];

		this._toggleLifecycleListeners('on', system);

		this._toggleElementListeners('on');
	}

	_toggleLifecycleListeners(onOrOff, system) {
		this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
		this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
		system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
		system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
	}

	_toggleElementListeners(onOrOff) {
		if (this.entity.element) {
			if (onOrOff === 'on' && this._hasElementListeners) {
				return;
			}

			this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);
			this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
			this._hasElementListeners = onOrOff === 'on';
		}
	}

	_onElementComponentAdd(entity) {
		if (this.entity === entity) {
			this._toggleElementListeners('on');
		}
	}

	_onElementComponentRemove(entity) {
		if (this.entity === entity) {
			this._toggleElementListeners('off');
		}
	}

	_onViewportElementGain() {
		this._syncAll();
	}

	_onContentElementGain() {
		this._destroyDragHelper();

		this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);

		this._contentDragHelper.on('drag:start', this._onContentDragStart, this);

		this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);

		this._contentDragHelper.on('drag:move', this._onContentDragMove, this);

		this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
		this._prevContentSizes[ORIENTATION_VERTICAL] = null;

		this._syncAll();
	}

	_onContentElementLose() {
		this._destroyDragHelper();
	}

	_onContentDragStart() {
		if (this._contentReference.entity && this.enabled && this.entity.enabled) {
			this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
		}
	}

	_onContentDragEnd() {
		this._prevContentDragPosition = null;

		this._enableContentInput();
	}

	_onContentDragMove(position) {
		if (this._contentReference.entity && this.enabled && this.entity.enabled) {
			this._wasDragged = true;

			this._setScrollFromContentPosition(position);

			this._setVelocityFromContentPositionDelta(position);

			if (!this._disabledContentInput) {
				const dx = position.x - this._dragStartPosition.x;
				const dy = position.y - this._dragStartPosition.y;

				if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
					this._disableContentInput();
				}
			}
		}
	}

	_onSetContentOrViewportSize() {
		this._syncAll();
	}

	_onSetHorizontalScrollbarValue(scrollValueX) {
		if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
			this._onSetScroll(scrollValueX, null);
		}
	}

	_onSetVerticalScrollbarValue(scrollValueY) {
		if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
			this._onSetScroll(null, scrollValueY);
		}
	}

	_onSetHorizontalScrollingEnabled() {
		this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
	}

	_onSetVerticalScrollingEnabled() {
		this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
	}

	_onHorizontalScrollbarGain() {
		this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

		this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
	}

	_onVerticalScrollbarGain() {
		this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);

		this._syncScrollbarPosition(ORIENTATION_VERTICAL);
	}

	_onSetScroll(x, y, resetVelocity) {
		if (resetVelocity !== false) {
			this._velocity.set(0, 0, 0);
		}

		let hasChanged = false;
		hasChanged |= this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
		hasChanged |= this._updateAxis(y, 'y', ORIENTATION_VERTICAL);

		if (hasChanged) {
			this.fire('set:scroll', this._scroll);
		}
	}

	_updateAxis(scrollValue, axis, orientation) {
		const hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;

		if (hasChanged || this._isDragging() || scrollValue === 0) {
			this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);

			this._syncContentPosition(orientation);

			this._syncScrollbarPosition(orientation);
		}

		return hasChanged;
	}

	_determineNewScrollValue(scrollValue, axis, orientation) {
		if (!this._getScrollingEnabled(orientation)) {
			return this._scroll[axis];
		}

		switch (this.scrollMode) {
			case SCROLL_MODE_CLAMP:
				return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));

			case SCROLL_MODE_BOUNCE:
				this._setVelocityFromOvershoot(scrollValue, axis, orientation);

				return scrollValue;

			case SCROLL_MODE_INFINITE:
				return scrollValue;

			default:
				console.warn('Unhandled scroll mode:' + this.scrollMode);
				return scrollValue;
		}
	}

	_syncAll() {
		this._syncContentPosition(ORIENTATION_HORIZONTAL);

		this._syncContentPosition(ORIENTATION_VERTICAL);

		this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);

		this._syncScrollbarPosition(ORIENTATION_VERTICAL);

		this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

		this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
	}

	_syncContentPosition(orientation) {
		const axis = this._getAxis(orientation);

		const sign = this._getSign(orientation);

		const contentEntity = this._contentReference.entity;

		if (contentEntity) {
			const prevContentSize = this._prevContentSizes[orientation];

			const currContentSize = this._getContentSize(orientation);

			if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
				const prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);

				const currMaxOffset = this._getMaxOffset(orientation, currContentSize);

				if (currMaxOffset === 0) {
					this._scroll[axis] = 1;
				} else {
					this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
				}
			}

			const offset = this._scroll[axis] * this._getMaxOffset(orientation);

			const contentPosition = contentEntity.getLocalPosition();
			contentPosition[axis] = offset * sign;
			contentEntity.setLocalPosition(contentPosition);
			this._prevContentSizes[orientation] = currContentSize;
		}
	}

	_syncScrollbarPosition(orientation) {
		const axis = this._getAxis(orientation);

		const scrollbarEntity = this._scrollbarReferences[orientation].entity;

		if (scrollbarEntity && scrollbarEntity.scrollbar) {
			this._scrollbarUpdateFlags[orientation] = true;
			scrollbarEntity.scrollbar.value = this._scroll[axis];
			scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
			this._scrollbarUpdateFlags[orientation] = false;
		}
	}

	_syncScrollbarEnabledState(orientation) {
		const entity = this._scrollbarReferences[orientation].entity;

		if (entity) {
			const isScrollingEnabled = this._getScrollingEnabled(orientation);

			const requestedVisibility = this._getScrollbarVisibility(orientation);

			switch (requestedVisibility) {
				case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
					entity.enabled = isScrollingEnabled;
					return;

				case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
					entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
					return;

				default:
					console.warn('Unhandled scrollbar visibility:' + requestedVisibility);
					entity.enabled = isScrollingEnabled;
			}
		}
	}

	_contentIsLargerThanViewport(orientation) {
		return this._getContentSize(orientation) > this._getViewportSize(orientation);
	}

	_contentPositionToScrollValue(contentPosition) {
		const maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);

		const maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);

		if (maxOffsetH === 0) {
			_tempScrollValue.x = 0;
		} else {
			_tempScrollValue.x = contentPosition.x / maxOffsetH;
		}

		if (maxOffsetV === 0) {
			_tempScrollValue.y = 0;
		} else {
			_tempScrollValue.y = contentPosition.y / -maxOffsetV;
		}

		return _tempScrollValue;
	}

	_getMaxOffset(orientation, contentSize) {
		contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;

		const viewportSize = this._getViewportSize(orientation);

		if (contentSize < viewportSize) {
			return -this._getViewportSize(orientation);
		}

		return viewportSize - contentSize;
	}

	_getMaxScrollValue(orientation) {
		return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
	}

	_getScrollbarHandleSize(axis, orientation) {
		const viewportSize = this._getViewportSize(orientation);

		const contentSize = this._getContentSize(orientation);

		if (Math.abs(contentSize) < 0.001) {
			return 1;
		}

		const handleSize = Math.min(viewportSize / contentSize, 1);

		const overshoot = this._toOvershoot(this._scroll[axis], orientation);

		if (overshoot === 0) {
			return handleSize;
		}

		return handleSize / (1 + Math.abs(overshoot));
	}

	_getViewportSize(orientation) {
		return this._getSize(orientation, this._viewportReference);
	}

	_getContentSize(orientation) {
		return this._getSize(orientation, this._contentReference);
	}

	_getSize(orientation, entityReference) {
		if (entityReference.entity && entityReference.entity.element) {
			return entityReference.entity.element[this._getCalculatedDimension(orientation)];
		}

		return 0;
	}

	_getScrollingEnabled(orientation) {
		if (orientation === ORIENTATION_HORIZONTAL) {
			return this.horizontal;
		} else if (orientation === ORIENTATION_VERTICAL) {
			return this.vertical;
		}

		console.warn('Unrecognized orientation: ' + orientation);
	}

	_getScrollbarVisibility(orientation) {
		if (orientation === ORIENTATION_HORIZONTAL) {
			return this.horizontalScrollbarVisibility;
		} else if (orientation === ORIENTATION_VERTICAL) {
			return this.verticalScrollbarVisibility;
		}

		console.warn('Unrecognized orientation: ' + orientation);
	}

	_getSign(orientation) {
		return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
	}

	_getAxis(orientation) {
		return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
	}

	_getCalculatedDimension(orientation) {
		return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
	}

	_destroyDragHelper() {
		if (this._contentDragHelper) {
			this._contentDragHelper.destroy();
		}
	}

	onUpdate() {
		if (this._contentReference.entity) {
			this._updateVelocity();

			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		}
	}

	_updateVelocity() {
		if (!this._isDragging()) {
			if (this.scrollMode === SCROLL_MODE_BOUNCE) {
				if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
					this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
				}

				if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
					this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
				}
			}

			if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
				const position = this._contentReference.entity.getLocalPosition();

				position.x += this._velocity.x;
				position.y += this._velocity.y;

				this._contentReference.entity.setLocalPosition(position);

				this._setScrollFromContentPosition(position);
			}

			this._velocity.x *= 1 - this.friction;
			this._velocity.y *= 1 - this.friction;
		}
	}

	_hasOvershoot(axis, orientation) {
		return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
	}

	_toOvershoot(scrollValue, orientation) {
		const maxScrollValue = this._getMaxScrollValue(orientation);

		if (scrollValue < 0) {
			return scrollValue;
		} else if (scrollValue > maxScrollValue) {
			return scrollValue - maxScrollValue;
		}

		return 0;
	}

	_setVelocityFromOvershoot(scrollValue, axis, orientation) {
		const overshootValue = this._toOvershoot(scrollValue, orientation);

		const overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);

		if (Math.abs(overshootPixels) > 0) {
			this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
		}
	}

	_setVelocityFromContentPositionDelta(position) {
		if (this._prevContentDragPosition) {
			this._velocity.sub2(position, this._prevContentDragPosition);

			this._prevContentDragPosition.copy(position);
		} else {
			this._velocity.set(0, 0, 0);

			this._prevContentDragPosition = position.clone();
		}
	}

	_setScrollFromContentPosition(position) {
		let scrollValue = this._contentPositionToScrollValue(position);

		if (this._isDragging()) {
			scrollValue = this._applyScrollValueTension(scrollValue);
		}

		this._onSetScroll(scrollValue.x, scrollValue.y, false);
	}

	_applyScrollValueTension(scrollValue) {
		const factor = 1;

		let max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);

		let overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);

		if (overshoot > 0) {
			scrollValue.x = max + factor * Math.log10(1 + overshoot);
		} else if (overshoot < 0) {
			scrollValue.x = -factor * Math.log10(1 - overshoot);
		}

		max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
		overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);

		if (overshoot > 0) {
			scrollValue.y = max + factor * Math.log10(1 + overshoot);
		} else if (overshoot < 0) {
			scrollValue.y = -factor * Math.log10(1 - overshoot);
		}

		return scrollValue;
	}

	_isDragging() {
		return this._contentDragHelper && this._contentDragHelper.isDragging;
	}

	_setScrollbarComponentsEnabled(enabled) {
		if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
			this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
		}

		if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
			this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
		}
	}

	_setContentDraggingEnabled(enabled) {
		if (this._contentDragHelper) {
			this._contentDragHelper.enabled = enabled;
		}
	}

	_onMouseWheel(event) {
		if (this.useMouseWheel) {
			const wheelEvent = event.event;
			const normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;
			const normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;
			const scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
			const scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
			this.scroll = new Vec2(scrollX, scrollY);
		}
	}

	_enableContentInput() {
		while (this._disabledContentInputEntities.length) {
			const e = this._disabledContentInputEntities.pop();

			if (e.element) {
				e.element.useInput = true;
			}
		}

		this._disabledContentInput = false;
	}

	_disableContentInput() {
		const _disableInput = e => {
			if (e.element && e.element.useInput) {
				this._disabledContentInputEntities.push(e);

				e.element.useInput = false;
			}

			const children = e.children;

			for (let i = 0, l = children.length; i < l; i++) {
				_disableInput(children[i]);
			}
		};

		const contentEntity = this._contentReference.entity;

		if (contentEntity) {
			const children = contentEntity.children;

			for (let i = 0, l = children.length; i < l; i++) {
				_disableInput(children[i]);
			}
		}

		this._disabledContentInput = true;
	}

	onEnable() {
		this._viewportReference.onParentComponentEnable();

		this._contentReference.onParentComponentEnable();

		this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();

		this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();

		this._setScrollbarComponentsEnabled(true);

		this._setContentDraggingEnabled(true);

		this._syncAll();
	}

	onDisable() {
		this._setScrollbarComponentsEnabled(false);

		this._setContentDraggingEnabled(false);
	}

	onRemove() {
		this._toggleLifecycleListeners('off', this.system);

		this._toggleElementListeners('off');

		this._destroyDragHelper();
	}

	set scroll(value) {
		this._onSetScroll(value.x, value.y);
	}

	get scroll() {
		return this._scroll;
	}

}

class ScrollViewComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$4 = [{
	name: 'enabled',
	type: 'boolean'
}, {
	name: 'horizontal',
	type: 'boolean'
}, {
	name: 'vertical',
	type: 'boolean'
}, {
	name: 'scrollMode',
	type: 'number'
}, {
	name: 'bounceAmount',
	type: 'number'
}, {
	name: 'friction',
	type: 'number'
}, {
	name: 'dragThreshold',
	type: 'number'
}, {
	name: 'useMouseWheel',
	type: 'boolean'
}, {
	name: 'mouseWheelSensitivity',
	type: 'vec2'
}, {
	name: 'horizontalScrollbarVisibility',
	type: 'number'
}, {
	name: 'verticalScrollbarVisibility',
	type: 'number'
}, {
	name: 'viewportEntity',
	type: 'entity'
}, {
	name: 'contentEntity',
	type: 'entity'
}, {
	name: 'horizontalScrollbarEntity',
	type: 'entity'
}, {
	name: 'verticalScrollbarEntity',
	type: 'entity'
}];
const DEFAULT_DRAG_THRESHOLD = 10;

class ScrollViewComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'scrollview';
		this.ComponentType = ScrollViewComponent;
		this.DataType = ScrollViewComponentData;
		this.schema = _schema$4;
		this.on('beforeremove', this._onRemoveComponent, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		if (data.dragThreshold === undefined) {
			data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
		}

		if (data.useMouseWheel === undefined) {
			data.useMouseWheel = true;
		}

		if (data.mouseWheelSensitivity === undefined) {
			data.mouseWheelSensitivity = new Vec2(1, 1);
		}

		super.initializeComponentData(component, data, _schema$4);
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			const entity = components[id].entity;
			const component = entity.scrollview;

			if (component.enabled && entity.enabled) {
				component.onUpdate();
			}
		}
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(ScrollViewComponent.prototype, _schema$4);

class ScrollbarComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._app = system.app;
		this._handleReference = new EntityReference(this, 'handleEntity', {
			'element#gain': this._onHandleElementGain,
			'element#lose': this._onHandleElementLose,
			'element#set:anchor': this._onSetHandleAlignment,
			'element#set:margin': this._onSetHandleAlignment,
			'element#set:pivot': this._onSetHandleAlignment
		});

		this._toggleLifecycleListeners('on');
	}

	_toggleLifecycleListeners(onOrOff) {
		this[onOrOff]('set_value', this._onSetValue, this);
		this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
		this[onOrOff]('set_orientation', this._onSetOrientation, this);
	}

	_onHandleElementGain() {
		this._destroyDragHelper();

		this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());

		this._handleDragHelper.on('drag:move', this._onHandleDrag, this);

		this._updateHandlePositionAndSize();
	}

	_onHandleElementLose() {
		this._destroyDragHelper();
	}

	_onHandleDrag(position) {
		if (this._handleReference.entity && this.enabled && this.entity.enabled) {
			this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
		}
	}

	_onSetValue(name, oldValue, newValue) {
		if (Math.abs(newValue - oldValue) > 1e-5) {
			this.data.value = math.clamp(newValue, 0, 1);

			this._updateHandlePositionAndSize();

			this.fire('set:value', this.data.value);
		}
	}

	_onSetHandleSize(name, oldValue, newValue) {
		if (Math.abs(newValue - oldValue) > 1e-5) {
			this.data.handleSize = math.clamp(newValue, 0, 1);

			this._updateHandlePositionAndSize();
		}
	}

	_onSetHandleAlignment() {
		this._updateHandlePositionAndSize();
	}

	_onSetOrientation(name, oldValue, newValue) {
		if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
			this._handleReference.entity.element[this._getOppositeDimension()] = 0;
		}
	}

	_updateHandlePositionAndSize() {
		const handleEntity = this._handleReference.entity;
		const handleElement = handleEntity && handleEntity.element;

		if (handleEntity) {
			const position = handleEntity.getLocalPosition();
			position[this._getAxis()] = this._getHandlePosition();

			this._handleReference.entity.setLocalPosition(position);
		}

		if (handleElement) {
			handleElement[this._getDimension()] = this._getHandleLength();
		}
	}

	_handlePositionToScrollValue(handlePosition) {
		return handlePosition * this._getSign() / this._getUsableTrackLength();
	}

	_scrollValueToHandlePosition(value) {
		return value * this._getSign() * this._getUsableTrackLength();
	}

	_getUsableTrackLength() {
		return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
	}

	_getTrackLength() {
		if (this.entity.element) {
			return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
		}

		return 0;
	}

	_getHandleLength() {
		return this._getTrackLength() * this.handleSize;
	}

	_getHandlePosition() {
		return this._scrollValueToHandlePosition(this.value);
	}

	_getSign() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
	}

	_getAxis() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
	}

	_getDimension() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
	}

	_getOppositeDimension() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
	}

	_destroyDragHelper() {
		if (this._handleDragHelper) {
			this._handleDragHelper.destroy();
		}
	}

	_setHandleDraggingEnabled(enabled) {
		if (this._handleDragHelper) {
			this._handleDragHelper.enabled = enabled;
		}
	}

	onEnable() {
		this._handleReference.onParentComponentEnable();

		this._setHandleDraggingEnabled(true);
	}

	onDisable() {
		this._setHandleDraggingEnabled(false);
	}

	onRemove() {
		this._destroyDragHelper();

		this._toggleLifecycleListeners('off');
	}

}

class ScrollbarComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$3 = [{
	name: 'enabled',
	type: 'boolean'
}, {
	name: 'orientation',
	type: 'number'
}, {
	name: 'value',
	type: 'number'
}, {
	name: 'handleSize',
	type: 'number'
}, {
	name: 'handleEntity',
	type: 'entity'
}];

class ScrollbarComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'scrollbar';
		this.ComponentType = ScrollbarComponent;
		this.DataType = ScrollbarComponentData;
		this.schema = _schema$3;
		this.on('beforeremove', this._onRemoveComponent, this);
	}

	initializeComponentData(component, data, properties) {
		super.initializeComponentData(component, data, _schema$3);
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

}

Component._buildAccessors(ScrollbarComponent.prototype, _schema$3);

const STATE_PLAYING = 0;
const STATE_PAUSED = 1;
const STATE_STOPPED = 2;

function capTime(time, duration) {
	return time % duration || 0;
}

class SoundInstance extends EventHandler {
	constructor(manager, sound, options) {
		super();
		this._manager = manager;
		this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
		this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
		this._loop = !!(options.loop !== undefined ? options.loop : false);
		this._sound = sound;
		this._state = STATE_STOPPED;
		this._suspended = false;
		this._suspendEndEvent = false;
		this._suspendInstanceEvents = false;
		this._playWhenLoaded = true;
		this._startTime = Math.max(0, Number(options.startTime) || 0);
		this._duration = Math.max(0, Number(options.duration) || 0);
		this._startOffset = null;
		this.source = null;
		this._onPlayCallback = options.onPlay;
		this._onPauseCallback = options.onPause;
		this._onResumeCallback = options.onResume;
		this._onStopCallback = options.onStop;
		this._onEndCallback = options.onEnd;

		if (hasAudioContext()) {
			this._startedAt = 0;
			this._currentTime = 0;
			this._currentOffset = 0;
			this._inputNode = null;
			this._connectorNode = null;
			this._firstNode = null;
			this._lastNode = null;

			this._initializeNodes();

			this._endedHandler = this._onEnded.bind(this);
		} else {
			this._isReady = false;
			this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
			this._timeUpdateHandler = this._onTimeUpdate.bind(this);
			this._endedHandler = this._onEnded.bind(this);

			this._createSource();
		}
	}

	set duration(value) {
		this._duration = Math.max(0, Number(value) || 0);
		const isPlaying = this._state === STATE_PLAYING;
		this.stop();

		if (isPlaying) {
			this.play();
		}
	}

	get duration() {
		if (!this._sound) {
			return 0;
		}

		if (this._duration) {
			return capTime(this._duration, this._sound.duration);
		}

		return this._sound.duration;
	}

	get isPaused() {
		return this._state === STATE_PAUSED;
	}

	get isPlaying() {
		return this._state === STATE_PLAYING;
	}

	get isStopped() {
		return this._state === STATE_STOPPED;
	}

	get isSuspended() {
		return this._suspended;
	}

	set loop(value) {
		this._loop = !!value;

		if (this.source) {
			this.source.loop = this._loop;
		}
	}

	get loop() {
		return this._loop;
	}

	set startTime(value) {
		this._startTime = Math.max(0, Number(value) || 0);
		const isPlaying = this._state === STATE_PLAYING;
		this.stop();

		if (isPlaying) {
			this.play();
		}
	}

	get startTime() {
		return this._startTime;
	}

	_onPlay() {
		this.fire('play');
		if (this._onPlayCallback) this._onPlayCallback(this);
	}

	_onPause() {
		this.fire('pause');
		if (this._onPauseCallback) this._onPauseCallback(this);
	}

	_onResume() {
		this.fire('resume');
		if (this._onResumeCallback) this._onResumeCallback(this);
	}

	_onStop() {
		this.fire('stop');
		if (this._onStopCallback) this._onStopCallback(this);
	}

	_onEnded() {
		if (this._suspendEndEvent) {
			this._suspendEndEvent = false;
			return;
		}

		this.fire('end');
		if (this._onEndCallback) this._onEndCallback(this);
		this.stop();
	}

	_onManagerVolumeChange() {
		this.volume = this._volume;
	}

	_onManagerSuspend() {
		if (this._state === STATE_PLAYING && !this._suspended) {
			this._suspended = true;
			this.pause();
		}
	}

	_onManagerResume() {
		if (this._suspended) {
			this._suspended = false;
			this.resume();
		}
	}

}

if (hasAudioContext()) {
	Object.assign(SoundInstance.prototype, {
		_initializeNodes: function () {
			this.gain = this._manager.context.createGain();
			this._inputNode = this.gain;
			this._connectorNode = this.gain;

			this._connectorNode.connect(this._manager.context.destination);
		},
		play: function () {
			if (this._state !== STATE_STOPPED) {
				this.stop();
			}

			if (!this.source) {
				this._createSource();
			}

			let offset = capTime(this._startOffset, this.duration);
			offset = capTime(this._startTime + offset, this._sound.duration);
			this._startOffset = null;

			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}

			this._startedAt = this._manager.context.currentTime;
			this._currentTime = 0;
			this._currentOffset = offset;
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;

			this._manager.on('volumechange', this._onManagerVolumeChange, this);

			this._manager.on('suspend', this._onManagerSuspend, this);

			this._manager.on('resume', this._onManagerResume, this);

			this._manager.on('destroy', this._onManagerDestroy, this);

			if (this._manager.suspended) {
				this._onManagerSuspend();
			}

			if (!this._suspendInstanceEvents) this._onPlay();
			return true;
		},
		pause: function () {
			this._playWhenLoaded = false;
			if (this._state !== STATE_PLAYING || !this.source) return false;

			this._updateCurrentTime();

			this._state = STATE_PAUSED;
			this._suspendEndEvent = true;
			this.source.stop(0);
			this.source = null;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) this._onPause();
			return true;
		},
		resume: function () {
			if (this._state !== STATE_PAUSED) {
				return false;
			}

			if (!this.source) {
				this._createSource();
			}

			let offset = this.currentTime;

			if (this._startOffset !== null) {
				offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
			}

			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}

			this._state = STATE_PLAYING;
			this._startedAt = this._manager.context.currentTime;
			this._currentOffset = offset;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;
			this._playWhenLoaded = false;
			if (!this._suspendInstanceEvents) this._onResume();
			return true;
		},
		stop: function () {
			this._playWhenLoaded = false;
			if (this._state === STATE_STOPPED || !this.source) return false;

			this._manager.off('volumechange', this._onManagerVolumeChange, this);

			this._manager.off('suspend', this._onManagerSuspend, this);

			this._manager.off('resume', this._onManagerResume, this);

			this._manager.off('destroy', this._onManagerDestroy, this);

			this._startedAt = 0;
			this._currentTime = 0;
			this._currentOffset = 0;
			this._startOffset = null;
			this._suspendEndEvent = true;

			if (this._state === STATE_PLAYING) {
				this.source.stop(0);
			}

			this.source = null;
			this._state = STATE_STOPPED;
			if (!this._suspendInstanceEvents) this._onStop();
			return true;
		},
		setExternalNodes: function (firstNode, lastNode) {
			if (!firstNode) {
				console.error('The firstNode must be a valid Audio Node');
				return;
			}

			if (!lastNode) {
				lastNode = firstNode;
			}

			const speakers = this._manager.context.destination;

			if (this._firstNode !== firstNode) {
				if (this._firstNode) {
					this._connectorNode.disconnect(this._firstNode);
				} else {
					this._connectorNode.disconnect(speakers);
				}

				this._firstNode = firstNode;

				this._connectorNode.connect(firstNode);
			}

			if (this._lastNode !== lastNode) {
				if (this._lastNode) {
					this._lastNode.disconnect(speakers);
				}

				this._lastNode = lastNode;

				this._lastNode.connect(speakers);
			}
		},
		clearExternalNodes: function () {
			const speakers = this._manager.context.destination;

			if (this._firstNode) {
				this._connectorNode.disconnect(this._firstNode);

				this._firstNode = null;
			}

			if (this._lastNode) {
				this._lastNode.disconnect(speakers);

				this._lastNode = null;
			}

			this._connectorNode.connect(speakers);
		},
		getExternalNodes: function () {
			return [this._firstNode, this._lastNode];
		},
		_createSource: function () {
			if (!this._sound) {
				return null;
			}

			const context = this._manager.context;

			if (this._sound.buffer) {
				this.source = context.createBufferSource();
				this.source.buffer = this._sound.buffer;
				this.source.connect(this._inputNode);
				this.source.onended = this._endedHandler;
				this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);

				if (this._duration) {
					this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
				}
			}

			return this.source;
		},
		_updateCurrentTime: function () {
			this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
		},
		_onManagerDestroy: function () {
			if (this.source && this._state === STATE_PLAYING) {
				this.source.stop(0);
				this.source = null;
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'volume', {
		get: function () {
			return this._volume;
		},
		set: function (volume) {
			volume = math.clamp(volume, 0, 1);
			this._volume = volume;

			if (this.gain) {
				this.gain.gain.value = volume * this._manager.volume;
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'pitch', {
		get: function () {
			return this._pitch;
		},
		set: function (pitch) {
			this._currentOffset = this.currentTime;
			this._startedAt = this._manager.context.currentTime;
			this._pitch = Math.max(Number(pitch) || 0, 0.01);

			if (this.source) {
				this.source.playbackRate.value = this._pitch;
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'sound', {
		get: function () {
			return this._sound;
		},
		set: function (value) {
			this._sound = value;

			if (this._state !== STATE_STOPPED) {
				this.stop();
			} else {
				this._createSource();
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'currentTime', {
		get: function () {
			if (this._startOffset !== null) {
				return this._startOffset;
			}

			if (this._state === STATE_PAUSED) {
				return this._currentTime;
			}

			if (this._state === STATE_STOPPED || !this.source) {
				return 0;
			}

			this._updateCurrentTime();

			return this._currentTime;
		},
		set: function (value) {
			if (value < 0) return;

			if (this._state === STATE_PLAYING) {
				const suspend = this._suspendInstanceEvents;
				this._suspendInstanceEvents = true;
				this.stop();
				this._startOffset = value;
				this.play();
				this._suspendInstanceEvents = suspend;
			} else {
				this._startOffset = value;
				this._currentTime = value;
			}
		}
	});
} else {
	Object.assign(SoundInstance.prototype, {
		play: function () {
			if (this._state !== STATE_STOPPED) {
				this.stop();
			}

			if (!this.source) {
				if (!this._createSource()) {
					return false;
				}
			}

			this.volume = this._volume;
			this.pitch = this._pitch;
			this.loop = this._loop;
			this.source.play();
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;

			this._manager.on('volumechange', this._onManagerVolumeChange, this);

			this._manager.on('suspend', this._onManagerSuspend, this);

			this._manager.on('resume', this._onManagerResume, this);

			this._manager.on('destroy', this._onManagerDestroy, this);

			if (this._manager.suspended) this._onManagerSuspend();
			if (!this._suspendInstanceEvents) this._onPlay();
			return true;
		},
		pause: function () {
			if (!this.source || this._state !== STATE_PLAYING) return false;
			this._suspendEndEvent = true;
			this.source.pause();
			this._playWhenLoaded = false;
			this._state = STATE_PAUSED;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) this._onPause();
			return true;
		},
		resume: function () {
			if (!this.source || this._state !== STATE_PAUSED) return false;
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;

			if (this.source.paused) {
				this.source.play();
				if (!this._suspendInstanceEvents) this._onResume();
			}

			return true;
		},
		stop: function () {
			if (!this.source || this._state === STATE_STOPPED) return false;

			this._manager.off('volumechange', this._onManagerVolumeChange, this);

			this._manager.off('suspend', this._onManagerSuspend, this);

			this._manager.off('resume', this._onManagerResume, this);

			this._manager.off('destroy', this._onManagerDestroy, this);

			this._suspendEndEvent = true;
			this.source.pause();
			this._playWhenLoaded = false;
			this._state = STATE_STOPPED;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) this._onStop();
			return true;
		},
		setExternalNodes: function () {},
		clearExternalNodes: function () {},
		getExternalNodes: function () {
			return [null, null];
		},
		_onLoadedMetadata: function () {
			this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
			this._isReady = true;
			let offset = capTime(this._startOffset, this.duration);
			offset = capTime(this._startTime + offset, this._sound.duration);
			this._startOffset = null;
			this.source.currentTime = offset;
		},
		_createSource: function () {
			if (this._sound && this._sound.audio) {
				this._isReady = false;
				this.source = this._sound.audio.cloneNode(true);
				this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
				this.source.addEventListener('timeupdate', this._timeUpdateHandler);
				this.source.onended = this._endedHandler;
			}

			return this.source;
		},
		_onTimeUpdate: function () {
			if (!this._duration) return;

			if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
				if (this.loop) {
					this.source.currentTime = capTime(this._startTime, this.source.duration);
				} else {
					this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
					this.source.pause();

					this._onEnded();
				}
			}
		},
		_onManagerDestroy: function () {
			if (this.source) {
				this.source.pause();
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'volume', {
		get: function () {
			return this._volume;
		},
		set: function (volume) {
			volume = math.clamp(volume, 0, 1);
			this._volume = volume;

			if (this.source) {
				this.source.volume = volume * this._manager.volume;
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'pitch', {
		get: function () {
			return this._pitch;
		},
		set: function (pitch) {
			this._pitch = Math.max(Number(pitch) || 0, 0.01);

			if (this.source) {
				this.source.playbackRate = this._pitch;
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'sound', {
		get: function () {
			return this._sound;
		},
		set: function (value) {
			this.stop();
			this._sound = value;
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'currentTime', {
		get: function () {
			if (this._startOffset !== null) {
				return this._startOffset;
			}

			if (this._state === STATE_STOPPED || !this.source) {
				return 0;
			}

			return this.source.currentTime - this._startTime;
		},
		set: function (value) {
			if (value < 0) return;
			this._startOffset = value;

			if (this.source && this._isReady) {
				this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
				this._startOffset = null;
			}
		}
	});
}

const MAX_DISTANCE = 10000;

class SoundInstance3d extends SoundInstance {
	constructor(manager, sound, options) {
		super(manager, sound, options);
		options = options || {};
		this._position = new Vec3();
		if (options.position) this.position = options.position;
		this._velocity = new Vec3();
		if (options.velocity) this.velocity = options.velocity;
		this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
		this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
		this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
		this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
	}

}

if (hasAudioContext()) {
	Object.assign(SoundInstance3d.prototype, {
		_initializeNodes: function () {
			this.gain = this._manager.context.createGain();
			this.panner = this._manager.context.createPanner();
			this.panner.connect(this.gain);
			this._inputNode = this.panner;
			this._connectorNode = this.gain;

			this._connectorNode.connect(this._manager.context.destination);
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'position', {
		get: function () {
			return this._position;
		},
		set: function (position) {
			this._position.copy(position);

			this.panner.setPosition(position.x, position.y, position.z);
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'velocity', {
		get: function () {
			return this._velocity;
		},
		set: function (velocity) {
			this._velocity.copy(velocity);

			this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
		get: function () {
			return this.panner.maxDistance;
		},
		set: function (value) {
			this.panner.maxDistance = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
		get: function () {
			return this.panner.refDistance;
		},
		set: function (value) {
			this.panner.refDistance = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
		get: function () {
			return this.panner.rolloffFactor;
		},
		set: function (value) {
			this.panner.rolloffFactor = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
		get: function () {
			return this.panner.distanceModel;
		},
		set: function (value) {
			this.panner.distanceModel = value;
		}
	});
} else {
	let offset = new Vec3();

	const fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
		offset = offset.sub2(posOne, posTwo);
		const distance = offset.length();

		if (distance < refDistance) {
			return 1;
		} else if (distance > maxDistance) {
			return 0;
		}

		let result = 0;

		if (distanceModel === DISTANCE_LINEAR) {
			result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
		} else if (distanceModel === DISTANCE_INVERSE) {
			result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
		} else if (distanceModel === DISTANCE_EXPONENTIAL) {
			result = Math.pow(distance / refDistance, -rollOffFactor);
		}

		return math.clamp(result, 0, 1);
	};

	Object.defineProperty(SoundInstance3d.prototype, 'position', {
		get: function () {
			return this._position;
		},
		set: function (position) {
			this._position.copy(position);

			if (this.source) {
				const listener = this._manager.listener;
				const lpos = listener.getPosition();
				const factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
				const v = this.volume;
				this.source.volume = v * factor * this._manager.volume;
			}
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'velocity', {
		get: function () {
			return this._velocity;
		},
		set: function (velocity) {
			this._velocity.copy(velocity);
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
		get: function () {
			return this._maxDistance;
		},
		set: function (value) {
			this._maxDistance = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
		get: function () {
			return this._refDistance;
		},
		set: function (value) {
			this._refDistance = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
		get: function () {
			return this._rollOffFactor;
		},
		set: function (value) {
			this._rollOffFactor = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
		get: function () {
			return this._distanceModel;
		},
		set: function (value) {
			this._distanceModel = value;
		}
	});
}

const instanceOptions = {
	volume: 0,
	pitch: 0,
	loop: false,
	startTime: 0,
	duration: 0,
	position: new Vec3(),
	maxDistance: 0,
	refDistance: 0,
	rollOffFactor: 0,
	distanceModel: 0,
	onPlay: null,
	onPause: null,
	onResume: null,
	onStop: null,
	onEnd: null
};

class SoundSlot extends EventHandler {
	constructor(component, name = 'Untitled', options = {}) {
		super();
		this.name = void 0;
		this.instances = [];
		this._component = component;
		this._assets = component.system.app.assets;
		this._manager = component.system.manager;
		this.name = name;
		this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
		this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
		this._loop = !!(options.loop !== undefined ? options.loop : false);
		this._duration = options.duration > 0 ? options.duration : null;
		this._startTime = Math.max(0, Number(options.startTime) || 0);
		this._overlap = !!options.overlap;
		this._autoPlay = !!options.autoPlay;
		this._firstNode = null;
		this._lastNode = null;
		this._asset = options.asset;

		if (this._asset instanceof Asset) {
			this._asset = this._asset.id;
		}

		this._onInstancePlayHandler = this._onInstancePlay.bind(this);
		this._onInstancePauseHandler = this._onInstancePause.bind(this);
		this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
		this._onInstanceStopHandler = this._onInstanceStop.bind(this);
		this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
	}

	play() {
		if (!this.overlap) {
			this.stop();
		}

		if (!this.isLoaded && !this._hasAsset()) {
			return;
		}

		const instance = this._createInstance();

		this.instances.push(instance);

		if (!this.isLoaded) {
			const onLoad = function onLoad(sound) {
				const playWhenLoaded = instance._playWhenLoaded;
				instance.sound = sound;

				if (playWhenLoaded) {
					instance.play();
				}
			};

			this.off('load', onLoad);
			this.once('load', onLoad);
			this.load();
		} else {
			instance.play();
		}

		return instance;
	}

	pause() {
		let paused = false;
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (instances[i].pause()) {
				paused = true;
			}
		}

		return paused;
	}

	resume() {
		let resumed = false;
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (instances[i].resume()) resumed = true;
		}

		return resumed;
	}

	stop() {
		let stopped = false;
		const instances = this.instances;
		let i = instances.length;

		while (i--) {
			instances[i].stop();
			stopped = true;
		}

		instances.length = 0;
		return stopped;
	}

	load() {
		if (!this._hasAsset()) return;

		const asset = this._assets.get(this._asset);

		if (!asset) {
			this._assets.off('add:' + this._asset, this._onAssetAdd, this);

			this._assets.once('add:' + this._asset, this._onAssetAdd, this);

			return;
		}

		asset.off('remove', this._onAssetRemoved, this);
		asset.on('remove', this._onAssetRemoved, this);

		if (!asset.resource) {
			asset.off('load', this._onAssetLoad, this);
			asset.once('load', this._onAssetLoad, this);

			this._assets.load(asset);

			return;
		}

		this.fire('load', asset.resource);
	}

	setExternalNodes(firstNode, lastNode) {
		if (!firstNode) {
			console.error('The firstNode must have a valid AudioNode');
			return;
		}

		if (!lastNode) {
			lastNode = firstNode;
		}

		this._firstNode = firstNode;
		this._lastNode = lastNode;

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].setExternalNodes(firstNode, lastNode);
			}
		}
	}

	clearExternalNodes() {
		this._firstNode = null;
		this._lastNode = null;

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].clearExternalNodes();
			}
		}
	}

	getExternalNodes() {
		return [this._firstNode, this._lastNode];
	}

	_hasAsset() {
		return this._asset != null;
	}

	_createInstance() {
		let instance = null;
		const component = this._component;
		let sound = null;

		if (this._hasAsset()) {
			const asset = this._assets.get(this._asset);

			if (asset) {
				sound = asset.resource;
			}
		}

		const data = instanceOptions;
		data.volume = this._volume * component.volume;
		data.pitch = this._pitch * component.pitch;
		data.loop = this._loop;
		data.startTime = this._startTime;
		data.duration = this._duration;
		data.onPlay = this._onInstancePlayHandler;
		data.onPause = this._onInstancePauseHandler;
		data.onResume = this._onInstanceResumeHandler;
		data.onStop = this._onInstanceStopHandler;
		data.onEnd = this._onInstanceEndHandler;

		if (component.positional) {
			data.position.copy(component.entity.getPosition());
			data.maxDistance = component.maxDistance;
			data.refDistance = component.refDistance;
			data.rollOffFactor = component.rollOffFactor;
			data.distanceModel = component.distanceModel;
			instance = new SoundInstance3d(this._manager, sound, data);
		} else {
			instance = new SoundInstance(this._manager, sound, data);
		}

		if (this._firstNode) {
			instance.setExternalNodes(this._firstNode, this._lastNode);
		}

		return instance;
	}

	_onInstancePlay(instance) {
		this.fire('play', instance);

		this._component.fire('play', this, instance);
	}

	_onInstancePause(instance) {
		this.fire('pause', instance);

		this._component.fire('pause', this, instance);
	}

	_onInstanceResume(instance) {
		this.fire('resume', instance);

		this._component.fire('resume', this, instance);
	}

	_onInstanceStop(instance) {
		const idx = this.instances.indexOf(instance);

		if (idx !== -1) {
			this.instances.splice(idx, 1);
		}

		this.fire('stop', instance);

		this._component.fire('stop', this, instance);
	}

	_onInstanceEnd(instance) {
		const idx = this.instances.indexOf(instance);

		if (idx !== -1) {
			this.instances.splice(idx, 1);
		}

		this.fire('end', instance);

		this._component.fire('end', this, instance);
	}

	_onAssetAdd(asset) {
		this.load();
	}

	_onAssetLoad(asset) {
		this.load();
	}

	_onAssetRemoved(asset) {
		asset.off('remove', this._onAssetRemoved, this);

		this._assets.off('add:' + asset.id, this._onAssetAdd, this);

		this.stop();
	}

	updatePosition(position) {
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			instances[i].position = position;
		}
	}

	set asset(value) {
		const old = this._asset;

		if (old) {
			this._assets.off('add:' + old, this._onAssetAdd, this);

			const oldAsset = this._assets.get(old);

			if (oldAsset) {
				oldAsset.off('remove', this._onAssetRemoved, this);
			}
		}

		this._asset = value;

		if (this._asset instanceof Asset) {
			this._asset = this._asset.id;
		}

		if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
			this.load();
		}
	}

	get asset() {
		return this._asset;
	}

	set autoPlay(value) {
		this._autoPlay = !!value;
	}

	get autoPlay() {
		return this._autoPlay;
	}

	set duration(value) {
		this._duration = Math.max(0, Number(value) || 0) || null;

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].duration = this._duration;
			}
		}
	}

	get duration() {
		let assetDuration = 0;

		if (this._hasAsset()) {
			const asset = this._assets.get(this._asset);

			assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;
		}

		if (this._duration != null) {
			return this._duration % (assetDuration || 1);
		}

		return assetDuration;
	}

	get isLoaded() {
		if (this._hasAsset()) {
			const asset = this._assets.get(this._asset);

			if (asset) {
				return !!asset.resource;
			}
		}

		return false;
	}

	get isPaused() {
		const instances = this.instances;
		const len = instances.length;
		if (len === 0) return false;

		for (let i = 0; i < len; i++) {
			if (!instances[i].isPaused) return false;
		}

		return true;
	}

	get isPlaying() {
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (instances[i].isPlaying) return true;
		}

		return false;
	}

	get isStopped() {
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (!instances[i].isStopped) return false;
		}

		return true;
	}

	set loop(value) {
		this._loop = !!value;
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			instances[i].loop = this._loop;
		}
	}

	get loop() {
		return this._loop;
	}

	set overlap(value) {
		this._overlap = !!value;
	}

	get overlap() {
		return this._overlap;
	}

	set pitch(value) {
		this._pitch = Math.max(Number(value) || 0, 0.01);

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].pitch = this.pitch * this._component.pitch;
			}
		}
	}

	get pitch() {
		return this._pitch;
	}

	set startTime(value) {
		this._startTime = Math.max(0, Number(value) || 0);

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].startTime = this._startTime;
			}
		}
	}

	get startTime() {
		return this._startTime;
	}

	set volume(value) {
		this._volume = math.clamp(Number(value) || 0, 0, 1);

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].volume = this._volume * this._component.volume;
			}
		}
	}

	get volume() {
		return this._volume;
	}

}

class SoundComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._volume = 1;
		this._pitch = 1;
		this._positional = true;
		this._refDistance = 1;
		this._maxDistance = 10000;
		this._rollOffFactor = 1;
		this._distanceModel = DISTANCE_LINEAR;
		this._slots = {};
		this._playingBeforeDisable = {};
	}

	_updateSoundInstances(property, value, isFactor) {
		const slots = this._slots;

		for (const key in slots) {
			const slot = slots[key];

			if (!slot.overlap) {
				const instances = slot.instances;

				for (let i = 0, len = instances.length; i < len; i++) {
					instances[i][property] = isFactor ? slot[property] * value : value;
				}
			}
		}
	}

	set distanceModel(value) {
		this._distanceModel = value;

		this._updateSoundInstances('distanceModel', value, false);
	}

	get distanceModel() {
		return this._distanceModel;
	}

	set maxDistance(value) {
		this._maxDistance = value;

		this._updateSoundInstances('maxDistance', value, false);
	}

	get maxDistance() {
		return this._maxDistance;
	}

	set refDistance(value) {
		this._refDistance = value;

		this._updateSoundInstances('refDistance', value, false);
	}

	get refDistance() {
		return this._refDistance;
	}

	set rollOffFactor(value) {
		this._rollOffFactor = value;

		this._updateSoundInstances('rollOffFactor', value, false);
	}

	get rollOffFactor() {
		return this._rollOffFactor;
	}

	set pitch(value) {
		this._pitch = value;

		this._updateSoundInstances('pitch', value, true);
	}

	get pitch() {
		return this._pitch;
	}

	set volume(value) {
		this._volume = value;

		this._updateSoundInstances('volume', value, true);
	}

	get volume() {
		return this._volume;
	}

	set positional(newValue) {
		this._positional = newValue;
		const slots = this._slots;

		for (const key in slots) {
			const slot = slots[key];

			if (!slot.overlap) {
				const instances = slot.instances;
				const oldLength = instances.length;

				for (let i = oldLength - 1; i >= 0; i--) {
					const isPlaying = instances[i].isPlaying || instances[i].isSuspended;
					const currentTime = instances[i].currentTime;
					if (isPlaying) instances[i].stop();

					const instance = slot._createInstance();

					if (isPlaying) {
						instance.play();
						instance.currentTime = currentTime;
					}

					instances.push(instance);
				}
			}
		}
	}

	get positional() {
		return this._positional;
	}

	set slots(newValue) {
		const oldValue = this._slots;

		if (oldValue) {
			for (const key in oldValue) {
				oldValue[key].stop();
			}
		}

		const slots = {};

		for (const key in newValue) {
			if (!(newValue[key] instanceof SoundSlot)) {
				if (newValue[key].name) {
					slots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);
				}
			} else {
				slots[newValue[key].name] = newValue[key];
			}
		}

		this._slots = slots;
		if (this.enabled && this.entity.enabled) this.onEnable();
	}

	get slots() {
		return this._slots;
	}

	onEnable() {
		if (this.system._inTools) {
			return;
		}

		const slots = this._slots;
		const playingBeforeDisable = this._playingBeforeDisable;

		for (const key in slots) {
			const slot = slots[key];

			if (slot.autoPlay && slot.isStopped) {
				slot.play();
			} else if (playingBeforeDisable[key]) {
				slot.resume();
			} else if (!slot.isLoaded) {
				slot.load();
			}
		}
	}

	onDisable() {
		const slots = this._slots;
		const playingBeforeDisable = {};

		for (const key in slots) {
			if (!slots[key].overlap) {
				if (slots[key].isPlaying) {
					slots[key].pause();
					playingBeforeDisable[key] = true;
				}
			}
		}

		this._playingBeforeDisable = playingBeforeDisable;
	}

	onRemove() {
		this.off();
	}

	addSlot(name, options) {
		const slots = this._slots;

		if (slots[name]) {
			return null;
		}

		const slot = new SoundSlot(this, name, options);
		slots[name] = slot;

		if (slot.autoPlay && this.enabled && this.entity.enabled) {
			slot.play();
		}

		return slot;
	}

	removeSlot(name) {
		const slots = this._slots;

		if (slots[name]) {
			slots[name].stop();
			delete slots[name];
		}
	}

	slot(name) {
		return this._slots[name];
	}

	play(name) {
		if (!this.enabled || !this.entity.enabled) {
			return null;
		}

		const slot = this._slots[name];

		if (!slot) {
			return null;
		}

		return slot.play();
	}

	pause(name) {
		const slots = this._slots;

		if (name) {
			const slot = slots[name];

			if (!slot) {
				return;
			}

			slot.pause();
		} else {
			for (const key in slots) {
				slots[key].pause();
			}
		}
	}

	resume(name) {
		const slots = this._slots;

		if (name) {
			const slot = slots[name];

			if (!slot) {
				return;
			}

			if (slot.isPaused) {
				slot.resume();
			}
		} else {
			for (const key in slots) {
				slots[key].resume();
			}
		}
	}

	stop(name) {
		const slots = this._slots;

		if (name) {
			const slot = slots[name];

			if (!slot) {
				return;
			}

			slot.stop();
		} else {
			for (const key in slots) {
				slots[key].stop();
			}
		}
	}

}

class SoundComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$2 = ['enabled'];

class SoundComponentSystem extends ComponentSystem {
	constructor(app, manager) {
		super(app);
		this.id = "sound";
		this.ComponentType = SoundComponent;
		this.DataType = SoundComponentData;
		this.schema = _schema$2;
		this.manager = manager;
		this.app.systems.on('update', this.onUpdate, this);
		this.on('beforeremove', this.onBeforeRemove, this);
	}

	set volume(volume) {
		this.manager.volume = volume;
	}

	get volume() {
		return this.manager.volume;
	}

	get context() {
		if (!hasAudioContext()) {
			return null;
		}

		return this.manager.context;
	}

	initializeComponentData(component, data, properties) {
		properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];

		for (let i = 0; i < properties.length; i++) {
			if (data.hasOwnProperty(properties[i])) {
				component[properties[i]] = data[properties[i]];
			}
		}

		super.initializeComponentData(component, data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const srcComponent = entity.sound;
		const srcSlots = srcComponent.slots;
		const slots = {};

		for (const key in srcSlots) {
			const srcSlot = srcSlots[key];
			slots[key] = {
				name: srcSlot.name,
				volume: srcSlot.volume,
				pitch: srcSlot.pitch,
				loop: srcSlot.loop,
				duration: srcSlot.duration,
				startTime: srcSlot.startTime,
				overlap: srcSlot.overlap,
				autoPlay: srcSlot.autoPlay,
				asset: srcSlot.asset
			};
		}

		const cloneData = {
			distanceModel: srcComponent.distanceModel,
			enabled: srcComponent.enabled,
			maxDistance: srcComponent.maxDistance,
			pitch: srcComponent.pitch,
			positional: srcComponent.positional,
			refDistance: srcComponent.refDistance,
			rollOffFactor: srcComponent.rollOffFactor,
			slots: slots,
			volume: srcComponent.volume
		};
		return this.addComponent(clone, cloneData);
	}

	onUpdate(dt) {
		const store = this.store;

		for (const id in store) {
			if (store.hasOwnProperty(id)) {
				const item = store[id];
				const entity = item.entity;

				if (entity.enabled) {
					const component = entity.sound;

					if (component.enabled && component.positional) {
						const position = entity.getPosition();
						const slots = component.slots;

						for (const key in slots) {
							slots[key].updatePosition(position);
						}
					}
				}
			}
		}
	}

	onBeforeRemove(entity, component) {
		const slots = component.slots;

		for (const key in slots) {
			if (!slots[key].overlap) {
				slots[key].stop();
			}
		}

		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(SoundComponent.prototype, _schema$2);

const SPRITETYPE_SIMPLE = 'simple';
const SPRITETYPE_ANIMATED = 'animated';

class SpriteAnimationClip extends EventHandler {
	constructor(component, data) {
		super();
		this._component = component;
		this._frame = 0;
		this._sprite = null;
		this._spriteAsset = null;
		this.spriteAsset = data.spriteAsset;
		this.name = data.name;
		this.fps = data.fps || 0;
		this.loop = data.loop || false;
		this._playing = false;
		this._paused = false;
		this._time = 0;
	}

	get duration() {
		if (this._sprite) {
			const fps = this.fps || Number.MIN_VALUE;
			return this._sprite.frameKeys.length / Math.abs(fps);
		}

		return 0;
	}

	set frame(value) {
		this._setFrame(value);

		const fps = this.fps || Number.MIN_VALUE;

		this._setTime(this._frame / fps);
	}

	get frame() {
		return this._frame;
	}

	get isPaused() {
		return this._paused;
	}

	get isPlaying() {
		return this._playing;
	}

	set sprite(value) {
		if (this._sprite) {
			this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);

			this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);

			this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);

			if (this._sprite.atlas) {
				this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
			}
		}

		this._sprite = value;

		if (this._sprite) {
			this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);

			this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);

			this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);

			if (this._sprite.atlas) {
				this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
			}
		}

		if (this._component.currentClip === this) {
			let mi;

			if (!value || !value.atlas) {
				mi = this._component._meshInstance;

				if (mi) {
					mi.deleteParameter('texture_emissiveMap');
					mi.deleteParameter('texture_opacityMap');
				}

				this._component._hideModel();
			} else {
				if (value.atlas.texture) {
					mi = this._component._meshInstance;

					if (mi) {
						mi.setParameter('texture_emissiveMap', value.atlas.texture);
						mi.setParameter('texture_opacityMap', value.atlas.texture);
					}

					if (this._component.enabled && this._component.entity.enabled) {
						this._component._showModel();
					}
				}

				if (this.time && this.fps) {
					this.time = this.time;
				} else {
					this.frame = this.frame;
				}
			}
		}
	}

	get sprite() {
		return this._sprite;
	}

	set spriteAsset(value) {
		const assets = this._component.system.app.assets;
		let id = value;

		if (value instanceof Asset) {
			id = value.id;
		}

		if (this._spriteAsset !== id) {
			if (this._spriteAsset) {
				const prev = assets.get(this._spriteAsset);

				if (prev) {
					this._unbindSpriteAsset(prev);
				}
			}

			this._spriteAsset = id;

			if (this._spriteAsset) {
				const asset = assets.get(this._spriteAsset);

				if (!asset) {
					this.sprite = null;
					assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
				} else {
					this._bindSpriteAsset(asset);
				}
			} else {
				this.sprite = null;
			}
		}
	}

	get spriteAsset() {
		return this._spriteAsset;
	}

	set time(value) {
		this._setTime(value);

		if (this._sprite) {
			this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
		} else {
			this.frame = 0;
		}
	}

	get time() {
		return this._time;
	}

	_onSpriteAssetAdded(asset) {
		this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

		if (this._spriteAsset === asset.id) {
			this._bindSpriteAsset(asset);
		}
	}

	_bindSpriteAsset(asset) {
		asset.on("load", this._onSpriteAssetLoad, this);
		asset.on("remove", this._onSpriteAssetRemove, this);

		if (asset.resource) {
			this._onSpriteAssetLoad(asset);
		} else {
			this._component.system.app.assets.load(asset);
		}
	}

	_unbindSpriteAsset(asset) {
		asset.off("load", this._onSpriteAssetLoad, this);
		asset.off("remove", this._onSpriteAssetRemove, this);

		if (asset.resource && asset.resource.atlas) {
			this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
		}
	}

	_onSpriteAssetLoad(asset) {
		if (!asset.resource) {
			this.sprite = null;
		} else {
			if (!asset.resource.atlas) {
				const atlasAssetId = asset.data.textureAtlasAsset;
				const assets = this._component.system.app.assets;
				assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
				assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
			} else {
				this.sprite = asset.resource;
			}
		}
	}

	_onTextureAtlasLoad(atlasAsset) {
		const spriteAsset = this._spriteAsset;

		if (spriteAsset instanceof Asset) {
			this._onSpriteAssetLoad(spriteAsset);
		} else {
			this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
		}
	}

	_onSpriteAssetRemove(asset) {
		this.sprite = null;
	}

	_onSpriteMeshesChange() {
		if (this._component.currentClip === this) {
			this._component._showFrame(this.frame);
		}
	}

	_onSpritePpuChanged() {
		if (this._component.currentClip === this) {
			if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
				this._component._showFrame(this.frame);
			}
		}
	}

	_update(dt) {
		if (this.fps === 0) return;
		if (!this._playing || this._paused || !this._sprite) return;
		const dir = this.fps < 0 ? -1 : 1;
		const time = this._time + dt * this._component.speed * dir;
		const duration = this.duration;
		const end = time > duration || time < 0;

		this._setTime(time);

		let frame = this.frame;

		if (this._sprite) {
			frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
		} else {
			frame = 0;
		}

		if (frame !== this._frame) {
			this._setFrame(frame);
		}

		if (end) {
			if (this.loop) {
				this.fire('loop');

				this._component.fire('loop', this);
			} else {
				this._playing = false;
				this._paused = false;
				this.fire('end');

				this._component.fire('end', this);
			}
		}
	}

	_setTime(value) {
		this._time = value;
		const duration = this.duration;

		if (this._time < 0) {
			if (this.loop) {
				this._time = this._time % duration + duration;
			} else {
				this._time = 0;
			}
		} else if (this._time > duration) {
			if (this.loop) {
				this._time %= duration;
			} else {
				this._time = duration;
			}
		}
	}

	_setFrame(value) {
		if (this._sprite) {
			this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
		} else {
			this._frame = value;
		}

		if (this._component.currentClip === this) {
			this._component._showFrame(this._frame);
		}
	}

	_destroy() {
		if (this._sprite) {
			this.sprite = null;
		}

		if (this._spriteAsset) {
			this.spriteAsset = null;
		}
	}

	play() {
		if (this._playing) return;
		this._playing = true;
		this._paused = false;
		this.frame = 0;
		this.fire('play');

		this._component.fire('play', this);
	}

	pause() {
		if (!this._playing || this._paused) return;
		this._paused = true;
		this.fire('pause');

		this._component.fire('pause', this);
	}

	resume() {
		if (!this._paused) return;
		this._paused = false;
		this.fire('resume');

		this._component.fire('resume', this);
	}

	stop() {
		if (!this._playing) return;
		this._playing = false;
		this._paused = false;
		this._time = 0;
		this.frame = 0;
		this.fire('stop');

		this._component.fire('stop', this);
	}

}

const PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
const PARAM_OPACITY_MAP = 'texture_opacityMap';
const PARAM_EMISSIVE = 'material_emissive';
const PARAM_OPACITY = 'material_opacity';
const PARAM_INNER_OFFSET = 'innerOffset';
const PARAM_OUTER_SCALE = 'outerScale';
const PARAM_ATLAS_RECT = 'atlasRect';

class SpriteComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._type = SPRITETYPE_SIMPLE;
		this._material = system.defaultMaterial;
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array(3);
		this._speed = 1;
		this._flipX = false;
		this._flipY = false;
		this._width = 1;
		this._height = 1;
		this._drawOrder = 0;
		this._layers = [LAYERID_WORLD];
		this._outerScale = new Vec2(1, 1);
		this._outerScaleUniform = new Float32Array(2);
		this._innerOffset = new Vec4();
		this._innerOffsetUniform = new Float32Array(4);
		this._atlasRect = new Vec4();
		this._atlasRectUniform = new Float32Array(4);
		this._batchGroupId = -1;
		this._batchGroup = null;
		this._node = new GraphNode();
		this._model = new Model();
		this._model.graph = this._node;
		this._meshInstance = null;
		entity.addChild(this._model.graph);
		this._model._entity = entity;
		this._updateAabbFunc = this._updateAabb.bind(this);
		this._addedModel = false;
		this._autoPlayClip = null;
		this._clips = {};
		this._defaultClip = new SpriteAnimationClip(this, {
			name: this.entity.name,
			fps: 0,
			loop: false,
			spriteAsset: null
		});
		this._currentClip = this._defaultClip;
	}

	set type(value) {
		if (this._type === value) return;
		this._type = value;

		if (this._type === SPRITETYPE_SIMPLE) {
			this.stop();
			this._currentClip = this._defaultClip;

			if (this.enabled && this.entity.enabled) {
				this._currentClip.frame = this.frame;

				if (this._currentClip.sprite) {
					this._showModel();
				} else {
					this._hideModel();
				}
			}
		} else if (this._type === SPRITETYPE_ANIMATED) {
			this.stop();

			if (this._autoPlayClip) {
				this._tryAutoPlay();
			}

			if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
				this._showModel();
			} else {
				this._hideModel();
			}
		}
	}

	get type() {
		return this._type;
	}

	set frame(value) {
		this._currentClip.frame = value;
	}

	get frame() {
		return this._currentClip.frame;
	}

	set spriteAsset(value) {
		this._defaultClip.spriteAsset = value;
	}

	get spriteAsset() {
		return this._defaultClip._spriteAsset;
	}

	set sprite(value) {
		this._currentClip.sprite = value;
	}

	get sprite() {
		return this._currentClip.sprite;
	}

	set material(value) {
		this._material = value;

		if (this._meshInstance) {
			this._meshInstance.material = value;
		}
	}

	get material() {
		return this._material;
	}

	set color(value) {
		this._color.r = value.r;
		this._color.g = value.g;
		this._color.b = value.b;

		if (this._meshInstance) {
			this._colorUniform[0] = this._color.r;
			this._colorUniform[1] = this._color.g;
			this._colorUniform[2] = this._color.b;

			this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
		}
	}

	get color() {
		return this._color;
	}

	set opacity(value) {
		this._color.a = value;

		if (this._meshInstance) {
			this._meshInstance.setParameter(PARAM_OPACITY, value);
		}
	}

	get opacity() {
		return this._color.a;
	}

	set clips(value) {
		if (!value) {
			for (const name in this._clips) {
				this.removeClip(name);
			}

			return;
		}

		for (const name in this._clips) {
			let found = false;

			for (const key in value) {
				if (value[key].name === name) {
					found = true;
					this._clips[name].fps = value[key].fps;
					this._clips[name].loop = value[key].loop;

					if (value[key].hasOwnProperty('sprite')) {
						this._clips[name].sprite = value[key].sprite;
					} else if (value[key].hasOwnProperty('spriteAsset')) {
						this._clips[name].spriteAsset = value[key].spriteAsset;
					}

					break;
				}
			}

			if (!found) {
				this.removeClip(name);
			}
		}

		for (const key in value) {
			if (this._clips[value[key].name]) continue;
			this.addClip(value[key]);
		}

		if (this._autoPlayClip) {
			this._tryAutoPlay();
		}

		if (!this._currentClip || !this._currentClip.sprite) {
			this._hideModel();
		}
	}

	get clips() {
		return this._clips;
	}

	get currentClip() {
		return this._currentClip;
	}

	set speed(value) {
		this._speed = value;
	}

	get speed() {
		return this._speed;
	}

	set flipX(value) {
		if (this._flipX === value) return;
		this._flipX = value;

		this._updateTransform();
	}

	get flipX() {
		return this._flipX;
	}

	set flipY(value) {
		if (this._flipY === value) return;
		this._flipY = value;

		this._updateTransform();
	}

	get flipY() {
		return this._flipY;
	}

	set width(value) {
		if (value === this._width) return;
		this._width = value;
		this._outerScale.x = this._width;

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
			this._updateTransform();
		}
	}

	get width() {
		return this._width;
	}

	set height(value) {
		if (value === this._height) return;
		this._height = value;
		this._outerScale.y = this.height;

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
			this._updateTransform();
		}
	}

	get height() {
		return this._height;
	}

	set batchGroupId(value) {
		if (this._batchGroupId === value) return;
		const prev = this._batchGroupId;
		this._batchGroupId = value;

		if (this.entity.enabled && prev >= 0) {
			this.system.app.batcher.remove(BatchGroup.SPRITE, prev, this.entity);
		}

		if (this.entity.enabled && value >= 0) {
			this.system.app.batcher.insert(BatchGroup.SPRITE, value, this.entity);
		} else {
			if (prev >= 0) {
				if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
		}
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set autoPlayClip(value) {
		this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;

		this._tryAutoPlay();
	}

	get autoPlayClip() {
		return this._autoPlayClip;
	}

	set drawOrder(value) {
		this._drawOrder = value;

		if (this._meshInstance) {
			this._meshInstance.drawOrder = value;
		}
	}

	get drawOrder() {
		return this._drawOrder;
	}

	set layers(value) {
		if (this._addedModel) {
			this._hideModel();
		}

		this._layers = value;

		if (!this._meshInstance) {
			return;
		}

		if (this.enabled && this.entity.enabled) {
			this._showModel();
		}
	}

	get layers() {
		return this._layers;
	}

	get aabb() {
		if (this._meshInstance) {
			return this._meshInstance.aabb;
		}

		return null;
	}

	onEnable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.on("set:layers", this._onLayersChanged, this);

		if (scene.layers) {
			scene.layers.on("add", this._onLayerAdded, this);
			scene.layers.on("remove", this._onLayerRemoved, this);
		}

		this._showModel();

		if (this._autoPlayClip) this._tryAutoPlay();

		if (this._batchGroupId >= 0) {
			app.batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
		}
	}

	onDisable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.off("set:layers", this._onLayersChanged, this);

		if (scene.layers) {
			scene.layers.off("add", this._onLayerAdded, this);
			scene.layers.off("remove", this._onLayerRemoved, this);
		}

		this.stop();

		this._hideModel();

		if (this._batchGroupId >= 0) {
			app.batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
		}
	}

	onDestroy() {
		this._currentClip = null;

		if (this._defaultClip) {
			this._defaultClip._destroy();

			this._defaultClip = null;
		}

		for (const key in this._clips) {
			this._clips[key]._destroy();
		}

		this._clips = null;

		this._hideModel();

		this._model = null;

		if (this._node) {
			if (this._node.parent) this._node.parent.removeChild(this._node);
			this._node = null;
		}

		if (this._meshInstance) {
			this._meshInstance.material = null;
			this._meshInstance.mesh = null;
			this._meshInstance = null;
		}
	}

	_showModel() {
		if (this._addedModel) return;
		if (!this._meshInstance) return;
		const meshInstances = [this._meshInstance];

		for (let i = 0, len = this._layers.length; i < len; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(meshInstances);
			}
		}

		this._addedModel = true;
	}

	_hideModel() {
		if (!this._addedModel || !this._meshInstance) return;
		const meshInstances = [this._meshInstance];

		for (let i = 0, len = this._layers.length; i < len; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.removeMeshInstances(meshInstances);
			}
		}

		this._addedModel = false;
	}

	_showFrame(frame) {
		if (!this.sprite) return;
		const mesh = this.sprite.meshes[frame];

		if (!mesh) {
			if (this._meshInstance) {
				this._meshInstance.mesh = null;
				this._meshInstance.visible = false;
			}

			return;
		}

		let material;

		if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
			material = this.system.default9SlicedMaterialSlicedMode;
		} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
			material = this.system.default9SlicedMaterialTiledMode;
		} else {
			material = this.system.defaultMaterial;
		}

		if (!this._meshInstance) {
			this._meshInstance = new MeshInstance(mesh, this._material, this._node);
			this._meshInstance.castShadow = false;
			this._meshInstance.receiveShadow = false;
			this._meshInstance.drawOrder = this._drawOrder;

			this._model.meshInstances.push(this._meshInstance);

			this._colorUniform[0] = this._color.r;
			this._colorUniform[1] = this._color.g;
			this._colorUniform[2] = this._color.b;

			this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);

			this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);

			if (this.enabled && this.entity.enabled) {
				this._showModel();
			}
		}

		if (this._meshInstance.material !== material) {
			this._meshInstance.material = material;
		}

		if (this._meshInstance.mesh !== mesh) {
			this._meshInstance.mesh = mesh;
			this._meshInstance.visible = true;
			this._meshInstance._aabbVer = -1;
		}

		if (this.sprite.atlas && this.sprite.atlas.texture) {
			this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);

			this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
		} else {
			this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);

			this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
		}

		if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			this._meshInstance._updateAabbFunc = this._updateAabbFunc;
			const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];

			if (frameData) {
				const borderWidthScale = 2 / frameData.rect.z;
				const borderHeightScale = 2 / frameData.rect.w;

				this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

				const tex = this.sprite.atlas.texture;

				this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
			} else {
				this._innerOffset.set(0, 0, 0, 0);
			}

			this._innerOffsetUniform[0] = this._innerOffset.x;
			this._innerOffsetUniform[1] = this._innerOffset.y;
			this._innerOffsetUniform[2] = this._innerOffset.z;
			this._innerOffsetUniform[3] = this._innerOffset.w;

			this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);

			this._atlasRectUniform[0] = this._atlasRect.x;
			this._atlasRectUniform[1] = this._atlasRect.y;
			this._atlasRectUniform[2] = this._atlasRect.z;
			this._atlasRectUniform[3] = this._atlasRect.w;

			this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
		} else {
			this._meshInstance._updateAabbFunc = null;
		}

		this._updateTransform();
	}

	_updateTransform() {
		let scaleX = this.flipX ? -1 : 1;
		let scaleY = this.flipY ? -1 : 1;
		let posX = 0;
		let posY = 0;

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			let w = 1;
			let h = 1;

			if (this.sprite.atlas) {
				const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];

				if (frameData) {
					w = frameData.rect.z;
					h = frameData.rect.w;
					posX = (0.5 - frameData.pivot.x) * this._width;
					posY = (0.5 - frameData.pivot.y) * this._height;
				}
			}

			const scaleMulX = w / this.sprite.pixelsPerUnit;
			const scaleMulY = h / this.sprite.pixelsPerUnit;

			this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));

			scaleX *= scaleMulX;
			scaleY *= scaleMulY;
			this._outerScale.x /= scaleMulX;
			this._outerScale.y /= scaleMulY;
			scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
			scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);

			if (this._meshInstance) {
				this._outerScaleUniform[0] = this._outerScale.x;
				this._outerScaleUniform[1] = this._outerScale.y;

				this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
			}
		}

		this._node.setLocalScale(scaleX, scaleY, 1);

		this._node.setLocalPosition(posX, posY, 0);
	}

	_updateAabb(aabb) {
		aabb.center.set(0, 0, 0);
		aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
		aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
		return aabb;
	}

	_tryAutoPlay() {
		if (!this._autoPlayClip) return;
		if (this.type !== SPRITETYPE_ANIMATED) return;
		const clip = this._clips[this._autoPlayClip];

		if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
			if (this.enabled && this.entity.enabled) {
				this.play(clip.name);
			}
		}
	}

	_onLayersChanged(oldComp, newComp) {
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);

		if (this.enabled && this.entity.enabled) {
			this._showModel();
		}
	}

	_onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;

		if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
			layer.addMeshInstances([this._meshInstance]);
		}
	}

	_onLayerRemoved(layer) {
		if (!this._meshInstance) return;
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances([this._meshInstance]);
	}

	removeModelFromLayers() {
		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances([this._meshInstance]);
		}
	}

	addClip(data) {
		const clip = new SpriteAnimationClip(this, {
			name: data.name,
			fps: data.fps,
			loop: data.loop,
			spriteAsset: data.spriteAsset
		});
		this._clips[data.name] = clip;
		if (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();
		return clip;
	}

	removeClip(name) {
		delete this._clips[name];
	}

	clip(name) {
		return this._clips[name];
	}

	play(name) {
		const clip = this._clips[name];
		const current = this._currentClip;

		if (current && current !== clip) {
			current._playing = false;
		}

		this._currentClip = clip;

		if (this._currentClip) {
			this._currentClip = clip;

			this._currentClip.play();
		}

		return clip;
	}

	pause() {
		if (this._currentClip === this._defaultClip) return;

		if (this._currentClip.isPlaying) {
			this._currentClip.pause();
		}
	}

	resume() {
		if (this._currentClip === this._defaultClip) return;

		if (this._currentClip.isPaused) {
			this._currentClip.resume();
		}
	}

	stop() {
		if (this._currentClip === this._defaultClip) return;

		this._currentClip.stop();
	}

}

class SpriteComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$1 = ['enabled'];

class SpriteComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'sprite';
		this.ComponentType = SpriteComponent;
		this.DataType = SpriteComponentData;
		this.schema = _schema$1;
		this._defaultTexture = null;
		this._defaultMaterial = null;
		this._default9SlicedMaterialSlicedMode = null;
		this._default9SlicedMaterialTiledMode = null;
		this.app.systems.on('update', this.onUpdate, this);
		this.on('beforeremove', this.onBeforeRemove, this);
	}

	set defaultMaterial(material) {
		this._defaultMaterial = material;
	}

	get defaultMaterial() {
		if (!this._defaultMaterial) {
			const texture = new Texture(this.app.graphicsDevice, {
				width: 1,
				height: 1,
				format: PIXELFORMAT_R8_G8_B8_A8
			});
			const pixels = new Uint8Array(texture.lock());
			pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
			texture.name = 'sprite';
			texture.unlock();
			const material = new StandardMaterial();
			material.diffuse.set(0, 0, 0);
			material.emissive.set(0.5, 0.5, 0.5);
			material.emissiveMap = texture;
			material.emissiveMapTint = true;
			material.opacityMap = texture;
			material.opacityMapChannel = "a";
			material.opacityTint = true;
			material.opacity = 0;
			material.useLighting = false;
			material.useGammaTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			material.pixelSnap = false;
			material.cull = CULLFACE_NONE;
			material.update();
			this._defaultTexture = texture;
			this._defaultMaterial = material;
		}

		return this._defaultMaterial;
	}

	set default9SlicedMaterialSlicedMode(material) {
		this._default9SlicedMaterialSlicedMode = material;
	}

	get default9SlicedMaterialSlicedMode() {
		if (!this._default9SlicedMaterialSlicedMode) {
			const material = this.defaultMaterial.clone();
			material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
			material.update();
			this._default9SlicedMaterialSlicedMode = material;
		}

		return this._default9SlicedMaterialSlicedMode;
	}

	set default9SlicedMaterialTiledMode(material) {
		this._default9SlicedMaterialTiledMode = material;
	}

	get default9SlicedMaterialTiledMode() {
		if (!this._default9SlicedMaterialTiledMode) {
			const material = this.defaultMaterial.clone();
			material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
			material.update();
			this._default9SlicedMaterialTiledMode = material;
		}

		return this._default9SlicedMaterialTiledMode;
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);

		if (this._defaultTexture) {
			this._defaultTexture.destroy();

			this._defaultTexture = null;
		}
	}

	initializeComponentData(component, data, properties) {
		if (data.enabled !== undefined) {
			component.enabled = data.enabled;
		}

		component.type = data.type;

		if (data.layers && Array.isArray(data.layers)) {
			component.layers = data.layers.slice(0);
		}

		if (data.drawOrder !== undefined) {
			component.drawOrder = data.drawOrder;
		}

		if (data.color !== undefined) {
			if (data.color instanceof Color) {
				component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);
			} else {
				component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
			}

			component.color = component.color;
		}

		if (data.opacity !== undefined) {
			component.opacity = data.opacity;
		}

		if (data.flipX !== undefined) {
			component.flipX = data.flipX;
		}

		if (data.flipY !== undefined) {
			component.flipY = data.flipY;
		}

		if (data.width !== undefined) {
			component.width = data.width;
		}

		if (data.height !== undefined) {
			component.height = data.height;
		}

		if (data.spriteAsset !== undefined) {
			component.spriteAsset = data.spriteAsset;
		}

		if (data.sprite) {
			component.sprite = data.sprite;
		}

		if (data.frame !== undefined) {
			component.frame = data.frame;
		}

		if (data.clips) {
			for (const name in data.clips) {
				component.addClip(data.clips[name]);
			}
		}

		if (data.speed !== undefined) {
			component.speed = data.speed;
		}

		if (data.autoPlayClip) {
			component.autoPlayClip = data.autoPlayClip;
		}

		component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const source = entity.sprite;
		return this.addComponent(clone, {
			enabled: source.enabled,
			type: source.type,
			spriteAsset: source.spriteAsset,
			sprite: source.sprite,
			frame: source.frame,
			color: source.color.clone(),
			opacity: source.opacity,
			flipX: source.flipX,
			flipY: source.flipY,
			speed: source.speed,
			clips: source.clips,
			autoPlayClip: source.autoPlayClip,
			batchGroupId: source.batchGroupId,
			drawOrder: source.drawOrder,
			layers: source.layers.slice(0)
		});
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];

				if (component.data.enabled && component.entity.enabled) {
					const sprite = component.entity.sprite;

					if (sprite._currentClip) {
						sprite._currentClip._update(dt);
					}
				}
			}
		}
	}

	onBeforeRemove(entity, component) {
		component.onDestroy();
	}

}

Component._buildAccessors(SpriteComponent.prototype, _schema$1);

class ZoneComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._oldState = true;
		this._size = new Vec3();
		this.on('set_enabled', this._onSetEnabled, this);
	}

	set size(data) {
		if (data instanceof Vec3) {
			this._size.copy(data);
		} else if (data instanceof Array && data.length >= 3) {
			this.size.set(data[0], data[1], data[2]);
		}
	}

	get size() {
		return this._size;
	}

	onEnable() {
		this._checkState();
	}

	onDisable() {
		this._checkState();
	}

	_onSetEnabled(prop, old, value) {
		this._checkState();
	}

	_checkState() {
		const state = this.enabled && this.entity.enabled;
		if (state === this._oldState) return;
		this._oldState = state;
		this.fire('enable');
		this.fire('state', this.enabled);
	}

	_onBeforeRemove() {
		this.fire('remove');
	}

}

class ZoneComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema = ['enabled'];

class ZoneComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'zone';
		this.ComponentType = ZoneComponent;
		this.DataType = ZoneComponentData;
		this.schema = _schema;
		this.on('beforeremove', this._onBeforeRemove, this);
	}

	initializeComponentData(component, data, properties) {
		component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

		if (data.size) {
			if (data.size instanceof Vec3) {
				component.size.copy(data.size);
			} else if (data.size instanceof Array && data.size.length >= 3) {
				component.size.set(data.size[0], data.size[1], data.size[2]);
			}
		}
	}

	cloneComponent(entity, clone) {
		const data = {
			size: entity.zone.size
		};
		return this.addComponent(clone, data);
	}

	_onBeforeRemove(entity, component) {
		component._onBeforeRemove();
	}

}

Component._buildAccessors(ZoneComponent.prototype, _schema);

class ApplicationStats {
	constructor(device) {
		this.frame = {
			fps: 0,
			ms: 0,
			dt: 0,
			updateStart: 0,
			updateTime: 0,
			renderStart: 0,
			renderTime: 0,
			physicsStart: 0,
			physicsTime: 0,
			cullTime: 0,
			sortTime: 0,
			skinTime: 0,
			morphTime: 0,
			instancingTime: 0,
			triangles: 0,
			otherPrimitives: 0,
			shaders: 0,
			materials: 0,
			cameras: 0,
			shadowMapUpdates: 0,
			shadowMapTime: 0,
			depthMapTime: 0,
			forwardTime: 0,
			lightClustersTime: 0,
			lightClusters: 0,
			_timeToCountFrames: 0,
			_fpsAccum: 0
		};
		this.drawCalls = {
			forward: 0,
			depth: 0,
			shadow: 0,
			immediate: 0,
			misc: 0,
			total: 0,
			skinned: 0,
			instanced: 0,
			removedByInstancing: 0
		};
		this.misc = {
			renderTargetCreationTime: 0
		};
		this.particles = {
			updatesPerFrame: 0,
			_updatesPerFrame: 0,
			frameTime: 0,
			_frameTime: 0
		};
		this.shaders = device._shaderStats;
		this.vram = device._vram;
		Object.defineProperty(this.vram, 'totalUsed', {
			get: function () {
				return this.tex + this.vb + this.ib;
			}
		});
		Object.defineProperty(this.vram, 'geom', {
			get: function () {
				return this.vb + this.ib;
			}
		});
	}

	get scene() {
		return getApplication().scene._stats;
	}

	get lightmapper() {
		return getApplication().lightmapper.stats;
	}

	get batcher() {
		return getApplication().batcher._stats;
	}

}

class SceneRegistryItem {
	constructor(name, url) {
		this.name = name;
		this.url = url;
		this.data = null;
		this._loading = false;
		this._onLoadedCallbacks = [];
	}

	get loaded() {
		return !!this.data;
	}

	get loading() {
		return this._loading;
	}

}

class SceneRegistry {
	constructor(app) {
		this._app = app;
		this._list = [];
		this._index = {};
		this._urlIndex = {};
	}

	destroy() {
		this._app = null;
	}

	list() {
		return this._list;
	}

	add(name, url) {
		if (this._index.hasOwnProperty(name)) {
			return false;
		}

		const item = new SceneRegistryItem(name, url);

		const i = this._list.push(item);

		this._index[item.name] = i - 1;
		this._urlIndex[item.url] = i - 1;
		return true;
	}

	find(name) {
		if (this._index.hasOwnProperty(name)) {
			return this._list[this._index[name]];
		}

		return null;
	}

	findByUrl(url) {
		if (this._urlIndex.hasOwnProperty(url)) {
			return this._list[this._urlIndex[url]];
		}

		return null;
	}

	remove(name) {
		if (this._index.hasOwnProperty(name)) {
			const idx = this._index[name];
			let item = this._list[idx];
			delete this._urlIndex[item.url];
			delete this._index[name];

			this._list.splice(idx, 1);

			for (let i = 0; i < this._list.length; i++) {
				item = this._list[i];
				this._index[item.name] = i;
				this._urlIndex[item.url] = i;
			}
		}
	}

	_loadSceneData(sceneItem, storeInCache, callback) {
		let url = sceneItem;

		if (sceneItem instanceof SceneRegistryItem) {
			url = sceneItem.url;
		} else {
			sceneItem = this.findByUrl(url);

			if (!sceneItem) {
				sceneItem = new SceneRegistryItem('Untitled', url);
			}
		}

		if (!sceneItem.url) {
			callback("URL or SceneRegistryItem is null when loading a scene");
			return;
		}

		if (sceneItem.loaded) {
			callback(null, sceneItem);
			return;
		}

		const handler = this._app.loader.getHandler("hierarchy");

		if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
			url = path.join(this._app.assets.prefix, url);
		}

		sceneItem._onLoadedCallbacks.push(callback);

		if (!sceneItem._loading) {
			handler.load(url, function (err, data) {
				sceneItem.data = data;
				sceneItem._loading = false;

				for (let i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {
					sceneItem._onLoadedCallbacks[i](err, sceneItem);
				}

				if (!storeInCache) {
					sceneItem.data = null;
				}

				sceneItem._onLoadedCallbacks.length = 0;
			});
		}

		sceneItem._loading = true;
	}

	loadSceneData(sceneItem, callback) {
		this._loadSceneData(sceneItem, true, callback);
	}

	unloadSceneData(sceneItem) {
		if (typeof sceneItem === 'string') {
			sceneItem = this.findByUrl(sceneItem);
		}

		if (sceneItem) {
			sceneItem.data = null;
		}
	}

	loadSceneHierarchy(sceneItem, callback) {
		const self = this;

		const handler = this._app.loader.getHandler("hierarchy");

		this._loadSceneData(sceneItem, false, function (err, sceneItem) {
			if (err) {
				if (callback) callback(err);
				return;
			}

			const url = sceneItem.url;
			const data = sceneItem.data;

			const _loaded = function _loaded() {
				self._app.systems.script.preloading = true;
				const entity = handler.open(url, data);
				self._app.systems.script.preloading = false;

				self._app.loader.clearCache(url, "hierarchy");

				self._app.root.addChild(entity);

				self._app.systems.fire('initialize', entity);

				self._app.systems.fire('postInitialize', entity);

				self._app.systems.fire('postPostInitialize', entity);

				if (callback) callback(err, entity);
			};

			self._app._preloadScripts(data, _loaded);
		});
	}

	loadSceneSettings(sceneItem, callback) {
		const self = this;

		this._loadSceneData(sceneItem, false, function (err, sceneItem) {
			if (!err) {
				self._app.applySceneSettings(sceneItem.data.settings);

				if (callback) {
					callback(null);
				}
			} else {
				if (callback) {
					callback(err);
				}
			}
		});
	}

	loadScene(url, callback) {
		const self = this;

		const handler = this._app.loader.getHandler("scene");

		if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
			url = path.join(this._app.assets.prefix, url);
		}

		handler.load(url, function (err, data) {
			if (!err) {
				const _loaded = function _loaded() {
					self._app.systems.script.preloading = true;
					const scene = handler.open(url, data);
					const sceneItem = self.findByUrl(url);

					if (sceneItem && !sceneItem.loaded) {
						sceneItem.data = data;
					}

					self._app.systems.script.preloading = false;

					self._app.loader.clearCache(url, "scene");

					self._app.loader.patch({
						resource: scene,
						type: "scene"
					}, self._app.assets);

					self._app.root.addChild(scene.root);

					if (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {
						self._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
					}

					if (callback) {
						callback(null, scene);
					}
				};

				self._app._preloadScripts(data, _loaded);
			} else {
				if (callback) {
					callback(err);
				}
			}
		});
	}

}

class SceneDepth {
	constructor(application) {
		this.application = application;
		this.device = application.graphicsDevice;
		this.clearOptions = null;
		this.layer = null;
		this.init();
	}

	allocateTexture(device, name, format) {
		const texture = new Texture(device, {
			format: format,
			width: device.width,
			height: device.height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = name;
		device.scope.resolve("uDepthMap").setValue(texture);
		return texture;
	}

	allocateRenderTarget(renderTarget, device, name, format, isDepth) {
		const buffer = this.allocateTexture(device, name, format);

		if (renderTarget) {
			renderTarget.destroyFrameBuffers();

			if (isDepth) {
				renderTarget._depthBuffer = buffer;
			} else {
				renderTarget._colorBuffer = buffer;
			}
		} else {
			renderTarget = new RenderTarget({
				colorBuffer: isDepth ? null : buffer,
				depthBuffer: isDepth ? buffer : null,
				depth: !isDepth,
				stencil: device.supportsStencil,
				autoResolve: false
			});
		}

		return renderTarget;
	}

	releaseRenderTarget(rt) {
		if (rt) {
			rt.destroyTextureBuffers();
			rt.destroy();
		}
	}

	initWebGl2() {
		const app = this.application;
		const self = this;
		this.clearOptions = {
			flags: 0
		};
		this.layer = new Layer({
			enabled: false,
			name: "Depth",
			id: LAYERID_DEPTH,
			onEnable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, "rt-depth2", PIXELFORMAT_DEPTHSTENCIL, true);
			},
			onDisable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = null;
			},
			onPreRenderOpaque: function (cameraPass) {
				const gl = app.graphicsDevice.gl;
				this.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);

				if (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {
					this.onEnable();
				}

				this.oldClear = this.cameras[cameraPass].camera._clearOptions;
				this.cameras[cameraPass].camera._clearOptions = self.clearOptions;
			},
			onPostRenderOpaque: function (cameraPass) {
				if (this.renderTarget) {
					this.cameras[cameraPass].camera._clearOptions = this.oldClear;
					app.graphicsDevice.setRenderTarget(this.renderTarget);
					app.graphicsDevice.updateBegin();
					const gl = app.graphicsDevice.gl;
					gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);
					gl.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
				}
			}
		});
	}

	initWebGl1() {
		const app = this.application;
		const self = this;
		this.clearOptions = {
			color: [254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255],
			depth: 1.0,
			flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
		};
		this.layer = new Layer({
			enabled: false,
			name: "Depth",
			id: LAYERID_DEPTH,
			shaderPass: SHADER_DEPTH,
			onEnable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, "rt-depth1", PIXELFORMAT_R8_G8_B8_A8, false);
			},
			onDisable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = null;
			},
			onPostCull: function (cameraPass) {
				const visibleObjects = this.instances.visibleOpaque[cameraPass];
				const visibleList = visibleObjects.list;
				const layerComposition = app.scene.layers;
				const subLayerEnabled = layerComposition.subLayerEnabled;
				const isTransparent = layerComposition.subLayerList;
				const rt = app.scene.layers.getLayerById(LAYERID_WORLD).renderTarget;
				const cam = this.cameras[cameraPass];
				let visibleLength = 0;
				const layers = layerComposition.layerList;

				for (let i = 0; i < layers.length; i++) {
					const layer = layers[i];
					if (layer === this) break;
					if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;
					const layerCamId = layer.cameras.indexOf(cam);
					if (layerCamId < 0) continue;
					const transparent = isTransparent[i];
					let layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
					const layerVisibleListLength = layerVisibleList.length;
					layerVisibleList = layerVisibleList.list;

					for (let j = 0; j < layerVisibleListLength; j++) {
						const drawCall = layerVisibleList[j];

						if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
							visibleList[visibleLength] = drawCall;
							visibleLength++;
						}
					}
				}

				visibleObjects.length = visibleLength;
			},
			onPreRenderOpaque: function (cameraPass) {
				if (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {
					this.onEnable();
				}

				this.oldClear = this.cameras[cameraPass].camera._clearOptions;
				this.cameras[cameraPass].camera._clearOptions = self.clearOptions;
			},
			onDrawCall: function () {
				app.graphicsDevice.setColorWrite(true, true, true, true);
			},
			onPostRenderOpaque: function (cameraPass) {
				if (!this.renderTarget) return;
				this.cameras[cameraPass].camera._clearOptions = this.oldClear;
			}
		});
	}

	init() {
		if (this.device.webgl2) {
			this.initWebGl2();
		} else {
			this.initWebGl1();
		}
	}

	patch(layer) {
		layer.onEnable = this.layer.onEnable;
		layer.onDisable = this.layer.onDisable;
		layer.onPreRenderOpaque = this.layer.onPreRenderOpaque;
		layer.onPostRenderOpaque = this.layer.onPostRenderOpaque;
		layer.shaderPass = this.layer.shaderPass;
		layer.onPostCull = this.layer.onPostCull;
		layer.onDrawCall = this.layer.onDrawCall;
	}

}

class Progress$1 {
	constructor(length) {
		this.length = length;
		this.count = 0;
	}

	inc() {
		this.count++;
	}

	done() {
		return this.count === this.length;
	}

}

let app = null;

class Application extends EventHandler {
	constructor(canvas, options = {}) {
		super();
		Application._applications[canvas.id] = this;
		setApplication(this);
		app = this;
		this._destroyRequested = false;
		this._inFrameUpdate = false;
		this._time = 0;
		this.timeScale = 1;
		this.maxDeltaTime = 0.1;
		this.frame = 0;
		this.autoRender = true;
		this.renderNextFrame = false;
		this.useLegacyScriptAttributeCloning = script.legacy;
		this._librariesLoaded = false;
		this._fillMode = FILLMODE_KEEP_ASPECT;
		this._resolutionMode = RESOLUTION_FIXED;
		this._allowResize = true;
		this.context = this;
		if (!options.graphicsDeviceOptions) options.graphicsDeviceOptions = {};

		if (platform.browser && !!navigator.xr) {
			options.graphicsDeviceOptions.xrCompatible = true;
		}

		options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
		this.graphicsDevice = new GraphicsDevice(canvas, options.graphicsDeviceOptions);

		this._initDefaultMaterial();

		this.stats = new ApplicationStats(this.graphicsDevice);
		this._soundManager = new SoundManager(options);
		this.loader = new ResourceLoader(this);
		LightsBuffer.init(this.graphicsDevice);
		this._entityIndex = {};
		this.scene = new Scene$1(this.graphicsDevice);

		this._registerSceneImmediate(this.scene);

		this.root = new Entity();
		this.root._enabledInHierarchy = true;
		this._enableList = [];
		this._enableList.size = 0;
		this.assets = new AssetRegistry(this.loader);
		if (options.assetPrefix) this.assets.prefix = options.assetPrefix;
		this.bundles = new BundleRegistry(this.assets);
		this.enableBundles = typeof TextDecoder !== 'undefined';
		this.scriptsOrder = options.scriptsOrder || [];
		this.scripts = new ScriptRegistry(this);
		this.i18n = new I18n(this);
		this.scenes = new SceneRegistry(this);
		const self = this;
		this.defaultLayerWorld = new Layer({
			name: "World",
			id: LAYERID_WORLD
		});
		this.sceneDepth = new SceneDepth(this);
		this.defaultLayerDepth = this.sceneDepth.layer;
		this.defaultLayerSkybox = new Layer({
			enabled: true,
			name: "Skybox",
			id: LAYERID_SKYBOX,
			opaqueSortMode: SORTMODE_NONE
		});
		this.defaultLayerUi = new Layer({
			enabled: true,
			name: "UI",
			id: LAYERID_UI,
			transparentSortMode: SORTMODE_MANUAL,
			passThrough: false
		});
		this.defaultLayerImmediate = new Layer({
			enabled: true,
			name: "Immediate",
			id: LAYERID_IMMEDIATE,
			opaqueSortMode: SORTMODE_NONE,
			passThrough: true
		});
		const defaultLayerComposition = new LayerComposition("default");
		defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
		defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
		defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
		defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
		defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
		defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
		defaultLayerComposition.pushTransparent(this.defaultLayerUi);
		this.scene.layers = defaultLayerComposition;
		this._immediateLayer = this.defaultLayerImmediate;
		this.scene.on('set:layers', function (oldComp, newComp) {
			const list = newComp.layerList;
			let layer;

			for (let i = 0; i < list.length; i++) {
				layer = list[i];

				switch (layer.id) {
					case LAYERID_DEPTH:
						self.sceneDepth.patch(layer);
						break;

					case LAYERID_UI:
						layer.passThrough = self.defaultLayerUi.passThrough;
						break;

					case LAYERID_IMMEDIATE:
						layer.passThrough = self.defaultLayerImmediate.passThrough;
						break;
				}
			}
		});
		AreaLightLuts.createPlaceholder(this.graphicsDevice);
		this.renderer = new ForwardRenderer(this.graphicsDevice);
		this.renderer.scene = this.scene;
		this.lightmapper = new Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);
		this.once('prerender', this._firstBake, this);
		this.batcher = new BatchManager(this.graphicsDevice, this.root, this.scene);
		this.once('prerender', this._firstBatch, this);
		this.keyboard = options.keyboard || null;
		this.mouse = options.mouse || null;
		this.touch = options.touch || null;
		this.gamepads = options.gamepads || null;
		this.elementInput = options.elementInput || null;
		if (this.elementInput) this.elementInput.app = this;
		this.vr = null;
		this.xr = new XrManager(this);
		if (this.elementInput) this.elementInput.attachSelectEvents();
		this._inTools = false;
		this._skyboxAsset = null;
		this._scriptPrefix = options.scriptPrefix || '';

		if (this.enableBundles) {
			this.loader.addHandler("bundle", new BundleHandler(this.assets));
		}

		this.loader.addHandler("animation", new AnimationHandler());
		this.loader.addHandler("animclip", new AnimClipHandler());
		this.loader.addHandler("animstategraph", new AnimStateGraphHandler());
		this.loader.addHandler("model", new ModelHandler(this.graphicsDevice));
		this.loader.addHandler("render", new RenderHandler(this.assets));
		this.loader.addHandler("material", new MaterialHandler(this));
		this.loader.addHandler("texture", new TextureHandler(this.graphicsDevice, this.assets, this.loader));
		this.loader.addHandler("text", new TextHandler());
		this.loader.addHandler("json", new JsonHandler());
		this.loader.addHandler("audio", new AudioHandler(this._soundManager));
		this.loader.addHandler("script", new ScriptHandler(this));
		this.loader.addHandler("scene", new SceneHandler(this));
		this.loader.addHandler("cubemap", new CubemapHandler(this.graphicsDevice, this.assets, this.loader));
		this.loader.addHandler("html", new HtmlHandler());
		this.loader.addHandler("css", new CssHandler());
		this.loader.addHandler("shader", new ShaderHandler());
		this.loader.addHandler("hierarchy", new HierarchyHandler(this));
		this.loader.addHandler("folder", new FolderHandler());
		this.loader.addHandler("font", new FontHandler(this.loader));
		this.loader.addHandler("binary", new BinaryHandler());
		this.loader.addHandler("textureatlas", new TextureAtlasHandler(this.loader));
		this.loader.addHandler("sprite", new SpriteHandler(this.assets, this.graphicsDevice));
		this.loader.addHandler("template", new TemplateHandler(this));
		this.loader.addHandler("container", new ContainerHandler(this.graphicsDevice, this.assets));
		this.systems = new ComponentSystemRegistry();
		this.systems.add(new RigidBodyComponentSystem(this));
		this.systems.add(new CollisionComponentSystem(this));
		this.systems.add(new JointComponentSystem(this));
		this.systems.add(new AnimationComponentSystem(this));
		this.systems.add(new AnimComponentSystem(this));
		this.systems.add(new ModelComponentSystem(this));
		this.systems.add(new RenderComponentSystem(this));
		this.systems.add(new CameraComponentSystem(this));
		this.systems.add(new LightComponentSystem(this));

		if (script.legacy) {
			this.systems.add(new ScriptLegacyComponentSystem(this));
		} else {
			this.systems.add(new ScriptComponentSystem(this));
		}

		this.systems.add(new AudioSourceComponentSystem(this, this._soundManager));
		this.systems.add(new SoundComponentSystem(this, this._soundManager));
		this.systems.add(new AudioListenerComponentSystem(this, this._soundManager));
		this.systems.add(new ParticleSystemComponentSystem(this));
		this.systems.add(new ScreenComponentSystem(this));
		this.systems.add(new ElementComponentSystem(this));
		this.systems.add(new ButtonComponentSystem(this));
		this.systems.add(new ScrollViewComponentSystem(this));
		this.systems.add(new ScrollbarComponentSystem(this));
		this.systems.add(new SpriteComponentSystem(this));
		this.systems.add(new LayoutGroupComponentSystem(this));
		this.systems.add(new LayoutChildComponentSystem(this));
		this.systems.add(new ZoneComponentSystem(this));
		this._visibilityChangeHandler = this.onVisibilityChange.bind(this);

		if (typeof document !== 'undefined') {
			if (document.hidden !== undefined) {
				this._hiddenAttr = 'hidden';
				document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
			} else if (document.mozHidden !== undefined) {
				this._hiddenAttr = 'mozHidden';
				document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
			} else if (document.msHidden !== undefined) {
				this._hiddenAttr = 'msHidden';
				document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
			} else if (document.webkitHidden !== undefined) {
				this._hiddenAttr = 'webkitHidden';
				document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
			}
		}

		this.tick = makeTick(this);
	}

	static getApplication(id) {
		return id ? Application._applications[id] : getApplication();
	}

	_initDefaultMaterial() {
		const material = new StandardMaterial();
		material.name = "Default Material";
		material.shadingModel = SPECULAR_BLINN;
		DefaultMaterial.add(this.graphicsDevice, material);
	}

	get fillMode() {
		return this._fillMode;
	}

	get resolutionMode() {
		return this._resolutionMode;
	}

	configure(url, callback) {
		http.get(url, (err, response) => {
			if (err) {
				callback(err);
				return;
			}

			const props = response.application_properties;
			const scenes = response.scenes;
			const assets = response.assets;

			this._parseApplicationProperties(props, err => {
				this._parseScenes(scenes);

				this._parseAssets(assets);

				if (!err) {
					callback(null);
				} else {
					callback(err);
				}
			});
		});
	}

	preload(callback) {
		this.fire("preload:start");
		const assets = this.assets.list({
			preload: true
		});
		const progress = new Progress$1(assets.length);
		let _done = false;

		const done = () => {
			if (!this.graphicsDevice) {
				return;
			}

			if (!_done && progress.done()) {
				_done = true;
				this.fire("preload:end");
				callback();
			}
		};

		const total = assets.length;

		if (progress.length) {
			const onAssetLoad = asset => {
				progress.inc();
				this.fire('preload:progress', progress.count / total);
				if (progress.done()) done();
			};

			const onAssetError = (err, asset) => {
				progress.inc();
				this.fire('preload:progress', progress.count / total);
				if (progress.done()) done();
			};

			for (let i = 0; i < assets.length; i++) {
				if (!assets[i].loaded) {
					assets[i].once('load', onAssetLoad);
					assets[i].once('error', onAssetError);
					this.assets.load(assets[i]);
				} else {
					progress.inc();
					this.fire("preload:progress", progress.count / total);
					if (progress.done()) done();
				}
			}
		} else {
			done();
		}
	}

	_preloadScripts(sceneData, callback) {
		if (!script.legacy) {
			callback();
			return;
		}

		this.systems.script.preloading = true;

		const scripts = this._getScriptReferences(sceneData);

		const l = scripts.length;
		const progress = new Progress$1(l);
		const regex = /^http(s)?:\/\//;

		if (l) {
			const onLoad = (err, ScriptType) => {
				if (err) console.error(err);
				progress.inc();

				if (progress.done()) {
					this.systems.script.preloading = false;
					callback();
				}
			};

			for (let i = 0; i < l; i++) {
				let scriptUrl = scripts[i];
				if (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = path.join(self._scriptPrefix, scripts[i]);
				this.loader.load(scriptUrl, 'script', onLoad);
			}
		} else {
			this.systems.script.preloading = false;
			callback();
		}
	}

	_handleAreaLightDataProperty(prop) {
		const asset = this.assets.get(prop);

		if (asset) {
			this.setAreaLightLuts(asset);
		} else {
			this.assets.once('add:' + prop, this.setAreaLightLuts, this);
		}
	}

	_parseApplicationProperties(props, callback) {
		if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
			this.loader.enableRetry(props.maxAssetRetries);
		}

		if (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;
		if (!props.resolutionMode) props.resolutionMode = props.resolution_mode;
		if (!props.fillMode) props.fillMode = props.fill_mode;
		this._width = props.width;
		this._height = props.height;

		if (props.useDevicePixelRatio) {
			this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
		}

		this.setCanvasResolution(props.resolutionMode, this._width, this._height);
		this.setCanvasFillMode(props.fillMode, this._width, this._height);

		if (props.layers && props.layerOrder) {
			const composition = new LayerComposition("application");
			const layers = {};

			for (const key in props.layers) {
				const data = props.layers[key];
				data.id = parseInt(key, 10);
				data.enabled = data.id !== LAYERID_DEPTH;
				layers[key] = new Layer(data);
			}

			for (let i = 0, len = props.layerOrder.length; i < len; i++) {
				const sublayer = props.layerOrder[i];
				const layer = layers[sublayer.layer];
				if (!layer) continue;

				if (sublayer.transparent) {
					composition.pushTransparent(layer);
				} else {
					composition.pushOpaque(layer);
				}

				composition.subLayerEnabled[i] = sublayer.enabled;
			}

			this.scene.layers = composition;
		}

		if (props.batchGroups) {
			for (let i = 0, len = props.batchGroups.length; i < len; i++) {
				const grp = props.batchGroups[i];
				this.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
			}
		}

		if (props.i18nAssets) {
			this.i18n.assets = props.i18nAssets;
		}

		if (props.areaLightDataAsset) {
			this._handleAreaLightDataProperty(props.areaLightDataAsset);
		}

		this._loadLibraries(props.libraries, callback);
	}

	_loadLibraries(urls, callback) {
		const len = urls.length;
		let count = len;
		const regex = /^http(s)?:\/\//;

		if (len) {
			const onLoad = (err, script) => {
				count--;

				if (err) {
					callback(err);
				} else if (count === 0) {
					this.onLibrariesLoaded();
					callback(null);
				}
			};

			for (let i = 0; i < len; ++i) {
				let url = urls[i];
				if (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = path.join(this._scriptPrefix, url);
				this.loader.load(url, 'script', onLoad);
			}
		} else {
			this.onLibrariesLoaded();
			callback(null);
		}
	}

	_parseScenes(scenes) {
		if (!scenes) return;

		for (let i = 0; i < scenes.length; i++) {
			this.scenes.add(scenes[i].name, scenes[i].url);
		}
	}

	_parseAssets(assets) {
		const list = [];
		const scriptsIndex = {};
		const bundlesIndex = {};

		if (!script.legacy) {
			for (let i = 0; i < this.scriptsOrder.length; i++) {
				const id = this.scriptsOrder[i];
				if (!assets[id]) continue;
				scriptsIndex[id] = true;
				list.push(assets[id]);
			}

			if (this.enableBundles) {
				for (const id in assets) {
					if (assets[id].type === 'bundle') {
						bundlesIndex[id] = true;
						list.push(assets[id]);
					}
				}
			}

			for (const id in assets) {
				if (scriptsIndex[id] || bundlesIndex[id]) continue;
				list.push(assets[id]);
			}
		} else {
			if (this.enableBundles) {
				for (const id in assets) {
					if (assets[id].type === 'bundle') {
						bundlesIndex[id] = true;
						list.push(assets[id]);
					}
				}
			}

			for (const id in assets) {
				if (bundlesIndex[id]) continue;
				list.push(assets[id]);
			}
		}

		for (let i = 0; i < list.length; i++) {
			const data = list[i];
			const asset = new Asset(data.name, data.type, data.file, data.data);
			asset.id = parseInt(data.id, 10);
			asset.preload = data.preload ? data.preload : false;
			asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
			asset.tags.add(data.tags);

			if (data.i18n) {
				for (const locale in data.i18n) {
					asset.addLocalizedAssetId(locale, data.i18n[locale]);
				}
			}

			this.assets.add(asset);
		}
	}

	_getScriptReferences(scene) {
		let priorityScripts = [];

		if (scene.settings.priority_scripts) {
			priorityScripts = scene.settings.priority_scripts;
		}

		const _scripts = [];
		const _index = {};

		for (let i = 0; i < priorityScripts.length; i++) {
			_scripts.push(priorityScripts[i]);

			_index[priorityScripts[i]] = true;
		}

		const entities = scene.entities;

		for (const key in entities) {
			if (!entities[key].components.script) {
				continue;
			}

			const scripts = entities[key].components.script.scripts;

			for (let i = 0; i < scripts.length; i++) {
				if (_index[scripts[i].url]) continue;

				_scripts.push(scripts[i].url);

				_index[scripts[i].url] = true;
			}
		}

		return _scripts;
	}

	start() {
		this.frame = 0;
		this.fire("start", {
			timestamp: now(),
			target: this
		});

		if (!this._librariesLoaded) {
			this.onLibrariesLoaded();
		}

		this.systems.fire('initialize', this.root);
		this.fire('initialize');
		this.systems.fire('postInitialize', this.root);
		this.systems.fire('postPostInitialize', this.root);
		this.fire('postinitialize');
		this.tick();
	}

	inputUpdate(dt) {
		if (this.controller) {
			this.controller.update(dt);
		}

		if (this.mouse) {
			this.mouse.update(dt);
		}

		if (this.keyboard) {
			this.keyboard.update(dt);
		}

		if (this.gamepads) {
			this.gamepads.update(dt);
		}
	}

	update(dt) {
		this.frame++;
		this.graphicsDevice.updateClientRect();
		if (this.vr) this.vr.poll();
		if (script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);
		this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
		this.systems.fire('animationUpdate', dt);
		this.systems.fire('postUpdate', dt);
		this.fire("update", dt);
		this.inputUpdate(dt);
	}

	render() {
		this.fire('prerender');
		this.root.syncHierarchy();
		this.batcher.updateAll();
		this.renderer.renderComposition(this.scene.layers);
		this.fire('postrender');
	}

	_fillFrameStatsBasic(now, dt, ms) {
		const stats = this.stats.frame;
		stats.dt = dt;
		stats.ms = ms;

		if (now > stats._timeToCountFrames) {
			stats.fps = stats._fpsAccum;
			stats._fpsAccum = 0;
			stats._timeToCountFrames = now + 1000;
		} else {
			stats._fpsAccum++;
		}

		this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
		this.graphicsDevice._drawCallsPerFrame = 0;
	}

	_fillFrameStats() {
		let stats = this.stats.frame;
		stats.cameras = this.renderer._camerasRendered;
		stats.materials = this.renderer._materialSwitches;
		stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
		stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
		stats.shadowMapTime = this.renderer._shadowMapTime;
		stats.depthMapTime = this.renderer._depthMapTime;
		stats.forwardTime = this.renderer._forwardTime;
		const prims = this.graphicsDevice._primsPerFrame;
		stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
		stats.cullTime = this.renderer._cullTime;
		stats.sortTime = this.renderer._sortTime;
		stats.skinTime = this.renderer._skinTime;
		stats.morphTime = this.renderer._morphTime;
		stats.instancingTime = this.renderer._instancingTime;
		stats.lightClusters = this.renderer._lightClusters;
		stats.lightClustersTime = this.renderer._lightClustersTime;
		stats.otherPrimitives = 0;

		for (let i = 0; i < prims.length; i++) {
			if (i < PRIMITIVE_TRIANGLES) {
				stats.otherPrimitives += prims[i];
			}

			prims[i] = 0;
		}

		this.renderer._camerasRendered = 0;
		this.renderer._materialSwitches = 0;
		this.renderer._shadowMapUpdates = 0;
		this.graphicsDevice._shaderSwitchesPerFrame = 0;
		this.renderer._cullTime = 0;
		this.renderer._layerCompositionUpdateTime = 0;
		this.renderer._lightClustersTime = 0;
		this.renderer._sortTime = 0;
		this.renderer._skinTime = 0;
		this.renderer._morphTime = 0;
		this.renderer._instancingTime = 0;
		this.renderer._shadowMapTime = 0;
		this.renderer._depthMapTime = 0;
		this.renderer._forwardTime = 0;
		stats = this.stats.drawCalls;
		stats.forward = this.renderer._forwardDrawCalls;
		stats.culled = this.renderer._numDrawCallsCulled;
		stats.depth = 0;
		stats.shadow = this.renderer._shadowDrawCalls;
		stats.skinned = this.renderer._skinDrawCalls;
		stats.immediate = 0;
		stats.instanced = 0;
		stats.removedByInstancing = 0;
		stats.misc = stats.total - (stats.forward + stats.shadow);
		this.renderer._depthDrawCalls = 0;
		this.renderer._shadowDrawCalls = 0;
		this.renderer._forwardDrawCalls = 0;
		this.renderer._numDrawCallsCulled = 0;
		this.renderer._skinDrawCalls = 0;
		this.renderer._immediateRendered = 0;
		this.renderer._instancedDrawCalls = 0;
		this.renderer._removedByInstancing = 0;
		this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
		stats = this.stats.particles;
		stats.updatesPerFrame = stats._updatesPerFrame;
		stats.frameTime = stats._frameTime;
		stats._updatesPerFrame = 0;
		stats._frameTime = 0;
	}

	setCanvasFillMode(mode, width, height) {
		this._fillMode = mode;
		this.resizeCanvas(width, height);
	}

	setCanvasResolution(mode, width, height) {
		this._resolutionMode = mode;

		if (mode === RESOLUTION_AUTO && width === undefined) {
			width = this.graphicsDevice.canvas.clientWidth;
			height = this.graphicsDevice.canvas.clientHeight;
		}

		this.graphicsDevice.resizeCanvas(width, height);
	}

	isHidden() {
		return document[this._hiddenAttr];
	}

	onVisibilityChange() {
		if (this.isHidden()) {
			this._soundManager.suspend();
		} else {
			this._soundManager.resume();
		}
	}

	resizeCanvas(width, height) {
		if (!this._allowResize) return;
		if (this.xr && this.xr.session) return;
		const windowWidth = window.innerWidth;
		const windowHeight = window.innerHeight;

		if (this._fillMode === FILLMODE_KEEP_ASPECT) {
			const r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
			const winR = windowWidth / windowHeight;

			if (r > winR) {
				width = windowWidth;
				height = width / r;
			} else {
				height = windowHeight;
				width = height * r;
			}
		} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
			width = windowWidth;
			height = windowHeight;
		}

		this.graphicsDevice.canvas.style.width = width + 'px';
		this.graphicsDevice.canvas.style.height = height + 'px';
		this.updateCanvasSize();
		return {
			width: width,
			height: height
		};
	}

	updateCanvasSize() {
		if (!this._allowResize || this.xr.active) {
			return;
		}

		if (this._resolutionMode === RESOLUTION_AUTO) {
			const canvas = this.graphicsDevice.canvas;
			this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
		}
	}

	onLibrariesLoaded() {
		this._librariesLoaded = true;
		this.systems.rigidbody.onLibraryLoaded();
	}

	applySceneSettings(settings) {
		let asset;

		if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
			const gravity = settings.physics.gravity;
			this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);
		}

		this.scene.applySettings(settings);

		if (settings.render.hasOwnProperty('skybox')) {
			if (settings.render.skybox) {
				asset = this.assets.get(settings.render.skybox);

				if (asset) {
					this.setSkybox(asset);
				} else {
					this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);
				}
			} else {
				this.setSkybox(null);
			}
		}
	}

	setAreaLightLuts(asset) {
		if (asset) {
			const device = this.graphicsDevice;
			asset.ready(asset => {
				AreaLightLuts.set(device, asset.resource);
			});
			this.assets.load(asset);
		}
	}

	setSkybox(asset) {
		if (asset !== this._skyboxAsset) {
			const onSkyboxRemoved = () => {
				this.setSkybox(null);
			};

			const onSkyboxChanged = () => {
				this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);
			};

			if (this._skyboxAsset) {
				this.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
				this.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

				this._skyboxAsset.off('change', onSkyboxChanged, this);
			}

			this._skyboxAsset = asset;

			if (this._skyboxAsset) {
				this.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
				this.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

				this._skyboxAsset.on('change', onSkyboxChanged, this);

				if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
					this._skyboxAsset.loadFaces = true;
				}

				this.assets.load(this._skyboxAsset);
			}

			onSkyboxChanged();
		}
	}

	enableVr() {
		if (!this.vr) {
			this.vr = new VrManager(this);
		}
	}

	disableVr() {
		if (this.vr) {
			this.vr.destroy();
			this.vr = null;
		}
	}

	_firstBake() {
		this.lightmapper.bake(null, this.scene.lightmapMode);
	}

	_firstBatch() {
		this.batcher.generate();
	}

	_processTimestamp(timestamp) {
		return timestamp;
	}

	drawLine(start, end, color, depthTest, layer) {
		this.scene.drawLine(start, end, color, depthTest, layer);
	}

	drawLines(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.drawLines(positions, colors, depthTest, layer);
	}

	drawLineArrays(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.drawLineArrays(positions, colors, depthTest, layer);
	}

	drawWireSphere(center, radius, color = Color.WHITE, segments = 20, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
	}

	drawWireAlignedBox(minPoint, maxPoint, color = Color.WHITE, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);
	}

	drawMeshInstance(meshInstance, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
	}

	drawMesh(mesh, material, matrix, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
	}

	drawQuad(matrix, material, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
	}

	drawTexture(x, y, width, height, texture, material, layer = this.scene.defaultDrawLayer) {
		const matrix = new Mat4();
		matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, height, 0.0));

		if (!material) {
			material = new Material$1();
			material.setParameter("colorMap", texture);
			material.shader = this.scene.immediate.getTextureShader();
			material.update();
		}

		this.drawQuad(matrix, material, layer);
	}

	drawDepthTexture(x, y, width, height, layer = this.scene.defaultDrawLayer) {
		const material = new Material$1();
		material.shader = this.scene.immediate.getDepthTextureShader();
		material.update();
		this.drawTexture(x, y, width, height, null, material, layer);
	}

	destroy() {
		if (this._inFrameUpdate) {
			this._destroyRequested = true;
			return;
		}

		const canvasId = this.graphicsDevice.canvas.id;
		this.off('librariesloaded');

		if (typeof document !== 'undefined') {
			document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
		}

		this._visibilityChangeHandler = null;
		this.root.destroy();
		this.root = null;

		if (this.mouse) {
			this.mouse.off();
			this.mouse.detach();
			this.mouse = null;
		}

		if (this.keyboard) {
			this.keyboard.off();
			this.keyboard.detach();
			this.keyboard = null;
		}

		if (this.touch) {
			this.touch.off();
			this.touch.detach();
			this.touch = null;
		}

		if (this.elementInput) {
			this.elementInput.detach();
			this.elementInput = null;
		}

		if (this.controller) {
			this.controller = null;
		}

		this.systems.destroy();

		if (this.scene.layers) {
			this.scene.layers.destroy();
		}

		const assets = this.assets.list();

		for (let i = 0; i < assets.length; i++) {
			assets[i].unload();
			assets[i].off();
		}

		this.assets.off();
		this.bundles.destroy();
		this.bundles = null;
		this.i18n.destroy();
		this.i18n = null;

		for (const key in this.loader.getHandler('script')._cache) {
			const element = this.loader.getHandler('script')._cache[key];

			const parent = element.parentNode;
			if (parent) parent.removeChild(element);
		}

		this.loader.getHandler('script')._cache = {};
		this.loader.destroy();
		this.loader = null;
		this.scene.destroy();
		this.scene = null;
		this.systems = null;
		this.context = null;
		this.scripts.destroy();
		this.scripts = null;
		this.scenes.destroy();
		this.scenes = null;
		this.lightmapper.destroy();
		this.lightmapper = null;
		this.batcher.destroy();
		this.batcher = null;
		this._entityIndex = {};
		this.defaultLayerDepth.onPreRenderOpaque = null;
		this.defaultLayerDepth.onPostRenderOpaque = null;
		this.defaultLayerDepth.onDisable = null;
		this.defaultLayerDepth.onEnable = null;
		this.defaultLayerDepth = null;
		this.defaultLayerWorld = null;
		destroyPostEffectQuad();

		if (this.vr) {
			this.vr.destroy();
			this.vr = null;
		}

		this.xr.end();
		ParticleEmitter.staticDestroy();
		this.renderer.destroy();
		this.renderer = null;
		DefaultMaterial.remove(this.graphicsDevice);
		this.graphicsDevice.destroy();
		this.graphicsDevice = null;
		this.tick = null;
		this.off();

		if (this._soundManager) {
			this._soundManager.destroy();

			this._soundManager = null;
		}

		script.app = null;
		Application._applications[canvasId] = null;

		if (getApplication() === this) {
			setApplication(null);
		}
	}

	getEntityFromIndex(guid) {
		return this._entityIndex[guid];
	}

	_registerSceneImmediate(scene) {
		this.on('postrender', scene.immediate.onPostRender, scene.immediate);
	}

}

Application._applications = {};
const _frameEndData = {};

const makeTick = function makeTick(_app) {
	const application = _app;
	let frameRequest;
	return function (timestamp, frame) {
		if (!application.graphicsDevice) return;
		setApplication(application);

		if (frameRequest) {
			window.cancelAnimationFrame(frameRequest);
			frameRequest = null;
		}

		app = application;
		const currentTime = application._processTimestamp(timestamp) || now();
		const ms = currentTime - (application._time || currentTime);
		let dt = ms / 1000.0;
		dt = math.clamp(dt, 0, application.maxDeltaTime);
		dt *= application.timeScale;
		application._time = currentTime;

		if (application.vr && application.vr.display) {
			frameRequest = application.vr.display.requestAnimationFrame(application.tick);
		} else if (application.xr.session) {
			frameRequest = application.xr.session.requestAnimationFrame(application.tick);
		} else {
			frameRequest = platform.browser ? window.requestAnimationFrame(application.tick) : null;
		}

		if (application.graphicsDevice.contextLost) return;

		application._fillFrameStatsBasic(currentTime, dt, ms);

		application._inFrameUpdate = true;
		application.fire("frameupdate", ms);

		if (frame) {
			application.xr.update(frame);
			application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
		} else {
			application.graphicsDevice.defaultFramebuffer = null;
		}

		application.update(dt);
		application.fire("framerender");

		if (application.autoRender || application.renderNextFrame) {
			application.updateCanvasSize();
			application.render();
			application.renderNextFrame = false;
		}

		_frameEndData.timestamp = now();
		_frameEndData.target = application;
		application.fire("frameend", _frameEndData);
		application.fire("frameEnd", _frameEndData);

		if (application.vr && application.vr.display && application.vr.display.presenting) {
			application.vr.display.submitFrame();
		}

		application._inFrameUpdate = false;

		if (application._destroyRequested) {
			application.destroy();
		}
	};
};

class Entity extends GraphNode {
	constructor(name, app) {
		super(name);
		this.anim = void 0;
		this.animation = void 0;
		this.audiolistener = void 0;
		this.button = void 0;
		this.camera = void 0;
		this.collision = void 0;
		this.element = void 0;
		this.layoutchild = void 0;
		this.layoutgroup = void 0;
		this.light = void 0;
		this.model = void 0;
		this.particlesystem = void 0;
		this.render = void 0;
		this.rigidbody = void 0;
		this.screen = void 0;
		this.script = void 0;
		this.scrollbar = void 0;
		this.scrollview = void 0;
		this.sound = void 0;
		this.sprite = void 0;
		if (name instanceof Application) app = name;
		this._batchHandle = null;
		this.c = {};
		this._app = app;

		if (!app) {
			this._app = Application.getApplication();

			if (!this._app) {
				throw new Error("Couldn't find current application");
			}
		}

		this._guid = null;
		this._destroying = false;
		this._template = false;
	}

	addComponent(type, data) {
		const system = this._app.systems[type];

		if (!system) {
			return null;
		}

		if (this.c[type]) {
			return null;
		}

		return system.addComponent(this, data);
	}

	removeComponent(type) {
		const system = this._app.systems[type];

		if (!system) {
			return;
		}

		if (!this.c[type]) {
			return;
		}

		system.removeComponent(this);
	}

	findComponent(type) {
		const entity = this.findOne(function (node) {
			return node.c && node.c[type];
		});
		return entity && entity.c[type];
	}

	findComponents(type) {
		const entities = this.find(function (node) {
			return node.c && node.c[type];
		});
		return entities.map(function (entity) {
			return entity.c[type];
		});
	}

	getGuid() {
		if (!this._guid) {
			this.setGuid(guid.create());
		}

		return this._guid;
	}

	setGuid(guid) {
		const index = this._app._entityIndex;

		if (this._guid) {
			delete index[this._guid];
		}

		this._guid = guid;
		index[this._guid] = this;
	}

	_notifyHierarchyStateChanged(node, enabled) {
		let enableFirst = false;
		if (node === this && this._app._enableList.length === 0) enableFirst = true;
		node._beingEnabled = true;

		node._onHierarchyStateChanged(enabled);

		if (node._onHierarchyStatePostChanged) this._app._enableList.push(node);
		const c = node._children;

		for (let i = 0, len = c.length; i < len; i++) {
			if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
		}

		node._beingEnabled = false;

		if (enableFirst) {
			for (let i = 0; i < this._app._enableList.length; i++) {
				this._app._enableList[i]._onHierarchyStatePostChanged();
			}

			this._app._enableList.length = 0;
		}
	}

	_onHierarchyStateChanged(enabled) {
		super._onHierarchyStateChanged(enabled);

		const components = this.c;

		for (const type in components) {
			if (components.hasOwnProperty(type)) {
				const component = components[type];

				if (component.enabled) {
					if (enabled) {
						component.onEnable();
					} else {
						component.onDisable();
					}
				}
			}
		}
	}

	_onHierarchyStatePostChanged() {
		const components = this.c;

		for (const type in components) {
			if (components.hasOwnProperty(type)) components[type].onPostStateChange();
		}
	}

	findByGuid(guid) {
		if (this._guid === guid) return this;
		const e = this._app._entityIndex[guid];

		if (e && (e === this || e.isDescendantOf(this))) {
			return e;
		}

		return null;
	}

	destroy() {
		this._destroying = true;

		for (const name in this.c) {
			this.c[name].enabled = false;
		}

		for (const name in this.c) {
			this.c[name].system.removeComponent(this);
		}

		if (this._parent) this._parent.removeChild(this);
		const children = this._children;
		let child = children.shift();

		while (child) {
			if (child instanceof Entity) {
				child.destroy();
			}

			child._parent = null;
			child = children.shift();
		}

		this.fire('destroy', this);
		this.off();

		if (this._guid) {
			delete this._app._entityIndex[this._guid];
		}

		this._destroying = false;
	}

	clone() {
		const duplicatedIdsMap = {};

		const clone = this._cloneRecursively(duplicatedIdsMap);

		duplicatedIdsMap[this.getGuid()] = clone;
		resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
		return clone;
	}

	_cloneRecursively(duplicatedIdsMap) {
		const clone = new Entity(this._app);

		super._cloneInternal(clone);

		for (const type in this.c) {
			const component = this.c[type];
			component.system.cloneComponent(this, clone);
		}

		for (let i = 0; i < this._children.length; i++) {
			const oldChild = this._children[i];

			if (oldChild instanceof Entity) {
				const newChild = oldChild._cloneRecursively(duplicatedIdsMap);

				clone.addChild(newChild);
				duplicatedIdsMap[oldChild.getGuid()] = newChild;
			}
		}

		return clone;
	}

}

function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
	if (oldEntity instanceof Entity) {
		const components = oldEntity.c;

		for (const componentName in components) {
			const component = components[componentName];
			const entityProperties = component.system.getPropertiesOfType('entity');

			for (let i = 0, len = entityProperties.length; i < len; i++) {
				const propertyDescriptor = entityProperties[i];
				const propertyName = propertyDescriptor.name;
				const oldEntityReferenceId = component[propertyName];
				const entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);

				if (entityIsWithinOldSubtree) {
					const newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();

					if (newEntityReferenceId) {
						newEntity.c[componentName][propertyName] = newEntityReferenceId;
					}
				}
			}
		}

		if (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {
			newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
		}

		if (components.render) {
			newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
		}

		if (components.anim) {
			newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
		}

		const _old = oldEntity.children.filter(function (e) {
			return e instanceof Entity;
		});

		const _new = newEntity.children.filter(function (e) {
			return e instanceof Entity;
		});

		for (let i = 0, len = _old.length; i < len; i++) {
			resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);
		}
	}
}

const _tempPoint = new Vec3();

class BakeLightAmbient extends BakeLight {
	constructor(scene) {
		const lightEntity = new Entity("AmbientLight");
		lightEntity.addComponent("light", {
			type: "directional",
			affectDynamic: true,
			affectLightmapped: false,
			bake: true,
			bakeNumSamples: scene.ambientBakeNumSamples,
			castShadows: true,
			normalOffsetBias: 0.05,
			shadowBias: 0.2,
			shadowDistance: 1,
			shadowResolution: 2048,
			shadowType: SHADOW_PCF3,
			color: Color.WHITE,
			intensity: 1
		});
		super(scene, lightEntity.light.light);
	}

	get numVirtualLights() {
		return this.light.bakeNumSamples;
	}

	prepareVirtualLight(index, numVirtualLights) {
		random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);

		this.light._node.lookAt(_tempPoint.mulScalar(-1));

		this.light._node.rotateLocal(90, 0, 0);

		const gamma = this.scene.gammaCorrection ? 2.2 : 1;
		const fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
		const linearIntensity = Math.pow(fullIntensity, gamma);
		this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
	}

}

class BakeMeshNode {
	constructor(node, meshInstances = null) {
		this.node = node;
		this.component = node.render || node.model;
		meshInstances = meshInstances || this.component.meshInstances;
		this.store();
		this.meshInstances = meshInstances;
		this.bounds = null;
		this.renderTargets = [];
	}

	store() {
		this.castShadows = this.component.castShadows;
	}

	restore() {
		this.component.castShadows = this.castShadows;
	}

}

const DENOISE_FILTER_SIZE = 15;

class LightmapFilters {
	constructor(device) {
		this.device = device;
		this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.dilatePS, "lmDilate");
		this.constantTexSource = device.scope.resolve("source");
		this.constantPixelOffset = device.scope.resolve("pixelOffset");
		this.pixelOffset = new Float32Array(2);
		this.shaderDenoise = null;
		this.sigmas = null;
		this.constantSigmas = null;
		this.kernel = null;
	}

	setSourceTexture(texture) {
		this.constantTexSource.setValue(texture);
	}

	prepare(textureWidth, textureHeight) {
		this.pixelOffset[0] = 1 / textureWidth;
		this.pixelOffset[1] = 1 / textureHeight;
		this.constantPixelOffset.setValue(this.pixelOffset);
	}

	prepareDenoise(filterRange, filterSmoothness) {
		if (!this.shaderDenoise) {
			this.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunks.bilateralDeNoisePS, "lmBilateralDeNoise");
			this.sigmas = new Float32Array(2);
			this.constantSigmas = this.device.scope.resolve("sigmas");
			this.constantKernel = this.device.scope.resolve("kernel[0]");
			this.bZnorm = this.device.scope.resolve("bZnorm");
		}

		this.sigmas[0] = filterRange;
		this.sigmas[1] = filterSmoothness;
		this.constantSigmas.setValue(this.sigmas);
		this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
	}

	evaluateDenoiseUniforms(filterRange, filterSmoothness) {
		function normpdf(x, sigma) {
			return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
		}

		this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
		const kernel = this.kernel;
		const kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);

		for (let j = 0; j <= kSize; ++j) {
			const value = normpdf(j, filterRange);
			kernel[kSize + j] = value;
			kernel[kSize - j] = value;
		}

		this.constantKernel.setValue(this.kernel);
		const bZnorm = 1 / normpdf(0.0, filterSmoothness);
		this.bZnorm.setValue(bZnorm);
	}

}

const MAX_LIGHTMAP_SIZE = 2048;
const PASS_COLOR = 0;
const PASS_DIR = 1;
const tempVec = new Vec3();

class Lightmapper {
	constructor(device, root, scene, renderer, assets) {
		this.device = device;
		this.root = root;
		this.scene = scene;
		this.renderer = renderer;
		this.assets = assets;
		this.shadowMapCache = renderer._shadowRenderer.shadowMapCache;
		this._tempSet = new Set();
		this._initCalled = false;
		this.passMaterials = [];
		this.ambientAOMaterial = null;
		this.fog = "";
		this.ambientLight = new Color();
		this.renderTargets = new Map();
		this.stats = {
			renderPasses: 0,
			lightmapCount: 0,
			totalRenderTime: 0,
			forwardTime: 0,
			fboTime: 0,
			shadowMapTime: 0,
			compileTime: 0,
			shadersLinked: 0
		};
	}

	destroy() {
		LightmapCache.decRef(this.blackTex);
		this.blackTex = null;
		LightmapCache.destroy();
		this.device = null;
		this.root = null;
		this.scene = null;
		this.renderer = null;
		this.assets = null;
	}

	initBake(device) {
		if (!this._initCalled) {
			this._initCalled = true;
			this.lightmapFilters = new LightmapFilters(device);
			this.constantBakeDir = device.scope.resolve("bakeDir");
			this.materials = [];
			this.blackTex = new Texture(this.device, {
				width: 4,
				height: 4,
				format: PIXELFORMAT_R8_G8_B8_A8,
				type: TEXTURETYPE_RGBM
			});
			this.blackTex.name = 'lightmapBlack';
			LightmapCache.incRef(this.blackTex);
			const camera = new Camera();
			camera.clearColor.set(0, 0, 0, 0);
			camera.clearColorBuffer = true;
			camera.clearDepthBuffer = false;
			camera.clearStencilBuffer = false;
			camera.frustumCulling = false;
			camera.projection = PROJECTION_ORTHOGRAPHIC;
			camera.aspectRatio = 1;
			camera.node = new GraphNode();
			this.camera = camera;
		}

		if (this.scene.clusteredLightingEnabled) {
			const lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, () => {});
			this.lightingParams = lightingParams;
			const srcParams = this.scene.lighting;
			lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
			lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
			lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
			lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
			lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
			lightingParams.cells = new Vec3(3, 3, 3);
			lightingParams.maxLightsPerCell = 4;
			this.worldClusters = new WorldClusters(device);
			this.worldClusters.name = "ClusterLightmapper";
		}
	}

	finishBake(bakeNodes) {
		this.materials = [];

		function destroyRT(rt) {
			LightmapCache.decRef(rt.colorBuffer);
			rt.destroy();
		}

		this.renderTargets.forEach(rt => {
			destroyRT(rt);
		});
		this.renderTargets.clear();
		bakeNodes.forEach(node => {
			node.renderTargets.forEach(rt => {
				destroyRT(rt);
			});
			node.renderTargets.length = 0;
		});
		this.ambientAOMaterial = null;

		if (this.worldClusters) {
			this.worldClusters.destroy();
			this.worldClusters = null;
		}
	}

	createMaterialForPass(device, scene, pass, addAmbient) {
		const material = new StandardMaterial();
		material.name = `lmMaterial-pass:${pass}-ambient:${addAmbient}`;
		material.chunks.transformVS = "#define UV1LAYOUT\n" + shaderChunks.transformVS;

		if (pass === PASS_COLOR) {
			let bakeLmEndChunk = shaderChunks.bakeLmEndPS;

			if (addAmbient) {
				bakeLmEndChunk = `
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								` + bakeLmEndChunk;
			} else {
				material.ambient = new Color(0, 0, 0);
				material.ambientTint = true;
			}

			material.chunks.endPS = bakeLmEndChunk;
			material.lightMap = this.blackTex;
		} else {
			material.chunks.basePS = shaderChunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
			material.chunks.endPS = shaderChunks.bakeDirLmEndPS;
		}

		material.chunks.outputAlphaPS = "\n";
		material.chunks.outputAlphaOpaquePS = "\n";
		material.chunks.outputAlphaPremulPS = "\n";
		material.cull = CULLFACE_NONE;
		material.forceUv1 = true;
		material.update();
		material.updateShader(device, scene);
		return material;
	}

	createMaterials(device, scene, passCount) {
		for (let pass = 0; pass < passCount; pass++) {
			if (!this.passMaterials[pass]) {
				this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
			}
		}

		if (!this.ambientAOMaterial) {
			this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);

			this.ambientAOMaterial.onUpdateShader = function (options) {
				options.lightMapWithoutAmbient = true;
				options.separateAmbient = true;
				return options;
			};
		}
	}

	createTexture(size, type, name) {
		const tex = new Texture(this.device, {
			width: size,
			height: size,
			format: PIXELFORMAT_R8_G8_B8_A8,
			mipmaps: false,
			type: type,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		tex.name = name;
		return tex;
	}

	collectModels(node, bakeNodes, allNodes) {
		var _node$model, _node$model2, _node$render;

		if (!node.enabled) return;
		let meshInstances;

		if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {
			if (allNodes) allNodes.push(new BakeMeshNode(node));

			if (node.model.lightmapped) {
				if (bakeNodes) {
					meshInstances = node.model.model.meshInstances;
				}
			}
		}

		if ((_node$render = node.render) != null && _node$render.enabled) {
			if (allNodes) allNodes.push(new BakeMeshNode(node));

			if (node.render.lightmapped) {
				if (bakeNodes) {
					meshInstances = node.render.meshInstances;
				}
			}
		}

		if (meshInstances) {
			let hasUv1 = true;

			for (let i = 0; i < meshInstances.length; i++) {
				if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
					hasUv1 = false;
					break;
				}
			}

			if (hasUv1) {
				const notInstancedMeshInstances = [];

				for (let i = 0; i < meshInstances.length; i++) {
					const mesh = meshInstances[i].mesh;

					if (this._tempSet.has(mesh)) {
						bakeNodes.push(new BakeMeshNode(node, [meshInstances[i]]));
					} else {
						notInstancedMeshInstances.push(meshInstances[i]);
					}

					this._tempSet.add(mesh);
				}

				this._tempSet.clear();

				if (notInstancedMeshInstances.length > 0) {
					bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
				}
			}
		}

		for (let i = 0; i < node._children.length; i++) {
			this.collectModels(node._children[i], bakeNodes, allNodes);
		}
	}

	prepareShadowCasters(nodes) {
		const casters = [];

		for (let n = 0; n < nodes.length; n++) {
			const component = nodes[n].component;
			component.castShadows = component.castShadowsLightmap;

			if (component.castShadowsLightmap) {
				const meshes = nodes[n].meshInstances;

				for (let i = 0; i < meshes.length; i++) {
					meshes[i].visibleThisFrame = true;
					casters.push(meshes[i]);
				}
			}
		}

		return casters;
	}

	updateTransforms(nodes) {
		for (let i = 0; i < nodes.length; i++) {
			const meshInstances = nodes[i].meshInstances;

			for (let j = 0; j < meshInstances.length; j++) {
				meshInstances[j].node.getWorldTransform();
			}
		}
	}

	calculateLightmapSize(node) {
		let data;
		const sizeMult = this.scene.lightmapSizeMultiplier || 16;
		const scale = tempVec;
		let srcArea, lightmapSizeMultiplier;

		if (node.model) {
			lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;

			if (node.model.asset) {
				data = this.assets.get(node.model.asset).data;

				if (data.area) {
					srcArea = data.area;
				}
			} else if (node.model._area) {
				data = node.model;

				if (data._area) {
					srcArea = data._area;
				}
			}
		} else if (node.render) {
			lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;

			if (node.render.type !== 'asset') {
				if (node.render._area) {
					data = node.render;

					if (data._area) {
						srcArea = data._area;
					}
				}
			}
		}

		const area = {
			x: 1,
			y: 1,
			z: 1,
			uv: 1
		};

		if (srcArea) {
			area.x = srcArea.x;
			area.y = srcArea.y;
			area.z = srcArea.z;
			area.uv = srcArea.uv;
		}

		const areaMult = lightmapSizeMultiplier || 1;
		area.x *= areaMult;
		area.y *= areaMult;
		area.z *= areaMult;
		const component = node.render || node.model;
		const bounds = this.computeNodeBounds(component.meshInstances);
		scale.copy(bounds.halfExtents);
		let totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
		totalArea /= area.uv;
		totalArea = Math.sqrt(totalArea);
		const lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
		return lightmapSize;
	}

	setLightmapping(nodes, value, passCount, shaderDefs) {
		for (let i = 0; i < nodes.length; i++) {
			const node = nodes[i];
			const meshInstances = node.meshInstances;

			for (let j = 0; j < meshInstances.length; j++) {
				const meshInstance = meshInstances[j];
				meshInstance.setLightmapped(value);

				if (value) {
					if (shaderDefs) {
						meshInstance._shaderDefs |= shaderDefs;
					}

					meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;

					for (let pass = 0; pass < passCount; pass++) {
						const tex = node.renderTargets[pass].colorBuffer;
						tex.minFilter = FILTER_LINEAR;
						tex.magFilter = FILTER_LINEAR;
						meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
					}
				}
			}
		}
	}

	bake(nodes, mode = BAKE_COLORDIR) {
		const device = this.device;
		const startTime = now();

		this.scene._updateSkybox(device);

		this.stats.renderPasses = 0;
		this.stats.shadowMapTime = 0;
		this.stats.forwardTime = 0;
		const startShaders = device._shaderStats.linked;
		const startFboTime = device._renderTargetCreationTime;
		const startCompileTime = device._shaderStats.compileTime;
		const bakeNodes = [];
		const allNodes = [];

		if (nodes) {
			for (let i = 0; i < nodes.length; i++) {
				this.collectModels(nodes[i], bakeNodes, null);
			}

			this.collectModels(this.root, null, allNodes);
		} else {
			this.collectModels(this.root, bakeNodes, allNodes);
		}

		if (bakeNodes.length > 0) {
			const passCount = mode === BAKE_COLORDIR ? 2 : 1;
			this.setLightmapping(bakeNodes, false, passCount);
			this.initBake(device);
			this.bakeInternal(passCount, bakeNodes, allNodes);
			let shaderDefs = SHADERDEF_LM;

			if (mode === BAKE_COLORDIR) {
				shaderDefs |= SHADERDEF_DIRLM;
			}

			if (this.scene.ambientBake) {
				shaderDefs |= SHADERDEF_LMAMBIENT;
			}

			this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
			this.finishBake(bakeNodes);
		}

		const nowTime = now();
		this.stats.totalRenderTime = nowTime - startTime;
		this.stats.shadersLinked = device._shaderStats.linked - startShaders;
		this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
		this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
		this.stats.lightmapCount = bakeNodes.length;
	}

	allocateTextures(bakeNodes, passCount) {
		for (let i = 0; i < bakeNodes.length; i++) {
			const bakeNode = bakeNodes[i];
			const size = this.calculateLightmapSize(bakeNode.node);

			for (let pass = 0; pass < passCount; pass++) {
				const tex = this.createTexture(size, TEXTURETYPE_DEFAULT, "lightmapper_lightmap_" + i);
				LightmapCache.incRef(tex);
				bakeNode.renderTargets[pass] = new RenderTarget({
					colorBuffer: tex,
					depth: false
				});
			}

			if (!this.renderTargets.has(size)) {
				const tex = this.createTexture(size, TEXTURETYPE_DEFAULT, "lightmapper_temp_lightmap_" + size);
				LightmapCache.incRef(tex);
				this.renderTargets.set(size, new RenderTarget({
					colorBuffer: tex,
					depth: false
				}));
			}
		}
	}

	prepareLightsToBake(layerComposition, allLights, bakeLights) {
		if (this.scene.ambientBake) {
			const ambientLight = new BakeLightAmbient(this.scene);
			bakeLights.push(ambientLight);
		}

		const sceneLights = layerComposition._lights;

		for (let i = 0; i < sceneLights.length; i++) {
			const light = sceneLights[i];
			const bakeLight = new BakeLightSimple(this.scene, light);
			allLights.push(bakeLight);

			if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
				light.isStatic = false;
				light.mask = 0xFFFFFFFF;
				light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
				bakeLights.push(bakeLight);
			}
		}

		bakeLights.sort();
	}

	restoreLights(allLights) {
		for (let i = 0; i < allLights.length; i++) {
			allLights[i].restore();
		}
	}

	setupScene() {
		this.revertStatic = false;

		if (this.scene._needsStaticPrepare) {
			this.scene._needsStaticPrepare = false;
			this.revertStatic = true;
		}

		this.fog = this.scene.fog;
		this.ambientLight.copy(this.scene.ambientLight);
		this.scene.fog = FOG_NONE;

		if (!this.scene.ambientBake) {
			this.scene.ambientLight.set(0, 0, 0);
		}

		this.renderer.setSceneConstants();
	}

	restoreScene() {
		this.scene.fog = this.fog;
		this.scene.ambientLight.copy(this.ambientLight);

		if (this.revertStatic) {
			this.scene._needsStaticPrepare = true;
		}
	}

	computeNodeBounds(meshInstances) {
		const bounds = new BoundingBox();

		if (meshInstances.length > 0) {
			bounds.copy(meshInstances[0].aabb);

			for (let m = 1; m < meshInstances.length; m++) {
				bounds.add(meshInstances[m].aabb);
			}
		}

		return bounds;
	}

	computeNodesBounds(nodes) {
		for (let i = 0; i < nodes.length; i++) {
			const meshInstances = nodes[i].meshInstances;
			nodes[i].bounds = this.computeNodeBounds(meshInstances);
		}
	}

	computeBounds(meshInstances) {
		const bounds = new BoundingBox();

		for (let i = 0; i < meshInstances.length; i++) {
			bounds.copy(meshInstances[0].aabb);

			for (let m = 1; m < meshInstances.length; m++) {
				bounds.add(meshInstances[m].aabb);
			}
		}

		return bounds;
	}

	backupMaterials(meshInstances) {
		for (let i = 0; i < meshInstances.length; i++) {
			this.materials[i] = meshInstances[i].material;
		}
	}

	restoreMaterials(meshInstances) {
		for (let i = 0; i < meshInstances.length; i++) {
			meshInstances[i].material = this.materials[i];
		}
	}

	lightCameraPrepare(device, bakeLight) {
		const light = bakeLight.light;
		let shadowCam;

		if (light.type === LIGHTTYPE_SPOT) {
			const lightRenderData = light.getRenderData(null, 0);
			shadowCam = lightRenderData.shadowCamera;

			shadowCam._node.setPosition(light._node.getPosition());

			shadowCam._node.setRotation(light._node.getRotation());

			shadowCam._node.rotateLocal(-90, 0, 0);

			shadowCam.projection = PROJECTION_PERSPECTIVE;
			shadowCam.nearClip = light.attenuationEnd / 1000;
			shadowCam.farClip = light.attenuationEnd;
			shadowCam.aspectRatio = 1;
			shadowCam.fov = light._outerConeAngle * 2;
			this.renderer.updateCameraFrustum(shadowCam);
		}

		return shadowCam;
	}

	lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
		const light = bakeLight.light;
		let lightAffectsNode = true;

		if (light.type === LIGHTTYPE_DIRECTIONAL) {
			tempVec.copy(casterBounds.center);
			tempVec.y += casterBounds.halfExtents.y;
			this.camera.node.setPosition(tempVec);
			this.camera.node.setEulerAngles(-90, 0, 0);
			this.camera.nearClip = 0;
			this.camera.farClip = casterBounds.halfExtents.y * 2;
			const frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
			this.camera.orthoHeight = frustumSize;
		} else {
			if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
				lightAffectsNode = false;
			}
		}

		if (light.type === LIGHTTYPE_SPOT) {
			let nodeVisible = false;
			const meshInstances = bakeNode.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				if (meshInstances[i]._isVisible(shadowCam)) {
					nodeVisible = true;
					break;
				}
			}

			if (!nodeVisible) {
				lightAffectsNode = false;
			}
		}

		return lightAffectsNode;
	}

	setupLightArray(lightArray, light) {
		lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
		lightArray[LIGHTTYPE_OMNI].length = 0;
		lightArray[LIGHTTYPE_SPOT].length = 0;
		lightArray[light.type][0] = light;
		light.visibleThisFrame = true;
	}

	renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight) {
		const light = bakeLight.light;

		if (!shadowMapRendered && light.castShadows) {
			if (!light.shadowMap && !this.scene.clusteredLightingEnabled) {
				light.shadowMap = this.shadowMapCache.get(this.device, light);
			}

			if (light.type === LIGHTTYPE_DIRECTIONAL) {
				this.renderer._shadowRenderer.cullDirectional(light, casters, this.camera);
			} else {
				this.renderer._shadowRenderer.cullLocal(light, casters);
			}

			this.renderer.renderShadows(lightArray[light.type], this.camera);
		}

		return true;
	}

	postprocessTextures(device, bakeNodes, passCount) {
		const numDilates2x = 1;
		const dilateShader = this.lightmapFilters.shaderDilate;
		const filterLightmap = this.scene.lightmapFilterEnabled;

		if (filterLightmap) {
			this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
		}

		for (let node = 0; node < bakeNodes.length; node++) {
			const bakeNode = bakeNodes[node];

			for (let pass = 0; pass < passCount; pass++) {
				const nodeRT = bakeNode.renderTargets[pass];
				const lightmap = nodeRT.colorBuffer;
				const tempRT = this.renderTargets.get(lightmap.width);
				const tempTex = tempRT.colorBuffer;
				this.lightmapFilters.prepare(lightmap.width, lightmap.height);

				for (let i = 0; i < numDilates2x; i++) {
					this.lightmapFilters.setSourceTexture(lightmap);
					const bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
					drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);
					this.lightmapFilters.setSourceTexture(tempTex);
					drawQuadWithShader(device, nodeRT, dilateShader);
				}
			}
		}
	}

	bakeInternal(passCount, bakeNodes, allNodes) {
		const scene = this.scene;
		const device = this.device;
		const clusteredLightingEnabled = scene.clusteredLightingEnabled;
		this.createMaterials(device, scene, passCount);
		this.setupScene();

		scene.layers._update();

		this.computeNodesBounds(bakeNodes);
		this.allocateTextures(bakeNodes, passCount);
		const allLights = [],
					bakeLights = [];
		this.prepareLightsToBake(scene.layers, allLights, bakeLights);
		this.updateTransforms(allNodes);
		const casters = this.prepareShadowCasters(allNodes);
		this.renderer.updateCpuSkinMatrices(casters);
		this.renderer.gpuUpdate(casters);
		const casterBounds = this.computeBounds(casters);
		let i, j, rcv, m;

		for (i = 0; i < bakeNodes.length; i++) {
			const bakeNode = bakeNodes[i];
			rcv = bakeNode.meshInstances;

			for (j = 0; j < rcv.length; j++) {
				m = rcv[j];
				m.setLightmapped(false);
				m.mask = MASK_BAKE;
				m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);
				m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
			}
		}

		for (j = 0; j < bakeLights.length; j++) {
			bakeLights[j].light.enabled = false;
		}

		const lightArray = [[], [], []];
		let pass, node;
		let shadersUpdatedOn1stPass = false;

		for (i = 0; i < bakeLights.length; i++) {
			const bakeLight = bakeLights[i];
			const isAmbientLight = bakeLight instanceof BakeLightAmbient;
			let numVirtualLights = bakeLight.numVirtualLights;

			if (passCount > 1 && numVirtualLights > 1) {
				numVirtualLights = 1;
			}

			for (let virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {
				if (numVirtualLights > 1) {
					bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
				}

				bakeLight.startBake();
				let shadowMapRendered = false;
				const shadowCam = this.lightCameraPrepare(device, bakeLight);

				for (node = 0; node < bakeNodes.length; node++) {
					const bakeNode = bakeNodes[node];
					rcv = bakeNode.meshInstances;
					const lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds);

					if (!lightAffectsNode) {
						continue;
					}

					this.setupLightArray(lightArray, bakeLight.light);

					if (clusteredLightingEnabled) {
						this.renderer.lightTextureAtlas.update(lightArray[LIGHTTYPE_SPOT], lightArray[LIGHTTYPE_OMNI], this.lightingParams);
					}

					shadowMapRendered = this.renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight);

					if (clusteredLightingEnabled) {
						const clusterLights = lightArray[LIGHTTYPE_SPOT].concat(lightArray[LIGHTTYPE_OMNI]);
						this.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);
					}

					this.backupMaterials(rcv);

					for (pass = 0; pass < passCount; pass++) {
						if (pass > 0 && virtualLightIndex > 0) {
							break;
						}

						if (isAmbientLight && pass > 0) {
							break;
						}

						const nodeRT = bakeNode.renderTargets[pass];
						const lightmapSize = bakeNode.renderTargets[pass].colorBuffer.width;
						const tempRT = this.renderTargets.get(lightmapSize);
						const tempTex = tempRT.colorBuffer;

						if (pass === 0) {
							shadersUpdatedOn1stPass = scene.updateShaders;
						} else if (shadersUpdatedOn1stPass) {
							scene.updateShaders = true;
						}

						let passMaterial = this.passMaterials[pass];

						if (isAmbientLight) {
							const lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;

							if (lastVirtualLightForPass && pass === 0) {
								passMaterial = this.ambientAOMaterial;
							}
						}

						for (j = 0; j < rcv.length; j++) {
							rcv[j].material = passMaterial;
						}

						this.renderer.updateShaders(rcv);
						this.renderer.setCamera(this.camera, tempRT, true);

						if (pass === PASS_DIR) {
							this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
						}

						if (clusteredLightingEnabled) {
							this.worldClusters.activate(this.renderer.lightTextureAtlas);
						}

						this.renderer._forwardTime = 0;
						this.renderer._shadowMapTime = 0;
						this.renderer.renderForward(this.camera, rcv, rcv.length, lightArray, SHADER_FORWARDHDR);
						bakeNode.renderTargets[pass] = tempRT;
						this.renderTargets.set(lightmapSize, nodeRT);

						for (j = 0; j < rcv.length; j++) {
							m = rcv[j];
							m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
							m._shaderDefs |= SHADERDEF_LM;
						}
					}

					this.restoreMaterials(rcv);
				}

				bakeLight.endBake(this.shadowMapCache);
			}
		}

		this.postprocessTextures(device, bakeNodes, passCount);

		for (node = 0; node < allNodes.length; node++) {
			allNodes[node].restore();
		}

		this.restoreLights(allLights);
		this.restoreScene();

		if (!clusteredLightingEnabled) {
			this.shadowMapCache.clear();
		}
	}

}

const reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

function createScript(name, app) {
	if (script.legacy) {
		return null;
	}

	if (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);

	const scriptType = function scriptType(args) {
		EventHandler.prototype.initEventHandler.call(this);
		ScriptType.prototype.initScriptType.call(this, args);
	};

	scriptType.prototype = Object.create(ScriptType.prototype);
	scriptType.prototype.constructor = scriptType;
	scriptType.extend = ScriptType.extend;
	scriptType.attributes = new ScriptAttributes(scriptType);
	registerScript(scriptType, name, app);
	return scriptType;
}

const reservedAttributes = {};
ScriptAttributes.reservedNames.forEach((value, value2, set) => {
	reservedAttributes[value] = 1;
});
createScript.reservedAttributes = reservedAttributes;

function registerScript(script, name, app) {
	if (script.legacy) {
		return;
	}

	if (typeof script !== 'function') throw new Error(`script class: '${script}' must be a constructor function (i.e. class).`);
	if (!(script.prototype instanceof ScriptType)) throw new Error(`script class: '${ScriptType.__getScriptName(script)}' does not extend pc.ScriptType.`);
	name = name || script.__name || ScriptType.__getScriptName(script);
	if (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);
	script.__name = name;
	const registry = app ? app.scripts : Application.getApplication().scripts;
	registry.add(script);

	ScriptHandler._push(script);
}

function isMousePointerLocked() {
	return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
}

class MouseEvent$1 {
	constructor(mouse, event) {
		let coords = {
			x: 0,
			y: 0
		};

		if (event) {
			if (event instanceof MouseEvent$1) {
				throw Error("Expected MouseEvent");
			}

			coords = mouse._getTargetCoords(event);
		} else {
			event = {};
		}

		if (coords) {
			this.x = coords.x;
			this.y = coords.y;
		} else if (isMousePointerLocked()) {
			this.x = 0;
			this.y = 0;
		} else {
			return;
		}

		this.wheelDelta = 0;

		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}

		if (isMousePointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = this.x - mouse._lastX;
			this.dy = this.y - mouse._lastY;
		}

		if (event.type === 'mousedown' || event.type === 'mouseup') {
			this.button = event.button;
		} else {
			this.button = MOUSEBUTTON_NONE;
		}

		this.buttons = mouse._buttons.slice(0);
		this.element = event.target;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.event = event;
	}

}

class Mouse extends EventHandler {
	constructor(element) {
		super();
		this._lastX = 0;
		this._lastY = 0;
		this._buttons = [false, false, false];
		this._lastbuttons = [false, false, false];
		this._upHandler = this._handleUp.bind(this);
		this._downHandler = this._handleDown.bind(this);
		this._moveHandler = this._handleMove.bind(this);
		this._wheelHandler = this._handleWheel.bind(this);

		this._contextMenuHandler = event => {
			event.preventDefault();
		};

		this._target = null;
		this._attached = false;
		this.attach(element);
	}

	static isPointerLocked() {
		return isMousePointerLocked();
	}

	attach(element) {
		this._target = element;
		if (this._attached) return;
		this._attached = true;
		const opts = platform.passiveEvents ? {
			passive: false
		} : false;
		window.addEventListener("mouseup", this._upHandler, opts);
		window.addEventListener("mousedown", this._downHandler, opts);
		window.addEventListener("mousemove", this._moveHandler, opts);
		window.addEventListener("wheel", this._wheelHandler, opts);
	}

	detach() {
		if (!this._attached) return;
		this._attached = false;
		this._target = null;
		const opts = platform.passiveEvents ? {
			passive: false
		} : false;
		window.removeEventListener("mouseup", this._upHandler, opts);
		window.removeEventListener("mousedown", this._downHandler, opts);
		window.removeEventListener("mousemove", this._moveHandler, opts);
		window.removeEventListener("wheel", this._wheelHandler, opts);
	}

	disableContextMenu() {
		if (!this._target) return;

		this._target.addEventListener("contextmenu", this._contextMenuHandler);
	}

	enableContextMenu() {
		if (!this._target) return;

		this._target.removeEventListener("contextmenu", this._contextMenuHandler);
	}

	enablePointerLock(success, error) {
		if (!document.body.requestPointerLock) {
			if (error) error();
			return;
		}

		const s = () => {
			success();
			document.removeEventListener('pointerlockchange', s);
		};

		const e = () => {
			error();
			document.removeEventListener('pointerlockerror', e);
		};

		if (success) {
			document.addEventListener('pointerlockchange', s, false);
		}

		if (error) {
			document.addEventListener('pointerlockerror', e, false);
		}

		document.body.requestPointerLock();
	}

	disablePointerLock(success) {
		if (!document.exitPointerLock) {
			return;
		}

		const s = () => {
			success();
			document.removeEventListener('pointerlockchange', s);
		};

		if (success) {
			document.addEventListener('pointerlockchange', s, false);
		}

		document.exitPointerLock();
	}

	update() {
		this._lastbuttons[0] = this._buttons[0];
		this._lastbuttons[1] = this._buttons[1];
		this._lastbuttons[2] = this._buttons[2];
	}

	isPressed(button) {
		return this._buttons[button];
	}

	wasPressed(button) {
		return this._buttons[button] && !this._lastbuttons[button];
	}

	wasReleased(button) {
		return !this._buttons[button] && this._lastbuttons[button];
	}

	_handleUp(event) {
		this._buttons[event.button] = false;
		const e = new MouseEvent$1(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEUP, e);
	}

	_handleDown(event) {
		this._buttons[event.button] = true;
		const e = new MouseEvent$1(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEDOWN, e);
	}

	_handleMove(event) {
		const e = new MouseEvent$1(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEMOVE, e);
		this._lastX = e.x;
		this._lastY = e.y;
	}

	_handleWheel(event) {
		const e = new MouseEvent$1(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEWHEEL, e);
	}

	_getTargetCoords(event) {
		const rect = this._target.getBoundingClientRect();

		const left = Math.floor(rect.left);
		const top = Math.floor(rect.top);

		if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
			return null;
		}

		return {
			x: event.clientX - left,
			y: event.clientY - top
		};
	}

}

let targetX, targetY;
const vecA = new Vec3();
const vecB = new Vec3();
const rayA = new Ray();
const rayB = new Ray();
const rayC = new Ray();
rayA.end = new Vec3();
rayB.end = new Vec3();
rayC.end = new Vec3();

const _pq = new Vec3();

const _pa = new Vec3();

const _pb = new Vec3();

const _pc = new Vec3();

const _pd = new Vec3();

const _m = new Vec3();

const _au = new Vec3();

const _bv = new Vec3();

const _cw = new Vec3();

const _ir = new Vec3();

const _sct = new Vec3();

const _accumulatedScale = new Vec3();

const _paddingTop = new Vec3();

const _paddingBottom = new Vec3();

const _paddingLeft = new Vec3();

const _paddingRight = new Vec3();

const _cornerBottomLeft = new Vec3();

const _cornerBottomRight = new Vec3();

const _cornerTopRight = new Vec3();

const _cornerTopLeft = new Vec3();

const ZERO_VEC4 = new Vec4();

function scalarTriple(p1, p2, p3) {
	return _sct.cross(p1, p2).dot(p3);
}

function intersectLineQuad(p, q, corners) {
	_pq.sub2(q, p);

	_pa.sub2(corners[0], p);

	_pb.sub2(corners[1], p);

	_pc.sub2(corners[2], p);

	_m.cross(_pc, _pq);

	let v = _pa.dot(_m);

	let u;
	let w;

	if (v >= 0) {
		u = -_pb.dot(_m);
		if (u < 0) return -1;
		w = scalarTriple(_pq, _pb, _pa);
		if (w < 0) return -1;
		const denom = 1.0 / (u + v + w);

		_au.copy(corners[0]).mulScalar(u * denom);

		_bv.copy(corners[1]).mulScalar(v * denom);

		_cw.copy(corners[2]).mulScalar(w * denom);

		_ir.copy(_au).add(_bv).add(_cw);
	} else {
		_pd.sub2(corners[3], p);

		u = _pd.dot(_m);
		if (u < 0) return -1;
		w = scalarTriple(_pq, _pa, _pd);
		if (w < 0) return -1;
		v = -v;
		const denom = 1.0 / (u + v + w);

		_au.copy(corners[0]).mulScalar(u * denom);

		_bv.copy(corners[3]).mulScalar(v * denom);

		_cw.copy(corners[2]).mulScalar(w * denom);

		_ir.copy(_au).add(_bv).add(_cw);
	}

	if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;
	if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;
	return _ir.sub(p).lengthSq();
}

class ElementInputEvent {
	constructor(event, element, camera) {
		this.event = event;
		this.element = element;
		this.camera = camera;
		this._stopPropagation = false;
	}

	stopPropagation() {
		this._stopPropagation = true;

		if (this.event) {
			this.event.stopImmediatePropagation();
			this.event.stopPropagation();
		}
	}

}

class ElementMouseEvent extends ElementInputEvent {
	constructor(event, element, camera, x, y, lastX, lastY) {
		super(event, element, camera);
		this.x = x;
		this.y = y;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.button = event.button;

		if (Mouse.isPointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = x - lastX;
			this.dy = y - lastY;
		}

		this.wheelDelta = 0;

		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}
	}

}

class ElementTouchEvent extends ElementInputEvent {
	constructor(event, element, camera, x, y, touch) {
		super(event, element, camera);
		this.touches = event.touches;
		this.changedTouches = event.changedTouches;
		this.x = x;
		this.y = y;
		this.touch = touch;
	}

}

class ElementSelectEvent extends ElementInputEvent {
	constructor(event, element, camera, inputSource) {
		super(event, element, camera);
		this.inputSource = inputSource;
	}

}

class ElementInput {
	constructor(domElement, options) {
		this._app = null;
		this._attached = false;
		this._target = null;
		this._enabled = true;
		this._lastX = 0;
		this._lastY = 0;
		this._upHandler = this._handleUp.bind(this);
		this._downHandler = this._handleDown.bind(this);
		this._moveHandler = this._handleMove.bind(this);
		this._wheelHandler = this._handleWheel.bind(this);
		this._touchstartHandler = this._handleTouchStart.bind(this);
		this._touchendHandler = this._handleTouchEnd.bind(this);
		this._touchcancelHandler = this._touchendHandler;
		this._touchmoveHandler = this._handleTouchMove.bind(this);
		this._sortHandler = this._sortElements.bind(this);
		this._elements = [];
		this._hoveredElement = null;
		this._pressedElement = null;
		this._touchedElements = {};
		this._touchesForWhichTouchLeaveHasFired = {};
		this._selectedElements = {};
		this._selectedPressedElements = {};
		this._useMouse = !options || options.useMouse !== false;
		this._useTouch = !options || options.useTouch !== false;
		this._useXr = !options || options.useXr !== false;
		this._selectEventsAttached = false;
		if (platform.touch) this._clickedEntities = {};
		this.attach(domElement);
	}

	set enabled(value) {
		this._enabled = value;
	}

	get enabled() {
		return this._enabled;
	}

	set app(value) {
		this._app = value;
	}

	get app() {
		return this._app || getApplication();
	}

	attach(domElement) {
		if (this._attached) {
			this._attached = false;
			this.detach();
		}

		this._target = domElement;
		this._attached = true;
		const opts = platform.passiveEvents ? {
			passive: true
		} : false;

		if (this._useMouse) {
			window.addEventListener('mouseup', this._upHandler, opts);
			window.addEventListener('mousedown', this._downHandler, opts);
			window.addEventListener('mousemove', this._moveHandler, opts);
			window.addEventListener('wheel', this._wheelHandler, opts);
		}

		if (this._useTouch && platform.touch) {
			this._target.addEventListener('touchstart', this._touchstartHandler, opts);

			this._target.addEventListener('touchend', this._touchendHandler, false);

			this._target.addEventListener('touchmove', this._touchmoveHandler, false);

			this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
		}

		this.attachSelectEvents();
	}

	attachSelectEvents() {
		if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
			if (!this._clickedEntities) this._clickedEntities = {};
			this._selectEventsAttached = true;
			this.app.xr.on('start', this._onXrStart, this);
		}
	}

	detach() {
		if (!this._attached) return;
		this._attached = false;
		const opts = platform.passiveEvents ? {
			passive: true
		} : false;

		if (this._useMouse) {
			window.removeEventListener('mouseup', this._upHandler, opts);
			window.removeEventListener('mousedown', this._downHandler, opts);
			window.removeEventListener('mousemove', this._moveHandler, opts);
			window.removeEventListener('wheel', this._wheelHandler, opts);
		}

		if (this._useTouch) {
			this._target.removeEventListener('touchstart', this._touchstartHandler, opts);

			this._target.removeEventListener('touchend', this._touchendHandler, false);

			this._target.removeEventListener('touchmove', this._touchmoveHandler, false);

			this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
		}

		if (this._selectEventsAttached) {
			this._selectEventsAttached = false;
			this.app.xr.off('start', this._onXrStart, this);
			this.app.xr.off('end', this._onXrEnd, this);
			this.app.xr.off('update', this._onXrUpdate, this);
			this.app.xr.input.off('selectstart', this._onSelectStart, this);
			this.app.xr.input.off('selectend', this._onSelectEnd, this);
			this.app.xr.input.off('remove', this._onXrInputRemove, this);
		}

		this._target = null;
	}

	addElement(element) {
		if (this._elements.indexOf(element) === -1) this._elements.push(element);
	}

	removeElement(element) {
		const idx = this._elements.indexOf(element);

		if (idx !== -1) this._elements.splice(idx, 1);
	}

	_handleUp(event) {
		if (!this._enabled) return;
		if (Mouse.isPointerLocked()) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mouseup', event);
	}

	_handleDown(event) {
		if (!this._enabled) return;
		if (Mouse.isPointerLocked()) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mousedown', event);
	}

	_handleMove(event) {
		if (!this._enabled) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mousemove', event);

		this._lastX = targetX;
		this._lastY = targetY;
	}

	_handleWheel(event) {
		if (!this._enabled) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mousewheel', event);
	}

	_determineTouchedElements(event) {
		const touchedElements = {};
		const cameras = this.app.systems.camera.cameras;

		for (let i = cameras.length - 1; i >= 0; i--) {
			const camera = cameras[i];
			let done = 0;
			const len = event.changedTouches.length;

			for (let j = 0; j < len; j++) {
				if (touchedElements[event.changedTouches[j].identifier]) {
					done++;
					continue;
				}

				const coords = this._calcTouchCoords(event.changedTouches[j]);

				const element = this._getTargetElement(camera, coords.x, coords.y);

				if (element) {
					done++;
					touchedElements[event.changedTouches[j].identifier] = {
						element: element,
						camera: camera,
						x: coords.x,
						y: coords.y
					};
				}
			}

			if (done === len) {
				break;
			}
		}

		return touchedElements;
	}

	_handleTouchStart(event) {
		if (!this._enabled) return;

		const newTouchedElements = this._determineTouchedElements(event);

		for (let i = 0, len = event.changedTouches.length; i < len; i++) {
			const touch = event.changedTouches[i];
			const newTouchInfo = newTouchedElements[touch.identifier];
			const oldTouchInfo = this._touchedElements[touch.identifier];

			if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
				this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));

				this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
			}
		}

		for (const touchId in newTouchedElements) {
			this._touchedElements[touchId] = newTouchedElements[touchId];
		}
	}

	_handleTouchEnd(event) {
		if (!this._enabled) return;
		const cameras = this.app.systems.camera.cameras;

		for (const key in this._clickedEntities) {
			delete this._clickedEntities[key];
		}

		for (let i = 0, len = event.changedTouches.length; i < len; i++) {
			const touch = event.changedTouches[i];
			const touchInfo = this._touchedElements[touch.identifier];
			if (!touchInfo) continue;
			const element = touchInfo.element;
			const camera = touchInfo.camera;
			const x = touchInfo.x;
			const y = touchInfo.y;
			delete this._touchedElements[touch.identifier];
			delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];

			this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));

			if (event.touches.length === 0) {
				const coords = this._calcTouchCoords(touch);

				for (let c = cameras.length - 1; c >= 0; c--) {
					const hovered = this._getTargetElement(cameras[c], coords.x, coords.y);

					if (hovered === element) {
						if (!this._clickedEntities[element.entity.getGuid()]) {
							this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));

							this._clickedEntities[element.entity.getGuid()] = true;
						}
					}
				}
			}
		}
	}

	_handleTouchMove(event) {
		event.preventDefault();
		if (!this._enabled) return;

		const newTouchedElements = this._determineTouchedElements(event);

		for (let i = 0, len = event.changedTouches.length; i < len; i++) {
			const touch = event.changedTouches[i];
			const newTouchInfo = newTouchedElements[touch.identifier];
			const oldTouchInfo = this._touchedElements[touch.identifier];

			if (oldTouchInfo) {
				const coords = this._calcTouchCoords(touch);

				if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
					this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));

					this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
				}

				this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
			}
		}
	}

	_onElementMouseEvent(eventType, event) {
		let element;
		const hovered = this._hoveredElement;
		this._hoveredElement = null;
		const cameras = this.app.systems.camera.cameras;
		let camera;

		for (let i = cameras.length - 1; i >= 0; i--) {
			camera = cameras[i];
			element = this._getTargetElement(camera, targetX, targetY);
			if (element) break;
		}

		if (element) {
			this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));

			this._hoveredElement = element;

			if (eventType === 'mousedown') {
				this._pressedElement = element;
			}
		}

		if (hovered !== this._hoveredElement) {
			if (hovered) {
				this._fireEvent('mouseleave', new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));
			}

			if (this._hoveredElement) {
				this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
			}
		}

		if (eventType === 'mouseup' && this._pressedElement) {
			if (this._pressedElement === this._hoveredElement) {
				this._pressedElement = null;

				if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
					this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
				}
			} else {
				this._pressedElement = null;
			}
		}
	}

	_onXrStart() {
		this.app.xr.on('end', this._onXrEnd, this);
		this.app.xr.on('update', this._onXrUpdate, this);
		this.app.xr.input.on('selectstart', this._onSelectStart, this);
		this.app.xr.input.on('selectend', this._onSelectEnd, this);
		this.app.xr.input.on('remove', this._onXrInputRemove, this);
	}

	_onXrEnd() {
		this.app.xr.off('update', this._onXrUpdate, this);
		this.app.xr.input.off('selectstart', this._onSelectStart, this);
		this.app.xr.input.off('selectend', this._onSelectEnd, this);
		this.app.xr.input.off('remove', this._onXrInputRemove, this);
	}

	_onXrUpdate() {
		if (!this._enabled) return;
		const inputSources = this.app.xr.input.inputSources;

		for (let i = 0; i < inputSources.length; i++) {
			this._onElementSelectEvent('selectmove', inputSources[i], null);
		}
	}

	_onXrInputRemove(inputSource) {
		const hovered = this._selectedElements[inputSource.id];

		if (hovered) {
			inputSource._elementEntity = null;

			this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
		}

		delete this._selectedElements[inputSource.id];
		delete this._selectedPressedElements[inputSource.id];
	}

	_onSelectStart(inputSource, event) {
		if (!this._enabled) return;

		this._onElementSelectEvent('selectstart', inputSource, event);
	}

	_onSelectEnd(inputSource, event) {
		if (!this._enabled) return;

		this._onElementSelectEvent('selectend', inputSource, event);
	}

	_onElementSelectEvent(eventType, inputSource, event) {
		let element;
		const hoveredBefore = this._selectedElements[inputSource.id];
		let hoveredNow;
		const cameras = this.app.systems.camera.cameras;
		let camera;

		if (inputSource.elementInput) {
			rayC.set(inputSource.getOrigin(), inputSource.getDirection());

			for (let i = cameras.length - 1; i >= 0; i--) {
				camera = cameras[i];
				element = this._getTargetElementByRay(rayC, camera);
				if (element) break;
			}
		}

		inputSource._elementEntity = element || null;

		if (element) {
			this._selectedElements[inputSource.id] = element;
			hoveredNow = element;
		} else {
			delete this._selectedElements[inputSource.id];
		}

		if (hoveredBefore !== hoveredNow) {
			if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
			if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
		}

		if (eventType === 'selectstart') {
			this._selectedPressedElements[inputSource.id] = hoveredNow;
			if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
		}

		const pressed = this._selectedPressedElements[inputSource.id];

		if (!inputSource.elementInput && pressed) {
			delete this._selectedPressedElements[inputSource.id];
			if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
		}

		if (eventType === 'selectend' && inputSource.elementInput) {
			delete this._selectedPressedElements[inputSource.id];
			if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));

			if (pressed && pressed === hoveredBefore) {
				this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
			}
		}
	}

	_fireEvent(name, evt) {
		let element = evt.element;

		while (true) {
			element.fire(name, evt);
			if (evt._stopPropagation) break;
			if (!element.entity.parent) break;
			element = element.entity.parent.element;
			if (!element) break;
		}
	}

	_calcMouseCoords(event) {
		const rect = this._target.getBoundingClientRect();

		const left = Math.floor(rect.left);
		const top = Math.floor(rect.top);

		if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
			targetX = null;
			targetY = null;
		} else {
			targetX = event.clientX - left;
			targetY = event.clientY - top;
		}
	}

	_calcTouchCoords(touch) {
		let totalOffsetX = 0;
		let totalOffsetY = 0;
		let target = touch.target;

		while (!(target instanceof HTMLElement)) {
			target = target.parentNode;
		}

		let currentElement = target;

		do {
			totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
			totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
			currentElement = currentElement.offsetParent;
		} while (currentElement);

		return {
			x: touch.pageX - totalOffsetX,
			y: touch.pageY - totalOffsetY
		};
	}

	_sortElements(a, b) {
		const layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
		if (layerOrder !== 0) return layerOrder;
		if (a.screen && !b.screen) return -1;
		if (!a.screen && b.screen) return 1;
		if (!a.screen && !b.screen) return 0;
		if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;
		if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;
		return b.drawOrder - a.drawOrder;
	}

	_getTargetElement(camera, x, y) {
		let result = null;
		let closestDistance3d = Infinity;

		this._elements.sort(this._sortHandler);

		let rayScreen, ray3d;

		for (let i = 0, len = this._elements.length; i < len; i++) {
			const element = this._elements[i];

			if (element.screen && element.screen.screen.screenSpace) {
				if (rayScreen === undefined) {
					rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;
				}

				if (!rayScreen) continue;

				const currentDistance = this._checkElement(rayScreen, element, true);

				if (currentDistance >= 0) {
					result = element;
					break;
				}
			} else {
				if (ray3d === undefined) {
					ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;
				}

				if (!ray3d) continue;

				const currentDistance = this._checkElement(ray3d, element, false);

				if (currentDistance >= 0) {
					if (currentDistance < closestDistance3d) {
						result = element;
						closestDistance3d = currentDistance;
					}

					if (element.screen) {
						result = element;
						break;
					}
				}
			}
		}

		return result;
	}

	_getTargetElementByRay(ray, camera) {
		let result = null;
		rayA.origin.copy(ray.origin);
		rayA.direction.copy(ray.direction);
		rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);

		this._elements.sort(this._sortHandler);

		for (let i = 0, len = this._elements.length; i < len; i++) {
			const element = this._elements[i];

			if (!element.screen || !element.screen.screen.screenSpace) {
				if (this._checkElement(rayA, element, false) >= 0) {
					result = element;
					break;
				}
			}
		}

		return result;
	}

	_buildHitCorners(element, screenOrWorldCorners, scaleX, scaleY, scaleZ) {
		let hitCorners = screenOrWorldCorners;
		const button = element.entity && element.entity.button;

		if (button) {
			const hitPadding = element.entity.button.hitPadding || ZERO_VEC4;

			_paddingTop.copy(element.entity.up);

			_paddingBottom.copy(_paddingTop).mulScalar(-1);

			_paddingRight.copy(element.entity.right);

			_paddingLeft.copy(_paddingRight).mulScalar(-1);

			_paddingTop.mulScalar(hitPadding.w * scaleY);

			_paddingBottom.mulScalar(hitPadding.y * scaleY);

			_paddingRight.mulScalar(hitPadding.z * scaleX);

			_paddingLeft.mulScalar(hitPadding.x * scaleX);

			_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);

			_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);

			_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);

			_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);

			hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
		}

		if (scaleX < 0) {
			const left = hitCorners[2].x;
			const right = hitCorners[0].x;
			hitCorners[0].x = left;
			hitCorners[1].x = right;
			hitCorners[2].x = right;
			hitCorners[3].x = left;
		}

		if (scaleY < 0) {
			const bottom = hitCorners[2].y;
			const top = hitCorners[0].y;
			hitCorners[0].y = bottom;
			hitCorners[1].y = bottom;
			hitCorners[2].y = top;
			hitCorners[3].y = top;
		}

		if (scaleZ < 0) {
			const x = hitCorners[2].x;
			const y = hitCorners[2].y;
			const z = hitCorners[2].z;
			hitCorners[2].x = hitCorners[0].x;
			hitCorners[2].y = hitCorners[0].y;
			hitCorners[2].z = hitCorners[0].z;
			hitCorners[0].x = x;
			hitCorners[0].y = y;
			hitCorners[0].z = z;
		}

		return hitCorners;
	}

	_calculateScaleToScreen(element) {
		let current = element.entity;
		const screenScale = element.screen.screen.scale;

		_accumulatedScale.set(screenScale, screenScale, screenScale);

		while (current && !current.screen) {
			_accumulatedScale.mul(current.getLocalScale());

			current = current.parent;
		}

		return _accumulatedScale;
	}

	_calculateScaleToWorld(element) {
		let current = element.entity;

		_accumulatedScale.set(1, 1, 1);

		while (current) {
			_accumulatedScale.mul(current.getLocalScale());

			current = current.parent;
		}

		return _accumulatedScale;
	}

	_calculateRayScreen(x, y, camera, ray) {
		const sw = this.app.graphicsDevice.width;
		const sh = this.app.graphicsDevice.height;
		const cameraWidth = camera.rect.z * sw;
		const cameraHeight = camera.rect.w * sh;
		const cameraLeft = camera.rect.x * sw;
		const cameraRight = cameraLeft + cameraWidth;
		const cameraBottom = (1 - camera.rect.y) * sh;
		const cameraTop = cameraBottom - cameraHeight;

		let _x = x * sw / this._target.clientWidth;

		let _y = y * sh / this._target.clientHeight;

		if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
			_x = sw * (_x - cameraLeft) / cameraWidth;
			_y = sh * (_y - cameraTop) / cameraHeight;
			_y = sh - _y;
			ray.origin.set(_x, _y, 1);
			ray.direction.set(0, 0, -1);
			ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
			return true;
		}

		return false;
	}

	_calculateRay3d(x, y, camera, ray) {
		const sw = this._target.clientWidth;
		const sh = this._target.clientHeight;
		const cameraWidth = camera.rect.z * sw;
		const cameraHeight = camera.rect.w * sh;
		const cameraLeft = camera.rect.x * sw;
		const cameraRight = cameraLeft + cameraWidth;
		const cameraBottom = (1 - camera.rect.y) * sh;
		const cameraTop = cameraBottom - cameraHeight;
		let _x = x;
		let _y = y;

		if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
			_x = sw * (_x - cameraLeft) / cameraWidth;
			_y = sh * (_y - cameraTop) / cameraHeight;
			camera.screenToWorld(_x, _y, camera.nearClip, vecA);
			camera.screenToWorld(_x, _y, camera.farClip, vecB);
			ray.origin.copy(vecA);
			ray.direction.set(0, 0, -1);
			ray.end.copy(vecB);
			return true;
		}

		return false;
	}

	_checkElement(ray, element, screen) {
		if (element.maskedBy) {
			if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
				return -1;
			}
		}

		let scale;

		if (screen) {
			scale = this._calculateScaleToScreen(element);
		} else {
			scale = this._calculateScaleToWorld(element);
		}

		const corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y, scale.z);

		return intersectLineQuad(ray.origin, ray.end, corners);
	}

}

function getTouchTargetCoords(touch) {
	let totalOffsetX = 0;
	let totalOffsetY = 0;
	let target = touch.target;

	while (!(target instanceof HTMLElement)) {
		target = target.parentNode;
	}

	let currentElement = target;

	do {
		totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
		totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
		currentElement = currentElement.offsetParent;
	} while (currentElement);

	return {
		x: touch.pageX - totalOffsetX,
		y: touch.pageY - totalOffsetY
	};
}

class Touch {
	constructor(touch) {
		const coords = getTouchTargetCoords(touch);
		this.id = touch.identifier;
		this.x = coords.x;
		this.y = coords.y;
		this.target = touch.target;
		this.touch = touch;
	}

}

class TouchEvent {
	constructor(device, event) {
		this.element = event.target;
		this.event = event;
		this.touches = [];
		this.changedTouches = [];

		if (event) {
			for (let i = 0, l = event.touches.length; i < l; i++) {
				this.touches.push(new Touch(event.touches[i]));
			}

			for (let i = 0, l = event.changedTouches.length; i < l; i++) {
				this.changedTouches.push(new Touch(event.changedTouches[i]));
			}
		}
	}

	getTouchById(id, list) {
		for (let i = 0, l = list.length; i < l; i++) {
			if (list[i].id === id) {
				return list[i];
			}
		}

		return null;
	}

}

class TouchDevice extends EventHandler {
	constructor(element) {
		super();
		this._element = null;
		this._startHandler = this._handleTouchStart.bind(this);
		this._endHandler = this._handleTouchEnd.bind(this);
		this._moveHandler = this._handleTouchMove.bind(this);
		this._cancelHandler = this._handleTouchCancel.bind(this);
		this.attach(element);
	}

	attach(element) {
		if (this._element) {
			this.detach();
		}

		this._element = element;

		this._element.addEventListener('touchstart', this._startHandler, false);

		this._element.addEventListener('touchend', this._endHandler, false);

		this._element.addEventListener('touchmove', this._moveHandler, false);

		this._element.addEventListener('touchcancel', this._cancelHandler, false);
	}

	detach() {
		if (this._element) {
			this._element.removeEventListener('touchstart', this._startHandler, false);

			this._element.removeEventListener('touchend', this._endHandler, false);

			this._element.removeEventListener('touchmove', this._moveHandler, false);

			this._element.removeEventListener('touchcancel', this._cancelHandler, false);
		}

		this._element = null;
	}

	_handleTouchStart(e) {
		this.fire('touchstart', new TouchEvent(this, e));
	}

	_handleTouchEnd(e) {
		this.fire('touchend', new TouchEvent(this, e));
	}

	_handleTouchMove(e) {
		e.preventDefault();
		this.fire('touchmove', new TouchEvent(this, e));
	}

	_handleTouchCancel(e) {
		this.fire('touchcancel', new TouchEvent(this, e));
	}

}

string.endsWith = function (s, subs) {
	return s.endsWith(subs);
};

string.startsWith = function (s, subs) {
	return s.startsWith(subs);
};
Object.defineProperty(Color.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(4);
		}

		this._data[0] = this.r;
		this._data[1] = this.g;
		this._data[2] = this.b;
		this._data[3] = this.a;
		return this._data;
	}
});
Object.defineProperty(Color.prototype, "data3", {
	get: function () {
		if (!this._data3) {
			this._data3 = new Float32Array(3);
		}

		this._data3[0] = this.r;
		this._data3[1] = this.g;
		this._data3[2] = this.b;
		return this._data3;
	}
});
math.INV_LOG2 = Math.LOG2E;
math.intToBytes = math.intToBytes32;
math.bytesToInt = math.bytesToInt32;
Object.defineProperty(Vec2.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(2);
		}

		this._data[0] = this.x;
		this._data[1] = this.y;
		return this._data;
	}
});
Vec2.prototype.scale = Vec2.prototype.mulScalar;
Object.defineProperty(Vec3.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(3);
		}

		this._data[0] = this.x;
		this._data[1] = this.y;
		this._data[2] = this.z;
		return this._data;
	}
});
Vec3.prototype.scale = Vec3.prototype.mulScalar;
Object.defineProperty(Vec4.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(4);
		}

		this._data[0] = this.x;
		this._data[1] = this.y;
		this._data[2] = this.z;
		this._data[3] = this.w;
		return this._data;
	}
});
Vec4.prototype.scale = Vec4.prototype.mulScalar;
BoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;

Frustum.prototype.update = function (projectionMatrix, viewMatrix) {
	const viewProj = new Mat4();
	viewProj.mul2(projectionMatrix, viewMatrix);
	this.setFromMat4(viewProj);
};
Object.defineProperty(shaderChunks, "transformSkinnedVS", {
	get: function () {
		return "#define SKIN\n" + shaderChunks.transformVS;
	}
});
const deprecatedChunks = {
	'ambientPrefilteredCube.frag': 'ambientEnv.frag',
	'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',
	'dpAtlasQuad.frag': null,
	'genParaboloid.frag': null,
	'prefilterCubemap.frag': null,
	'reflectionDpAtlas.frag': 'reflectionEnv.frag',
	'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',
	'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'
};
Object.keys(deprecatedChunks).forEach(chunkName => {
	deprecatedChunks[chunkName];
	Object.defineProperty(shaderChunks, chunkName, {
		get: function () {
			return null;
		},
		set: function () {}
	});
});
Object.defineProperties(Texture.prototype, {
	rgbm: {
		get: function () {
			return this.type === TEXTURETYPE_RGBM;
		},
		set: function (rgbm) {
			this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
		}
	},
	swizzleGGGR: {
		get: function () {
			return this.type === TEXTURETYPE_SWIZZLEGGGR;
		},
		set: function (swizzleGGGR) {
			this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
		}
	}
});
Object.defineProperty(Scene$1.prototype, 'defaultMaterial', {
	get: function () {
		return DefaultMaterial.get(getApplication().graphicsDevice);
	}
});
['128', '64', '32', '16', '8', '4'].forEach((size, index) => {
	Object.defineProperty(Scene$1.prototype, `skyboxPrefiltered${size}`, {
		get: function () {
			return this._prefilteredCubemaps[index];
		},
		set: function (value) {
			this._prefilteredCubemaps[index] = value;
			this.updateShaders = true;
		}
	});
});
Object.defineProperty(Batch.prototype, 'model', {
	get: function () {
		return null;
	}
});

MeshInstance.prototype.syncAabb = function () {};

Morph.prototype.getTarget = function (index) {
	return this.targets[index];
};

GraphNode.prototype._dirtify = function (local) {
	if (local) this._dirtifyLocal();else this._dirtifyWorld();
};

GraphNode.prototype.addLabel = function (label) {
	this._labels[label] = true;
};

GraphNode.prototype.getLabels = function () {
	return Object.keys(this._labels);
};

GraphNode.prototype.hasLabel = function (label) {
	return !!this._labels[label];
};

GraphNode.prototype.removeLabel = function (label) {
	delete this._labels[label];
};

GraphNode.prototype.findByLabel = function (label, results = []) {
	if (this.hasLabel(label)) {
		results.push(this);
	}

	for (let i = 0; i < this._children.length; ++i) {
		results = this._children[i].findByLabel(label, results);
	}

	return results;
};

GraphNode.prototype.getChildren = function () {
	return this.children;
};

GraphNode.prototype.getName = function () {
	return this.name;
};

GraphNode.prototype.getPath = function () {
	return this.path;
};

GraphNode.prototype.getRoot = function () {
	return this.root;
};

GraphNode.prototype.getParent = function () {
	return this.parent;
};

GraphNode.prototype.setName = function (name) {
	this.name = name;
};

Material$1.prototype.getName = function () {
	return this.name;
};

Material$1.prototype.setName = function (name) {
	this.name = name;
};

Material$1.prototype.getShader = function () {
	return this.shader;
};

Material$1.prototype.setShader = function (shader) {
	this.shader = shader;
};

function _defineAlias(newName, oldName) {
	Object.defineProperty(StandardMaterial.prototype, oldName, {
		get: function () {
			return this[newName];
		},
		set: function (value) {
			this[newName] = value;
		}
	});
}

_defineAlias("diffuseTint", "diffuseMapTint");

_defineAlias("specularTint", "specularMapTint");

_defineAlias("emissiveTint", "emissiveMapTint");

_defineAlias("aoVertexColor", "aoMapVertexColor");

_defineAlias("diffuseVertexColor", "diffuseMapVertexColor");

_defineAlias("specularVertexColor", "specularMapVertexColor");

_defineAlias("emissiveVertexColor", "emissiveMapVertexColor");

_defineAlias("metalnessVertexColor", "metalnessMapVertexColor");

_defineAlias("glossVertexColor", "glossMapVertexColor");

_defineAlias("opacityVertexColor", "opacityMapVertexColor");

_defineAlias("lightVertexColor", "lightMapVertexColor");

Animation.prototype.getDuration = function () {
	return this.duration;
};

Animation.prototype.getName = function () {
	return this.name;
};

Animation.prototype.getNodes = function () {
	return this.nodes;
};

Animation.prototype.setDuration = function (duration) {
	this.duration = duration;
};

Animation.prototype.setName = function (name) {
	this.name = name;
};

Skeleton.prototype.getAnimation = function () {
	return this.animation;
};

Skeleton.prototype.getCurrentTime = function () {
	return this.currentTime;
};

Skeleton.prototype.getLooping = function () {
	return this.looping;
};

Skeleton.prototype.getNumNodes = function () {
	return this.numNodes;
};

Skeleton.prototype.setAnimation = function (animation) {
	this.animation = animation;
};

Skeleton.prototype.setCurrentTime = function (time) {
	this.currentTime = time;
};

Skeleton.prototype.setLooping = function (looping) {
	this.looping = looping;
};

SoundManager.prototype.getListener = function () {
	return this.listener;
};

SoundManager.prototype.getVolume = function () {
	return this.volume;
};

SoundManager.prototype.setVolume = function (volume) {
	this.volume = volume;
};

AssetRegistry.prototype.getAssetById = function (id) {
	return this.get(id);
};

Object.defineProperty(XrInputSource.prototype, 'ray', {
	get: function () {
		return this._rayLocal;
	}
});
Object.defineProperty(XrInputSource.prototype, 'position', {
	get: function () {
		return this._localPosition;
	}
});
Object.defineProperty(XrInputSource.prototype, 'rotation', {
	get: function () {
		return this._localRotation;
	}
});
Object.defineProperty(ElementInput.prototype, 'wheel', {
	get: function () {
		return this.wheelDelta * -2;
	}
});
Object.defineProperty(MouseEvent$1.prototype, 'wheel', {
	get: function () {
		return this.wheelDelta * -2;
	}
});

Application.prototype.isFullscreen = function () {
	return !!document.fullscreenElement;
};

Application.prototype.enableFullscreen = function (element, success, error) {
	element = element || this.graphicsDevice.canvas;

	const s = function s() {
		success();
		document.removeEventListener('fullscreenchange', s);
	};

	const e = function e() {
		error();
		document.removeEventListener('fullscreenerror', e);
	};

	if (success) {
		document.addEventListener('fullscreenchange', s, false);
	}

	if (error) {
		document.addEventListener('fullscreenerror', e, false);
	}

	if (element.requestFullscreen) {
		element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
	} else {
		error();
	}
};

Application.prototype.disableFullscreen = function (success) {
	const s = function s() {
		success();
		document.removeEventListener('fullscreenchange', s);
	};

	if (success) {
		document.addEventListener('fullscreenchange', s, false);
	}

	document.exitFullscreen();
};

Application.prototype.getSceneUrl = function (name) {
	const entry = this.scenes.find(name);

	if (entry) {
		return entry.url;
	}

	return null;
};

Application.prototype.loadScene = function (url, callback) {
	this.scenes.loadScene(url, callback);
};

Application.prototype.loadSceneHierarchy = function (url, callback) {
	this.scenes.loadSceneHierarchy(url, callback);
};

Application.prototype.loadSceneSettings = function (url, callback) {
	this.scenes.loadSceneSettings(url, callback);
};

Application.prototype.renderMeshInstance = function (meshInstance, options) {
	const layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
	this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
};

Application.prototype.renderMesh = function (mesh, material, matrix, options) {
	const layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
	this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
};

Application.prototype._addLines = function (positions, colors, options) {
	const layer = options && options.layer ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);
	const depthTest = options && options.depthTest !== undefined ? options.depthTest : true;
	const batch = this.scene.immediate.getBatch(layer, depthTest);
	batch.addLines(positions, colors);
};

Application.prototype.renderLine = function (start, end, color) {
	let endColor = color;
	let options;
	const arg3 = arguments[3];
	const arg4 = arguments[4];

	if (arg3 instanceof Color) {
		endColor = arg3;

		if (typeof arg4 === 'number') {
			if (arg4 === LINEBATCH_OVERLAY) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: false
				};
			} else {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: true
				};
			}
		} else {
			options = arg4;
		}
	} else if (typeof arg3 === 'number') {
		endColor = color;

		if (arg3 === LINEBATCH_OVERLAY) {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: false
			};
		} else {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: true
			};
		}
	} else if (arg3) {
		options = arg3;
	}

	this._addLines([start, end], [color, endColor], options);
};

Application.prototype.renderLines = function (position, color, options) {
	if (!options) {
		options = {
			layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
			depthTest: true
		};
	} else if (typeof options === 'number') {
		if (options === LINEBATCH_OVERLAY) {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: false
			};
		} else {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: true
			};
		}
	}

	const multiColor = !!color.length;

	if (multiColor) {
		if (position.length !== color.length) {
			console.error("renderLines: position/color arrays have different lengths");
			return;
		}
	}

	if (position.length % 2 !== 0) {
		console.error("renderLines: array length is not divisible by 2");
		return;
	}

	this._addLines(position, color, options);
};

Object.defineProperty(CameraComponent.prototype, "node", {
	get: function () {
		return this.entity;
	}
});
Object.defineProperty(LightComponent.prototype, "enable", {
	get: function () {
		return this.enabled;
	},
	set: function (value) {
		this.enabled = value;
	}
});

ModelComponent.prototype.setVisible = function (visible) {
	this.enabled = visible;
};

Object.defineProperty(ModelComponent.prototype, "aabb", {
	get: function () {
		return null;
	},
	set: function (type) {}
});
Object.defineProperty(RenderComponent.prototype, "aabb", {
	get: function () {
		return null;
	},
	set: function (type) {}
});
Object.defineProperty(RigidBodyComponent.prototype, "bodyType", {
	get: function () {
		return this.type;
	},
	set: function (type) {
		this.type = type;
	}
});

RigidBodyComponent.prototype.syncBodyToEntity = function () {
	this._updateDynamic();
};

RigidBodyComponentSystem.prototype.setGravity = function () {
	if (arguments.length === 1) {
		this.gravity.copy(arguments[0]);
	} else {
		this.gravity.set(arguments[0], arguments[1], arguments[2]);
	}
};

/**
 * Blade Mesh Posstions
 * @type {Array}
 */
const meshPositions = [
    0.2472488433122635,
    1.6666533946990967,
    0,
    0.16416716575622559,
    1.6666533946990967,
    0,
    0.15526895225048065,
    1.5763176679611206,
    0,
    0.23243571817874908,
    1.5668010711669922,
    0,
    0.3315504193305969,
    1.6666533946990967,
    0,
    0.3090425729751587,
    1.5535097122192383,
    0,
    0.41751596331596375,
    1.6666533946990967,
    0,
    0.3849049210548401,
    1.5364761352539062,
    0,
    0.5056233406066895,
    1.6666533946990967,
    0,
    0.45983991026878357,
    1.5157407522201538,
    0,
    0.5963965654373169,
    1.6666533946990967,
    0,
    0.5336672067642212,
    1.4913538694381714,
    0,
    0.6904183030128479,
    1.6666533946990967,
    0,
    0.6062088012695312,
    1.463374137878418,
    0,
    0.7883456349372864,
    1.6666533946990967,
    0,
    0.6772900223731995,
    1.4318692684173584,
    0,
    0.8909319639205933,
    1.6666533946990967,
    0,
    0.7467395067214966,
    1.3969147205352783,
    0,
    0.9990513324737549,
    1.6666533946990967,
    0,
    0.8143900036811829,
    1.3585948944091797,
    0,
    1.1137312650680542,
    1.6666533946990967,
    0,
    0.8800786733627319,
    1.3170020580291748,
    0,
    1.2361955642700195,
    1.6666533946990967,
    0,
    0.9436472058296204,
    1.2722365856170654,
    0,
    0.07772809267044067,
    1.6666533946990967,
    0,
    0.07772809267044067,
    1.5820367336273193,
    0,
    0,
    1.6666533946990967,
    0,
    0,
    1.5839447975158691,
    0,
    -0.0817786380648613,
    1.664645791053772,
    0,
    -0.07772809267044067,
    1.5820367336273193,
    0,
    -0.16336026787757874,
    1.658627986907959,
    0,
    -0.15526895225048065,
    1.5763176679611206,
    0,
    -0.24454833567142487,
    1.6486144065856934,
    0,
    -0.23243571817874908,
    1.5668010711669922,
    0,
    -0.3251473009586334,
    1.6346290111541748,
    0,
    -0.3090425729751587,
    1.5535097122192383,
    0,
    -0.404962956905365,
    1.6167058944702148,
    0,
    -0.3849049210548401,
    1.5364761352539062,
    0,
    -0.4838029444217682,
    1.5948878526687622,
    0,
    -0.45983991026878357,
    1.5157407522201538,
    0,
    -0.5614774823188782,
    1.5692274570465088,
    0,
    -0.5336672067642212,
    1.4913538694381714,
    0,
    -0.6377993226051331,
    1.5397869348526,
    0,
    -0.6062088012695312,
    1.463374137878418,
    0,
    -0.7125847339630127,
    1.5066368579864502,
    0,
    -0.6772900223731995,
    1.4318692684173584,
    0,
    -0.7856534123420715,
    1.469857096672058,
    0,
    -0.7467395067214966,
    1.3969147205352783,
    0,
    -0.8568293452262878,
    1.4295363426208496,
    0,
    -0.8143900036811829,
    1.3585948944091797,
    0,
    -0.9259411096572876,
    1.385771632194519,
    0,
    -0.8800786733627319,
    1.3170020580291748,
    0,
    -0.9928222894668579,
    1.3386685848236084,
    0,
    -0.9436472058296204,
    1.2722365856170654,
    0,
    -1.0573115348815918,
    1.2883405685424805,
    0,
    -1.0049421787261963,
    1.2244060039520264,
    0,
    -1.1192537546157837,
    1.2349088191986084,
    0,
    -1.0638165473937988,
    1.1736259460449219,
    0,
    -1.178499460220337,
    1.178502082824707,
    0,
    -1.12012779712677,
    1.1200183629989624,
    0,
    -1.2349061965942383,
    1.1192562580108643,
    0,
    -1.1737405061721802,
    1.0637125968933105,
    0,
    -1.2883378267288208,
    1.0573139190673828,
    0,
    -1.224525809288025,
    1.004844307899475,
    0,
    -1.3386658430099487,
    0.9928244948387146,
    0,
    -1.2723610401153564,
    0.9435550570487976,
    0,
    -1.3857687711715698,
    0.9259433746337891,
    0,
    -1.3171309232711792,
    0.8799929022789001,
    0,
    -1.4295333623886108,
    0.8568314909934998,
    0,
    -1.3587278127670288,
    0.8143108487129211,
    0,
    -1.4698541164398193,
    0.7856553196907043,
    0,
    -1.397051453590393,
    0.7466667890548706,
    0,
    -1.5066337585449219,
    0.712586522102356,
    0,
    -1.4320093393325806,
    0.6772240400314331,
    0,
    -1.5397837162017822,
    0.6378011107444763,
    0,
    -1.4635173082351685,
    0.6061499118804932,
    0,
    -1.5692243576049805,
    0.5614790916442871,
    0,
    -1.4914997816085815,
    0.5336154103279114,
    0,
    -1.5948846340179443,
    0.4838044345378876,
    0,
    -1.5158891677856445,
    0.45979538559913635,
    0,
    -1.6167025566101074,
    0.40496429800987244,
    0,
    -1.5366264581680298,
    0.384867787361145,
    0,
    -1.6346256732940674,
    0.3251485228538513,
    0,
    -1.553661823272705,
    0.30901291966438293,
    0,
    -1.648611068725586,
    0.2445494532585144,
    0,
    -1.5669543743133545,
    0.23241358995437622,
    0,
    -1.6586246490478516,
    0.16336126625537872,
    0,
    -1.5764720439910889,
    0.15525442361831665,
    0,
    -1.6646424531936646,
    0.08177950978279114,
    0,
    -1.5821917057037354,
    0.07772119343280792,
    0,
    -1.6666499376296997,
    7.450580596923828e-7,
    0,
    -1.5840997695922852,
    7.450580596923828e-7,
    0,
    1.3679208755493164,
    1.6666533946990967,
    0,
    1.0049421787261963,
    1.2244060039520264,
    0,
    1.9099923372268677,
    0.4214799404144287,
    0,
    1.9868781566619873,
    0.4573325216770172,
    0,
    1.744999885559082,
    0.7199999690055847,
    0,
    1.8405001163482666,
    0.37282103300094604,
    0,
    2.526153802871704,
    0.31283411383628845,
    0,
    2.5950000286102295,
    0.7249999642372131,
    0,
    2.4661667346954346,
    0.37282103300094604,
    0,
    2.396674633026123,
    0.4214799404144287,
    0,
    3.5353410243988037,
    0.4214799404144287,
    0,
    3.6048333644866943,
    0.37282103300094604,
    0,
    3.705000162124634,
    0.7199999690055847,
    0,
    2.884999990463257,
    0.7300000190734863,
    0,
    3.048658847808838,
    0.4214799404144287,
    0,
    3.125544548034668,
    0.4573325216770172,
    0,
    2.9791665077209473,
    0.37282103300094604,
    0,
    4.187325954437256,
    0.4214799404144287,
    0,
    4.03000020980835,
    0.7050000429153442,
    0,
    4.117833614349365,
    0.37282103300094604,
    0,
    4.264211654663086,
    0.4573325216770172,
    0,
    4.757999897003174,
    0.5320000052452087,
    0,
    4.674007892608643,
    0.4214799404144287,
    0,
    4.743500232696533,
    0.37282103300094604,
    0,
    4.5971221923828125,
    0.4573325216770172,
    0,
    1.190999984741211,
    1.1460000276565552,
    0,
    1.12012779712677,
    1.1200183629989624,
    0,
    1.1737405061721802,
    1.0637125968933105,
    0,
    1.224525809288025,
    1.004844307899475,
    0,
    2.1533334255218506,
    0.8524738550186157,
    0,
    2.1533334255218506,
    0.48668304085731506,
    0,
    2.237844944000244,
    0.47928929328918457,
    0,
    3.2920002937316895,
    0.8524738550186157,
    0,
    3.207489013671875,
    0.47928929328918457,
    0,
    3.2920002937316895,
    0.48668304085731506,
    0,
    3.376511573791504,
    0.47928929328918457,
    0,
    4.057846546173096,
    0.31283411383628845,
    0,
    2.2277963161468506,
    1.6666533946990967,
    0,
    2.2380640506744385,
    1.594059944152832,
    0,
    2.350635528564453,
    1.6666533946990967,
    0,
    2.104956865310669,
    1.6666533946990967,
    0,
    2.76401424407959,
    1.594059944152832,
    0,
    3.2422549724578857,
    1.594059944152832,
    0,
    2.964832305908203,
    1.6666533946990967,
    0,
    3.0876717567443848,
    1.6666533946990967,
    0,
    2.8419928550720215,
    1.6666533946990967,
    0,
    2.719153642654419,
    1.6666533946990967,
    0,
    3.2105109691619873,
    1.6666533946990967,
    0,
    3.33335018157959,
    1.6666533946990967,
    0,
    1.7364388704299927,
    1.6666533946990967,
    0,
    1.8633335828781128,
    1.594059944152832,
    0,
    1.8592782020568848,
    1.6666533946990967,
    0,
    1.613599419593811,
    1.6666533946990967,
    0,
    3.4151289463043213,
    1.664645791053772,
    0,
    2.068822145462036,
    0.47928929328918457,
    0,
    2.319788694381714,
    0.4573325216770172,
    0,
    3.4584550857543945,
    0.4573325216770172,
    0,
    3.6648201942443848,
    0.31283411383628845,
    0,
    4.346155166625977,
    0.47928929328918457,
    0,
    4.430666446685791,
    0.8524738550186157,
    0,
    4.430666446685791,
    0.48668304085731506,
    0,
    4.5151777267456055,
    0.47928929328918457,
    0,
    1.0638165473937988,
    1.1736259460449219,
    0,
    1.3559999465942383,
    0.918999969959259,
    0,
    1.2723610401153564,
    0.9435550570487976,
    0,
    1.3171309232711792,
    0.8799929022789001,
    0,
    1.397051453590393,
    0.7466667890548706,
    0,
    1.3587278127670288,
    0.8143108487129211,
    0,
    1.9821174144744873,
    1.6666533946990967,
    0,
    3.5820000171661377,
    1.5760000944137573,
    0,
    3.4967105388641357,
    1.658627986907959,
    0,
    1.490760087966919,
    1.6666533946990967,
    0,
    2.812711238861084,
    0.08451224118471146,
    0,
    2.7226827144622803,
    0.08451224118471146,
    0,
    2.7226827144622803,
    7.450580596923828e-7,
    0,
    2.8053176403045654,
    7.450580596923828e-7,
    0,
    2.6326217651367188,
    0.08451224118471146,
    0,
    2.6400158405303955,
    7.450580596923828e-7,
    0,
    2.7226827144622803,
    0.727400004863739,
    0,
    2.5126829147338867,
    1.594059944152832,
    0,
    2.4734747409820557,
    1.6666533946990967,
    0,
    2.5963141918182373,
    1.6666533946990967,
    0,
    1.6740447282791138,
    0.08451224118471146,
    0,
    1.5983912944793701,
    0.09899487346410751,
    0,
    1.603168249130249,
    -0.0011273215059190989,
    0,
    1.6666511297225952,
    7.450580596923828e-7,
    0,
    1.5821917057037354,
    0.07772119343280792,
    0,
    1.5840997695922852,
    7.450580596923828e-7,
    0,
    1.4635173082351685,
    0.6061499118804932,
    0,
    1.4914997816085815,
    0.5336154103279114,
    0,
    1.5010000467300415,
    0.6399999856948853,
    0,
    1.5158891677856445,
    0.45979538559913635,
    0,
    1.4320093393325806,
    0.6772240400314331,
    0,
    1.5366499423980713,
    1.594059944152832,
    0,
    1.7805131673812866,
    0.31283411383628845,
    0,
    1.5699999332427979,
    0.4000000059604645,
    0,
    1.6960015296936035,
    0.16645589470863342,
    0,
    1.5906872749328613,
    0.19898943603038788,
    0,
    1.5764720439910889,
    0.15525442361831665,
    0,
    1.5810649394989014,
    0.29885998368263245,
    0,
    1.7318540811538696,
    0.24334189295768738,
    0,
    1.5669543743133545,
    0.23241358995437622,
    0,
    1.5366264581680298,
    0.384867787361145,
    0,
    1.553661823272705,
    0.30901291966438293,
    0,
    2.919179677963257,
    0.31283411383628845,
    0,
    2.7226827144622803,
    0.31283411383628845,
    0,
    3.867666721343994,
    0.7124999761581421,
    0,
    3.8959999084472656,
    1.49399995803833,
    0,
    4.131999969482422,
    1.3619999885559082,
    0,
    3.867666721343994,
    0.31283411383628845,
    0,
    3.9513778686523438,
    0.08451224118471146,
    0,
    3.867666721343994,
    0.08451224118471146,
    0,
    3.867666721343994,
    7.450580596923828e-7,
    0,
    3.943984270095825,
    7.450580596923828e-7,
    0,
    3.7712883949279785,
    0.08451224118471146,
    0,
    3.7786827087402344,
    7.450580596923828e-7,
    0,
    4.957400798797607,
    0.08341200649738312,
    0,
    4.965715408325195,
    7.450580596923828e-7,
    0,
    5,
    7.450580596923828e-7,
    0,
    4.997992992401123,
    0.08177950978279114,
    0,
    4.917348861694336,
    7.450580596923828e-7,
    0,
    4.9099555015563965,
    0.08451224118471146,
    0,
    4.991974830627441,
    0.16336126625537872,
    0,
    4.949268341064453,
    0.16498948633670807,
    0,
    4.887998580932617,
    0.16645589470863342,
    0,
    4.981961250305176,
    0.2445494532585144,
    0,
    4.9413862228393555,
    0.24406039714813232,
    0,
    4.852146148681641,
    0.24334189295768738,
    0,
    2.7226827144622803,
    0.16645589470863342,
    0,
    2.8346681594848633,
    0.16645589470863342,
    0,
    2.6106650829315186,
    0.16645589470863342,
    0,
    2.7226827144622803,
    0.24334189295768738,
    0,
    2.87052059173584,
    0.24334189295768738,
    0,
    2.574812889099121,
    0.24334189295768738,
    0,
    3.867666721343994,
    0.24334189295768738,
    0,
    4.009187698364258,
    0.24334189295768738,
    0,
    3.7134792804718018,
    0.24334189295768738,
    0,
    3.867666721343994,
    0.16645589470863342,
    0,
    3.973334550857544,
    0.16645589470863342,
    0,
    3.749331474304199,
    0.16645589470863342,
    0,
    4.926000118255615,
    0.3240000009536743,
    0,
    4.803487300872803,
    0.31283411383628845,
    0,
    3.6584978103637695,
    1.6346290111541748,
    0,
    3.5778985023498535,
    1.6486144065856934,
    0,
    3.7383131980895996,
    1.6167058944702148,
    0,
    3.8171534538269043,
    1.5948878526687622,
    0,
    3.8948278427124023,
    1.5692274570465088,
    0,
    3.971149444580078,
    1.5397869348526,
    0,
    4.045935153961182,
    1.5066368579864502,
    0,
    4.119003772735596,
    1.469857096672058,
    0,
    4.190179824829102,
    1.4295363426208496,
    0,
    4.259291172027588,
    1.385771632194519,
    0,
    4.424000263214111,
    1.187999963760376,
    0,
    4.390661716461182,
    1.2883405685424805,
    0,
    4.326172351837158,
    1.3386685848236084,
    0,
    4.452604293823242,
    1.2349088191986084,
    0,
    4.511849880218506,
    1.178502082824707,
    0,
    4.568256378173828,
    1.1192562580108643,
    0,
    4.664000034332275,
    0.9340000152587891,
    0,
    4.621687889099121,
    1.0573139190673828,
    0,
    4.672016143798828,
    0.9928244948387146,
    0,
    4.719119071960449,
    0.9259433746337891,
    0,
    4.76288366317749,
    0.8568314909934998,
    0,
    4.809999942779541,
    0.6679999828338623,
    0,
    4.80320405960083,
    0.7856553196907043,
    0,
    4.839983940124512,
    0.712586522102356,
    0,
    4.873133659362793,
    0.6378011107444763,
    0,
    4.9025750160217285,
    0.5614790916442871,
    0,
    4.892000198364258,
    0.48000001907348633,
    0,
    4.928235054016113,
    0.4838044345378876,
    0,
    4.967976093292236,
    0.3251485228538513,
    0,
    4.950052738189697,
    0.40496429800987244,
    0,
    0.2472488433122635,
    -1.6666518449783325,
    0,
    0.23243571817874908,
    -1.566799521446228,
    0,
    0.15526895225048065,
    -1.5763161182403564,
    0,
    0.16416716575622559,
    -1.6666518449783325,
    0,
    0.3315504193305969,
    -1.6666518449783325,
    0,
    0.3090425729751587,
    -1.5535082817077637,
    0,
    0.41751596331596375,
    -1.6666518449783325,
    0,
    0.3849049210548401,
    -1.5364747047424316,
    0,
    0.5056233406066895,
    -1.6666518449783325,
    0,
    0.45983991026878357,
    -1.5157392024993896,
    0,
    0.5963965654373169,
    -1.6666518449783325,
    0,
    0.5336672067642212,
    -1.4913523197174072,
    0,
    0.6904183030128479,
    -1.6666518449783325,
    0,
    0.6062088012695312,
    -1.4633725881576538,
    0,
    0.7883456349372864,
    -1.6666518449783325,
    0,
    0.6772900223731995,
    -1.4318677186965942,
    0,
    0.8909319639205933,
    -1.6666518449783325,
    0,
    0.7467395067214966,
    -1.3969132900238037,
    0,
    0.9990513324737549,
    -1.6666518449783325,
    0,
    0.8143900036811829,
    -1.3585933446884155,
    0,
    1.1137312650680542,
    -1.6666518449783325,
    0,
    0.8800786733627319,
    -1.3170006275177002,
    0,
    1.2361955642700195,
    -1.6666518449783325,
    0,
    0.9436472058296204,
    -1.2722350358963013,
    0,
    0.07772809267044067,
    -1.5820351839065552,
    0,
    0.07772809267044067,
    -1.6666518449783325,
    0,
    3.469446951953614e-16,
    -1.5839433670043945,
    0,
    3.469446951953614e-16,
    -1.6666518449783325,
    0,
    -0.07772809267044067,
    -1.5820351839065552,
    0,
    -0.0817786380648613,
    -1.6646442413330078,
    0,
    -0.15526895225048065,
    -1.5763161182403564,
    0,
    -0.16336026787757874,
    -1.6586264371871948,
    0,
    -0.23243571817874908,
    -1.566799521446228,
    0,
    -0.24454833567142487,
    -1.6486128568649292,
    0,
    -0.3090425729751587,
    -1.5535082817077637,
    0,
    -0.3251473009586334,
    -1.6346275806427002,
    0,
    -0.3849049210548401,
    -1.5364747047424316,
    0,
    -0.404962956905365,
    -1.6167044639587402,
    0,
    -0.45983991026878357,
    -1.5157392024993896,
    0,
    -0.4838029444217682,
    -1.5948864221572876,
    0,
    -0.5336672067642212,
    -1.4913523197174072,
    0,
    -0.5614774823188782,
    -1.5692260265350342,
    0,
    -0.6062088012695312,
    -1.4633725881576538,
    0,
    -0.6377993226051331,
    -1.539785385131836,
    0,
    -0.6772900223731995,
    -1.4318677186965942,
    0,
    -0.7125847339630127,
    -1.506635308265686,
    0,
    -0.7467395067214966,
    -1.3969132900238037,
    0,
    -0.7856534123420715,
    -1.4698556661605835,
    0,
    -0.8143900036811829,
    -1.3585933446884155,
    0,
    -0.8568293452262878,
    -1.429534912109375,
    0,
    -0.8800786733627319,
    -1.3170006275177002,
    0,
    -0.9259411096572876,
    -1.3857702016830444,
    0,
    -0.9436472058296204,
    -1.2722350358963013,
    0,
    -0.9928222894668579,
    -1.3386671543121338,
    0,
    -1.0049421787261963,
    -1.2244044542312622,
    0,
    -1.0573115348815918,
    -1.2883391380310059,
    0,
    -1.0638165473937988,
    -1.1736243963241577,
    0,
    -1.1192537546157837,
    -1.2349073886871338,
    0,
    -1.12012779712677,
    -1.1200168132781982,
    0,
    -1.178499460220337,
    -1.1785006523132324,
    0,
    -1.1737405061721802,
    -1.0637110471725464,
    0,
    -1.2349061965942383,
    -1.1192548274993896,
    0,
    -1.224525809288025,
    -1.004842758178711,
    0,
    -1.2883378267288208,
    -1.0573124885559082,
    0,
    -1.2723610401153564,
    -0.9435535669326782,
    0,
    -1.3386658430099487,
    -0.9928230047225952,
    0,
    -1.3171309232711792,
    -0.8799914121627808,
    0,
    -1.3857687711715698,
    -0.9259418845176697,
    0,
    -1.3587278127670288,
    -0.8143093585968018,
    0,
    -1.4295333623886108,
    -0.8568300008773804,
    0,
    -1.397051453590393,
    -0.7466652989387512,
    0,
    -1.4698541164398193,
    -0.785653829574585,
    0,
    -1.4320093393325806,
    -0.6772225499153137,
    0,
    -1.5066337585449219,
    -0.7125850319862366,
    0,
    -1.4635173082351685,
    -0.6061484217643738,
    0,
    -1.5397837162017822,
    -0.6377996206283569,
    0,
    -1.4914997816085815,
    -0.533613920211792,
    0,
    -1.5692243576049805,
    -0.5614776015281677,
    0,
    -1.5158891677856445,
    -0.45979389548301697,
    0,
    -1.5948846340179443,
    -0.4838029444217682,
    0,
    -1.5366264581680298,
    -0.38486629724502563,
    0,
    -1.6167025566101074,
    -0.40496280789375305,
    0,
    -1.553661823272705,
    -0.30901142954826355,
    0,
    -1.6346256732940674,
    -0.32514703273773193,
    0,
    -1.5669543743133545,
    -0.23241209983825684,
    0,
    -1.648611068725586,
    -0.24454796314239502,
    0,
    -1.5764720439910889,
    -0.15525293350219727,
    0,
    -1.6586246490478516,
    -0.16335977613925934,
    0,
    -1.5821917057037354,
    -0.07771970331668854,
    0,
    -1.6646424531936646,
    -0.08177801966667175,
    0,
    1.3679208755493164,
    -1.6666518449783325,
    0,
    1.0049421787261963,
    -1.2244044542312622,
    0,
    1.9099923372268677,
    -0.4214784502983093,
    0,
    1.744999885559082,
    -0.7199984788894653,
    0,
    1.9868781566619873,
    -0.4573310315608978,
    0,
    1.8405001163482666,
    -0.37281954288482666,
    0,
    2.526153802871704,
    -0.31283262372016907,
    0,
    2.4661667346954346,
    -0.37281954288482666,
    0,
    2.5950000286102295,
    -0.7249984741210938,
    0,
    2.396674633026123,
    -0.4214784502983093,
    0,
    3.5353410243988037,
    -0.4214784502983093,
    0,
    3.705000162124634,
    -0.7199984788894653,
    0,
    3.6048333644866943,
    -0.37281954288482666,
    0,
    2.884999990463257,
    -0.7299985289573669,
    0,
    3.125544548034668,
    -0.4573310315608978,
    0,
    3.048658847808838,
    -0.4214784502983093,
    0,
    2.9791665077209473,
    -0.37281954288482666,
    0,
    4.187325954437256,
    -0.4214784502983093,
    0,
    4.117833614349365,
    -0.37281954288482666,
    0,
    4.03000020980835,
    -0.7049984931945801,
    0,
    4.264211654663086,
    -0.4573310315608978,
    0,
    4.757999897003174,
    -0.5319985151290894,
    0,
    4.743500232696533,
    -0.37281954288482666,
    0,
    4.674007892608643,
    -0.4214784502983093,
    0,
    4.5971221923828125,
    -0.4573310315608978,
    0,
    1.190999984741211,
    -1.145998477935791,
    0,
    1.1737405061721802,
    -1.0637110471725464,
    0,
    1.12012779712677,
    -1.1200168132781982,
    0,
    1.224525809288025,
    -1.004842758178711,
    0,
    2.1533334255218506,
    -0.8524723052978516,
    0,
    2.237844944000244,
    -0.4792878031730652,
    0,
    2.1533334255218506,
    -0.4866815507411957,
    0,
    3.2920002937316895,
    -0.8524723052978516,
    0,
    3.2920002937316895,
    -0.4866815507411957,
    0,
    3.207489013671875,
    -0.4792878031730652,
    0,
    3.376511573791504,
    -0.4792878031730652,
    0,
    4.057846546173096,
    -0.31283262372016907,
    0,
    2.2277963161468506,
    -1.6666518449783325,
    0,
    2.350635528564453,
    -1.6666518449783325,
    0,
    2.2380640506744385,
    -1.5940583944320679,
    0,
    2.104956865310669,
    -1.6666518449783325,
    0,
    2.76401424407959,
    -1.5940583944320679,
    0,
    3.2422549724578857,
    -1.5940583944320679,
    0,
    2.964832305908203,
    -1.6666518449783325,
    0,
    3.0876717567443848,
    -1.6666518449783325,
    0,
    2.8419928550720215,
    -1.6666518449783325,
    0,
    2.719153642654419,
    -1.6666518449783325,
    0,
    3.2105109691619873,
    -1.6666518449783325,
    0,
    3.33335018157959,
    -1.6666518449783325,
    0,
    1.7364388704299927,
    -1.6666518449783325,
    0,
    1.8592782020568848,
    -1.6666518449783325,
    0,
    1.8633335828781128,
    -1.5940583944320679,
    0,
    1.613599419593811,
    -1.6666518449783325,
    0,
    3.4151289463043213,
    -1.6646442413330078,
    0,
    2.068822145462036,
    -0.4792878031730652,
    0,
    2.319788694381714,
    -0.4573310315608978,
    0,
    3.4584550857543945,
    -0.4573310315608978,
    0,
    3.6648201942443848,
    -0.31283262372016907,
    0,
    4.346155166625977,
    -0.4792878031730652,
    0,
    4.430666446685791,
    -0.8524723052978516,
    0,
    4.430666446685791,
    -0.4866815507411957,
    0,
    4.5151777267456055,
    -0.4792878031730652,
    0,
    1.0638165473937988,
    -1.1736243963241577,
    0,
    1.3559999465942383,
    -0.9189984798431396,
    0,
    1.2723610401153564,
    -0.9435535669326782,
    0,
    1.3171309232711792,
    -0.8799914121627808,
    0,
    1.397051453590393,
    -0.7466652989387512,
    0,
    1.3587278127670288,
    -0.8143093585968018,
    0,
    1.9821174144744873,
    -1.6666518449783325,
    0,
    3.5820000171661377,
    -1.5759985446929932,
    0,
    3.4967105388641357,
    -1.6586264371871948,
    0,
    1.490760087966919,
    -1.6666518449783325,
    0,
    2.812711238861084,
    -0.08451075106859207,
    0,
    2.7226827144622803,
    -0.08451075106859207,
    0,
    2.6326217651367188,
    -0.08451075106859207,
    0,
    2.5126829147338867,
    -1.5940583944320679,
    0,
    2.7226827144622803,
    -0.7273985147476196,
    0,
    2.4734747409820557,
    -1.6666518449783325,
    0,
    2.5963141918182373,
    -1.6666518449783325,
    0,
    1.6740447282791138,
    -0.08451075106859207,
    0,
    1.603285551071167,
    -0.10128706693649292,
    0,
    1.5821917057037354,
    -0.07771970331668854,
    0,
    1.4635173082351685,
    -0.6061484217643738,
    0,
    1.5010000467300415,
    -0.6399984955787659,
    0,
    1.4914997816085815,
    -0.533613920211792,
    0,
    1.5158891677856445,
    -0.45979389548301697,
    0,
    1.4320093393325806,
    -0.6772225499153137,
    0,
    1.5366499423980713,
    -1.5940583944320679,
    0,
    1.7805131673812866,
    -0.31283262372016907,
    0,
    1.5699999332427979,
    -0.3999985158443451,
    0,
    1.6960015296936035,
    -0.16645440459251404,
    0,
    1.5991445779800415,
    -0.2013990879058838,
    0,
    1.5764720439910889,
    -0.15525293350219727,
    0,
    1.5888115167617798,
    -0.3012150526046753,
    0,
    1.7318540811538696,
    -0.243340402841568,
    0,
    1.5669543743133545,
    -0.23241209983825684,
    0,
    1.5366264581680298,
    -0.38486629724502563,
    0,
    1.553661823272705,
    -0.30901142954826355,
    0,
    2.919179677963257,
    -0.31283262372016907,
    0,
    2.7226827144622803,
    -0.31283262372016907,
    0,
    3.8959999084472656,
    -1.4939985275268555,
    0,
    3.867666721343994,
    -0.7124984860420227,
    0,
    4.131999969482422,
    -1.3619985580444336,
    0,
    3.867666721343994,
    -0.31283262372016907,
    0,
    3.9513778686523438,
    -0.08451075106859207,
    0,
    3.867666721343994,
    -0.08451075106859207,
    0,
    3.7712883949279785,
    -0.08451075106859207,
    0,
    4.957400798797607,
    -0.08341051638126373,
    0,
    4.997992992401123,
    -0.08177801966667175,
    0,
    4.9099555015563965,
    -0.08451075106859207,
    0,
    4.991974830627441,
    -0.16335977613925934,
    0,
    4.949268341064453,
    -0.16498799622058868,
    0,
    4.887998580932617,
    -0.16645440459251404,
    0,
    4.9413862228393555,
    -0.24405890703201294,
    0,
    4.981961250305176,
    -0.24454796314239502,
    0,
    4.852146148681641,
    -0.243340402841568,
    0,
    2.7226827144622803,
    -0.16645440459251404,
    0,
    2.8346681594848633,
    -0.16645440459251404,
    0,
    2.6106650829315186,
    -0.16645440459251404,
    0,
    2.7226827144622803,
    -0.243340402841568,
    0,
    2.87052059173584,
    -0.243340402841568,
    0,
    2.574812889099121,
    -0.243340402841568,
    0,
    4.009187698364258,
    -0.243340402841568,
    0,
    3.867666721343994,
    -0.243340402841568,
    0,
    3.7134792804718018,
    -0.243340402841568,
    0,
    3.867666721343994,
    -0.16645440459251404,
    0,
    3.973334550857544,
    -0.16645440459251404,
    0,
    3.749331474304199,
    -0.16645440459251404,
    0,
    4.926000118255615,
    -0.32399851083755493,
    0,
    4.803487300872803,
    -0.31283262372016907,
    0,
    3.5778985023498535,
    -1.6486128568649292,
    0,
    3.6584978103637695,
    -1.6346275806427002,
    0,
    3.7383131980895996,
    -1.6167044639587402,
    0,
    3.8171534538269043,
    -1.5948864221572876,
    0,
    3.8948278427124023,
    -1.5692260265350342,
    0,
    3.971149444580078,
    -1.539785385131836,
    0,
    4.045935153961182,
    -1.506635308265686,
    0,
    4.119003772735596,
    -1.4698556661605835,
    0,
    4.190179824829102,
    -1.429534912109375,
    0,
    4.259291172027588,
    -1.3857702016830444,
    0,
    4.424000263214111,
    -1.1879985332489014,
    0,
    4.326172351837158,
    -1.3386671543121338,
    0,
    4.390661716461182,
    -1.2883391380310059,
    0,
    4.452604293823242,
    -1.2349073886871338,
    0,
    4.511849880218506,
    -1.1785006523132324,
    0,
    4.568256378173828,
    -1.1192548274993896,
    0,
    4.664000034332275,
    -0.9339985251426697,
    0,
    4.621687889099121,
    -1.0573124885559082,
    0,
    4.672016143798828,
    -0.9928230047225952,
    0,
    4.719119071960449,
    -0.9259418845176697,
    0,
    4.76288366317749,
    -0.8568300008773804,
    0,
    4.809999942779541,
    -0.6679984927177429,
    0,
    4.80320405960083,
    -0.785653829574585,
    0,
    4.839983940124512,
    -0.7125850319862366,
    0,
    4.873133659362793,
    -0.6377996206283569,
    0,
    4.9025750160217285,
    -0.5614776015281677,
    0,
    4.928235054016113,
    -0.4838029444217682,
    0,
    4.892000198364258,
    -0.47999852895736694,
    0,
    4.967976093292236,
    -0.32514703273773193,
    0,
    4.950052738189697,
    -0.40496280789375305,
    0
];


/**
 * Blade Mesh Indices
 * @type {Array}
 */
const meshIndices = [
    0,
    1,
    2,
    0,
    2,
    3,
    4,
    0,
    3,
    4,
    3,
    5,
    6,
    4,
    5,
    6,
    5,
    7,
    8,
    6,
    7,
    8,
    7,
    9,
    10,
    8,
    9,
    10,
    9,
    11,
    12,
    10,
    11,
    12,
    11,
    13,
    14,
    12,
    13,
    14,
    13,
    15,
    16,
    14,
    15,
    16,
    15,
    17,
    18,
    16,
    17,
    18,
    17,
    19,
    20,
    18,
    19,
    20,
    19,
    21,
    22,
    20,
    21,
    22,
    21,
    23,
    1,
    24,
    25,
    1,
    25,
    2,
    24,
    26,
    27,
    24,
    27,
    25,
    26,
    28,
    29,
    26,
    29,
    27,
    28,
    30,
    31,
    28,
    31,
    29,
    30,
    32,
    33,
    30,
    33,
    31,
    32,
    34,
    35,
    32,
    35,
    33,
    34,
    36,
    37,
    34,
    37,
    35,
    36,
    38,
    39,
    36,
    39,
    37,
    38,
    40,
    41,
    38,
    41,
    39,
    40,
    42,
    43,
    40,
    43,
    41,
    42,
    44,
    45,
    42,
    45,
    43,
    44,
    46,
    47,
    44,
    47,
    45,
    46,
    48,
    49,
    46,
    49,
    47,
    48,
    50,
    51,
    48,
    51,
    49,
    50,
    52,
    53,
    50,
    53,
    51,
    52,
    54,
    55,
    52,
    55,
    53,
    54,
    56,
    57,
    54,
    57,
    55,
    56,
    58,
    59,
    56,
    59,
    57,
    58,
    60,
    61,
    58,
    61,
    59,
    60,
    62,
    63,
    60,
    63,
    61,
    62,
    64,
    65,
    62,
    65,
    63,
    64,
    66,
    67,
    64,
    67,
    65,
    66,
    68,
    69,
    66,
    69,
    67,
    68,
    70,
    71,
    68,
    71,
    69,
    70,
    72,
    73,
    70,
    73,
    71,
    72,
    74,
    75,
    72,
    75,
    73,
    74,
    76,
    77,
    74,
    77,
    75,
    76,
    78,
    79,
    76,
    79,
    77,
    78,
    80,
    81,
    78,
    81,
    79,
    80,
    82,
    83,
    80,
    83,
    81,
    82,
    84,
    85,
    82,
    85,
    83,
    84,
    86,
    87,
    84,
    87,
    85,
    86,
    88,
    89,
    86,
    89,
    87,
    88,
    90,
    91,
    88,
    91,
    89,
    92,
    22,
    23,
    92,
    23,
    93,
    94,
    95,
    96,
    97,
    94,
    96,
    98,
    99,
    100,
    101,
    100,
    99,
    102,
    103,
    104,
    105,
    106,
    107,
    105,
    108,
    106,
    109,
    110,
    111,
    112,
    110,
    109,
    113,
    114,
    115,
    116,
    114,
    113,
    117,
    118,
    119,
    117,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    124,
    126,
    127,
    111,
    110,
    128,
    129,
    130,
    131,
    132,
    130,
    129,
    133,
    105,
    124,
    133,
    124,
    134,
    135,
    133,
    136,
    137,
    133,
    135,
    138,
    133,
    137,
    139,
    134,
    140,
    141,
    142,
    143,
    144,
    142,
    141,
    134,
    145,
    140,
    146,
    121,
    95,
    122,
    121,
    146,
    99,
    121,
    147,
    147,
    121,
    123,
    99,
    147,
    101,
    99,
    130,
    142,
    99,
    142,
    121,
    124,
    107,
    125,
    124,
    105,
    107,
    104,
    124,
    148,
    148,
    124,
    127,
    104,
    148,
    102,
    104,
    103,
    149,
    150,
    151,
    112,
    112,
    151,
    110,
    152,
    151,
    150,
    113,
    151,
    116,
    116,
    151,
    153,
    153,
    151,
    152,
    118,
    117,
    154,
    154,
    117,
    93,
    120,
    155,
    117,
    120,
    156,
    155,
    156,
    157,
    155,
    158,
    155,
    159,
    157,
    159,
    155,
    142,
    160,
    143,
    104,
    161,
    134,
    104,
    134,
    124,
    133,
    134,
    136,
    134,
    139,
    136,
    134,
    162,
    145,
    142,
    144,
    163,
    142,
    130,
    160,
    130,
    132,
    160,
    164,
    165,
    166,
    164,
    166,
    167,
    165,
    168,
    169,
    165,
    169,
    166,
    130,
    99,
    170,
    130,
    170,
    171,
    171,
    170,
    105,
    171,
    105,
    133,
    130,
    171,
    131,
    171,
    172,
    131,
    171,
    173,
    172,
    171,
    133,
    173,
    133,
    138,
    173,
    174,
    175,
    176,
    174,
    176,
    177,
    175,
    178,
    179,
    175,
    179,
    176,
    180,
    181,
    182,
    181,
    183,
    182,
    184,
    180,
    182,
    158,
    184,
    182,
    158,
    182,
    155,
    96,
    95,
    121,
    163,
    185,
    142,
    96,
    121,
    142,
    96,
    142,
    185,
    185,
    155,
    182,
    185,
    182,
    96,
    96,
    186,
    97,
    96,
    182,
    187,
    96,
    187,
    186,
    188,
    189,
    175,
    188,
    175,
    174,
    189,
    190,
    178,
    189,
    178,
    175,
    191,
    189,
    188,
    191,
    188,
    192,
    187,
    191,
    192,
    187,
    192,
    186,
    193,
    190,
    189,
    193,
    189,
    191,
    182,
    183,
    187,
    183,
    194,
    187,
    187,
    195,
    193,
    187,
    193,
    191,
    187,
    194,
    195,
    108,
    105,
    196,
    196,
    105,
    170,
    196,
    170,
    197,
    197,
    170,
    99,
    197,
    99,
    98,
    161,
    104,
    198,
    161,
    198,
    199,
    199,
    198,
    110,
    199,
    110,
    200,
    149,
    201,
    198,
    149,
    198,
    104,
    201,
    128,
    110,
    201,
    110,
    198,
    202,
    203,
    204,
    202,
    204,
    205,
    203,
    206,
    207,
    203,
    207,
    204,
    208,
    209,
    210,
    208,
    210,
    211,
    212,
    209,
    208,
    212,
    208,
    213,
    214,
    215,
    208,
    214,
    208,
    211,
    216,
    213,
    208,
    216,
    208,
    215,
    214,
    217,
    218,
    214,
    218,
    215,
    218,
    219,
    216,
    218,
    216,
    215,
    220,
    165,
    164,
    220,
    164,
    221,
    220,
    222,
    168,
    220,
    168,
    165,
    223,
    220,
    221,
    223,
    221,
    224,
    196,
    197,
    223,
    196,
    223,
    224,
    197,
    98,
    225,
    197,
    225,
    223,
    223,
    225,
    222,
    223,
    222,
    220,
    128,
    201,
    226,
    128,
    226,
    227,
    201,
    149,
    228,
    201,
    228,
    226,
    229,
    203,
    202,
    229,
    202,
    230,
    227,
    226,
    229,
    227,
    229,
    230,
    226,
    228,
    231,
    226,
    231,
    229,
    229,
    231,
    206,
    229,
    206,
    203,
    232,
    233,
    219,
    232,
    219,
    218,
    161,
    234,
    235,
    161,
    236,
    234,
    161,
    237,
    236,
    161,
    199,
    237,
    199,
    238,
    237,
    199,
    239,
    238,
    199,
    240,
    239,
    199,
    200,
    240,
    200,
    241,
    240,
    200,
    242,
    241,
    200,
    243,
    242,
    134,
    161,
    162,
    161,
    235,
    162,
    244,
    245,
    246,
    244,
    247,
    245,
    244,
    248,
    247,
    200,
    246,
    243,
    200,
    244,
    246,
    248,
    244,
    249,
    110,
    151,
    244,
    110,
    244,
    200,
    250,
    244,
    151,
    244,
    250,
    249,
    250,
    251,
    249,
    250,
    252,
    251,
    250,
    253,
    252,
    253,
    250,
    254,
    255,
    254,
    250,
    254,
    255,
    256,
    257,
    256,
    255,
    257,
    255,
    258,
    258,
    255,
    259,
    151,
    113,
    255,
    151,
    255,
    250,
    233,
    113,
    115,
    259,
    260,
    261,
    262,
    232,
    218,
    262,
    218,
    217,
    261,
    260,
    263,
    232,
    262,
    263,
    232,
    263,
    260,
    259,
    255,
    260,
    233,
    232,
    260,
    233,
    260,
    113,
    260,
    255,
    113,
    117,
    155,
    185,
    117,
    185,
    163,
    117,
    163,
    92,
    117,
    92,
    93,
    264,
    265,
    266,
    264,
    266,
    267,
    268,
    269,
    265,
    268,
    265,
    264,
    270,
    271,
    269,
    270,
    269,
    268,
    272,
    273,
    271,
    272,
    271,
    270,
    274,
    275,
    273,
    274,
    273,
    272,
    276,
    277,
    275,
    276,
    275,
    274,
    278,
    279,
    277,
    278,
    277,
    276,
    280,
    281,
    279,
    280,
    279,
    278,
    282,
    283,
    281,
    282,
    281,
    280,
    284,
    285,
    283,
    284,
    283,
    282,
    286,
    287,
    285,
    286,
    285,
    284,
    267,
    266,
    288,
    267,
    288,
    289,
    289,
    288,
    290,
    289,
    290,
    291,
    291,
    290,
    292,
    291,
    292,
    293,
    293,
    292,
    294,
    293,
    294,
    295,
    295,
    294,
    296,
    295,
    296,
    297,
    297,
    296,
    298,
    297,
    298,
    299,
    299,
    298,
    300,
    299,
    300,
    301,
    301,
    300,
    302,
    301,
    302,
    303,
    303,
    302,
    304,
    303,
    304,
    305,
    305,
    304,
    306,
    305,
    306,
    307,
    307,
    306,
    308,
    307,
    308,
    309,
    309,
    308,
    310,
    309,
    310,
    311,
    311,
    310,
    312,
    311,
    312,
    313,
    313,
    312,
    314,
    313,
    314,
    315,
    315,
    314,
    316,
    315,
    316,
    317,
    317,
    316,
    318,
    317,
    318,
    319,
    319,
    318,
    320,
    319,
    320,
    321,
    321,
    320,
    322,
    321,
    322,
    323,
    323,
    322,
    324,
    323,
    324,
    325,
    325,
    324,
    326,
    325,
    326,
    327,
    327,
    326,
    328,
    327,
    328,
    329,
    329,
    328,
    330,
    329,
    330,
    331,
    331,
    330,
    332,
    331,
    332,
    333,
    333,
    332,
    334,
    333,
    334,
    335,
    335,
    334,
    336,
    335,
    336,
    337,
    337,
    336,
    338,
    337,
    338,
    339,
    339,
    338,
    340,
    339,
    340,
    341,
    341,
    340,
    342,
    341,
    342,
    343,
    343,
    342,
    344,
    343,
    344,
    345,
    345,
    344,
    346,
    345,
    346,
    347,
    347,
    346,
    348,
    347,
    348,
    349,
    349,
    348,
    350,
    349,
    350,
    351,
    351,
    350,
    352,
    351,
    352,
    353,
    353,
    352,
    91,
    353,
    91,
    90,
    354,
    355,
    287,
    354,
    287,
    286,
    356,
    357,
    358,
    359,
    357,
    356,
    360,
    361,
    362,
    363,
    362,
    361,
    364,
    365,
    366,
    367,
    368,
    369,
    367,
    369,
    370,
    371,
    372,
    373,
    374,
    371,
    373,
    375,
    376,
    377,
    378,
    375,
    377,
    379,
    380,
    381,
    379,
    382,
    380,
    383,
    384,
    385,
    386,
    387,
    388,
    386,
    389,
    387,
    372,
    390,
    373,
    391,
    392,
    393,
    394,
    391,
    393,
    395,
    396,
    386,
    395,
    386,
    367,
    397,
    398,
    395,
    399,
    397,
    395,
    400,
    399,
    395,
    401,
    402,
    396,
    403,
    404,
    405,
    406,
    403,
    405,
    396,
    402,
    407,
    408,
    358,
    383,
    385,
    408,
    383,
    362,
    409,
    383,
    409,
    384,
    383,
    362,
    363,
    409,
    362,
    383,
    405,
    362,
    405,
    393,
    386,
    388,
    368,
    386,
    368,
    367,
    365,
    410,
    386,
    410,
    389,
    386,
    365,
    364,
    410,
    365,
    411,
    366,
    412,
    374,
    413,
    374,
    373,
    413,
    414,
    412,
    413,
    375,
    378,
    413,
    378,
    415,
    413,
    415,
    414,
    413,
    381,
    416,
    379,
    416,
    355,
    379,
    382,
    379,
    417,
    382,
    417,
    418,
    418,
    417,
    419,
    420,
    421,
    417,
    419,
    417,
    421,
    405,
    404,
    422,
    365,
    386,
    396,
    365,
    396,
    423,
    395,
    398,
    396,
    396,
    398,
    401,
    396,
    407,
    424,
    405,
    425,
    406,
    405,
    422,
    393,
    393,
    422,
    394,
    426,
    167,
    166,
    426,
    166,
    427,
    427,
    166,
    169,
    427,
    169,
    428,
    393,
    429,
    430,
    393,
    430,
    362,
    429,
    395,
    367,
    429,
    367,
    430,
    393,
    392,
    429,
    429,
    392,
    431,
    429,
    431,
    432,
    429,
    432,
    395,
    395,
    432,
    400,
    433,
    177,
    176,
    433,
    176,
    434,
    434,
    176,
    179,
    434,
    179,
    435,
    436,
    437,
    438,
    438,
    437,
    439,
    440,
    437,
    436,
    420,
    437,
    440,
    420,
    417,
    437,
    357,
    383,
    358,
    425,
    405,
    441,
    357,
    441,
    405,
    357,
    405,
    383,
    441,
    357,
    437,
    441,
    437,
    417,
    357,
    359,
    442,
    357,
    442,
    443,
    357,
    443,
    437,
    444,
    433,
    434,
    444,
    434,
    445,
    445,
    434,
    435,
    445,
    435,
    446,
    447,
    448,
    444,
    447,
    444,
    445,
    443,
    442,
    448,
    443,
    448,
    447,
    449,
    447,
    445,
    449,
    445,
    446,
    437,
    443,
    439,
    439,
    443,
    450,
    443,
    447,
    449,
    443,
    449,
    451,
    443,
    451,
    450,
    370,
    452,
    367,
    452,
    453,
    430,
    452,
    430,
    367,
    453,
    360,
    362,
    453,
    362,
    430,
    423,
    454,
    455,
    423,
    455,
    365,
    454,
    456,
    373,
    454,
    373,
    455,
    411,
    365,
    455,
    411,
    455,
    457,
    457,
    455,
    373,
    457,
    373,
    390,
    458,
    205,
    204,
    458,
    204,
    459,
    459,
    204,
    207,
    459,
    207,
    460,
    461,
    462,
    210,
    461,
    210,
    209,
    212,
    463,
    461,
    212,
    461,
    209,
    464,
    462,
    461,
    464,
    461,
    465,
    466,
    465,
    461,
    466,
    461,
    463,
    464,
    465,
    467,
    464,
    467,
    468,
    467,
    465,
    466,
    467,
    466,
    469,
    470,
    471,
    426,
    470,
    426,
    427,
    470,
    427,
    428,
    470,
    428,
    472,
    473,
    474,
    471,
    473,
    471,
    470,
    452,
    474,
    473,
    452,
    473,
    453,
    453,
    473,
    475,
    453,
    475,
    360,
    473,
    470,
    472,
    473,
    472,
    475,
    390,
    476,
    477,
    390,
    477,
    457,
    457,
    477,
    478,
    457,
    478,
    411,
    479,
    480,
    458,
    479,
    458,
    459,
    476,
    480,
    479,
    476,
    479,
    477,
    477,
    479,
    481,
    477,
    481,
    478,
    479,
    459,
    460,
    479,
    460,
    481,
    482,
    467,
    469,
    482,
    469,
    483,
    423,
    484,
    485,
    423,
    485,
    486,
    423,
    486,
    487,
    423,
    487,
    454,
    454,
    487,
    488,
    454,
    488,
    489,
    454,
    489,
    490,
    454,
    490,
    456,
    456,
    490,
    491,
    456,
    491,
    492,
    456,
    492,
    493,
    396,
    424,
    423,
    423,
    424,
    484,
    494,
    495,
    496,
    494,
    496,
    497,
    494,
    497,
    498,
    456,
    493,
    495,
    456,
    495,
    494,
    498,
    499,
    494,
    373,
    456,
    494,
    373,
    494,
    413,
    500,
    413,
    494,
    494,
    499,
    500,
    500,
    499,
    501,
    500,
    501,
    502,
    500,
    502,
    503,
    503,
    504,
    500,
    505,
    500,
    504,
    504,
    506,
    505,
    507,
    505,
    506,
    507,
    508,
    505,
    508,
    509,
    505,
    413,
    500,
    505,
    413,
    505,
    375,
    483,
    376,
    375,
    509,
    510,
    511,
    512,
    468,
    467,
    512,
    467,
    482,
    510,
    513,
    511,
    482,
    511,
    513,
    482,
    513,
    512,
    509,
    511,
    505,
    483,
    375,
    511,
    483,
    511,
    482,
    511,
    375,
    505,
    379,
    425,
    441,
    379,
    441,
    417,
    379,
    355,
    354,
    379,
    354,
    425
];


/**
 * Blade Mesh UVs
 * @type {Array}
 */
const meshUvs = [
    0.2870854139328003,
    0.2500014901161194,
    0.2746231257915497,
    0.2500014901161194,
    0.27328839898109436,
    0.26355189085006714,
    0.28486350178718567,
    0.26497936248779297,
    0.29973074793815613,
    0.2500014901161194,
    0.29635462164878845,
    0.266973078250885,
    0.3126256763935089,
    0.2500014901161194,
    0.3077339231967926,
    0.2695280909538269,
    0.3258417248725891,
    0.2500014901161194,
    0.31897422671318054,
    0.2726384401321411,
    0.33945783972740173,
    0.2500014901161194,
    0.3300483822822571,
    0.2762964963912964,
    0.35356107354164124,
    0.2500014901161194,
    0.3409295976161957,
    0.28049343824386597,
    0.36825016140937805,
    0.2500014901161194,
    0.3515917956829071,
    0.2852191925048828,
    0.3836381435394287,
    0.2500014901161194,
    0.36200928688049316,
    0.2904623746871948,
    0.3998561203479767,
    0.2500014901161194,
    0.37215688824653625,
    0.2962104082107544,
    0.41705819964408875,
    0.2500014901161194,
    0.3820101320743561,
    0.3024492859840393,
    0.43542778491973877,
    0.2500014901161194,
    0.39154547452926636,
    0.3091641664505005,
    0.26165735721588135,
    0.2500014901161194,
    0.26165735721588135,
    0.26269400119781494,
    0.24999810755252838,
    0.2500014901161194,
    0.24999810755252838,
    0.2624077796936035,
    0.23773127794265747,
    0.25030261278152466,
    0.23833885788917542,
    0.26269400119781494,
    0.225493922829628,
    0.25120532512664795,
    0.22670765221118927,
    0.26355189085006714,
    0.21331574022769928,
    0.2527073621749878,
    0.21513254940509796,
    0.26497936248779297,
    0.20122583210468292,
    0.25480514764785767,
    0.2036415934562683,
    0.266973078250885,
    0.1892535388469696,
    0.25749361515045166,
    0.19226211309432983,
    0.2695280909538269,
    0.17742741107940674,
    0.26076632738113403,
    0.18102200329303741,
    0.2726384401321411,
    0.16577625274658203,
    0.26461541652679443,
    0.16994784772396088,
    0.2762964963912964,
    0.1543278992176056,
    0.2690315246582031,
    0.15906654298305511,
    0.28049343824386597,
    0.14311008155345917,
    0.2740040421485901,
    0.1484043300151825,
    0.2852191925048828,
    0.13214975595474243,
    0.27952098846435547,
    0.13798683881759644,
    0.2904623746871948,
    0.12147333472967148,
    0.28556913137435913,
    0.12783925235271454,
    0.2962104082107544,
    0.11110655218362808,
    0.2921338677406311,
    0.11798591911792755,
    0.3024492859840393,
    0.10107440501451492,
    0.29919934272766113,
    0.10845066606998444,
    0.3091641664505005,
    0.09140096604824066,
    0.30674856901168823,
    0.09925633668899536,
    0.3163387179374695,
    0.08210963755846024,
    0.3147633671760559,
    0.09042523056268692,
    0.323955774307251,
    0.07322268933057785,
    0.32322436571121216,
    0.0819784626364708,
    0.3319969177246094,
    0.06476172059774399,
    0.3321112394332886,
    0.07393653690814972,
    0.34044283628463745,
    0.0567469485104084,
    0.34140264987945557,
    0.06631878763437271,
    0.34927308559417725,
    0.04919770359992981,
    0.35107606649398804,
    0.05914345756173134,
    0.3584665060043335,
    0.042132239788770676,
    0.3611082434654236,
    0.0524279959499836,
    0.368000864982605,
    0.035567548125982285,
    0.37147510051727295,
    0.04618839919567108,
    0.3778531551361084,
    0.029519449919462204,
    0.3821514844894409,
    0.04043986648321152,
    0.38799983263015747,
    0.02400251105427742,
    0.3931118845939636,
    0.03519614785909653,
    0.3984162211418152,
    0.019029948860406876,
    0.40432971715927124,
    0.030469926074147224,
    0.40907740592956543,
    0.014613897539675236,
    0.4157780408859253,
    0.026272615417838097,
    0.41995757818222046,
    0.010764789767563343,
    0.4274292588233948,
    0.022614195942878723,
    0.43103063106536865,
    0.007492152974009514,
    0.43925535678863525,
    0.01950356736779213,
    0.44226980209350586,
    0.00480363005772233,
    0.45122772455215454,
    0.016948195174336433,
    0.45364809036254883,
    0.0027057838160544634,
    0.4633175730705261,
    0.014954368583858013,
    0.46513795852661133,
    0.0012038287241011858,
    0.4754958748817444,
    0.013526675291359425,
    0.47671186923980713,
    0.00030109137878753245,
    0.4877331852912903,
    0.012668710201978683,
    0.48834192752838135,
    -9.06169361769571e-10,
    0.5,
    0.012382542714476585,
    0.5,
    0.45518678426742554,
    0.2500014901161194,
    0.4007396996021271,
    0.3163387179374695,
    0.5364977121353149,
    0.4367779493331909,
    0.5480305552482605,
    0.4314000606536865,
    0.5117486119270325,
    0.39199984073638916,
    0.5260737538337708,
    0.4440768361091614,
    0.6289219856262207,
    0.4530748724937439,
    0.6392490267753601,
    0.3912498354911804,
    0.6199238896369934,
    0.4440768361091614,
    0.6095001101493835,
    0.4367779493331909,
    0.7803006172180176,
    0.4367779493331909,
    0.7907243967056274,
    0.4440768361091614,
    0.8057495355606079,
    0.39199984073638916,
    0.6827490925788879,
    0.3904998302459717,
    0.7072980403900146,
    0.4367779493331909,
    0.7188308835029602,
    0.4314000606536865,
    0.6968740820884705,
    0.4440768361091614,
    0.8780983686447144,
    0.4367779493331909,
    0.8544995188713074,
    0.3942498564720154,
    0.8676745891571045,
    0.4440768361091614,
    0.8896313905715942,
    0.4314000606536865,
    0.9636998772621155,
    0.4201998710632324,
    0.9511009454727173,
    0.4367779493331909,
    0.9615249037742615,
    0.4440768361091614,
    0.9395681023597717,
    0.4314000606536865,
    0.42864859104156494,
    0.32809966802597046,
    0.4180176854133606,
    0.3319969177246094,
    0.4260595142841339,
    0.34044283628463745,
    0.4336773455142975,
    0.34927308559417725,
    0.5729988217353821,
    0.3721287250518799,
    0.5729988217353821,
    0.42699748277664185,
    0.5856756567955017,
    0.42810654640197754,
    0.7437993288040161,
    0.3721287250518799,
    0.7311225533485413,
    0.42810654640197754,
    0.7437993288040161,
    0.42699748277664185,
    0.7564761638641357,
    0.42810654640197754,
    0.8586764931678772,
    0.4530748724937439,
    0.5841682553291321,
    0.2500014901161194,
    0.5857085585594177,
    0.26089054346084595,
    0.6025941371917725,
    0.2500014901161194,
    0.5657424330711365,
    0.2500014901161194,
    0.66460120677948,
    0.26089054346084595,
    0.7363375425338745,
    0.26089054346084595,
    0.694723904132843,
    0.2500014901161194,
    0.7131499648094177,
    0.2500014901161194,
    0.6762980222702026,
    0.2500014901161194,
    0.6578721404075623,
    0.2500014901161194,
    0.7315760254859924,
    0.2500014901161194,
    0.7500019073486328,
    0.2500014901161194,
    0.510464608669281,
    0.2500014901161194,
    0.5294987559318542,
    0.26089054346084595,
    0.5288904905319214,
    0.2500014901161194,
    0.4920385479927063,
    0.2500014901161194,
    0.7622687220573425,
    0.25030261278152466,
    0.5603222250938416,
    0.42810654640197754,
    0.597967267036438,
    0.4314000606536865,
    0.7687675952911377,
    0.4314000606536865,
    0.7997224926948547,
    0.4530748724937439,
    0.901922881603241,
    0.42810654640197754,
    0.9145996570587158,
    0.3721287250518799,
    0.9145996570587158,
    0.42699748277664185,
    0.9272764325141907,
    0.42810654640197754,
    0.4095709025859833,
    0.323955774307251,
    0.45339858531951904,
    0.36214977502822876,
    0.44085267186164856,
    0.3584665060043335,
    0.44756823778152466,
    0.368000864982605,
    0.45955637097358704,
    0.38799983263015747,
    0.45380765199661255,
    0.3778531551361084,
    0.5473163723945618,
    0.2500014901161194,
    0.787299394607544,
    0.2635995149612427,
    0.7745059132575989,
    0.25120532512664795,
    0.4736126661300659,
    0.2500014901161194,
    0.6719058156013489,
    0.48732322454452515,
    0.6584014892578125,
    0.48732322454452515,
    0.6584014892578125,
    0.5,
    0.6707967519760132,
    0.5,
    0.6448923349380493,
    0.48732322454452515,
    0.6460014581680298,
    0.5,
    0.6584014892578125,
    0.39088982343673706,
    0.6269014477729797,
    0.26089054346084595,
    0.6210201978683472,
    0.2500014901161194,
    0.6394460797309875,
    0.2500014901161194,
    0.5011053085327148,
    0.48732322454452515,
    0.4897572994232178,
    0.4851508140563965,
    0.49047383666038513,
    0.5001691579818726,
    0.4999963939189911,
    0.5,
    0.48732733726501465,
    0.48834192752838135,
    0.48761358857154846,
    0.5,
    0.4695262908935547,
    0.40907740592956543,
    0.4737236201763153,
    0.41995757818222046,
    0.47514861822128296,
    0.40399986505508423,
    0.47738203406333923,
    0.43103063106536865,
    0.4647999703884125,
    0.3984162211418152,
    0.4804961681365967,
    0.26089054346084595,
    0.5170756578445435,
    0.4530748724937439,
    0.48549866676330566,
    0.4399999976158142,
    0.5043988823890686,
    0.47503161430358887,
    0.4886016547679901,
    0.4701516032218933,
    0.48646944761276245,
    0.47671186923980713,
    0.48715847730636597,
    0.45517098903656006,
    0.5097768306732178,
    0.4634987711906433,
    0.4850417673587799,
    0.46513795852661133,
    0.48049256205558777,
    0.44226980209350586,
    0.48304784297943115,
    0.45364809036254883,
    0.6878759860992432,
    0.4530748724937439,
    0.6584014892578125,
    0.4530748724937439,
    0.8301494121551514,
    0.3931248188018799,
    0.834399402141571,
    0.2758995294570923,
    0.8697995543479919,
    0.2956995964050293,
    0.8301494121551514,
    0.4530748724937439,
    0.8427061438560486,
    0.48732322454452515,
    0.8301494121551514,
    0.48732322454452515,
    0.8301494121551514,
    0.5,
    0.8415972590446472,
    0.5,
    0.815692663192749,
    0.48732322454452515,
    0.8168017864227295,
    0.5,
    0.9936099052429199,
    0.4874882698059082,
    0.9948572516441345,
    0.5,
    1,
    0.5,
    0.99969881772995,
    0.4877331852912903,
    0.9876022338867188,
    0.5,
    0.9864931702613831,
    0.48732322454452515,
    0.9987961649894714,
    0.4754958748817444,
    0.9923900961875916,
    0.47525161504745483,
    0.9831995964050293,
    0.47503161430358887,
    0.9972941875457764,
    0.4633175730705261,
    0.9912078380584717,
    0.46339094638824463,
    0.9778218269348145,
    0.4634987711906433,
    0.6584014892578125,
    0.47503161430358887,
    0.6751993894577026,
    0.47503161430358887,
    0.6415987610816956,
    0.47503161430358887,
    0.6584014892578125,
    0.4634987711906433,
    0.6805771589279175,
    0.4634987711906433,
    0.6362208127975464,
    0.4634987711906433,
    0.8301494121551514,
    0.4634987711906433,
    0.8513776659965515,
    0.4634987711906433,
    0.8070213198661804,
    0.4634987711906433,
    0.8301494121551514,
    0.47503161430358887,
    0.8459997177124023,
    0.47503161430358887,
    0.8123990893363953,
    0.47503161430358887,
    0.9888999462127686,
    0.4513999819755554,
    0.9705229997634888,
    0.4530748724937439,
    0.798774003982544,
    0.25480514764785767,
    0.7866840958595276,
    0.2527073621749878,
    0.8107464909553528,
    0.25749361515045166,
    0.8225724101066589,
    0.26076632738113403,
    0.8342235684394836,
    0.26461541652679443,
    0.8456718921661377,
    0.2690315246582031,
    0.8568897247314453,
    0.2740040421485901,
    0.8678500652313232,
    0.27952098846435547,
    0.8785266876220703,
    0.28556913137435913,
    0.8888932466506958,
    0.2921338677406311,
    0.9135997295379639,
    0.32179969549179077,
    0.9085988402366638,
    0.30674856901168823,
    0.8989254236221313,
    0.29919934272766113,
    0.9178903698921204,
    0.3147633671760559,
    0.9267773032188416,
    0.32322436571121216,
    0.9352381229400635,
    0.3321112394332886,
    0.9495997428894043,
    0.35989975929260254,
    0.9432529807090759,
    0.34140264987945557,
    0.9508020877838135,
    0.35107606649398804,
    0.9578675627708435,
    0.3611082434654236,
    0.9644324779510498,
    0.37147510051727295,
    0.9714997410774231,
    0.3997998833656311,
    0.9704805612564087,
    0.3821514844894409,
    0.9759975075721741,
    0.3931118845939636,
    0.9809699654579163,
    0.40432971715927124,
    0.985386073589325,
    0.4157780408859253,
    0.9837998151779175,
    0.42799991369247437,
    0.9892351031303406,
    0.4274292588233948,
    0.9951961636543274,
    0.45122772455215454,
    0.9925078749656677,
    0.43925535678863525,
    0.2870854139328003,
    0.7499985098838806,
    0.28486350178718567,
    0.7350205779075623,
    0.27328839898109436,
    0.7364481091499329,
    0.2746231257915497,
    0.7499985098838806,
    0.29973074793815613,
    0.7499985098838806,
    0.29635462164878845,
    0.7330268621444702,
    0.3126256763935089,
    0.7499985098838806,
    0.3077339231967926,
    0.7304718494415283,
    0.3258417248725891,
    0.7499985098838806,
    0.31897422671318054,
    0.7273615598678589,
    0.33945783972740173,
    0.7499985098838806,
    0.3300483822822571,
    0.7237035036087036,
    0.35356107354164124,
    0.7499985098838806,
    0.3409295976161957,
    0.719506561756134,
    0.36825016140937805,
    0.7499985098838806,
    0.3515917956829071,
    0.7147808074951172,
    0.3836381435394287,
    0.7499985098838806,
    0.36200928688049316,
    0.7095376253128052,
    0.3998561203479767,
    0.7499985098838806,
    0.37215688824653625,
    0.7037895917892456,
    0.41705819964408875,
    0.7499985098838806,
    0.3820101320743561,
    0.6975506544113159,
    0.43542778491973877,
    0.7499985098838806,
    0.39154547452926636,
    0.6908358335494995,
    0.26165735721588135,
    0.7373059988021851,
    0.26165735721588135,
    0.7499985098838806,
    0.24999810755252838,
    0.7375921607017517,
    0.24999810755252838,
    0.7499985098838806,
    0.23833885788917542,
    0.7373059988021851,
    0.23773127794265747,
    0.7496973276138306,
    0.22670765221118927,
    0.7364481091499329,
    0.225493922829628,
    0.748794674873352,
    0.21513254940509796,
    0.7350205779075623,
    0.21331574022769928,
    0.7472926378250122,
    0.2036415934562683,
    0.7330268621444702,
    0.20122583210468292,
    0.7451947927474976,
    0.19226211309432983,
    0.7304718494415283,
    0.1892535388469696,
    0.7425063848495483,
    0.18102200329303741,
    0.7273615598678589,
    0.17742741107940674,
    0.7392336130142212,
    0.16994784772396088,
    0.7237035036087036,
    0.16577625274658203,
    0.7353845834732056,
    0.15906654298305511,
    0.719506561756134,
    0.1543278992176056,
    0.7309684753417969,
    0.1484043300151825,
    0.7147808074951172,
    0.14311008155345917,
    0.7259959578514099,
    0.13798683881759644,
    0.7095376253128052,
    0.13214975595474243,
    0.7204790115356445,
    0.12783925235271454,
    0.7037895917892456,
    0.12147333472967148,
    0.7144308686256409,
    0.11798591911792755,
    0.6975506544113159,
    0.11110655218362808,
    0.7078661322593689,
    0.10845066606998444,
    0.6908358335494995,
    0.10107440501451492,
    0.7008006572723389,
    0.09925633668899536,
    0.6836612224578857,
    0.09140096604824066,
    0.6932514309883118,
    0.09042523056268692,
    0.6760441660881042,
    0.08210963755846024,
    0.6852366924285889,
    0.0819784626364708,
    0.6680030822753906,
    0.07322268933057785,
    0.6767756342887878,
    0.07393653690814972,
    0.6595571637153625,
    0.06476172059774399,
    0.6678887009620667,
    0.06631878763437271,
    0.6507269144058228,
    0.0567469485104084,
    0.6585973501205444,
    0.05914345756173134,
    0.6415334939956665,
    0.04919770359992981,
    0.648923933506012,
    0.0524279959499836,
    0.631999135017395,
    0.042132239788770676,
    0.6388916969299316,
    0.04618839919567108,
    0.6221468448638916,
    0.035567548125982285,
    0.628524899482727,
    0.04043986648321152,
    0.6120001673698425,
    0.029519449919462204,
    0.6178484559059143,
    0.03519614785909653,
    0.60158371925354,
    0.02400251105427742,
    0.6068881154060364,
    0.030469926074147224,
    0.5909225940704346,
    0.019029948860406876,
    0.595670223236084,
    0.026272615417838097,
    0.5800423622131348,
    0.014613897539675236,
    0.5842219591140747,
    0.022614195942878723,
    0.5689693689346313,
    0.010764789767563343,
    0.5725707411766052,
    0.01950356736779213,
    0.5577301979064941,
    0.007492152974009514,
    0.5607446432113647,
    0.016948195174336433,
    0.5463519096374512,
    0.00480363005772233,
    0.5487722754478455,
    0.014954368583858013,
    0.5348620414733887,
    0.0027057838160544634,
    0.5366823673248291,
    0.013526675291359425,
    0.5232880711555481,
    0.0012038287241011858,
    0.5245041251182556,
    0.012668710201978683,
    0.5116580724716187,
    0.00030109137878753245,
    0.5122668743133545,
    0.45518678426742554,
    0.7499985098838806,
    0.4007396996021271,
    0.6836612224578857,
    0.5364977121353149,
    0.5632220506668091,
    0.5117486119270325,
    0.6080001592636108,
    0.5480305552482605,
    0.5685999393463135,
    0.5260737538337708,
    0.5559232234954834,
    0.6289219856262207,
    0.5469251275062561,
    0.6199238896369934,
    0.5559232234954834,
    0.6392490267753601,
    0.6087501049041748,
    0.6095001101493835,
    0.5632220506668091,
    0.7803006172180176,
    0.5632220506668091,
    0.8057495355606079,
    0.6080001592636108,
    0.7907243967056274,
    0.5559232234954834,
    0.6827490925788879,
    0.6095001697540283,
    0.7188308835029602,
    0.5685999393463135,
    0.7072980403900146,
    0.5632220506668091,
    0.6968740820884705,
    0.5559232234954834,
    0.8780983686447144,
    0.5632220506668091,
    0.8676745891571045,
    0.5559232234954834,
    0.8544995188713074,
    0.6057501435279846,
    0.8896313905715942,
    0.5685999393463135,
    0.9636998772621155,
    0.5798000693321228,
    0.9615249037742615,
    0.5559232234954834,
    0.9511009454727173,
    0.5632220506668091,
    0.9395681023597717,
    0.5685999393463135,
    0.42864859104156494,
    0.6719002723693848,
    0.4260595142841339,
    0.6595571637153625,
    0.4180176854133606,
    0.6680030822753906,
    0.4336773455142975,
    0.6507269144058228,
    0.5729988217353821,
    0.6278712749481201,
    0.5856756567955017,
    0.5718934535980225,
    0.5729988217353821,
    0.5730025172233582,
    0.7437993288040161,
    0.6278712749481201,
    0.7437993288040161,
    0.5730025172233582,
    0.7311225533485413,
    0.5718934535980225,
    0.7564761638641357,
    0.5718934535980225,
    0.8586764931678772,
    0.5469251275062561,
    0.5841682553291321,
    0.7499985098838806,
    0.6025941371917725,
    0.7499985098838806,
    0.5857085585594177,
    0.7391095161437988,
    0.5657424330711365,
    0.7499985098838806,
    0.66460120677948,
    0.7391095161437988,
    0.7363375425338745,
    0.7391095161437988,
    0.694723904132843,
    0.7499985098838806,
    0.7131499648094177,
    0.7499985098838806,
    0.6762980222702026,
    0.7499985098838806,
    0.6578721404075623,
    0.7499985098838806,
    0.7315760254859924,
    0.7499985098838806,
    0.7500019073486328,
    0.7499985098838806,
    0.510464608669281,
    0.7499985098838806,
    0.5288904905319214,
    0.7499985098838806,
    0.5294987559318542,
    0.7391095161437988,
    0.4920385479927063,
    0.7499985098838806,
    0.7622687220573425,
    0.7496973276138306,
    0.5603222250938416,
    0.5718934535980225,
    0.597967267036438,
    0.5685999393463135,
    0.7687675952911377,
    0.5685999393463135,
    0.7997224926948547,
    0.5469251275062561,
    0.901922881603241,
    0.5718934535980225,
    0.9145996570587158,
    0.6278712749481201,
    0.9145996570587158,
    0.5730025172233582,
    0.9272764325141907,
    0.5718934535980225,
    0.4095709025859833,
    0.6760441660881042,
    0.45339858531951904,
    0.6378502249717712,
    0.44085267186164856,
    0.6415334939956665,
    0.44756823778152466,
    0.631999135017395,
    0.45955637097358704,
    0.6120001673698425,
    0.45380765199661255,
    0.6221468448638916,
    0.5473163723945618,
    0.7499985098838806,
    0.787299394607544,
    0.7364004850387573,
    0.7745059132575989,
    0.748794674873352,
    0.4736126661300659,
    0.7499985098838806,
    0.6719058156013489,
    0.5126767158508301,
    0.6584014892578125,
    0.5126767158508301,
    0.6448923349380493,
    0.5126767158508301,
    0.6269014477729797,
    0.7391095161437988,
    0.6584014892578125,
    0.6091101765632629,
    0.6210201978683472,
    0.7499985098838806,
    0.6394460797309875,
    0.7499985098838806,
    0.5011053085327148,
    0.5126767158508301,
    0.49049144983291626,
    0.5151932239532471,
    0.48732733726501465,
    0.5116580724716187,
    0.4695262908935547,
    0.5909225940704346,
    0.47514861822128296,
    0.596000075340271,
    0.4737236201763153,
    0.5800423622131348,
    0.47738203406333923,
    0.5689693689346313,
    0.4647999703884125,
    0.60158371925354,
    0.4804961681365967,
    0.7391095161437988,
    0.5170756578445435,
    0.5469251275062561,
    0.48549866676330566,
    0.5600000619888306,
    0.5043988823890686,
    0.5249683260917664,
    0.4898703992366791,
    0.530210018157959,
    0.48646944761276245,
    0.5232880711555481,
    0.48832041025161743,
    0.545182466506958,
    0.5097768306732178,
    0.5365012884140015,
    0.4850417673587799,
    0.5348620414733887,
    0.48049256205558777,
    0.5577301979064941,
    0.48304784297943115,
    0.5463519096374512,
    0.6878759860992432,
    0.5469251275062561,
    0.6584014892578125,
    0.5469251275062561,
    0.834399402141571,
    0.7241004705429077,
    0.8301494121551514,
    0.6068751215934753,
    0.8697995543479919,
    0.7043004035949707,
    0.8301494121551514,
    0.5469251275062561,
    0.8427061438560486,
    0.5126767158508301,
    0.8301494121551514,
    0.5126767158508301,
    0.815692663192749,
    0.5126767158508301,
    0.9936099052429199,
    0.5125117301940918,
    0.99969881772995,
    0.5122668743133545,
    0.9864931702613831,
    0.5126767158508301,
    0.9987961649894714,
    0.5245041251182556,
    0.9923900961875916,
    0.5247483253479004,
    0.9831995964050293,
    0.5249683260917664,
    0.9912078380584717,
    0.5366089940071106,
    0.9972941875457764,
    0.5366823673248291,
    0.9778218269348145,
    0.5365012884140015,
    0.6584014892578125,
    0.5249683260917664,
    0.6751993894577026,
    0.5249683260917664,
    0.6415987610816956,
    0.5249683260917664,
    0.6584014892578125,
    0.5365012884140015,
    0.6805771589279175,
    0.5365012884140015,
    0.6362208127975464,
    0.5365012884140015,
    0.8513776659965515,
    0.5365012884140015,
    0.8301494121551514,
    0.5365012884140015,
    0.8070213198661804,
    0.5365012884140015,
    0.8301494121551514,
    0.5249683260917664,
    0.8459997177124023,
    0.5249683260917664,
    0.8123990893363953,
    0.5249683260917664,
    0.9888999462127686,
    0.5486000180244446,
    0.9705229997634888,
    0.5469251275062561,
    0.7866840958595276,
    0.7472926378250122,
    0.798774003982544,
    0.7451947927474976,
    0.8107464909553528,
    0.7425063848495483,
    0.8225724101066589,
    0.7392336130142212,
    0.8342235684394836,
    0.7353845834732056,
    0.8456718921661377,
    0.7309684753417969,
    0.8568897247314453,
    0.7259959578514099,
    0.8678500652313232,
    0.7204790115356445,
    0.8785266876220703,
    0.7144308686256409,
    0.8888932466506958,
    0.7078661322593689,
    0.9135997295379639,
    0.6782002449035645,
    0.8989254236221313,
    0.7008006572723389,
    0.9085988402366638,
    0.6932514309883118,
    0.9178903698921204,
    0.6852366924285889,
    0.9267773032188416,
    0.6767756342887878,
    0.9352381229400635,
    0.6678887009620667,
    0.9495997428894043,
    0.6401002407073975,
    0.9432529807090759,
    0.6585973501205444,
    0.9508020877838135,
    0.648923933506012,
    0.9578675627708435,
    0.6388916969299316,
    0.9644324779510498,
    0.628524899482727,
    0.9714997410774231,
    0.6002001166343689,
    0.9704805612564087,
    0.6178484559059143,
    0.9759975075721741,
    0.6068881154060364,
    0.9809699654579163,
    0.595670223236084,
    0.985386073589325,
    0.5842219591140747,
    0.9892351031303406,
    0.5725707411766052,
    0.9837998151779175,
    0.5720000863075256,
    0.9951961636543274,
    0.5487722754478455,
    0.9925078749656677,
    0.5607446432113647
];

/**
 * Blade Mesh morph positions
 * @type {Array}
 */
const meshMorphPositions = [
    [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.2433396577835083,
        0.4214792251586914,
        0,
        0.32022643089294434,
        0.45733174681663513,
        0,
        0.12999999523162842,
        0.36799997091293335,
        0,
        0.17384862899780273,
        0.37282031774520874,
        0,
        0.8595011234283447,
        0.31283333897590637,
        0,
        0.6299998760223389,
        0.2800000309944153,
        0,
        0.799515962600708,
        0.37282031774520874,
        0,
        0.7300219535827637,
        0.4214792251586914,
        0,
        0.6083533763885498,
        -0.2107395976781845,
        0,
        0.5736072063446045,
        -0.18641014397144318,
        0,
        0.45600008964538574,
        -0.012000024318695068,
        0,
        0.7720000743865967,
        0.15700006484985352,
        0,
        0.8516945838928223,
        -0.2107395976781845,
        0,
        0.8132517337799072,
        -0.22866588830947876,
        0,
        0.8864405155181885,
        -0.18641014397144318,
        0,
        0.36501169204711914,
        -0.2107395976781845,
        0,
        0.39999961853027344,
        -0.006000041961669922,
        0,
        0.39975738525390625,
        -0.18641014397144318,
        0,
        0.326568603515625,
        -0.22866588830947876,
        0,
        0.046000003814697266,
        -0.07199999690055847,
        0,
        0.12167072296142578,
        -0.2107395976781845,
        0,
        0.08692407608032227,
        -0.18641014397144318,
        0,
        0.16011333465576172,
        -0.22866588830947876,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.3516664505004883,
        0.4075261354446411,
        0,
        0.4866824150085449,
        0.486682265996933,
        0,
        0.5711932182312012,
        0.47928857803344727,
        0,
        0.6400001049041748,
        -0.05200004577636719,
        0,
        0.7722787857055664,
        -0.23964427411556244,
        0,
        0.7300233840942383,
        -0.24334114789962769,
        0,
        0.6877684593200684,
        -0.23964427411556244,
        0,
        0.4297513961791992,
        -0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.40217137336730957,
        0.47928857803344727,
        0,
        0.6531369686126709,
        0.45733174681663513,
        0,
        0.6467962265014648,
        -0.22866588830947876,
        0,
        0.5436139106750488,
        -0.15641668438911438,
        0,
        0.2855968475341797,
        -0.23964427411556244,
        0,
        0.19000005722045898,
        -0.14399999380111694,
        0,
        0.24334096908569336,
        -0.24334114789962769,
        0,
        0.20108556747436523,
        -0.23964427411556244,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.9696683883666992,
        -0.04225574806332588,
        0,
        0.9723927974700928,
        0.011487752199172974,
        0,
        0.9723927974700928,
        0,
        0,
        0.973365068435669,
        0,
        0,
        0.965970516204834,
        0.08451149612665176,
        0,
        0.9733645915985107,
        0,
        0,
        0.7223169803619385,
        0.23760002851486206,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.00739288330078125,
        0.08451149612665176,
        0,
        0.0010020732879638672,
        0.00047581642866134644,
        0,
        -0.0004520416259765625,
        0.0004030172131024301,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.11386048793792725,
        0.31283333897590637,
        0,
        0,
        0,
        0,
        0.029349684715270996,
        0.16645514965057373,
        0,
        0.0016508102416992188,
        0.0004993528127670288,
        0,
        0,
        0,
        0,
        0.0013196468353271484,
        0.0004146695137023926,
        0,
        0.06520307064056396,
        0.24334114789962769,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.9164340496063232,
        -0.15641668438911438,
        0,
        0.9723927974700928,
        0.03316590189933777,
        0,
        0.4239997863769531,
        -0.012000024318695068,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.4719996452331543,
        -0.12999999523162842,
        0,
        0.4829854965209961,
        -0.04225574806332588,
        0,
        0.4719996452331543,
        -0.03999999910593033,
        0,
        0.4719996452331543,
        0,
        0,
        0.4866821765899658,
        0,
        0,
        0.49037981033325195,
        -0.04225574806332588,
        0,
        0.4866824150085449,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.003696441650390625,
        -0.04225574806332588,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.014675140380859375,
        -0.08322757482528687,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.032601356506347656,
        -0.12167057394981384,
        0,
        0.9723927974700928,
        0.007544100284576416,
        0,
        0.9586899280548096,
        -0.08322757482528687,
        0,
        0.9440135955810547,
        0.16645514965057373,
        0,
        0.9723927974700928,
        0.004658102989196777,
        0,
        0.9407634735107422,
        -0.12167057394981384,
        0,
        0.9081616401672363,
        0.24334114789962769,
        0,
        0.4719996452331543,
        -0.1120000034570694,
        0,
        0.45408058166503906,
        -0.12167057394981384,
        0,
        0.5192840099334717,
        -0.12167057394981384,
        0,
        0.4719996452331543,
        -0.07800000160932541,
        0,
        0.47200751304626465,
        -0.08322757482528687,
        0,
        0.5013580322265625,
        -0.08322757482528687,
        0,
        0,
        0,
        0,
        0.0569310188293457,
        -0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.2433396577835083,
        -0.42147916555404663,
        0,
        0.12999999523162842,
        -0.3680000305175781,
        0,
        0.32022643089294434,
        -0.4573318064212799,
        0,
        0.17384862899780273,
        -0.37282025814056396,
        0,
        0.8595011234283447,
        -0.31283339858055115,
        0,
        0.799515962600708,
        -0.37282025814056396,
        0,
        0.6299998760223389,
        -0.2799999713897705,
        0,
        0.7300219535827637,
        -0.42147916555404663,
        0,
        0.6083533763885498,
        0.2107395976781845,
        0,
        0.45600008964538574,
        0.012000024318695068,
        0,
        0.5736072063446045,
        0.18641014397144318,
        0,
        0.7720000743865967,
        -0.15700006484985352,
        0,
        0.8132517337799072,
        0.22866588830947876,
        0,
        0.8516945838928223,
        0.2107395976781845,
        0,
        0.8864405155181885,
        0.18641014397144318,
        0,
        0.36501169204711914,
        0.2107395976781845,
        0,
        0.39975738525390625,
        0.18641014397144318,
        0,
        0.39999961853027344,
        0.006000041961669922,
        0,
        0.326568603515625,
        0.22866588830947876,
        0,
        0.046000003814697266,
        0.07199999690055847,
        0,
        0.08692407608032227,
        0.18641014397144318,
        0,
        0.12167072296142578,
        0.2107395976781845,
        0,
        0.16011333465576172,
        0.22866588830947876,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.3516664505004883,
        -0.4075261354446411,
        0,
        0.5711932182312012,
        -0.4792885184288025,
        0,
        0.4866824150085449,
        -0.48668232560157776,
        0,
        0.6400001049041748,
        0.05200004577636719,
        0,
        0.7300233840942383,
        0.24334114789962769,
        0,
        0.7722787857055664,
        0.23964427411556244,
        0,
        0.6877684593200684,
        0.23964427411556244,
        0,
        0.4297513961791992,
        0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.40217137336730957,
        -0.4792885184288025,
        0,
        0.6531369686126709,
        -0.4573318064212799,
        0,
        0.6467962265014648,
        0.22866588830947876,
        0,
        0.5436139106750488,
        0.15641668438911438,
        0,
        0.2855968475341797,
        0.23964427411556244,
        0,
        0.19000005722045898,
        0.14399999380111694,
        0,
        0.24334096908569336,
        0.24334114789962769,
        0,
        0.20108556747436523,
        0.23964427411556244,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.9696683883666992,
        0.04225574806332588,
        0,
        0.9723927974700928,
        -0.011487752199172974,
        0,
        0.965970516204834,
        -0.08451149612665176,
        0,
        0,
        0,
        0,
        0.7223169803619385,
        -0.23760002851486206,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.00739288330078125,
        -0.08451149612665176,
        0,
        -0.001673579216003418,
        0.00034965574741363525,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.11386048793792725,
        -0.31283339858055115,
        0,
        0,
        0,
        0,
        0.029349684715270996,
        -0.16645514965057373,
        0,
        -0.002778291702270508,
        0.0003414154052734375,
        0,
        0,
        0,
        0,
        -0.0028470754623413086,
        0.00036212801933288574,
        0,
        0.06520307064056396,
        -0.24334114789962769,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.9164340496063232,
        0.15641668438911438,
        0,
        0.9723927974700928,
        -0.03316590189933777,
        0,
        0,
        0,
        0,
        0.4239997863769531,
        0.012000024318695068,
        0,
        0,
        0,
        0,
        0.4719996452331543,
        0.12999999523162842,
        0,
        0.4829854965209961,
        0.04225574806332588,
        0,
        0.4719996452331543,
        0.03999999910593033,
        0,
        0.49037981033325195,
        0.04225574806332588,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.003696441650390625,
        0.04225574806332588,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.014675140380859375,
        0.08322757482528687,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.032601356506347656,
        0.12167057394981384,
        0,
        0.9723927974700928,
        -0.007544100284576416,
        0,
        0.9586899280548096,
        0.08322757482528687,
        0,
        0.9440135955810547,
        -0.16645514965057373,
        0,
        0.9723927974700928,
        -0.004658102989196777,
        0,
        0.9407634735107422,
        0.12167057394981384,
        0,
        0.9081616401672363,
        -0.24334114789962769,
        0,
        0.45408058166503906,
        0.12167057394981384,
        0,
        0.4719996452331543,
        0.1120000034570694,
        0,
        0.5192840099334717,
        0.12167057394981384,
        0,
        0.4719996452331543,
        0.07800000160932541,
        0,
        0.47200751304626465,
        0.08322757482528687,
        0,
        0.5013580322265625,
        0.08322757482528687,
        0,
        0,
        0,
        0,
        0.0569310188293457,
        0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ],
    [
        -0.002700507640838623,
        -0.01803898811340332,
        0,
        -0.0008068978786468506,
        -0.008025407791137695,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.006403118371963501,
        -0.032024264335632324,
        0,
        0,
        0,
        0,
        -0.012553006410598755,
        -0.049947381019592285,
        0,
        0,
        0,
        0,
        -0.021820425987243652,
        -0.07176542282104492,
        0,
        0,
        0,
        0,
        0.02750498056411743,
        -0.11568272113800049,
        0,
        0,
        0,
        0,
        0.07358193397521973,
        -0.1596001386642456,
        0,
        0,
        0,
        0,
        0.11575323343276978,
        -0.20351731777191162,
        0,
        0,
        0,
        0,
        0.15326547622680664,
        -0.2474346160888672,
        0,
        0,
        0,
        0,
        0.18524479866027832,
        -0.2913520336151123,
        0,
        0,
        0,
        0,
        0.2106635570526123,
        -0.3352692127227783,
        0,
        0,
        0,
        0,
        0.22829794883728027,
        -0.3791865110397339,
        0,
        0,
        0,
        0,
        0.004050545394420624,
        -0.002007603645324707,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.23667120933532715,
        -0.42310380935668945,
        0,
        0,
        0,
        0,
        2.6377081871032715,
        -0.3597858250141144,
        0,
        2.5720760822296143,
        -0.39039045572280884,
        0,
        2.760000228881836,
        -0.6209999918937683,
        0,
        2.6970279216766357,
        -0.31824934482574463,
        0,
        2.111737012863159,
        -0.26704302430152893,
        0,
        2.056161642074585,
        -0.6198743581771851,
        0,
        2.1629436016082764,
        -0.31824934482574463,
        0,
        2.222263813018799,
        -0.3597858250141144,
        0,
        1.2502696514129639,
        -0.3597858250141144,
        0,
        1.1909492015838623,
        -0.31824934482574463,
        0,
        1.1071116924285889,
        -0.6155993938446045,
        0,
        1.8082115650177002,
        -0.6241493821144104,
        0,
        1.6657137870788574,
        -0.3597858250141144,
        0,
        1.6000819206237793,
        -0.39039045572280884,
        0,
        1.7250337600708008,
        -0.31824934482574463,
        0,
        0.6937189102172852,
        -0.3597858250141144,
        0,
        0.8292365074157715,
        -0.6027743816375732,
        0,
        0.7530393600463867,
        -0.31824934482574463,
        0,
        0.628087043762207,
        -0.39039045572280884,
        0,
        0.20599985122680664,
        -0.4505000114440918,
        0,
        0.2782745361328125,
        -0.3597858250141144,
        0,
        0.21895456314086914,
        -0.31824934482574463,
        0,
        0.3439064025878906,
        -0.39039045572280884,
        0,
        0.0690000057220459,
        0.029000043869018555,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2.4126665592193604,
        -0.7304738163948059,
        0,
        2.429985761642456,
        -0.41544485092163086,
        0,
        2.357844829559326,
        -0.40913331508636475,
        0,
        1.4602265357971191,
        -0.7288644909858704,
        0,
        1.5301322937011719,
        -0.40913331508636475,
        0,
        1.457991600036621,
        -0.41544485092163086,
        0,
        1.385850429534912,
        -0.40913331508636475,
        0,
        0.8042459487915039,
        -0.26704302430152893,
        0,
        0.3574862480163574,
        -0.7305248379707336,
        0,
        0.23393583297729492,
        -0.7560599446296692,
        0,
        0.37474584579467773,
        -0.774442195892334,
        0,
        0.3402271270751953,
        -0.6866075992584229,
        0,
        0.48398590087890625,
        -0.9480599164962769,
        0,
        0.6337449550628662,
        -1.1200599670410156,
        0,
        0.4610424041748047,
        -0.9940286874771118,
        0,
        0.4783012866973877,
        -1.0379459857940674,
        0,
        0.4437828063964844,
        -0.9501113295555115,
        0,
        0.42652344703674316,
        -0.9061939716339111,
        0,
        0.495560884475708,
        -1.081863284111023,
        0,
        0.5128202438354492,
        -1.125780463218689,
        0,
        0.28844916820526123,
        -0.5548557043075562,
        0,
        0.07066631317138672,
        -0.6180599331855774,
        0,
        0.3057084083557129,
        -0.5987730026245117,
        0,
        0.27118992805480957,
        -0.5109384059906006,
        0,
        0.5711400508880615,
        -1.1676902770996094,
        0,
        2.502126932144165,
        -0.40913331508636475,
        0,
        2.287895441055298,
        -0.39039045572280884,
        0,
        1.3159008026123047,
        -0.39039045572280884,
        0,
        1.1397428512573242,
        -0.26704302430152893,
        0,
        0.558138370513916,
        -0.40913331508636475,
        0,
        0.4866666793823242,
        -0.7288644909858704,
        0,
        0.48599720001220703,
        -0.41544485092163086,
        0,
        0.41385650634765625,
        -0.40913331508636475,
        0,
        0,
        0,
        0,
        0.1237567663192749,
        0.03842973709106445,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.3229677677154541,
        -0.6426904201507568,
        0,
        1.0239999294281006,
        -1.3160001039505005,
        0,
        0.6296570301055908,
        -1.205589771270752,
        0,
        0.25393056869506836,
        -0.467021107673645,
        0,
        1.867124080657959,
        -0.07214176654815674,
        0,
        1.9469926357269287,
        -0.07225733250379562,
        0,
        1.9469926357269287,
        0,
        0,
        1.8734357357025146,
        0,
        0,
        2.020853042602539,
        -0.07214176654815674,
        0,
        2.0145413875579834,
        0,
        0,
        1.9469926357269287,
        -0.6219263672828674,
        0,
        0.3273169994354248,
        -0.8340598940849304,
        0,
        0.39200496673583984,
        -0.8183594942092896,
        0,
        0.40926432609558105,
        -0.8622767329216003,
        0,
        2.8391189575195312,
        -0.07214176654815674,
        0,
        0.16590666770935059,
        -0.0008331388235092163,
        0,
        0.16807377338409424,
        -0.00031630927696824074,
        0,
        2.8454298973083496,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.14129769802093506,
        0.05462402105331421,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.22135019302368164,
        -0.6860598921775818,
        0,
        2.748234272003174,
        -0.26704302430152893,
        0,
        0.14499998092651367,
        -0.005000025033950806,
        0,
        2.820375919342041,
        -0.14209091663360596,
        0,
        0.16088545322418213,
        -0.0017549842596054077,
        0,
        0,
        0,
        0,
        0.15377235412597656,
        -0.0031194090843200684,
        0,
        2.78977108001709,
        -0.2077227234840393,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1.776240587234497,
        -0.26704302430152893,
        0,
        1.9469926357269287,
        -0.2674725353717804,
        0,
        0.9680314064025879,
        -0.6091868281364441,
        0,
        0.9120001792907715,
        -1.2960000038146973,
        0,
        0.7109999656677246,
        -1.1700000762939453,
        0,
        0.9680314064025879,
        -0.2674725353717804,
        0,
        0.8951301574707031,
        -0.07214176654815674,
        0,
        0.9680314064025879,
        -0.07225733250379562,
        0,
        0.9680314064025879,
        0,
        0,
        0.9014418125152588,
        0,
        0,
        1.0488591194152832,
        -0.07214176654815674,
        0,
        1.0425472259521484,
        0,
        0,
        0.03545188903808594,
        -0.07139543443918228,
        0,
        0.02852153778076172,
        0,
        0,
        0,
        0,
        0,
        0.0017132759094238281,
        -0.06980903446674347,
        0,
        0.07055330276489258,
        0,
        0,
        0.07686424255371094,
        -0.07214176654815674,
        0,
        0.006850242614746094,
        -0.13944925367832184,
        0,
        0.041800498962402344,
        -0.14021176099777222,
        0,
        0.09560728073120117,
        -0.14209091663360596,
        0,
        0.013350963592529297,
        -0.1969558447599411,
        0,
        0.04669809341430664,
        -0.20252151787281036,
        0,
        0.12621164321899414,
        -0.2077227234840393,
        0,
        1.9469926357269287,
        -0.14231915771961212,
        0,
        1.848381519317627,
        -0.14209091663360596,
        0,
        2.03959584236145,
        -0.14209091663360596,
        0,
        1.9469926357269287,
        -0.20805668830871582,
        0,
        1.817777156829834,
        -0.2077227234840393,
        0,
        2.0702009201049805,
        -0.2077227234840393,
        0,
        0.9680314064025879,
        -0.20805668830871582,
        0,
        0.8457822799682617,
        -0.2077227234840393,
        0,
        1.0982062816619873,
        -0.2077227234840393,
        0,
        0.9680314064025879,
        -0.14231915771961212,
        0,
        0.876387357711792,
        -0.14209091663360596,
        0,
        1.0676021575927734,
        -0.14209091663360596,
        0,
        0.05819988250732422,
        -0.2691999673843384,
        0,
        0.16774845123291016,
        -0.26704302430152893,
        0,
        0.7480673789978027,
        -1.269425392150879,
        0,
        0.6885676383972168,
        -1.239493489265442,
        0,
        0.8083505630493164,
        -1.2954195737838745,
        0,
        0.8696088790893555,
        -1.3175188302993774,
        0,
        0.9320330619812012,
        -1.3357757329940796,
        0,
        0.8670811653137207,
        -1.310091257095337,
        0,
        0.8034672737121582,
        -1.2812505960464478,
        0,
        0.7413449287414551,
        -1.2493231296539307,
        0,
        0.6808643341064453,
        -1.2143861055374146,
        0,
        0.6221709251403809,
        -1.176523208618164,
        0,
        0.47536325454711914,
        -1.0132554769515991,
        0,
        0.510706901550293,
        -1.0923930406570435,
        0,
        0.565406322479248,
        -1.1358263492584229,
        0,
        0.4582037925720215,
        -1.0463279485702515,
        0,
        0.40802526473999023,
        -0.9977423548698425,
        0,
        0.36029052734375,
        -0.9467530250549316,
        0,
        0.2749471664428711,
        -0.7988166213035583,
        0,
        0.31511545181274414,
        -0.8934828639030457,
        0,
        0.27260875701904297,
        -0.838060200214386,
        0,
        0.23287248611450195,
        -0.7806186676025391,
        0,
        0.19600248336791992,
        -0.7212965488433838,
        0,
        0.15513134002685547,
        -0.5647777318954468,
        0,
        0.16208791732788086,
        -0.660236656665802,
        0,
        0.1312098503112793,
        -0.5975862145423889,
        0,
        0.10344409942626953,
        -0.5334962010383606,
        0,
        0.07885503768920898,
        -0.4681209623813629,
        0,
        0.08411550521850586,
        -0.40413886308670044,
        0,
        0.05750417709350586,
        -0.4016179144382477,
        0,
        0.02471303939819336,
        -0.26587188243865967,
        0,
        0.03944253921508789,
        -0.3341474235057831,
        0,
        -0.002700507640838623,
        0.01803898811340332,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0008068978786468506,
        0.008025407791137695,
        0,
        -0.006403118371963501,
        0.032024264335632324,
        0,
        0,
        0,
        0,
        -0.012553006410598755,
        0.049947381019592285,
        0,
        0,
        0,
        0,
        -0.021820425987243652,
        0.07176554203033447,
        0,
        0,
        0,
        0,
        0.02750498056411743,
        0.11568272113800049,
        0,
        0,
        0,
        0,
        0.07358193397521973,
        0.1596001386642456,
        0,
        0,
        0,
        0,
        0.11575323343276978,
        0.20351731777191162,
        0,
        0,
        0,
        0,
        0.15326547622680664,
        0.2474346160888672,
        0,
        0,
        0,
        0,
        0.18524479866027832,
        0.29135191440582275,
        0,
        0,
        0,
        0,
        0.2106635570526123,
        0.3352692127227783,
        0,
        0,
        0,
        0,
        0.22829794883728027,
        0.3791865110397339,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.004050545394420624,
        0.002007603645324707,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.23667120933532715,
        0.42310380935668945,
        0,
        0,
        0,
        0,
        2.6377081871032715,
        0.3597858250141144,
        0,
        2.760000228881836,
        0.6209999918937683,
        0,
        2.5720760822296143,
        0.39039045572280884,
        0,
        2.6970279216766357,
        0.31824934482574463,
        0,
        2.111737012863159,
        0.26704302430152893,
        0,
        2.1629436016082764,
        0.31824934482574463,
        0,
        2.056161642074585,
        0.6198743581771851,
        0,
        2.222263813018799,
        0.3597858250141144,
        0,
        1.2502696514129639,
        0.3597858250141144,
        0,
        1.1071116924285889,
        0.6155993938446045,
        0,
        1.1909492015838623,
        0.31824934482574463,
        0,
        1.8082115650177002,
        0.6241493821144104,
        0,
        1.6000819206237793,
        0.39039045572280884,
        0,
        1.6657137870788574,
        0.3597858250141144,
        0,
        1.7250337600708008,
        0.31824934482574463,
        0,
        0.6937189102172852,
        0.3597858250141144,
        0,
        0.7530393600463867,
        0.31824934482574463,
        0,
        0.8292365074157715,
        0.6027743816375732,
        0,
        0.628087043762207,
        0.39039045572280884,
        0,
        0.20599985122680664,
        0.4505000114440918,
        0,
        0.21895456314086914,
        0.31824934482574463,
        0,
        0.2782745361328125,
        0.3597858250141144,
        0,
        0.3439064025878906,
        0.39039045572280884,
        0,
        0.0690000057220459,
        -0.029000043869018555,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2.4126665592193604,
        0.7304738163948059,
        0,
        2.357844829559326,
        0.40913331508636475,
        0,
        2.429985761642456,
        0.41544485092163086,
        0,
        1.4602265357971191,
        0.7288644909858704,
        0,
        1.457991600036621,
        0.41544485092163086,
        0,
        1.5301322937011719,
        0.40913331508636475,
        0,
        1.385850429534912,
        0.40913331508636475,
        0,
        0.8042459487915039,
        0.26704302430152893,
        0,
        0.3574862480163574,
        0.7305248379707336,
        0,
        0.37474584579467773,
        0.774442195892334,
        0,
        0.23393583297729492,
        0.7560599446296692,
        0,
        0.3402271270751953,
        0.6866075992584229,
        0,
        0.48398590087890625,
        0.9480599164962769,
        0,
        0.6337449550628662,
        1.1200599670410156,
        0,
        0.4610424041748047,
        0.9940286874771118,
        0,
        0.4783012866973877,
        1.0379459857940674,
        0,
        0.4437828063964844,
        0.9501113295555115,
        0,
        0.42652344703674316,
        0.9061939716339111,
        0,
        0.495560884475708,
        1.081863284111023,
        0,
        0.5128202438354492,
        1.125780463218689,
        0,
        0.28844916820526123,
        0.5548557043075562,
        0,
        0.3057084083557129,
        0.5987730026245117,
        0,
        0.07066631317138672,
        0.6180599331855774,
        0,
        0.27118992805480957,
        0.5109385251998901,
        0,
        0.5711400508880615,
        1.1676902770996094,
        0,
        2.502126932144165,
        0.40913331508636475,
        0,
        2.287895441055298,
        0.39039045572280884,
        0,
        1.3159008026123047,
        0.39039045572280884,
        0,
        1.1397428512573242,
        0.26704302430152893,
        0,
        0.558138370513916,
        0.40913331508636475,
        0,
        0.4866666793823242,
        0.7288644909858704,
        0,
        0.48599720001220703,
        0.41544485092163086,
        0,
        0.41385650634765625,
        0.40913331508636475,
        0,
        0,
        0,
        0,
        0.12431418895721436,
        -0.03773856163024902,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.3229677677154541,
        0.6426903009414673,
        0,
        1.0239999294281006,
        1.3160001039505005,
        0,
        0.6296570301055908,
        1.205589771270752,
        0,
        0.25393056869506836,
        0.467021107673645,
        0,
        1.867124080657959,
        0.07214176654815674,
        0,
        1.9469926357269287,
        0.07225733250379562,
        0,
        2.020853042602539,
        0.07214176654815674,
        0,
        0.3273169994354248,
        0.8340598940849304,
        0,
        1.9469926357269287,
        0.6219263672828674,
        0,
        0.39200496673583984,
        0.8183594942092896,
        0,
        0.40926432609558105,
        0.8622767329216003,
        0,
        2.8391189575195312,
        0.07214176654815674,
        0,
        0.16686654090881348,
        0.00004729628562927246,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.14165890216827393,
        -0.05382949113845825,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.22135019302368164,
        0.6860598921775818,
        0,
        2.748234272003174,
        0.26704302430152893,
        0,
        0.14499998092651367,
        0.005000025033950806,
        0,
        2.820375919342041,
        0.14209091663360596,
        0,
        0.16255652904510498,
        0.0006660819053649902,
        0,
        0,
        0,
        0,
        0.1547764539718628,
        0.002169191837310791,
        0,
        2.78977108001709,
        0.2077227234840393,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1.776240587234497,
        0.26704302430152893,
        0,
        1.9469926357269287,
        0.2674725353717804,
        0,
        0.9120001792907715,
        1.2960000038146973,
        0,
        0.9680314064025879,
        0.6091868281364441,
        0,
        0.7109999656677246,
        1.1700000762939453,
        0,
        0.9680314064025879,
        0.2674725353717804,
        0,
        0.8951301574707031,
        0.07214176654815674,
        0,
        0.9680314064025879,
        0.07225733250379562,
        0,
        1.0488591194152832,
        0.07214176654815674,
        0,
        0.03545188903808594,
        0.07139543443918228,
        0,
        0.0017132759094238281,
        0.06980903446674347,
        0,
        0.07686424255371094,
        0.07214176654815674,
        0,
        0.006850242614746094,
        0.13944925367832184,
        0,
        0.041800498962402344,
        0.14021176099777222,
        0,
        0.09560728073120117,
        0.14209091663360596,
        0,
        0.04669809341430664,
        0.20252151787281036,
        0,
        0.013350963592529297,
        0.1969558447599411,
        0,
        0.12621164321899414,
        0.2077227234840393,
        0,
        1.9469926357269287,
        0.14231915771961212,
        0,
        1.848381519317627,
        0.14209091663360596,
        0,
        2.03959584236145,
        0.14209091663360596,
        0,
        1.9469926357269287,
        0.20805668830871582,
        0,
        1.817777156829834,
        0.2077227234840393,
        0,
        2.0702009201049805,
        0.2077227234840393,
        0,
        0.8457822799682617,
        0.2077227234840393,
        0,
        0.9680314064025879,
        0.20805668830871582,
        0,
        1.0982062816619873,
        0.2077227234840393,
        0,
        0.9680314064025879,
        0.14231915771961212,
        0,
        0.876387357711792,
        0.14209091663360596,
        0,
        1.0676021575927734,
        0.14209091663360596,
        0,
        0.05819988250732422,
        0.2691999673843384,
        0,
        0.16774845123291016,
        0.26704302430152893,
        0,
        0.6885676383972168,
        1.239493489265442,
        0,
        0.7480673789978027,
        1.269425392150879,
        0,
        0.8083505630493164,
        1.2954195737838745,
        0,
        0.8696088790893555,
        1.3175188302993774,
        0,
        0.9320330619812012,
        1.3357757329940796,
        0,
        0.8670811653137207,
        1.310091257095337,
        0,
        0.8034672737121582,
        1.2812505960464478,
        0,
        0.7413449287414551,
        1.2493231296539307,
        0,
        0.6808643341064453,
        1.2143861055374146,
        0,
        0.6221709251403809,
        1.176523208618164,
        0,
        0.47536325454711914,
        1.0132554769515991,
        0,
        0.565406322479248,
        1.1358263492584229,
        0,
        0.510706901550293,
        1.0923930406570435,
        0,
        0.4582037925720215,
        1.0463279485702515,
        0,
        0.40802526473999023,
        0.9977423548698425,
        0,
        0.36029052734375,
        0.9467530250549316,
        0,
        0.2749471664428711,
        0.7988166213035583,
        0,
        0.31511545181274414,
        0.8934828639030457,
        0,
        0.27260875701904297,
        0.838060200214386,
        0,
        0.23287248611450195,
        0.7806186676025391,
        0,
        0.19600248336791992,
        0.7212965488433838,
        0,
        0.15513134002685547,
        0.5647777318954468,
        0,
        0.16208791732788086,
        0.660236656665802,
        0,
        0.1312098503112793,
        0.5975862145423889,
        0,
        0.10344409942626953,
        0.5334962010383606,
        0,
        0.07885503768920898,
        0.4681209623813629,
        0,
        0.05750417709350586,
        0.4016179144382477,
        0,
        0.08411550521850586,
        0.40413886308670044,
        0,
        0.02471303939819336,
        0.26587188243865967,
        0,
        0.03944253921508789,
        0.3341474235057831,
        0
    ],
    [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.12167060375213623,
        -0.2107395976781845,
        0,
        -0.16011357307434082,
        -0.22866588830947876,
        0,
        0,
        0,
        0,
        -0.08692443370819092,
        -0.18641014397144318,
        0,
        -0.4297513961791992,
        -0.15641668438911438,
        0,
        -0.21499991416931152,
        0.07500004768371582,
        0,
        -0.39975786209106445,
        -0.18641014397144318,
        0,
        -0.36501169204711914,
        -0.2107395976781845,
        0,
        0.24334001541137695,
        0.4214792251586914,
        0,
        0.3128337860107422,
        0.37282031774520874,
        0,
        0.12299966812133789,
        0.30800002813339233,
        0,
        -0.16899991035461426,
        0.25199997425079346,
        0,
        -0.24334239959716797,
        0.4214792251586914,
        0,
        -0.16645574569702148,
        0.45733174681663513,
        0,
        -0.312833309173584,
        0.37282031774520874,
        0,
        0.36501169204711914,
        -0.2107395976781845,
        0,
        0.24499988555908203,
        0.0849999189376831,
        0,
        0.39975738525390625,
        -0.18641014397144318,
        0,
        0.326568603515625,
        -0.22866588830947876,
        0,
        0,
        0,
        0,
        0.12167072296142578,
        -0.2107395976781845,
        0,
        0.08692407608032227,
        -0.18641014397144318,
        0,
        0.16011333465576172,
        -0.22866588830947876,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.17333340644836426,
        0.017526209354400635,
        0,
        -0.24334120750427246,
        -0.24334114789962769,
        0,
        -0.2855968475341797,
        -0.23964427411556244,
        0,
        0,
        0.3400000333786011,
        0,
        -0.08451128005981445,
        0.47928857803344727,
        0,
        0,
        0.486682265996933,
        0,
        0.08451128005981445,
        0.47928857803344727,
        0,
        0.4297513961791992,
        -0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.20108556747436523,
        -0.23964427411556244,
        0,
        -0.3265688419342041,
        -0.22866588830947876,
        0,
        0.16645479202270508,
        0.45733174681663513,
        0,
        0.3728194236755371,
        0.31283333897590637,
        0,
        0.2855968475341797,
        -0.23964427411556244,
        0,
        0,
        0,
        0,
        0.24334096908569336,
        -0.24334114789962769,
        0,
        0.20108556747436523,
        -0.23964427411556244,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.47928929328918457,
        0.08451149612665176,
        0,
        -0.5,
        -0.019860200583934784,
        0,
        -0.5,
        0,
        0,
        -0.4866819381713867,
        0,
        0,
        -0.4829854965209961,
        -0.04225574806332588,
        0,
        -0.4866824150085449,
        0,
        0,
        -0.1446828842163086,
        0.22860002517700195,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0036967992782592773,
        -0.04225574806332588,
        0,
        0.0009113550186157227,
        0.0004747062921524048,
        0,
        -0.0005533695220947266,
        0.0004042122745886445,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0569310188293457,
        -0.15641668438911438,
        0,
        0,
        0,
        0,
        -0.014675259590148926,
        -0.08322757482528687,
        0,
        0.0015821456909179688,
        0.0004971474409103394,
        0,
        0,
        0,
        0,
        0.0012818574905395508,
        0.00041282176971435547,
        0,
        -0.03260147571563721,
        -0.12167057394981384,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.372821569442749,
        0.31283333897590637,
        0,
        -0.5,
        -0.07351583242416382,
        0,
        0.16233301162719727,
        0.24150002002716064,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.49500036239624023,
        -0.05474585294723511,
        0,
        0.4829854965209961,
        -0.04225574806332588,
        0,
        0.49500036239624023,
        -0.014789514243602753,
        0,
        0.49500036239624023,
        0,
        0,
        0.4866821765899658,
        0,
        0,
        0.47928857803344727,
        0.08451149612665176,
        0,
        0.4866824150085449,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.003696441650390625,
        -0.04225574806332588,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.014675140380859375,
        -0.08322757482528687,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.032601356506347656,
        -0.12167057394981384,
        0,
        -0.5,
        -0.03911694884300232,
        0,
        -0.4573323726654053,
        0.16645514965057373,
        0,
        -0.47200703620910645,
        -0.08322757482528687,
        0,
        -0.5,
        -0.05718517303466797,
        0,
        -0.4214789867401123,
        0.24334114789962769,
        0,
        -0.45408082008361816,
        -0.12167057394981384,
        0,
        0.49500036239624023,
        -0.042584702372550964,
        0,
        0.45408058166503906,
        -0.12167057394981384,
        0,
        0.4214799404144287,
        0.24334114789962769,
        0,
        0.49500036239624023,
        -0.02912965416908264,
        0,
        0.47200751304626465,
        -0.08322757482528687,
        0,
        0.45733165740966797,
        0.16645514965057373,
        0,
        0,
        0,
        0,
        0.0569310188293457,
        -0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.12167060375213623,
        0.2107395976781845,
        0,
        0,
        0,
        0,
        -0.16011357307434082,
        0.22866588830947876,
        0,
        -0.08692443370819092,
        0.18641014397144318,
        0,
        -0.4297513961791992,
        0.15641668438911438,
        0,
        -0.39975786209106445,
        0.18641014397144318,
        0,
        -0.21499991416931152,
        -0.07500004768371582,
        0,
        -0.36501169204711914,
        0.2107395976781845,
        0,
        0.24334001541137695,
        -0.42147916555404663,
        0,
        0.12299966812133789,
        -0.30799996852874756,
        0,
        0.3128337860107422,
        -0.37282025814056396,
        0,
        -0.16899991035461426,
        -0.25200003385543823,
        0,
        -0.16645574569702148,
        -0.4573318064212799,
        0,
        -0.24334239959716797,
        -0.42147916555404663,
        0,
        -0.312833309173584,
        -0.37282025814056396,
        0,
        0.36501169204711914,
        0.2107395976781845,
        0,
        0.39975738525390625,
        0.18641014397144318,
        0,
        0.24499988555908203,
        -0.0849999189376831,
        0,
        0.326568603515625,
        0.22866588830947876,
        0,
        0,
        0,
        0,
        0.08692407608032227,
        0.18641014397144318,
        0,
        0.12167072296142578,
        0.2107395976781845,
        0,
        0.16011333465576172,
        0.22866588830947876,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.17333340644836426,
        -0.017526209354400635,
        0,
        -0.2855968475341797,
        0.23964427411556244,
        0,
        -0.24334120750427246,
        0.24334114789962769,
        0,
        0,
        -0.3399999141693115,
        0,
        0,
        -0.48668232560157776,
        0,
        -0.08451128005981445,
        -0.4792885184288025,
        0,
        0.08451128005981445,
        -0.4792885184288025,
        0,
        0.4297513961791992,
        0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.20108556747436523,
        0.23964427411556244,
        0,
        -0.3265688419342041,
        0.22866588830947876,
        0,
        0.16645479202270508,
        -0.4573318064212799,
        0,
        0.3728194236755371,
        -0.31283339858055115,
        0,
        0.2855968475341797,
        0.23964427411556244,
        0,
        0,
        0,
        0,
        0.24334096908569336,
        0.24334114789962769,
        0,
        0.20108556747436523,
        0.23964427411556244,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.47928929328918457,
        -0.08451149612665176,
        0,
        -0.5,
        0.019860200583934784,
        0,
        -0.4829854965209961,
        0.04225574806332588,
        0,
        0,
        0,
        0,
        -0.1446828842163086,
        -0.22860002517700195,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0036967992782592773,
        0.04225574806332588,
        0,
        -0.0017715692520141602,
        0.0003534853458404541,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0569310188293457,
        0.15641668438911438,
        0,
        0,
        0,
        0,
        -0.014675259590148926,
        0.08322757482528687,
        0,
        -0.002859354019165039,
        0.0003470778465270996,
        0,
        0,
        0,
        0,
        -0.0028954744338989258,
        0.00036713480949401855,
        0,
        -0.03260147571563721,
        0.12167057394981384,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.372821569442749,
        -0.31283339858055115,
        0,
        -0.5,
        0.07351583242416382,
        0,
        0,
        0,
        0,
        0.16233301162719727,
        -0.24150002002716064,
        0,
        0,
        0,
        0,
        0.49500036239624023,
        0.05474585294723511,
        0,
        0.4829854965209961,
        0.04225574806332588,
        0,
        0.49500036239624023,
        0.014789514243602753,
        0,
        0.47928857803344727,
        -0.08451149612665176,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.003696441650390625,
        0.04225574806332588,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.014675140380859375,
        0.08322757482528687,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.032601356506347656,
        0.12167057394981384,
        0,
        -0.5,
        0.03911694884300232,
        0,
        -0.4573323726654053,
        -0.16645514965057373,
        0,
        -0.47200703620910645,
        0.08322757482528687,
        0,
        -0.5,
        0.05718517303466797,
        0,
        -0.4214789867401123,
        -0.24334114789962769,
        0,
        -0.45408082008361816,
        0.12167057394981384,
        0,
        0.45408058166503906,
        0.12167057394981384,
        0,
        0.49500036239624023,
        0.042584702372550964,
        0,
        0.4214799404144287,
        -0.24334114789962769,
        0,
        0.49500036239624023,
        0.02912965416908264,
        0,
        0.47200751304626465,
        0.08322757482528687,
        0,
        0.45733165740966797,
        -0.16645514965057373,
        0,
        0,
        0,
        0,
        0.0569310188293457,
        0.15641668438911438,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ],
    [
        0.386249840259552,
        -0.5111169815063477,
        0,
        0.40879666805267334,
        -0.5551019906997681,
        0,
        -0.10822245478630066,
        -1.0986930131912231,
        0,
        -0.16200768947601318,
        -1.092059850692749,
        0,
        0.36248308420181274,
        -0.4671320915222168,
        0,
        -0.21540266275405884,
        -1.0827958583831787,
        0,
        0.3370523750782013,
        -0.42314696311950684,
        0,
        -0.26827874779701233,
        -1.0709233283996582,
        0,
        0.30947983264923096,
        -0.379162073135376,
        0,
        -0.3205084204673767,
        -1.0564707517623901,
        0,
        0.2792414426803589,
        -0.33517706394195557,
        0,
        -0.37196603417396545,
        -1.0394731760025024,
        0,
        0.24575459957122803,
        -0.2911919355392456,
        0,
        -0.422527551651001,
        -1.019971251487732,
        0,
        0.20836210250854492,
        -0.24720704555511475,
        0,
        -0.47207111120224,
        -0.998012363910675,
        0,
        0.16631078720092773,
        -0.20322203636169434,
        0,
        -0.5204774141311646,
        -0.9736491441726685,
        0,
        0.11872625350952148,
        -0.15923690795898438,
        0,
        -0.5676298141479492,
        -0.9469401240348816,
        0,
        0.06458115577697754,
        -0.11525201797485352,
        0,
        -0.6134148836135864,
        -0.917949914932251,
        0,
        0.002651691436767578,
        -0.0712670087814331,
        0,
        -0.6577221155166626,
        -0.8867483735084534,
        0,
        0.4347008466720581,
        -0.5990869998931885,
        0,
        -0.05417648330330849,
        -1.1026790142059326,
        0,
        0.4518941044807434,
        -0.6430720090866089,
        0,
        0,
        -1.1040090322494507,
        0,
        0.47313788533210754,
        -0.6850494742393494,
        0,
        0.05417648330330849,
        -1.1026790142059326,
        0,
        0.49418461322784424,
        -0.723016619682312,
        0,
        0.10822245478630066,
        -1.0986930131912231,
        0,
        0.5148378610610962,
        -0.7569880485534668,
        0,
        0.16200768947601318,
        -1.092059850692749,
        0,
        0.5349019765853882,
        -0.7869877815246582,
        0,
        0.21540266275405884,
        -1.0827958583831787,
        0,
        0.554182767868042,
        -0.8130496144294739,
        0,
        0.26827874779701233,
        -1.0709233283996582,
        0,
        0.5724878907203674,
        -0.8352165818214417,
        0,
        0.3205084204673767,
        -1.0564707517623901,
        0,
        0.5896275639533997,
        -0.8535411953926086,
        0,
        0.37196603417396545,
        -1.0394731760025024,
        0,
        0.6054145693778992,
        -0.8680855631828308,
        0,
        0.422527551651001,
        -1.019971251487732,
        0,
        0.6196650862693787,
        -0.8789206147193909,
        0,
        0.47207111120224,
        -0.998012363910675,
        0,
        0.6321989297866821,
        -0.8861258625984192,
        0,
        0.5204774141311646,
        -0.9736491441726685,
        0,
        0.6428400278091431,
        -0.8897900581359863,
        0,
        0.5676298141479492,
        -0.9469401240348816,
        0,
        0.6514168977737427,
        -0.890010416507721,
        0,
        0.6134148836135864,
        -0.917949914932251,
        0,
        0.6577632427215576,
        -0.8868923187255859,
        0,
        0.6577221155166626,
        -0.8867483735084534,
        0,
        0.7004885673522949,
        -0.8535491228103638,
        0,
        0.7004446983337402,
        -0.8534104824066162,
        0,
        0.7415264248847961,
        -0.8181495666503906,
        0,
        0.7414801120758057,
        -0.818016767501831,
        0,
        0.7807778120040894,
        -0.7807790637016296,
        0,
        0.7807291150093079,
        -0.7806522846221924,
        0,
        0.8181482553482056,
        -0.7415276765823364,
        0,
        0.8180971145629883,
        -0.7414071559906006,
        0,
        0.8535478115081787,
        -0.7004896402359009,
        0,
        0.8534945249557495,
        -0.7003759741783142,
        0,
        0.8868910074234009,
        -0.6577642560005188,
        0,
        0.8868356347084045,
        -0.6576573252677917,
        0,
        0.9180976152420044,
        -0.6134541630744934,
        0,
        0.9180402159690857,
        -0.6133545637130737,
        0,
        0.9470924735069275,
        -0.5676663517951965,
        0,
        0.9470332264900208,
        -0.567574143409729,
        0,
        0.9738056659698486,
        -0.5205107927322388,
        0,
        0.9737448692321777,
        -0.5204262137413025,
        0,
        0.9981728792190552,
        -0.4721013307571411,
        0,
        0.9981105327606201,
        -0.4720246493816376,
        0,
        1.0201354026794434,
        -0.422554612159729,
        0,
        1.0200716257095337,
        -0.42248597741127014,
        0,
        1.0396403074264526,
        -0.3719898760318756,
        0,
        1.039575457572937,
        -0.37192943692207336,
        0,
        1.0566407442092896,
        -0.32052895426750183,
        0,
        1.0565747022628784,
        -0.3204768896102905,
        0,
        1.071095585823059,
        -0.26829588413238525,
        0,
        1.0710285902023315,
        -0.26825234293937683,
        0,
        1.0829699039459229,
        -0.21541647613048553,
        0,
        1.0829023122787476,
        -0.21538150310516357,
        0,
        1.0922353267669678,
        -0.1620180904865265,
        0,
        1.0921671390533447,
        -0.16199177503585815,
        0,
        1.0988696813583374,
        -0.1082293912768364,
        0,
        1.0988010168075562,
        -0.10821183770895004,
        0,
        1.1028565168380737,
        -0.05417997017502785,
        0,
        1.1027876138687134,
        -0.05417116731405258,
        0,
        1.1041866540908813,
        2.4079236027318984e-7,
        0,
        1.104117512702942,
        2.4079236027318984e-7,
        0,
        -0.06853866577148438,
        -0.027281999588012695,
        0,
        -0.7004446983337402,
        -0.8534104824066162,
        0,
        -0.9986465573310852,
        0.13621646165847778,
        0,
        -0.9737987518310547,
        0.14780351519584656,
        0,
        -0.9955851435661316,
        -0.13240021467208862,
        0,
        -1.021105408668518,
        0.12049058079719543,
        0,
        -0.7995140552520752,
        0.10110360383987427,
        0,
        -0.8490850925445557,
        0.06124985218048096,
        0,
        -0.8189002275466919,
        0.12049058079719543,
        0,
        -0.8413589000701904,
        0.13621646165847778,
        0,
        -0.4733562469482422,
        0.13621646165847778,
        0,
        -0.4508974552154541,
        0.12049058079719543,
        0,
        -0.4267849922180176,
        0.23759979009628296,
        0,
        -0.6973850727081299,
        0.24089974164962769,
        0,
        -0.6306471824645996,
        0.13621646165847778,
        0,
        -0.6057994365692139,
        0.14780351519584656,
        0,
        -0.6531062126159668,
        0.12049058079719543,
        0,
        -0.26264524459838867,
        0.13621646165847778,
        0,
        -0.3195347785949707,
        0.2326498031616211,
        0,
        -0.28510379791259766,
        0.12049058079719543,
        0,
        -0.23779773712158203,
        0.14780351519584656,
        0,
        -0.07929515838623047,
        0.17555975914001465,
        0,
        -0.10535764694213867,
        0.13621646165847778,
        0,
        -0.08289575576782227,
        0.12049058079719543,
        0,
        -0.13020563125610352,
        0.14780351519584656,
        0,
        -0.7589999437332153,
        -0.7080000042915344,
        0,
        -0.7807291150093079,
        -0.7806522846221924,
        0,
        -0.8180971145629883,
        -0.7414071559906006,
        0,
        -0.8534945249557495,
        -0.7003759741783142,
        0,
        -0.9388351440429688,
        0.08931612968444824,
        0,
        -0.920002818107605,
        0.15728923678398132,
        0,
        -0.8926913738250732,
        0.15489965677261353,
        0,
        -0.563075065612793,
        0.2813161611557007,
        0,
        -0.5793156623840332,
        0.15489965677261353,
        0,
        -0.5520005226135254,
        0.15728923678398132,
        0,
        -0.5246889591217041,
        0.15489965677261353,
        0,
        -0.304490327835083,
        0.10110360383987427,
        0,
        -0.3759993314743042,
        0.3269284963607788,
        0,
        -0.31806397438049316,
        0.11594021320343018,
        0,
        -0.3998821973800659,
        0.3707926273345947,
        0,
        -0.34984421730041504,
        0.278261661529541,
        0,
        -0.24901437759399414,
        0.2359400987625122,
        0,
        -0.41225504875183105,
        0.24094009399414062,
        0,
        -0.4937293529510498,
        0.5147931575775146,
        0,
        -0.5091409683227539,
        0.5280430316925049,
        0,
        -0.4775388240814209,
        0.49628782272338867,
        0,
        -0.4603116512298584,
        0.47257184982299805,
        0,
        -0.5240316390991211,
        0.536005973815918,
        0,
        -0.538661003112793,
        0.5386624336242676,
        0,
        -0.25545215606689453,
        0.10467302799224854,
        0,
        -0.2383335828781128,
        -0.01905989646911621,
        0,
        -0.2897942066192627,
        0.1669996976852417,
        0,
        -0.1931476593017578,
        0.060688018798828125,
        0,
        -0.512230396270752,
        0.5380135774612427,
        0,
        -0.9473142623901367,
        0.15489965677261353,
        0,
        -0.8662068843841553,
        0.14780351519584656,
        0,
        -0.49820756912231445,
        0.14780351519584656,
        0,
        -0.43151116371154785,
        0.10110360383987427,
        0,
        -0.21131277084350586,
        0.15489965677261353,
        0,
        -0.1873149871826172,
        0.2813161611557007,
        0,
        -0.18400096893310547,
        0.15728923678398132,
        0,
        -0.15668964385986328,
        0.15489965677261353,
        0,
        -0.7414801120758057,
        -0.818016767501831,
        0,
        -0.843999981880188,
        -0.5509999394416809,
        0,
        -0.8868356347084045,
        -0.6576573252677917,
        0,
        -0.9180402159690857,
        -0.6133545637130737,
        0,
        -0.9737448692321777,
        -0.5204262137413025,
        0,
        -0.9470332264900208,
        -0.567574143409729,
        0,
        -0.32118499279022217,
        0.22490918636322021,
        0,
        -0.2969999313354492,
        0.21399986743927002,
        0,
        -0.48586320877075195,
        0.5360684394836426,
        0,
        -0.1308431625366211,
        0.016703128814697266,
        0,
        -0.706902027130127,
        0.02731318026781082,
        0,
        -0.7509498596191406,
        0.027888797223567963,
        0,
        -0.7509498596191406,
        2.4079236027318984e-7,
        0,
        -0.7092912197113037,
        2.4079236027318984e-7,
        0,
        -0.7651040554046631,
        0.02731318026781082,
        0,
        -0.762715220451355,
        2.4079236027318984e-7,
        0,
        -0.7469497919082642,
        0.14604181051254272,
        0,
        -0.30268287658691406,
        0.20094013214111328,
        0,
        -0.42173314094543457,
        0.4097483158111572,
        0,
        -0.44179344177246094,
        0.44370222091674805,
        0,
        -1.0749012231826782,
        0.02731318026781082,
        0,
        -1.066666841506958,
        -0.04831935465335846,
        0,
        -1.071443796157837,
        0.0006151511333882809,
        0,
        -1.077290415763855,
        2.4079236027318984e-7,
        0,
        -1.1027876138687134,
        -0.05417116731405258,
        0,
        -1.104117512702942,
        2.4079236027318984e-7,
        0,
        -1.0200716257095337,
        -0.42248597741127014,
        0,
        -1.039575457572937,
        -0.37192943692207336,
        0,
        -0.9692755341529846,
        -0.305999755859375,
        0,
        -1.0565747022628784,
        -0.3204768896102905,
        0,
        -0.9981105327606201,
        -0.4720246493816376,
        0,
        -0.5716499090194702,
        -0.5840598344802856,
        0,
        -1.0404950380325317,
        0.10110360383987427,
        0,
        -1.0382754802703857,
        -0.1947351098060608,
        0,
        -1.0678062438964844,
        0.053796231746673584,
        0,
        -1.0589627027511597,
        -0.09712622314691544,
        0,
        -1.0988010168075562,
        -0.10821183770895004,
        0,
        -1.0493404865264893,
        -0.14580905437469482,
        0,
        -1.0562201738357544,
        0.07864472270011902,
        0,
        -1.0921671390533447,
        -0.16199177503585815,
        0,
        -1.0710285902023315,
        -0.26825234293937683,
        0,
        -1.0829023122787476,
        -0.21538150310516357,
        0,
        -0.672492265701294,
        0.10110360383987427,
        0,
        -0.7509498596191406,
        0.10323503613471985,
        0,
        -0.3731050491333008,
        0.23512470722198486,
        0,
        -0.305999755859375,
        0.22099995613098145,
        0,
        -0.2069997787475586,
        0.20300006866455078,
        0,
        -0.3731050491333008,
        0.10323503613471985,
        0,
        -0.3394804000854492,
        0.030888795852661133,
        0,
        -0.3731050491333008,
        0.027888797223567963,
        0,
        -0.3731050491333008,
        2.4079236027318984e-7,
        0,
        -0.34128880500793457,
        2.4079236027318984e-7,
        0,
        -0.39710140228271484,
        0.02731318026781082,
        0,
        -0.3947126865386963,
        2.4079236027318984e-7,
        0,
        -0.023999691009521484,
        0.030000001192092896,
        0,
        -0.022432804107666016,
        2.4079236027318984e-7,
        0,
        0,
        0,
        0,
        -0.0006499290466308594,
        0.026429995894432068,
        0,
        -0.026710033416748047,
        2.4079236027318984e-7,
        0,
        -0.029102802276611328,
        0.02731318026781082,
        0,
        -0.0025930404663085938,
        0.05279609560966492,
        0,
        -0.026000022888183594,
        0.05800001323223114,
        0,
        -0.036197662353515625,
        0.053796231746673584,
        0,
        -0.005830287933349609,
        0.07903498411178589,
        0,
        -0.03399991989135742,
        0.07400000095367432,
        0,
        -0.047783851623535156,
        0.07864472270011902,
        0,
        -0.7509498596191406,
        0.05493021011352539,
        0,
        -0.6998038291931152,
        0.053796231746673584,
        0,
        -0.7721991539001465,
        0.053796231746673584,
        0,
        -0.7509498596191406,
        0.08030259609222412,
        0,
        -0.6882176399230957,
        0.07864472270011902,
        0,
        -0.7837854623794556,
        0.07864472270011902,
        0,
        -0.3731050491333008,
        0.08030259609222412,
        0,
        -0.32021546363830566,
        0.07864472270011902,
        0,
        -0.4157860279083252,
        0.07864472270011902,
        0,
        -0.3731050491333008,
        0.05493021011352539,
        0,
        -0.3258044719696045,
        0.05679622292518616,
        0,
        -0.40419960021972656,
        0.053796231746673584,
        0,
        -0.03703117370605469,
        0.09858125448226929,
        0,
        -0.06350898742675781,
        0.10110360383987427,
        0,
        -0.43357348442077637,
        0.5283119678497314,
        0,
        -0.4596233367919922,
        0.532832145690918,
        0,
        -0.4077773094177246,
        0.5225193500518799,
        0,
        -0.382279634475708,
        0.5154455900192261,
        0,
        -0.3571767807006836,
        0.5071523189544678,
        0,
        -0.33250856399536133,
        0.49763762950897217,
        0,
        -0.30834197998046875,
        0.4869241714477539,
        0,
        -0.2847251892089844,
        0.4750373363494873,
        0,
        -0.26172399520874023,
        0.46200621128082275,
        0,
        -0.23938655853271484,
        0.44786226749420166,
        0,
        -0.19533395767211914,
        0.14892077445983887,
        0,
        -0.1969308853149414,
        0.416373610496521,
        0,
        -0.2177720069885254,
        0.43263912200927734,
        0,
        -0.176910400390625,
        0.3991053104400635,
        0,
        -0.15776300430297852,
        0.38087546825408936,
        0,
        -0.13953447341918945,
        0.36172807216644287,
        0,
        -0.20599985122680664,
        0.20500004291534424,
        0,
        -0.12226390838623047,
        0.3417092561721802,
        0,
        -0.10599899291992188,
        0.320867121219635,
        0,
        -0.0907754898071289,
        0.2992520332336426,
        0,
        -0.07663202285766602,
        0.276915967464447,
        0,
        -0.12299966812133789,
        0.2269999384880066,
        0,
        -0.06360340118408203,
        0.25391286611557007,
        0,
        -0.05171537399291992,
        0.23029804229736328,
        0,
        -0.041002750396728516,
        0.20612841844558716,
        0,
        -0.03148794174194336,
        0.18146222829818726,
        0,
        -0.04700040817260742,
        0.14300000667572021,
        0,
        -0.023192882537841797,
        0.15635886788368225,
        0,
        -0.010349750518798828,
        0.10508346557617188,
        0,
        -0.01614093780517578,
        0.13087883591651917,
        0,
        0.386249840259552,
        0.5111174583435059,
        0,
        -0.16200768947601318,
        1.0920603275299072,
        0,
        -0.10822245478630066,
        1.0986934900283813,
        0,
        0.40879666805267334,
        0.5551024675369263,
        0,
        0.36248308420181274,
        0.46713244915008545,
        0,
        -0.21540266275405884,
        1.082796335220337,
        0,
        0.3370523750782013,
        0.42314743995666504,
        0,
        -0.26827874779701233,
        1.0709238052368164,
        0,
        0.30947983264923096,
        0.37916243076324463,
        0,
        -0.3205084204673767,
        1.0564712285995483,
        0,
        0.2792414426803589,
        0.33517754077911377,
        0,
        -0.37196603417396545,
        1.0394736528396606,
        0,
        0.24575459957122803,
        0.2911924123764038,
        0,
        -0.422527551651001,
        1.0199717283248901,
        0,
        0.20836210250854492,
        0.24720752239227295,
        0,
        -0.47207111120224,
        0.9980128407478333,
        0,
        0.16631078720092773,
        0.20322251319885254,
        0,
        -0.5204774141311646,
        0.9736496210098267,
        0,
        0.11872625350952148,
        0.15923750400543213,
        0,
        -0.5676298141479492,
        0.9469406008720398,
        0,
        0.06458115577697754,
        0.11525249481201172,
        0,
        -0.6134148836135864,
        0.9179503917694092,
        0,
        0.002651691436767578,
        0.07126760482788086,
        0,
        -0.6577221155166626,
        0.8867488503456116,
        0,
        -0.05417648330330849,
        1.1026794910430908,
        0,
        0.4347008466720581,
        0.5990874767303467,
        0,
        -3.469446951953614e-16,
        1.1040095090866089,
        0,
        0.4518941044807434,
        0.6430724859237671,
        0,
        0.05417648330330849,
        1.1026794910430908,
        0,
        0.47313788533210754,
        0.6850499510765076,
        0,
        0.10822245478630066,
        1.0986934900283813,
        0,
        0.49418461322784424,
        0.7230170965194702,
        0,
        0.16200768947601318,
        1.0920603275299072,
        0,
        0.5148378610610962,
        0.7569884657859802,
        0,
        0.21540266275405884,
        1.082796335220337,
        0,
        0.5349019765853882,
        0.7869882583618164,
        0,
        0.26827874779701233,
        1.0709238052368164,
        0,
        0.554182767868042,
        0.8130500912666321,
        0,
        0.3205084204673767,
        1.0564712285995483,
        0,
        0.5724878907203674,
        0.8352170586585999,
        0,
        0.37196603417396545,
        1.0394736528396606,
        0,
        0.5896275639533997,
        0.8535416722297668,
        0,
        0.422527551651001,
        1.0199717283248901,
        0,
        0.6054145693778992,
        0.868086040019989,
        0,
        0.47207111120224,
        0.9980128407478333,
        0,
        0.6196650862693787,
        0.8789210319519043,
        0,
        0.5204774141311646,
        0.9736496210098267,
        0,
        0.6321989297866821,
        0.8861263394355774,
        0,
        0.5676298141479492,
        0.9469406008720398,
        0,
        0.6428400278091431,
        0.8897905349731445,
        0,
        0.6134148836135864,
        0.9179503917694092,
        0,
        0.6514168977737427,
        0.8900108933448792,
        0,
        0.6577221155166626,
        0.8867488503456116,
        0,
        0.6577632427215576,
        0.8868927955627441,
        0,
        0.7004446983337402,
        0.8534108996391296,
        0,
        0.7004885673522949,
        0.853549599647522,
        0,
        0.7414801120758057,
        0.8180172443389893,
        0,
        0.7415264248847961,
        0.8181500434875488,
        0,
        0.7807291150093079,
        0.7806527614593506,
        0,
        0.7807778120040894,
        0.7807795405387878,
        0,
        0.8180971145629883,
        0.7414076328277588,
        0,
        0.8181482553482056,
        0.7415281534194946,
        0,
        0.8534945249557495,
        0.7003764510154724,
        0,
        0.8535478115081787,
        0.7004901766777039,
        0,
        0.8868356347084045,
        0.65765780210495,
        0,
        0.8868910074234009,
        0.657764732837677,
        0,
        0.9180402159690857,
        0.6133551001548767,
        0,
        0.9180976152420044,
        0.6134546399116516,
        0,
        0.9470332264900208,
        0.5675746202468872,
        0,
        0.9470924735069275,
        0.5676668286323547,
        0,
        0.9737448692321777,
        0.5204266905784607,
        0,
        0.9738056659698486,
        0.520511269569397,
        0,
        0.9981105327606201,
        0.4720250964164734,
        0,
        0.9981728792190552,
        0.4721018373966217,
        0,
        1.0200716257095337,
        0.42248642444610596,
        0,
        1.0201354026794434,
        0.4225551187992096,
        0,
        1.039575457572937,
        0.37192991375923157,
        0,
        1.0396403074264526,
        0.3719903528690338,
        0,
        1.0565747022628784,
        0.32047736644744873,
        0,
        1.0566407442092896,
        0.32052943110466003,
        0,
        1.0710285902023315,
        0.26825281977653503,
        0,
        1.071095585823059,
        0.26829639077186584,
        0,
        1.0829023122787476,
        0.21538199484348297,
        0,
        1.0829699039459229,
        0.21541693806648254,
        0,
        1.0921671390533447,
        0.16199226677417755,
        0,
        1.0922353267669678,
        0.1620185822248459,
        0,
        1.0988010168075562,
        0.10821231454610825,
        0,
        1.0988696813583374,
        0.1082298681139946,
        0,
        1.1027876138687134,
        0.05417165160179138,
        0,
        1.1028565168380737,
        0.05418045446276665,
        0,
        -0.06853866577148438,
        0.02728259563446045,
        0,
        -0.7004446983337402,
        0.8534108996391296,
        0,
        -0.9986465573310852,
        -0.13621598482131958,
        0,
        -0.9955851435661316,
        0.13240069150924683,
        0,
        -0.9737987518310547,
        -0.14780303835868835,
        0,
        -1.021105408668518,
        -0.12049010396003723,
        0,
        -0.7995140552520752,
        -0.10110315680503845,
        0,
        -0.8189002275466919,
        -0.12049010396003723,
        0,
        -0.8490850925445557,
        -0.061249375343322754,
        0,
        -0.8413589000701904,
        -0.13621598482131958,
        0,
        -0.4733562469482422,
        -0.13621598482131958,
        0,
        -0.4267849922180176,
        -0.23759931325912476,
        0,
        -0.4508974552154541,
        -0.12049010396003723,
        0,
        -0.6973850727081299,
        -0.24089926481246948,
        0,
        -0.6057994365692139,
        -0.14780303835868835,
        0,
        -0.6306471824645996,
        -0.13621598482131958,
        0,
        -0.6531062126159668,
        -0.12049010396003723,
        0,
        -0.26264524459838867,
        -0.13621598482131958,
        0,
        -0.28510379791259766,
        -0.12049010396003723,
        0,
        -0.3195347785949707,
        -0.2326493263244629,
        0,
        -0.23779773712158203,
        -0.14780303835868835,
        0,
        -0.07929515838623047,
        -0.17555928230285645,
        0,
        -0.08289575576782227,
        -0.12049010396003723,
        0,
        -0.10535764694213867,
        -0.13621598482131958,
        0,
        -0.13020563125610352,
        -0.14780303835868835,
        0,
        -0.7589999437332153,
        0.7080004811286926,
        0,
        -0.8180971145629883,
        0.7414076328277588,
        0,
        -0.7807291150093079,
        0.7806527614593506,
        0,
        -0.8534945249557495,
        0.7003764510154724,
        0,
        -0.9388351440429688,
        -0.08931571245193481,
        0,
        -0.8926913738250732,
        -0.15489917993545532,
        0,
        -0.920002818107605,
        -0.15728875994682312,
        0,
        -0.563075065612793,
        -0.2813156843185425,
        0,
        -0.5520005226135254,
        -0.15728875994682312,
        0,
        -0.5793156623840332,
        -0.15489917993545532,
        0,
        -0.5246889591217041,
        -0.15489917993545532,
        0,
        -0.304490327835083,
        -0.10110315680503845,
        0,
        -0.3759993314743042,
        -0.32692790031433105,
        0,
        -0.3998821973800659,
        -0.370792031288147,
        0,
        -0.31806397438049316,
        -0.11593961715698242,
        0,
        -0.34984421730041504,
        -0.27826106548309326,
        0,
        -0.24901437759399414,
        -0.235939621925354,
        0,
        -0.41225504875183105,
        -0.24093949794769287,
        0,
        -0.4937293529510498,
        -0.514792799949646,
        0,
        -0.5091409683227539,
        -0.5280426740646362,
        0,
        -0.4775388240814209,
        -0.4962872266769409,
        0,
        -0.4603116512298584,
        -0.4725712537765503,
        0,
        -0.5240316390991211,
        -0.5360053777694702,
        0,
        -0.538661003112793,
        -0.5386618375778198,
        0,
        -0.25545215606689453,
        -0.10467243194580078,
        0,
        -0.2897942066192627,
        -0.1669992208480835,
        0,
        -0.2383335828781128,
        0.019060492515563965,
        0,
        -0.1931476593017578,
        -0.06068742275238037,
        0,
        -0.512230396270752,
        -0.5380129814147949,
        0,
        -0.9473142623901367,
        -0.15489917993545532,
        0,
        -0.8662068843841553,
        -0.14780303835868835,
        0,
        -0.49820756912231445,
        -0.14780303835868835,
        0,
        -0.43151116371154785,
        -0.10110315680503845,
        0,
        -0.21131277084350586,
        -0.15489917993545532,
        0,
        -0.1873149871826172,
        -0.2813156843185425,
        0,
        -0.18400096893310547,
        -0.15728875994682312,
        0,
        -0.15668964385986328,
        -0.15489917993545532,
        0,
        -0.7414801120758057,
        0.8180172443389893,
        0,
        -0.843999981880188,
        0.5510004162788391,
        0,
        -0.8868356347084045,
        0.65765780210495,
        0,
        -0.9180402159690857,
        0.6133551001548767,
        0,
        -0.9737448692321777,
        0.5204266905784607,
        0,
        -0.9470332264900208,
        0.5675746202468872,
        0,
        -0.32118499279022217,
        -0.22490859031677246,
        0,
        -0.2969999313354492,
        -0.21399927139282227,
        0,
        -0.48586320877075195,
        -0.5360680818557739,
        0,
        -0.1308431625366211,
        -0.01670253276824951,
        0,
        -0.706902027130127,
        -0.02731270343065262,
        0,
        -0.7509498596191406,
        -0.02788832038640976,
        0,
        -0.7651040554046631,
        -0.02731270343065262,
        0,
        -0.30268287658691406,
        -0.20093953609466553,
        0,
        -0.7469497919082642,
        -0.14604133367538452,
        0,
        -0.42173314094543457,
        -0.4097479581832886,
        0,
        -0.44179344177246094,
        -0.4437016248703003,
        0,
        -1.0749012231826782,
        -0.02731270343065262,
        0,
        -1.0715610980987549,
        0.04958720505237579,
        0,
        -1.1027876138687134,
        0.05417165160179138,
        0,
        -1.0200716257095337,
        0.42248642444610596,
        0,
        -0.9692755341529846,
        0.3060002624988556,
        0,
        -1.039575457572937,
        0.37192991375923157,
        0,
        -1.0565747022628784,
        0.32047736644744873,
        0,
        -0.9981105327606201,
        0.4720250964164734,
        0,
        -0.5716499090194702,
        0.5840603113174438,
        0,
        -1.0404950380325317,
        -0.10110315680503845,
        0,
        -1.0382754802703857,
        0.194735586643219,
        0,
        -1.0678062438964844,
        -0.05379574000835419,
        0,
        -1.0674201250076294,
        0.09851153194904327,
        0,
        -1.0988010168075562,
        0.10821231454610825,
        0,
        -1.0570870637893677,
        0.1471398025751114,
        0,
        -1.0562201738357544,
        -0.07864424586296082,
        0,
        -1.0921671390533447,
        0.16199226677417755,
        0,
        -1.0710285902023315,
        0.26825281977653503,
        0,
        -1.0829023122787476,
        0.21538199484348297,
        0,
        -0.672492265701294,
        -0.10110315680503845,
        0,
        -0.7509498596191406,
        -0.10323455929756165,
        0,
        -0.305999755859375,
        -0.2209993600845337,
        0,
        -0.3731050491333008,
        -0.23512428998947144,
        0,
        -0.2069997787475586,
        -0.20299947261810303,
        0,
        -0.3731050491333008,
        -0.10323455929756165,
        0,
        -0.3394804000854492,
        -0.03088831901550293,
        0,
        -0.3731050491333008,
        -0.02788832038640976,
        0,
        -0.39710140228271484,
        -0.02731270343065262,
        0,
        -0.023999691009521484,
        -0.029999524354934692,
        0,
        -0.0006499290466308594,
        -0.026429519057273865,
        0,
        -0.029102802276611328,
        -0.02731270343065262,
        0,
        -0.0025930404663085938,
        -0.05279560387134552,
        0,
        -0.026000022888183594,
        -0.05799952149391174,
        0,
        -0.036197662353515625,
        -0.05379574000835419,
        0,
        -0.03399991989135742,
        -0.07399952411651611,
        0,
        -0.005830287933349609,
        -0.07903450727462769,
        0,
        -0.047783851623535156,
        -0.07864424586296082,
        0,
        -0.7509498596191406,
        -0.054929718375205994,
        0,
        -0.6998038291931152,
        -0.05379574000835419,
        0,
        -0.7721991539001465,
        -0.05379574000835419,
        0,
        -0.7509498596191406,
        -0.08030208945274353,
        0,
        -0.6882176399230957,
        -0.07864424586296082,
        0,
        -0.7837854623794556,
        -0.07864424586296082,
        0,
        -0.32021546363830566,
        -0.07864424586296082,
        0,
        -0.3731050491333008,
        -0.08030208945274353,
        0,
        -0.4157860279083252,
        -0.07864424586296082,
        0,
        -0.3731050491333008,
        -0.054929718375205994,
        0,
        -0.3258044719696045,
        -0.056795746088027954,
        0,
        -0.40419960021972656,
        -0.05379574000835419,
        0,
        -0.03703117370605469,
        -0.09858077764511108,
        0,
        -0.06350898742675781,
        -0.10110315680503845,
        0,
        -0.4596233367919922,
        -0.5328315496444702,
        0,
        -0.43357348442077637,
        -0.5283114910125732,
        0,
        -0.4077773094177246,
        -0.5225186347961426,
        0,
        -0.382279634475708,
        -0.5154451131820679,
        0,
        -0.3571767807006836,
        -0.5071518421173096,
        0,
        -0.33250856399536133,
        -0.4976370334625244,
        0,
        -0.30834197998046875,
        -0.48692357540130615,
        0,
        -0.2847251892089844,
        -0.4750368595123291,
        0,
        -0.26172399520874023,
        -0.462005615234375,
        0,
        -0.23938655853271484,
        -0.4478616714477539,
        0,
        -0.19533395767211914,
        -0.14892029762268066,
        0,
        -0.2177720069885254,
        -0.4326385259628296,
        0,
        -0.1969308853149414,
        -0.41637301445007324,
        0,
        -0.176910400390625,
        -0.3991048336029053,
        0,
        -0.15776300430297852,
        -0.38087499141693115,
        0,
        -0.13953447341918945,
        -0.3617277145385742,
        0,
        -0.20599985122680664,
        -0.20499950647354126,
        0,
        -0.12226390838623047,
        -0.341708779335022,
        0,
        -0.10599899291992188,
        -0.32086658477783203,
        0,
        -0.0907754898071289,
        -0.29925161600112915,
        0,
        -0.07663202285766602,
        -0.2769155502319336,
        0,
        -0.12299966812133789,
        -0.2269994616508484,
        0,
        -0.06360340118408203,
        -0.25391244888305664,
        0,
        -0.05171537399291992,
        -0.23029756546020508,
        0,
        -0.041002750396728516,
        -0.20612794160842896,
        0,
        -0.03148794174194336,
        -0.18146175146102905,
        0,
        -0.023192882537841797,
        -0.15635839104652405,
        0,
        -0.04700040817260742,
        -0.14299947023391724,
        0,
        -0.010349750518798828,
        -0.10508301854133606,
        0,
        -0.01614093780517578,
        -0.13087841868400574,
        0
    ],
    [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.12167060375213623,
        -0.2107395976781845,
        0,
        -0.16011357307434082,
        -0.22866588830947876,
        0,
        0,
        0,
        0,
        -0.08692443370819092,
        -0.18641014397144318,
        0,
        -0.4297513961791992,
        -0.15641668438911438,
        0,
        -0.33499979972839355,
        0.06000000238418579,
        0,
        -0.39975786209106445,
        -0.18641014397144318,
        0,
        -0.36501169204711914,
        -0.2107395976781845,
        0,
        -0.8516933917999268,
        -0.2107395976781845,
        0,
        -0.8864400386810303,
        -0.18641014397144318,
        0,
        -0.8350002765655518,
        -0.029999971389770508,
        0,
        -0.31999993324279785,
        -0.010000050067901611,
        0,
        -0.6083521842956543,
        -0.2107395976781845,
        0,
        -0.6467952728271484,
        -0.22866588830947876,
        0,
        -0.5736064910888672,
        -0.18641014397144318,
        0,
        -0.7300252914428711,
        0.4214792251586914,
        0,
        -0.7100000381469727,
        0.19499993324279785,
        0,
        -0.7995162010192871,
        0.37282031774520874,
        0,
        -0.6531386375427246,
        0.45733174681663513,
        0,
        -0.07999992370605469,
        0.2800000309944153,
        0,
        -0.24334287643432617,
        0.4214792251586914,
        0,
        -0.17384910583496094,
        0.37282031774520874,
        0,
        -0.32022809982299805,
        0.45733174681663513,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.14333343505859375,
        -0.017473816871643066,
        0,
        -0.24334120750427246,
        -0.24334114789962769,
        0,
        -0.2855968475341797,
        -0.23964427411556244,
        0,
        -0.5470001697540283,
        -0.05747377872467041,
        0,
        -0.6877679824829102,
        -0.23964427411556244,
        0,
        -0.7300233840942383,
        -0.24334114789962769,
        0,
        -0.7722792625427246,
        -0.23964427411556244,
        0,
        -0.8595046997070312,
        0.31283333897590637,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.20108556747436523,
        -0.23964427411556244,
        0,
        -0.3265688419342041,
        -0.22866588830947876,
        0,
        -0.8132505416870117,
        -0.22866588830947876,
        0,
        -0.9164328575134277,
        -0.15641668438911438,
        0,
        -0.5711936950683594,
        0.47928857803344727,
        0,
        -0.4766664505004883,
        0.2995262145996094,
        0,
        -0.4866824150085449,
        0.486682265996933,
        0,
        -0.40217113494873047,
        0.47928857803344727,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.49037885665893555,
        -0.04225574806332588,
        0,
        -0.48600006103515625,
        -0.024508334696292877,
        0,
        -0.48600006103515625,
        0,
        0,
        -0.4866819381713867,
        0,
        0,
        -0.4829854965209961,
        -0.04225574806332588,
        0,
        -0.4866824150085449,
        0,
        0,
        -0.2776827812194824,
        0.02760004997253418,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0036967992782592773,
        -0.04225574806332588,
        0,
        0.0009113550186157227,
        0.0004747062921524048,
        0,
        -0.0005533695220947266,
        0.0004042122745886445,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0569310188293457,
        -0.15641668438911438,
        0,
        0,
        0,
        0,
        -0.014675259590148926,
        -0.08322757482528687,
        0,
        0.0015821456909179688,
        0.0004971474409103394,
        0,
        0,
        0,
        0,
        0.0012818574905395508,
        0.00041282176971435547,
        0,
        -0.03260147571563721,
        -0.12167057394981384,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.5436127185821533,
        -0.15641668438911438,
        0,
        -0.48600006103515625,
        -0.09072166681289673,
        0,
        -0.8450000286102295,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.9717988967895508,
        -0.015661269426345825,
        0,
        -0.9659719467163086,
        0.08451149612665176,
        0,
        -0.9717988967895508,
        0.018766678869724274,
        0,
        -0.9717988967895508,
        -0.0011501713888719678,
        0,
        -0.9733645915985107,
        0,
        0,
        -0.9696674346923828,
        -0.04225574806332588,
        0,
        -0.9733648300170898,
        0,
        0,
        -0.006339073181152344,
        0.05151616036891937,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.007394313812255859,
        0.08451149612665176,
        0,
        0,
        0,
        0,
        -0.010427474975585938,
        0.06925784051418304,
        0,
        -0.029351234436035156,
        0.16645514965057373,
        0,
        0,
        0,
        0,
        -0.015134334564208984,
        0.07380187511444092,
        0,
        -0.06520318984985352,
        0.24334114789962769,
        0,
        -0.48600006103515625,
        -0.04827199876308441,
        0,
        -0.5013570785522461,
        -0.08322757482528687,
        0,
        -0.47200703620910645,
        -0.08322757482528687,
        0,
        -0.48600006103515625,
        -0.07056893408298492,
        0,
        -0.5192835330963135,
        -0.12167057394981384,
        0,
        -0.45408082008361816,
        -0.12167057394981384,
        0,
        -0.9717988967895508,
        -0.012418374419212341,
        0,
        -0.9081621170043945,
        0.24334114789962769,
        0,
        -0.9407627582550049,
        -0.12167057394981384,
        0,
        -0.9717988967895508,
        0.009208470582962036,
        0,
        -0.9440150260925293,
        0.16645514965057373,
        0,
        -0.9586889743804932,
        -0.08322757482528687,
        0,
        -0.017035961151123047,
        0.07816505432128906,
        0,
        -0.11386394500732422,
        0.31283333897590637,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.12167060375213623,
        0.2107395976781845,
        0,
        0,
        0,
        0,
        -0.16011357307434082,
        0.22866588830947876,
        0,
        -0.08692443370819092,
        0.18641014397144318,
        0,
        -0.4297513961791992,
        0.15641668438911438,
        0,
        -0.39975786209106445,
        0.18641014397144318,
        0,
        -0.33499979972839355,
        -0.06000000238418579,
        0,
        -0.36501169204711914,
        0.2107395976781845,
        0,
        -0.8516933917999268,
        0.2107395976781845,
        0,
        -0.8350002765655518,
        0.029999971389770508,
        0,
        -0.8864400386810303,
        0.18641014397144318,
        0,
        -0.31999993324279785,
        0.010000050067901611,
        0,
        -0.6467952728271484,
        0.22866588830947876,
        0,
        -0.6083521842956543,
        0.2107395976781845,
        0,
        -0.5736064910888672,
        0.18641014397144318,
        0,
        -0.7300252914428711,
        -0.42147916555404663,
        0,
        -0.7995162010192871,
        -0.37282025814056396,
        0,
        -0.7100000381469727,
        -0.19499993324279785,
        0,
        -0.6531386375427246,
        -0.4573318064212799,
        0,
        -0.07999992370605469,
        -0.2800000309944153,
        0,
        -0.17384910583496094,
        -0.37282025814056396,
        0,
        -0.24334287643432617,
        -0.42147916555404663,
        0,
        -0.32022809982299805,
        -0.4573318064212799,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.14333343505859375,
        0.017473816871643066,
        0,
        -0.2855968475341797,
        0.23964427411556244,
        0,
        -0.24334120750427246,
        0.24334114789962769,
        0,
        -0.5470001697540283,
        0.05747377872467041,
        0,
        -0.7300233840942383,
        0.24334114789962769,
        0,
        -0.6877679824829102,
        0.23964427411556244,
        0,
        -0.7722792625427246,
        0.23964427411556244,
        0,
        -0.8595046997070312,
        -0.31283339858055115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.20108556747436523,
        0.23964427411556244,
        0,
        -0.3265688419342041,
        0.22866588830947876,
        0,
        -0.8132505416870117,
        0.22866588830947876,
        0,
        -0.9164328575134277,
        0.15641668438911438,
        0,
        -0.5711936950683594,
        -0.4792885184288025,
        0,
        -0.4766664505004883,
        -0.2995262145996094,
        0,
        -0.4866824150085449,
        -0.48668232560157776,
        0,
        -0.40217113494873047,
        -0.4792885184288025,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.49037885665893555,
        0.04225574806332588,
        0,
        -0.48600006103515625,
        0.024508334696292877,
        0,
        -0.4829854965209961,
        0.04225574806332588,
        0,
        0,
        0,
        0,
        -0.2776827812194824,
        -0.02760004997253418,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0036967992782592773,
        0.04225574806332588,
        0,
        -0.0017715692520141602,
        0.0003534853458404541,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.0569310188293457,
        0.15641668438911438,
        0,
        0,
        0,
        0,
        -0.014675259590148926,
        0.08322757482528687,
        0,
        -0.002859354019165039,
        0.0003470778465270996,
        0,
        0,
        0,
        0,
        -0.0028954744338989258,
        0.00036713480949401855,
        0,
        -0.03260147571563721,
        0.12167057394981384,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -0.5436127185821533,
        0.15641668438911438,
        0,
        -0.48600006103515625,
        0.09072166681289673,
        0,
        0,
        0,
        0,
        -0.8450000286102295,
        0,
        0,
        0,
        0,
        0,
        -0.9717988967895508,
        0.015661269426345825,
        0,
        -0.9659719467163086,
        -0.08451149612665176,
        0,
        -0.9717988967895508,
        -0.018766678869724274,
        0,
        -0.9696674346923828,
        0.04225574806332588,
        0,
        -0.006339073181152344,
        -0.05151616036891937,
        0,
        0,
        0,
        0,
        -0.007394313812255859,
        -0.08451149612665176,
        0,
        0,
        0,
        0,
        -0.010427474975585938,
        -0.06925784051418304,
        0,
        -0.029351234436035156,
        -0.16645514965057373,
        0,
        -0.015134334564208984,
        -0.07380187511444092,
        0,
        0,
        0,
        0,
        -0.06520318984985352,
        -0.24334114789962769,
        0,
        -0.48600006103515625,
        0.04827199876308441,
        0,
        -0.5013570785522461,
        0.08322757482528687,
        0,
        -0.47200703620910645,
        0.08322757482528687,
        0,
        -0.48600006103515625,
        0.07056893408298492,
        0,
        -0.5192835330963135,
        0.12167057394981384,
        0,
        -0.45408082008361816,
        0.12167057394981384,
        0,
        -0.9081621170043945,
        -0.24334114789962769,
        0,
        -0.9717988967895508,
        0.012418374419212341,
        0,
        -0.9407627582550049,
        0.12167057394981384,
        0,
        -0.9717988967895508,
        -0.009208470582962036,
        0,
        -0.9440150260925293,
        -0.16645514965057373,
        0,
        -0.9586889743804932,
        0.08322757482528687,
        0,
        -0.017035961151123047,
        -0.07816505432128906,
        0,
        -0.11386394500732422,
        -0.31283339858055115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ],
    [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.12154901027679443,
        0.21052885055541992,
        0,
        0.15995359420776367,
        0.22843721508979797,
        0,
        0.03839099407196045,
        0.35279959440231323,
        0,
        0.08683764934539795,
        0.18622374534606934,
        0,
        0.4293215274810791,
        0.15626025199890137,
        0,
        0.4200000762939453,
        0.20999997854232788,
        0,
        0.39935827255249023,
        0.18622374534606934,
        0,
        0.36464691162109375,
        0.21052885055541992,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863247871398926,
        0,
        0,
        0.36464643478393555,
        -0.2105288952589035,
        0,
        0.4099998474121094,
        -0.15000003576278687,
        0,
        0.39935874938964844,
        -0.18622371554374695,
        0,
        0.32624244689941406,
        -0.22843724489212036,
        0,
        0.037000179290771484,
        -0.12699997425079346,
        0,
        0.12154817581176758,
        -0.2105288952589035,
        0,
        0.0868377685546875,
        -0.18622371554374695,
        0,
        0.15995311737060547,
        -0.22843724489212036,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.21166658401489258,
        0.21752619743347168,
        0,
        0.24309802055358887,
        0.24309781193733215,
        0,
        0.2853109836578369,
        0.2394046187400818,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4293212890625,
        -0.15626028180122375,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.20088458061218262,
        0.2394046187400818,
        0,
        0.32624220848083496,
        0.22843721508979797,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863252639770508,
        0,
        0,
        0.285311222076416,
        -0.23940463364124298,
        0,
        0.19933366775512695,
        -0.23747384548187256,
        0,
        0.24309778213500977,
        -0.24309782683849335,
        0,
        0.20088481903076172,
        -0.23940463364124298,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.4863252639770508,
        0,
        0,
        0.4974551200866699,
        0.018744654953479767,
        0,
        0.4974551200866699,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.48250246047973633,
        0.04221349209547043,
        0,
        0.48619556427001953,
        0,
        0,
        0.42731738090515137,
        0.13260000944137573,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.003693103790283203,
        0.04221349209547043,
        0,
        0.0009113550186157227,
        0.0004747062921524048,
        0,
        -0.0005533695220947266,
        0.0004042122745886445,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.05687403678894043,
        0.15626025199890137,
        0,
        0,
        0,
        0,
        0.014660477638244629,
        0.08314433693885803,
        0,
        0.0015821456909179688,
        0.0004971474409103394,
        0,
        0,
        0,
        0,
        0.0012818574905395508,
        0.00041282176971435547,
        0,
        0.032568931579589844,
        0.12154892086982727,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4974551200866699,
        0.06938645243644714,
        0,
        0.4163331985473633,
        -0.048500001430511475,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.48400020599365234,
        -0.06768932938575745,
        0,
        0.4825019836425781,
        -0.042213499546051025,
        0,
        0.48400020599365234,
        -0.01860012859106064,
        0,
        0.48400020599365234,
        -0.0004301601729821414,
        0,
        0.48619532585144043,
        0,
        0,
        0.4863252639770508,
        0,
        0,
        0.4863252639770508,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.0036935806274414062,
        -0.042213499546051025,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.014660835266113281,
        -0.08314434438943863,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.032568931579589844,
        -0.12154891341924667,
        0,
        0.4974551200866699,
        0.03691975772380829,
        0,
        0.4863252639770508,
        0,
        0,
        0.47153496742248535,
        0.08314433693885803,
        0,
        0.4974551200866699,
        0.05397304892539978,
        0,
        0.4863250255584717,
        0,
        0,
        0.4536268711090088,
        0.12154892086982727,
        0,
        0.48400020599365234,
        -0.05274850130081177,
        0,
        0.4536271095275879,
        -0.12154891341924667,
        0,
        0.4863250255584717,
        0,
        0,
        0.48400020599365234,
        -0.03621801733970642,
        0,
        0.47153449058532715,
        -0.08314434438943863,
        0,
        0.4863252639770508,
        0,
        0,
        0,
        0,
        0,
        0.056873321533203125,
        -0.15626028180122375,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.12154901027679443,
        -0.21052885055541992,
        0,
        0.03839099407196045,
        -0.352799654006958,
        0,
        0.15995359420776367,
        -0.22843721508979797,
        0,
        0.08683764934539795,
        -0.18622374534606934,
        0,
        0.4293215274810791,
        -0.15626025199890137,
        0,
        0.39935827255249023,
        -0.18622374534606934,
        0,
        0.4200000762939453,
        -0.21000003814697266,
        0,
        0.36464691162109375,
        -0.21052885055541992,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863247871398926,
        0,
        0,
        0.36464643478393555,
        0.2105288952589035,
        0,
        0.39935874938964844,
        0.18622371554374695,
        0,
        0.4099998474121094,
        0.15000003576278687,
        0,
        0.32624244689941406,
        0.22843724489212036,
        0,
        0.037000179290771484,
        0.12699997425079346,
        0,
        0.0868377685546875,
        0.18622371554374695,
        0,
        0.12154817581176758,
        0.2105288952589035,
        0,
        0.15995311737060547,
        0.22843724489212036,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.21166658401489258,
        -0.21752619743347168,
        0,
        0.2853109836578369,
        -0.2394046187400818,
        0,
        0.24309802055358887,
        -0.24309781193733215,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4293212890625,
        0.15626028180122375,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.20088458061218262,
        -0.2394046187400818,
        0,
        0.32624220848083496,
        -0.22843721508979797,
        0,
        0.4863250255584717,
        0,
        0,
        0.4863252639770508,
        0,
        0,
        0.285311222076416,
        0.23940463364124298,
        0,
        0.19933366775512695,
        0.23747384548187256,
        0,
        0.24309778213500977,
        0.24309782683849335,
        0,
        0.20088481903076172,
        0.23940463364124298,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.4863252639770508,
        0,
        0,
        0.4974551200866699,
        -0.018744654953479767,
        0,
        0.48250246047973633,
        -0.04221349209547043,
        0,
        0,
        0,
        0,
        0.42731738090515137,
        -0.1326000690460205,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.003693103790283203,
        -0.04221349209547043,
        0,
        -0.0017715692520141602,
        0.0003534853458404541,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.05687403678894043,
        -0.15626025199890137,
        0,
        0,
        0,
        0,
        0.014660477638244629,
        -0.08314433693885803,
        0,
        -0.002859354019165039,
        0.0003470778465270996,
        0,
        0,
        0,
        0,
        -0.0028954744338989258,
        0.00036713480949401855,
        0,
        0.032568931579589844,
        -0.12154892086982727,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.4863250255584717,
        0,
        0,
        0.4974551200866699,
        -0.06938645243644714,
        0,
        0,
        0,
        0,
        0.4163331985473633,
        0.048500001430511475,
        0,
        0,
        0,
        0,
        0.48400020599365234,
        0.06768932938575745,
        0,
        0.4825019836425781,
        0.042213499546051025,
        0,
        0.48400020599365234,
        0.01860012859106064,
        0,
        0.4863252639770508,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.0036935806274414062,
        0.042213499546051025,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.014660835266113281,
        0.08314434438943863,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0.032568931579589844,
        0.12154891341924667,
        0,
        0.4974551200866699,
        -0.03691975772380829,
        0,
        0.4863252639770508,
        0,
        0,
        0.47153496742248535,
        -0.08314433693885803,
        0,
        0.4974551200866699,
        -0.05397304892539978,
        0,
        0.4863250255584717,
        0,
        0,
        0.4536268711090088,
        -0.12154892086982727,
        0,
        0.4536271095275879,
        0.12154891341924667,
        0,
        0.48400020599365234,
        0.05274850130081177,
        0,
        0.4863250255584717,
        0,
        0,
        0.48400020599365234,
        0.03621801733970642,
        0,
        0.47153449058532715,
        0.08314434438943863,
        0,
        0.4863252639770508,
        0,
        0,
        0,
        0,
        0,
        0.056873321533203125,
        0.15626028180122375,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ],
    [
        0.2197294682264328,
        1.481149435043335,
        0,
        0.14777812361717224,
        1.5002686977386475,
        0,
        0.14859063923358917,
        1.5085171461105347,
        0,
        0.22243838012218475,
        1.4994101524353027,
        0,
        0.2893359065055847,
        1.45444655418396,
        0,
        0.2957502603530884,
        1.4866902828216553,
        0,
        0.3557826578617096,
        1.420224905014038,
        0,
        0.3683496117591858,
        1.4703893661499023,
        0,
        0.4182245135307312,
        1.3785665035247803,
        0,
        0.4400615990161896,
        1.4505459070205688,
        0,
        0.4757751226425171,
        1.3295717239379883,
        0,
        0.5107135772705078,
        1.4272083044052124,
        0,
        0.5274941325187683,
        1.2733585834503174,
        0,
        0.5801351070404053,
        1.4004316329956055,
        0,
        0.5723733305931091,
        1.2100632190704346,
        0,
        0.6481587290763855,
        1.3702819347381592,
        0,
        0.6093156337738037,
        1.1398370265960693,
        0,
        0.7146211862564087,
        1.3368308544158936,
        0,
        0.6371104717254639,
        1.0628502368927002,
        0,
        0.7793620228767395,
        1.300159215927124,
        0,
        0.6544033288955688,
        0.9792876243591309,
        0,
        0.842225193977356,
        1.2603552341461182,
        0,
        0.6596523523330688,
        0.8893508911132812,
        0,
        0.9030598998069763,
        1.217515230178833,
        0,
        0.07843261957168579,
        1.5117590427398682,
        0,
        0.0743848979473114,
        1.5139906406402588,
        0,
        0,
        1.515592336654663,
        0,
        0,
        1.5158166885375977,
        0,
        -0.07438208907842636,
        1.5137666463851929,
        0,
        -0.0743848979473114,
        1.5139906406402588,
        0,
        -0.1485850214958191,
        1.5082941055297852,
        0,
        -0.14859063923358917,
        1.5085171461105347,
        0,
        -0.22242997586727142,
        1.4991884231567383,
        0,
        -0.22243838012218475,
        1.4994101524353027,
        0,
        -0.2957390248775482,
        1.4864706993103027,
        0,
        -0.2957502603530884,
        1.4866902828216553,
        0,
        -0.36833566427230835,
        1.47017240524292,
        0,
        -0.3683496117591858,
        1.4703893661499023,
        0,
        -0.44004496932029724,
        1.4503320455551147,
        0,
        -0.4400615990161896,
        1.4505459070205688,
        0,
        -0.5106942057609558,
        1.426997423171997,
        0,
        -0.5107135772705078,
        1.4272083044052124,
        0,
        -0.5801131129264832,
        1.400225043296814,
        0,
        -0.5801351070404053,
        1.4004316329956055,
        0,
        -0.6481342315673828,
        1.370079755783081,
        0,
        -0.6481587290763855,
        1.3702819347381592,
        0,
        -0.714594304561615,
        1.336633324623108,
        0,
        -0.7146211862564087,
        1.3368308544158936,
        0,
        -0.7793324589729309,
        1.2999670505523682,
        0,
        -0.7793620228767395,
        1.300159215927124,
        0,
        -0.8421934843063354,
        1.2601691484451294,
        0,
        -0.842225193977356,
        1.2603552341461182,
        0,
        -0.9030256271362305,
        1.2173354625701904,
        0,
        -0.9030598998069763,
        1.217515230178833,
        0,
        -0.9616818428039551,
        1.1715688705444336,
        0,
        -0.9617183208465576,
        1.1717422008514404,
        0,
        -1.0180219411849976,
        1.1229803562164307,
        0,
        -1.0180602073669434,
        1.1231460571289062,
        0,
        -1.0719091892242432,
        1.071685552597046,
        0,
        -1.07194983959198,
        1.0718439817428589,
        0,
        -1.123213768005371,
        1.0178096294403076,
        0,
        -1.1232563257217407,
        1.0179600715637207,
        0,
        -1.1718133687973022,
        0.9614818096160889,
        0,
        -1.171857476234436,
        0.9616237878799438,
        0,
        -1.217589020729065,
        0.902837336063385,
        0,
        -1.217634916305542,
        0.9029708504676819,
        0,
        -1.2604318857192993,
        0.8420178890228271,
        0,
        -1.2604795694351196,
        0.8421424031257629,
        0,
        -1.3002382516860962,
        0.7791703343391418,
        0,
        -1.3002873659133911,
        0.7792854905128479,
        0,
        -1.3369123935699463,
        0.7144455313682556,
        0,
        -1.3369625806808472,
        0.7145510911941528,
        0,
        -1.3703646659851074,
        0.6479992866516113,
        0,
        -1.370416522026062,
        0.6480950117111206,
        0,
        -1.4005162715911865,
        0.5799922347068787,
        0,
        -1.4005693197250366,
        0.5800778865814209,
        0,
        -1.4272942543029785,
        0.5105878114700317,
        0,
        -1.427348256111145,
        0.5106632113456726,
        0,
        -1.4506337642669678,
        0.43995335698127747,
        0,
        -1.4506888389587402,
        0.4400183856487274,
        0,
        -1.4704785346984863,
        0.36825910210609436,
        0,
        -1.4705342054367065,
        0.36831343173980713,
        0,
        -1.4867808818817139,
        0.2956774830818176,
        0,
        -1.4868369102478027,
        0.2957211434841156,
        0,
        -1.4995012283325195,
        0.22238361835479736,
        0,
        -1.4995577335357666,
        0.2224164605140686,
        0,
        -1.5086088180541992,
        0.14855413138866425,
        0,
        -1.5086658000946045,
        0.1485760509967804,
        0,
        -1.5140823125839233,
        0.07436586916446686,
        0,
        -1.5141394138336182,
        0.07437683641910553,
        0,
        -1.5159083604812622,
        -7.450580596923828e-7,
        0,
        -1.5159657001495361,
        -7.450580596923828e-7,
        0,
        0.6510725021362305,
        0.7932562828063965,
        0,
        0.9617183208465576,
        1.1717422008514404,
        0,
        2.637735366821289,
        -0.35978949069976807,
        0,
        2.5721027851104736,
        -0.3903944492340088,
        0,
        2.7731070518493652,
        -0.6161036491394043,
        0,
        2.6970555782318115,
        -0.3182525932788849,
        0,
        2.11175799369812,
        -0.2670457661151886,
        0,
        2.0567619800567627,
        -0.6203821301460266,
        0,
        2.1629655361175537,
        -0.3182525932788849,
        0,
        2.2222867012023926,
        -0.35978949069976807,
        0,
        1.2502825260162354,
        -0.35978949069976807,
        0,
        1.1909615993499756,
        -0.3182525932788849,
        0,
        1.1069352626800537,
        -0.6161036491394043,
        0,
        1.8090770244598389,
        -0.6244526505470276,
        0,
        1.6657304763793945,
        -0.35978949069976807,
        0,
        1.6000981330871582,
        -0.3903944492340088,
        0,
        1.7250514030456543,
        -0.3182525932788849,
        0,
        0.6937260627746582,
        -0.35978949069976807,
        0,
        0.8292484283447266,
        -0.6034241318702698,
        0,
        0.7530474662780762,
        -0.3182525932788849,
        0,
        0.6280937194824219,
        -0.3903944492340088,
        0,
        0.20588254928588867,
        -0.45523205399513245,
        0,
        0.2782778739929199,
        -0.35978949069976807,
        0,
        0.21895694732666016,
        -0.3182525932788849,
        0,
        0.34390974044799805,
        -0.3903944492340088,
        0,
        1.0370213985443115,
        1.0687907934188843,
        0,
        1.07194983959198,
        1.0718439817428589,
        0,
        1.1232563257217407,
        1.0179600715637207,
        0,
        1.171857476234436,
        0.9616237878799438,
        0,
        2.422696352005005,
        -0.7294614911079407,
        0,
        2.430011034011841,
        -0.4154490828514099,
        0,
        2.3578686714172363,
        -0.4091375172138214,
        0,
        1.4603385925292969,
        -0.7294614911079407,
        0,
        1.5301475524902344,
        -0.4091375172138214,
        0,
        1.4580063819885254,
        -0.4154490828514099,
        0,
        1.3858647346496582,
        -0.4091375172138214,
        0,
        0.8042540550231934,
        -0.2670457661151886,
        0,
        0.48331475257873535,
        0.24241113662719727,
        0,
        0.9808909893035889,
        -0.1680145263671875,
        0,
        0.4561147689819336,
        0.16760694980621338,
        0,
        0.5105149745941162,
        0.3172152042388916,
        0,
        0.8279612064361572,
        -0.4593261480331421,
        0,
        0.5362305641174316,
        -0.6049820184707642,
        0,
        0.3201141357421875,
        -0.20641374588012695,
        0,
        0.29291391372680664,
        -0.2812178134918213,
        0,
        0.34731411933898926,
        -0.13160955905914307,
        0,
        0.3745143413543701,
        -0.05680549144744873,
        0,
        0.2657136917114258,
        -0.3560218811035156,
        0,
        0.23851394653320312,
        -0.43082594871520996,
        0,
        0.5921152830123901,
        0.5416276454925537,
        0,
        1.1691113710403442,
        -0.032358646392822266,
        0,
        0.5649151802062988,
        0.4668233394622803,
        0,
        0.619315505027771,
        0.616431474685669,
        0,
        0.25237417221069336,
        -0.5036225318908691,
        0,
        2.50215220451355,
        -0.4091375172138214,
        0,
        2.28791880607605,
        -0.3903944492340088,
        0,
        1.3159146308898926,
        -0.3903944492340088,
        0,
        1.139754295349121,
        -0.2670457661151886,
        0,
        0.5581436157226562,
        -0.4091375172138214,
        0,
        0.48598194122314453,
        -0.7294614911079407,
        0,
        0.48600196838378906,
        -0.4154490828514099,
        0,
        0.4138603210449219,
        -0.4091375172138214,
        0,
        1.0180602073669434,
        1.1231460571289062,
        0,
        1.312314510345459,
        0.8676854968070984,
        0,
        1.217634916305542,
        0.9029708504676819,
        0,
        1.2604795694351196,
        0.8421424031257629,
        0,
        1.3369625806808472,
        0.7145510911941528,
        0,
        1.3002873659133911,
        0.7792854905128479,
        0,
        0.5377151966094971,
        0.39201951026916504,
        0,
        0.39203500747680664,
        -0.7404707670211792,
        0,
        0.2664320468902588,
        -0.57240891456604,
        0,
        0.6465156078338623,
        0.6912357807159424,
        0,
        1.867143154144287,
        -0.07214249670505524,
        0,
        1.9475038051605225,
        -0.07231677323579788,
        0,
        1.9475038051605225,
        -7.450580596923828e-7,
        0,
        1.8734548091888428,
        -7.450580596923828e-7,
        0,
        2.0208740234375,
        -0.07214249670505524,
        0,
        2.014561891555786,
        -7.450580596923828e-7,
        0,
        1.9475038051605225,
        -0.6224358677864075,
        0,
        0.8927822113037109,
        -0.31367027759552,
        0,
        0.42891478538513184,
        0.09280276298522949,
        0,
        0.401714563369751,
        0.017998695373535156,
        0,
        2.8391480445861816,
        -0.07214249670505524,
        0,
        1.6760122776031494,
        0.0908341035246849,
        0,
        1.6880700588226318,
        -0.002887637121602893,
        0,
        2.845458984375,
        -7.450580596923828e-7,
        0,
        1.5141394138336182,
        0.07437761127948761,
        0,
        1.515882968902588,
        -7.450580596923828e-7,
        0,
        1.4005693197250366,
        0.5800778865814209,
        0,
        1.427348256111145,
        0.5106632113456726,
        0,
        1.5170000791549683,
        0.5500000715255737,
        0,
        1.4506888389587402,
        0.4400183856487274,
        0,
        1.370416522026062,
        0.6480950117111206,
        0,
        1.2733500003814697,
        0.12094008922576904,
        0,
        2.748262405395508,
        -0.2670457661151886,
        0,
        1.6039998531341553,
        0.36800000071525574,
        0,
        2.820404529571533,
        -0.14209237694740295,
        0,
        1.656407356262207,
        0.18360702693462372,
        0,
        1.5086658000946045,
        0.1485760509967804,
        0,
        1.6319806575775146,
        0.27551981806755066,
        0,
        2.789799690246582,
        -0.20772483944892883,
        0,
        1.4995577335357666,
        0.2224164605140686,
        0,
        1.4705342054367065,
        0.36831343173980713,
        0,
        1.4868369102478027,
        0.2957211434841156,
        0,
        1.7762587070465088,
        -0.2670457661151886,
        0,
        1.9475038051605225,
        -0.26769179105758667,
        0,
        0.9677410125732422,
        -0.6096858978271484,
        0,
        0.3302426338195801,
        -0.8515821695327759,
        0,
        0.41930580139160156,
        -0.9603173732757568,
        0,
        0.9684958457946777,
        -0.26769179105758667,
        0,
        0.8951396942138672,
        -0.07214249670505524,
        0,
        0.9684619903564453,
        -0.07231677323579788,
        0,
        0.9684596061706543,
        -7.450580596923828e-7,
        0,
        0.9014508724212646,
        -7.450580596923828e-7,
        0,
        1.0488700866699219,
        -0.07214249670505524,
        0,
        1.042557716369629,
        -7.450580596923828e-7,
        0,
        0.03499937057495117,
        -0.07101200520992279,
        0,
        0.028152942657470703,
        -7.450580596923828e-7,
        0,
        0,
        0,
        0,
        0.0017132759094238281,
        -0.06980974227190018,
        0,
        0.07055377960205078,
        -7.450580596923828e-7,
        0,
        0.07686519622802734,
        -0.07214249670505524,
        0,
        0.006850719451904297,
        -0.13945068418979645,
        0,
        0.04113149642944336,
        -0.1399894803762436,
        0,
        0.09560823440551758,
        -0.14209237694740295,
        0,
        0.015398025512695312,
        -0.20875565707683563,
        0,
        0.0468134880065918,
        -0.20766039192676544,
        0,
        0.12621307373046875,
        -0.20772483944892883,
        0,
        1.9475038051605225,
        -0.1424359679222107,
        0,
        1.8484001159667969,
        -0.14209237694740295,
        0,
        2.039616823196411,
        -0.14209237694740295,
        0,
        1.9475038051605225,
        -0.20822730660438538,
        0,
        1.817795753479004,
        -0.20772483944892883,
        0,
        2.0702219009399414,
        -0.20772483944892883,
        0,
        0.9684805870056152,
        -0.20822730660438538,
        0,
        0.8457908630371094,
        -0.20772483944892883,
        0,
        1.0982177257537842,
        -0.20772483944892883,
        0,
        0.9684691429138184,
        -0.1424359679222107,
        0,
        0.8763959407806396,
        -0.14209237694740295,
        0,
        1.067612648010254,
        -0.14209237694740295,
        0,
        0.05865049362182617,
        -0.2739640772342682,
        0,
        0.16774988174438477,
        -0.2670457661151886,
        0,
        0.29592323303222656,
        -0.6980182528495789,
        0,
        0.2808830738067627,
        -0.6371994018554688,
        0,
        0.31174707412719727,
        -0.754899263381958,
        0,
        0.32854604721069336,
        -0.8078852891921997,
        0,
        0.3465108871459961,
        -0.8570290207862854,
        0,
        0.3658285140991211,
        -0.9023925065994263,
        0,
        0.38668203353881836,
        -0.944046676158905,
        0,
        0.4092531204223633,
        -0.9820711016654968,
        0,
        0.4337158203125,
        -1.0165544748306274,
        0,
        0.46024370193481445,
        -1.0475938320159912,
        0,
        0.4869999885559082,
        -1.0399999618530273,
        0,
        0.5201516151428223,
        -1.0997710227966309,
        0,
        0.4890012741088867,
        -1.075294852256775,
        0,
        0.46727561950683594,
        -1.0541598796844482,
        0,
        0.4167017936706543,
        -1.0060091018676758,
        0,
        0.36855077743530273,
        -0.9554349184036255,
        0,
        0.27050018310546875,
        -0.8015000224113464,
        0,
        0.3229403495788574,
        -0.9025588631629944,
        0,
        0.27997827529907227,
        -0.8475084900856018,
        0,
        0.23976945877075195,
        -0.7904164791107178,
        0,
        0.20241069793701172,
        -0.7314202189445496,
        0,
        0.14949989318847656,
        -0.5665000081062317,
        0,
        0.16799163818359375,
        -0.6706618666648865,
        0,
        0.1365952491760254,
        -0.6082878708839417,
        0,
        0.10829734802246094,
        -0.5444484949111938,
        0,
        0.08316516876220703,
        -0.4792975187301636,
        0,
        0.08684968948364258,
        -0.409824013710022,
        0,
        0.06126070022583008,
        -0.41299179196357727,
        0,
        0.027336597442626953,
        -0.27755773067474365,
        0,
        0.042636871337890625,
        -0.34569117426872253,
        0,
        0.2197294682264328,
        -1.4811509847640991,
        0,
        0.22243838012218475,
        -1.499411702156067,
        0,
        0.14859063923358917,
        -1.5085186958312988,
        0,
        0.14777812361717224,
        -1.5002702474594116,
        0,
        0.2893359065055847,
        -1.4544481039047241,
        0,
        0.2957502603530884,
        -1.486691951751709,
        0,
        0.3557826578617096,
        -1.4202264547348022,
        0,
        0.3683496117591858,
        -1.470391035079956,
        0,
        0.4182245135307312,
        -1.3785680532455444,
        0,
        0.4400615990161896,
        -1.450547456741333,
        0,
        0.4757751226425171,
        -1.3295732736587524,
        0,
        0.5107135772705078,
        -1.4272096157073975,
        0,
        0.5274941325187683,
        -1.2733598947525024,
        0,
        0.5801351070404053,
        -1.4004331827163696,
        0,
        0.5723733305931091,
        -1.2100647687911987,
        0,
        0.6481587290763855,
        -1.3702834844589233,
        0,
        0.6093156337738037,
        -1.1398385763168335,
        0,
        0.7146211862564087,
        -1.3368322849273682,
        0,
        0.6371104717254639,
        -1.0628515481948853,
        0,
        0.7793620228767395,
        -1.300160527229309,
        0,
        0.6544033288955688,
        -0.9792889356613159,
        0,
        0.842225193977356,
        -1.2603566646575928,
        0,
        0.6596523523330688,
        -0.8893522024154663,
        0,
        0.9030598998069763,
        -1.2175167798995972,
        0,
        0.0743848979473114,
        -1.513992190361023,
        0,
        0.07843261957168579,
        -1.5117605924606323,
        0,
        0,
        -1.5158181190490723,
        0,
        0,
        -1.5155938863754272,
        0,
        -0.0743848979473114,
        -1.513992190361023,
        0,
        -0.07438208907842636,
        -1.513768196105957,
        0,
        -0.14859063923358917,
        -1.5085186958312988,
        0,
        -0.1485850214958191,
        -1.5082956552505493,
        0,
        -0.22243838012218475,
        -1.499411702156067,
        0,
        -0.22242997586727142,
        -1.4991899728775024,
        0,
        -0.2957502603530884,
        -1.486691951751709,
        0,
        -0.2957390248775482,
        -1.4864723682403564,
        0,
        -0.3683496117591858,
        -1.470391035079956,
        0,
        -0.36833566427230835,
        -1.4701738357543945,
        0,
        -0.4400615990161896,
        -1.450547456741333,
        0,
        -0.44004496932029724,
        -1.4503334760665894,
        0,
        -0.5107135772705078,
        -1.4272096157073975,
        0,
        -0.5106942057609558,
        -1.4269990921020508,
        0,
        -0.5801351070404053,
        -1.4004331827163696,
        0,
        -0.5801131129264832,
        -1.400226354598999,
        0,
        -0.6481587290763855,
        -1.3702834844589233,
        0,
        -0.6481342315673828,
        -1.3700810670852661,
        0,
        -0.7146211862564087,
        -1.3368322849273682,
        0,
        -0.714594304561615,
        -1.3366347551345825,
        0,
        -0.7793620228767395,
        -1.300160527229309,
        0,
        -0.7793324589729309,
        -1.2999687194824219,
        0,
        -0.842225193977356,
        -1.2603566646575928,
        0,
        -0.8421934843063354,
        -1.260170578956604,
        0,
        -0.9030598998069763,
        -1.2175167798995972,
        0,
        -0.9030256271362305,
        -1.217336893081665,
        0,
        -0.9617183208465576,
        -1.1717437505722046,
        0,
        -0.9616818428039551,
        -1.1715703010559082,
        0,
        -1.0180602073669434,
        -1.1231476068496704,
        0,
        -1.0180219411849976,
        -1.1229817867279053,
        0,
        -1.07194983959198,
        -1.071845293045044,
        0,
        -1.0719091892242432,
        -1.0716869831085205,
        0,
        -1.1232563257217407,
        -1.0179616212844849,
        0,
        -1.123213768005371,
        -1.0178110599517822,
        0,
        -1.171857476234436,
        -0.961625337600708,
        0,
        -1.1718133687973022,
        -0.9614832401275635,
        0,
        -1.217634916305542,
        -0.9029723405838013,
        0,
        -1.217589020729065,
        -0.9028388261795044,
        0,
        -1.2604795694351196,
        -0.8421438932418823,
        0,
        -1.2604318857192993,
        -0.8420193791389465,
        0,
        -1.3002873659133911,
        -0.7792869806289673,
        0,
        -1.3002382516860962,
        -0.7791718244552612,
        0,
        -1.3369625806808472,
        -0.7145525813102722,
        0,
        -1.3369123935699463,
        -0.714447021484375,
        0,
        -1.370416522026062,
        -0.64809650182724,
        0,
        -1.3703646659851074,
        -0.6480007767677307,
        0,
        -1.4005693197250366,
        -0.5800793766975403,
        0,
        -1.4005162715911865,
        -0.579993724822998,
        0,
        -1.427348256111145,
        -0.510664701461792,
        0,
        -1.4272942543029785,
        -0.5105893015861511,
        0,
        -1.4506888389587402,
        -0.4400198757648468,
        0,
        -1.4506337642669678,
        -0.43995484709739685,
        0,
        -1.4705342054367065,
        -0.3683149218559265,
        0,
        -1.4704785346984863,
        -0.36826059222221375,
        0,
        -1.4868369102478027,
        -0.295722633600235,
        0,
        -1.4867808818817139,
        -0.295678973197937,
        0,
        -1.4995577335357666,
        -0.222417950630188,
        0,
        -1.4995012283325195,
        -0.22238510847091675,
        0,
        -1.5086658000946045,
        -0.14857754111289978,
        0,
        -1.5086088180541992,
        -0.14855562150478363,
        0,
        -1.5141394138336182,
        -0.07437832653522491,
        0,
        -1.5140823125839233,
        -0.07436735928058624,
        0,
        0.6510725021362305,
        -0.7932575941085815,
        0,
        0.9617183208465576,
        -1.1717437505722046,
        0,
        2.637735366821289,
        0.3597880005836487,
        0,
        2.7731070518493652,
        0.6161021590232849,
        0,
        2.5721027851104736,
        0.3903929591178894,
        0,
        2.6970555782318115,
        0.3182511031627655,
        0,
        2.11175799369812,
        0.2670442759990692,
        0,
        2.1629655361175537,
        0.3182511031627655,
        0,
        2.0567619800567627,
        0.6203806400299072,
        0,
        2.2222867012023926,
        0.3597880005836487,
        0,
        1.2502825260162354,
        0.3597880005836487,
        0,
        1.1069352626800537,
        0.6161021590232849,
        0,
        1.1909615993499756,
        0.3182511031627655,
        0,
        1.8090770244598389,
        0.6244511604309082,
        0,
        1.6000981330871582,
        0.3903929591178894,
        0,
        1.6657304763793945,
        0.3597880005836487,
        0,
        1.7250514030456543,
        0.3182511031627655,
        0,
        0.6937260627746582,
        0.3597880005836487,
        0,
        0.7530474662780762,
        0.3182511031627655,
        0,
        0.8292484283447266,
        0.6034226417541504,
        0,
        0.6280937194824219,
        0.3903929591178894,
        0,
        0.20588254928588867,
        0.45523056387901306,
        0,
        0.21895694732666016,
        0.3182511031627655,
        0,
        0.2782778739929199,
        0.3597880005836487,
        0,
        0.34390974044799805,
        0.3903929591178894,
        0,
        1.0370213985443115,
        -1.0687923431396484,
        0,
        1.1232563257217407,
        -1.0179616212844849,
        0,
        1.07194983959198,
        -1.071845293045044,
        0,
        1.171857476234436,
        -0.961625337600708,
        0,
        2.422696352005005,
        0.7294600009918213,
        0,
        2.3578686714172363,
        0.409136027097702,
        0,
        2.430011034011841,
        0.4154475927352905,
        0,
        1.4603385925292969,
        0.7294600009918213,
        0,
        1.4580063819885254,
        0.4154475927352905,
        0,
        1.5301475524902344,
        0.409136027097702,
        0,
        1.3858647346496582,
        0.409136027097702,
        0,
        0.8042540550231934,
        0.2670442759990692,
        0,
        0.48331475257873535,
        -0.24241268634796143,
        0,
        0.4561147689819336,
        -0.167608380317688,
        0,
        0.9808909893035889,
        0.16801297664642334,
        0,
        0.5105149745941162,
        -0.3172166347503662,
        0,
        0.8279612064361572,
        0.4593247175216675,
        0,
        0.5362305641174316,
        0.6049805283546448,
        0,
        0.3201141357421875,
        0.2064121961593628,
        0,
        0.29291391372680664,
        0.28121626377105713,
        0,
        0.34731411933898926,
        0.13160812854766846,
        0,
        0.3745143413543701,
        0.05680394172668457,
        0,
        0.2657136917114258,
        0.35602033138275146,
        0,
        0.23851394653320312,
        0.43082451820373535,
        0,
        0.5921152830123901,
        -0.5416291952133179,
        0,
        0.5649151802062988,
        -0.46682488918304443,
        0,
        1.1691113710403442,
        0.032357096672058105,
        0,
        0.619315505027771,
        -0.6164330244064331,
        0,
        0.25237417221069336,
        0.5036211013793945,
        0,
        2.50215220451355,
        0.409136027097702,
        0,
        2.28791880607605,
        0.3903929591178894,
        0,
        1.3159146308898926,
        0.3903929591178894,
        0,
        1.139754295349121,
        0.2670442759990692,
        0,
        0.5581436157226562,
        0.409136027097702,
        0,
        0.48598194122314453,
        0.7294600009918213,
        0,
        0.48600196838378906,
        0.4154475927352905,
        0,
        0.4138603210449219,
        0.409136027097702,
        0,
        1.0180602073669434,
        -1.1231476068496704,
        0,
        1.312314510345459,
        -0.8676869869232178,
        0,
        1.217634916305542,
        -0.9029723405838013,
        0,
        1.2604795694351196,
        -0.8421438932418823,
        0,
        1.3369625806808472,
        -0.7145525813102722,
        0,
        1.3002873659133911,
        -0.7792869806289673,
        0,
        0.5377151966094971,
        -0.3920208215713501,
        0,
        0.39203500747680664,
        0.740469217300415,
        0,
        0.2664320468902588,
        0.5724073648452759,
        0,
        0.6465156078338623,
        -0.6912373304367065,
        0,
        1.867143154144287,
        0.07214100658893585,
        0,
        1.9475038051605225,
        0.0723152831196785,
        0,
        2.0208740234375,
        0.07214100658893585,
        0,
        0.8927822113037109,
        0.3136688470840454,
        0,
        1.9475038051605225,
        0.6224343776702881,
        0,
        0.42891478538513184,
        -0.0928041934967041,
        0,
        0.401714563369751,
        -0.018000245094299316,
        0,
        2.8391480445861816,
        0.07214100658893585,
        0,
        1.6879560947418213,
        -0.09714114665985107,
        0,
        1.5141394138336182,
        -0.074379101395607,
        0,
        1.4005693197250366,
        -0.5800793766975403,
        0,
        1.5170000791549683,
        -0.5500015616416931,
        0,
        1.427348256111145,
        -0.510664701461792,
        0,
        1.4506888389587402,
        -0.4400198757648468,
        0,
        1.370416522026062,
        -0.64809650182724,
        0,
        1.2733500003814697,
        -0.12094151973724365,
        0,
        2.748262405395508,
        0.2670442759990692,
        0,
        1.6039998531341553,
        -0.3680014908313751,
        0,
        2.820404529571533,
        0.14209088683128357,
        0,
        1.6761947870254517,
        -0.1909068524837494,
        0,
        1.5086658000946045,
        -0.14857754111289978,
        0,
        1.6488007307052612,
        -0.28220051527023315,
        0,
        2.789799690246582,
        0.20772334933280945,
        0,
        1.4995577335357666,
        -0.222417950630188,
        0,
        1.4705342054367065,
        -0.3683149218559265,
        0,
        1.4868369102478027,
        -0.295722633600235,
        0,
        1.7762587070465088,
        0.2670442759990692,
        0,
        1.9475038051605225,
        0.2676903009414673,
        0,
        0.3302426338195801,
        0.8515806794166565,
        0,
        0.9677410125732422,
        0.609684407711029,
        0,
        0.41930580139160156,
        0.9603158831596375,
        0,
        0.9684958457946777,
        0.2676903009414673,
        0,
        0.8951396942138672,
        0.07214100658893585,
        0,
        0.9684619903564453,
        0.0723152831196785,
        0,
        1.0488700866699219,
        0.07214100658893585,
        0,
        0.03499937057495117,
        0.0710105150938034,
        0,
        0.0017132759094238281,
        0.06980825215578079,
        0,
        0.07686519622802734,
        0.07214100658893585,
        0,
        0.006850719451904297,
        0.13944919407367706,
        0,
        0.04113149642944336,
        0.1399879902601242,
        0,
        0.09560823440551758,
        0.14209088683128357,
        0,
        0.0468134880065918,
        0.20765890181064606,
        0,
        0.015398025512695312,
        0.20875416696071625,
        0,
        0.12621307373046875,
        0.20772334933280945,
        0,
        1.9475038051605225,
        0.1424344778060913,
        0,
        1.8484001159667969,
        0.14209088683128357,
        0,
        2.039616823196411,
        0.14209088683128357,
        0,
        1.9475038051605225,
        0.208225816488266,
        0,
        1.817795753479004,
        0.20772334933280945,
        0,
        2.0702219009399414,
        0.20772334933280945,
        0,
        0.8457908630371094,
        0.20772334933280945,
        0,
        0.9684805870056152,
        0.208225816488266,
        0,
        1.0982177257537842,
        0.20772334933280945,
        0,
        0.9684691429138184,
        0.1424344778060913,
        0,
        0.8763959407806396,
        0.14209088683128357,
        0,
        1.067612648010254,
        0.14209088683128357,
        0,
        0.05865049362182617,
        0.2739625871181488,
        0,
        0.16774988174438477,
        0.2670442759990692,
        0,
        0.2808830738067627,
        0.6371978521347046,
        0,
        0.29592323303222656,
        0.6980167627334595,
        0,
        0.31174707412719727,
        0.7548977732658386,
        0,
        0.32854604721069336,
        0.8078837990760803,
        0,
        0.3465108871459961,
        0.857027530670166,
        0,
        0.3658285140991211,
        0.9023910164833069,
        0,
        0.38668203353881836,
        0.9440451860427856,
        0,
        0.4092531204223633,
        0.9820696115493774,
        0,
        0.4337158203125,
        1.0165529251098633,
        0,
        0.46024370193481445,
        1.047592282295227,
        0,
        0.4869999885559082,
        1.0399985313415527,
        0,
        0.4890012741088867,
        1.0752934217453003,
        0,
        0.5201516151428223,
        1.0997694730758667,
        0,
        0.46727561950683594,
        1.054158329963684,
        0,
        0.4167017936706543,
        1.0060076713562012,
        0,
        0.36855077743530273,
        0.9554333686828613,
        0,
        0.27050018310546875,
        0.801498532295227,
        0,
        0.3229403495788574,
        0.902557373046875,
        0,
        0.27997827529907227,
        0.8475069999694824,
        0,
        0.23976945877075195,
        0.7904149293899536,
        0,
        0.20241069793701172,
        0.7314187288284302,
        0,
        0.14949989318847656,
        0.5664985179901123,
        0,
        0.16799163818359375,
        0.6706603765487671,
        0,
        0.1365952491760254,
        0.6082863807678223,
        0,
        0.10829734802246094,
        0.5444470047950745,
        0,
        0.08316516876220703,
        0.4792960286140442,
        0,
        0.06126070022583008,
        0.4129903018474579,
        0,
        0.08684968948364258,
        0.4098225235939026,
        0,
        0.027336597442626953,
        0.27755624055862427,
        0,
        0.042636871337890625,
        0.34568968415260315,
        0
    ],
    [
        0.2197294682264328,
        1.481149435043335,
        0,
        0.14777812361717224,
        1.5002686977386475,
        0,
        0.14859063923358917,
        1.5085171461105347,
        0,
        0.22243838012218475,
        1.4994101524353027,
        0,
        0.2893359065055847,
        1.45444655418396,
        0,
        0.2957502603530884,
        1.4866902828216553,
        0,
        0.3557826578617096,
        1.420224905014038,
        0,
        0.3683496117591858,
        1.4703893661499023,
        0,
        0.4182245135307312,
        1.3785665035247803,
        0,
        0.4400615990161896,
        1.4505459070205688,
        0,
        0.4757751226425171,
        1.3295717239379883,
        0,
        0.5107135772705078,
        1.4272083044052124,
        0,
        0.5274941325187683,
        1.2733585834503174,
        0,
        0.5801351070404053,
        1.4004316329956055,
        0,
        0.5723733305931091,
        1.2100632190704346,
        0,
        0.6481587290763855,
        1.3702819347381592,
        0,
        0.6093156337738037,
        1.1398370265960693,
        0,
        0.7146211862564087,
        1.3368308544158936,
        0,
        0.6371104717254639,
        1.0628502368927002,
        0,
        0.7793620228767395,
        1.300159215927124,
        0,
        0.6544033288955688,
        0.9792876243591309,
        0,
        0.842225193977356,
        1.2603552341461182,
        0,
        0.6581543684005737,
        0.8953964710235596,
        0,
        0.9030598998069763,
        1.217515230178833,
        0,
        0.07843261957168579,
        1.5117590427398682,
        0,
        0.0743848979473114,
        1.5139906406402588,
        0,
        0,
        1.515592336654663,
        0,
        0,
        1.5158166885375977,
        0,
        -0.07438208907842636,
        1.5137666463851929,
        0,
        -0.0743848979473114,
        1.5139906406402588,
        0,
        -0.1485850214958191,
        1.5082941055297852,
        0,
        -0.14859063923358917,
        1.5085171461105347,
        0,
        -0.22242997586727142,
        1.4991884231567383,
        0,
        -0.22243838012218475,
        1.4994101524353027,
        0,
        -0.2957390248775482,
        1.4864706993103027,
        0,
        -0.2957502603530884,
        1.4866902828216553,
        0,
        -0.36833566427230835,
        1.47017240524292,
        0,
        -0.3683496117591858,
        1.4703893661499023,
        0,
        -0.44004496932029724,
        1.4503320455551147,
        0,
        -0.4400615990161896,
        1.4505459070205688,
        0,
        -0.5106942057609558,
        1.426997423171997,
        0,
        -0.5107135772705078,
        1.4272083044052124,
        0,
        -0.5801131129264832,
        1.400225043296814,
        0,
        -0.5801351070404053,
        1.4004316329956055,
        0,
        -0.6481342315673828,
        1.370079755783081,
        0,
        -0.6481587290763855,
        1.3702819347381592,
        0,
        -0.714594304561615,
        1.336633324623108,
        0,
        -0.7146211862564087,
        1.3368308544158936,
        0,
        -0.7793324589729309,
        1.2999670505523682,
        0,
        -0.7793620228767395,
        1.300159215927124,
        0,
        -0.8421934843063354,
        1.2601691484451294,
        0,
        -0.842225193977356,
        1.2603552341461182,
        0,
        -0.9030256271362305,
        1.2173354625701904,
        0,
        -0.9030598998069763,
        1.217515230178833,
        0,
        -0.9616818428039551,
        1.1715688705444336,
        0,
        -0.9617183208465576,
        1.1717422008514404,
        0,
        -1.0180219411849976,
        1.1229803562164307,
        0,
        -1.0180602073669434,
        1.1231460571289062,
        0,
        -1.0719091892242432,
        1.071685552597046,
        0,
        -1.07194983959198,
        1.0718439817428589,
        0,
        -1.123213768005371,
        1.0178096294403076,
        0,
        -1.1232563257217407,
        1.0179600715637207,
        0,
        -1.1718133687973022,
        0.9614818096160889,
        0,
        -1.171857476234436,
        0.9616237878799438,
        0,
        -1.217589020729065,
        0.902837336063385,
        0,
        -1.217634916305542,
        0.9029708504676819,
        0,
        -1.2604318857192993,
        0.8420178890228271,
        0,
        -1.2604795694351196,
        0.8421424031257629,
        0,
        -1.3002382516860962,
        0.7791703343391418,
        0,
        -1.3002873659133911,
        0.7792854905128479,
        0,
        -1.3369123935699463,
        0.7144455313682556,
        0,
        -1.3369625806808472,
        0.7145510911941528,
        0,
        -1.3703646659851074,
        0.6479992866516113,
        0,
        -1.370416522026062,
        0.6480950117111206,
        0,
        -1.4005162715911865,
        0.5799922347068787,
        0,
        -1.4005693197250366,
        0.5800778865814209,
        0,
        -1.4272942543029785,
        0.5105878114700317,
        0,
        -1.427348256111145,
        0.5106632113456726,
        0,
        -1.4506337642669678,
        0.43995335698127747,
        0,
        -1.4506888389587402,
        0.4400183856487274,
        0,
        -1.4704785346984863,
        0.36825910210609436,
        0,
        -1.4705342054367065,
        0.36831343173980713,
        0,
        -1.4867808818817139,
        0.2956774830818176,
        0,
        -1.4868369102478027,
        0.2957211434841156,
        0,
        -1.4995012283325195,
        0.22238361835479736,
        0,
        -1.4995577335357666,
        0.2224164605140686,
        0,
        -1.5086088180541992,
        0.14855413138866425,
        0,
        -1.5086658000946045,
        0.1485760509967804,
        0,
        -1.5140823125839233,
        0.07436586916446686,
        0,
        -1.5141394138336182,
        0.07437683641910553,
        0,
        -1.5159083604812622,
        -7.450580596923828e-7,
        0,
        -1.5159657001495361,
        -7.450580596923828e-7,
        0,
        0.6602792739868164,
        0.8063466548919678,
        0,
        0.9617183208465576,
        1.1717422008514404,
        0,
        1.3713022470474243,
        -0.1870468556880951,
        0,
        1.3371813297271729,
        -0.20295771956443787,
        0,
        1.4444284439086914,
        -0.32039982080459595,
        0,
        1.402141809463501,
        -0.16545268893241882,
        0,
        1.0978572368621826,
        -0.13883137702941895,
        0,
        1.066178798675537,
        -0.3226248025894165,
        0,
        1.1244792938232422,
        -0.16545268893241882,
        0,
        1.1553187370300293,
        -0.1870468556880951,
        0,
        0.6499950885772705,
        -0.1870468556880951,
        0,
        0.6191561222076416,
        -0.16545268893241882,
        0,
        0.5722286701202393,
        -0.32039982080459595,
        0,
        0.9389283657073975,
        -0.32404983043670654,
        0,
        0.8659772872924805,
        -0.1870468556880951,
        0,
        0.8318562507629395,
        -0.20295771956443787,
        0,
        0.8968169689178467,
        -0.16545268893241882,
        0,
        0.3606534004211426,
        -0.1870468556880951,
        0,
        0.42920351028442383,
        -0.31432482600212097,
        0,
        0.3914933204650879,
        -0.16545268893241882,
        0,
        0.32653236389160156,
        -0.20295771956443787,
        0,
        0.10364341735839844,
        -0.23673981428146362,
        0,
        0.1446700096130371,
        -0.1870468556880951,
        0,
        0.1138315200805664,
        -0.16545268893241882,
        0,
        0.17879104614257812,
        -0.20295771956443787,
        0,
        1.064000129699707,
        1.0860000848770142,
        0,
        1.07194983959198,
        1.0718439817428589,
        0,
        1.1232563257217407,
        1.0179600715637207,
        0,
        1.171857476234436,
        0.9616237878799438,
        0,
        1.2627203464508057,
        -0.3793506920337677,
        0,
        1.2633106708526611,
        -0.2159830629825592,
        0,
        1.2258052825927734,
        -0.21270179748535156,
        0,
        0.7560138702392578,
        -0.3793506920337677,
        0,
        0.7954907417297363,
        -0.21270179748535156,
        0,
        0.7579865455627441,
        -0.2159830629825592,
        0,
        0.7204813957214355,
        -0.21270179748535156,
        0,
        0.41811466217041016,
        -0.13883137702941895,
        0,
        0.4744713306427002,
        0.35808491706848145,
        0,
        1.007335901260376,
        -0.12987804412841797,
        0,
        0.44792747497558594,
        0.29404759407043457,
        0,
        0.5010154247283936,
        0.4221222400665283,
        0,
        0.8849854469299316,
        -0.37709009647369385,
        0,
        0.6085443496704102,
        -0.500696063041687,
        0,
        0.31520795822143555,
        -0.026139259338378906,
        0,
        0.2886638641357422,
        -0.09017658233642578,
        0,
        0.3417520523071289,
        0.03789806365966797,
        0,
        0.36829566955566406,
        0.1019355058670044,
        0,
        0.26212000846862793,
        -0.1542140245437622,
        0,
        0.23557615280151367,
        -0.21825134754180908,
        0,
        0.580647349357605,
        0.614234447479248,
        0,
        1.180266261100769,
        -0.006272077560424805,
        0,
        0.5541033744812012,
        0.5501971244812012,
        0,
        0.6071914434432983,
        0.6782717704772949,
        0,
        0.2500929832458496,
        -0.2802811861038208,
        0,
        1.3008158206939697,
        -0.21270179748535156,
        0,
        1.1894400119781494,
        -0.20295771956443787,
        0,
        0.6841154098510742,
        -0.20295771956443787,
        0,
        0.592534065246582,
        -0.13883137702941895,
        0,
        0.29016733169555664,
        -0.21270179748535156,
        0,
        0.24930715560913086,
        -0.3793506920337677,
        0,
        0.25266218185424805,
        -0.2159830629825592,
        0,
        0.21515655517578125,
        -0.21270179748535156,
        0,
        1.0180602073669434,
        1.1231460571289062,
        0,
        1.2839999198913574,
        0.9160000681877136,
        0,
        1.217634916305542,
        0.9029708504676819,
        0,
        1.2604795694351196,
        0.8421424031257629,
        0,
        1.3369625806808472,
        0.7145510911941528,
        0,
        1.3002873659133911,
        0.7792854905128479,
        0,
        0.5275595188140869,
        0.4861595630645752,
        0,
        0.4705994129180908,
        -0.606242299079895,
        0,
        0.26480674743652344,
        -0.3383007049560547,
        0,
        0.6337354183197021,
        0.7423090934753418,
        0,
        0.9706873893737793,
        -0.03750533610582352,
        0,
        1.0093600749969482,
        -0.03760776296257973,
        0,
        1.0093600749969482,
        -7.450580596923828e-7,
        0,
        0.9739689826965332,
        -7.450580596923828e-7,
        0,
        1.0506091117858887,
        -0.03750533610582352,
        0,
        1.0473272800445557,
        -7.450580596923828e-7,
        0,
        1.0093600749969482,
        -0.32369279861450195,
        0,
        0.9345166683197021,
        -0.25348401069641113,
        0,
        0.4213836193084717,
        0.2300102710723877,
        0,
        0.3948395252227783,
        0.16597282886505127,
        0,
        1.4760125875473022,
        -0.03750533610582352,
        0,
        1.5278027057647705,
        0.0019437521696090698,
        0,
        1.5240004062652588,
        -7.450580596923828e-7,
        0,
        1.479293942451477,
        -7.450580596923828e-7,
        0,
        1.5141394138336182,
        0.07437761127948761,
        0,
        1.515882968902588,
        -7.450580596923828e-7,
        0,
        1.4005693197250366,
        0.5800778865814209,
        0,
        1.427348256111145,
        0.5106632113456726,
        0,
        1.4299999475479126,
        0.6469999551773071,
        0,
        1.4506888389587402,
        0.4400183856487274,
        0,
        1.370416522026062,
        0.6480950117111206,
        0,
        1.3597257137298584,
        0.08390522003173828,
        0,
        1.4287623167037964,
        -0.13883137702941895,
        0,
        1.4800002574920654,
        0.3639999330043793,
        0,
        1.4662680625915527,
        -0.07387077808380127,
        0,
        1.5328621864318848,
        0.0032358169555664062,
        0,
        1.5086658000946045,
        0.1485760509967804,
        0,
        1.5322520732879639,
        0.051729023456573486,
        0,
        1.4503566026687622,
        -0.10799169540405273,
        0,
        1.4995577335357666,
        0.2224164605140686,
        0,
        1.4705342054367065,
        0.36831343173980713,
        0,
        1.4868369102478027,
        0.2957211434841156,
        0,
        0.9234387874603271,
        -0.13883137702941895,
        0,
        1.0093600749969482,
        -0.1392109990119934,
        0,
        0.49984216690063477,
        -0.31706228852272034,
        0,
        0.3583993911743164,
        -0.6478481888771057,
        0,
        0.32419919967651367,
        -0.6394542455673218,
        0,
        0.5027446746826172,
        -0.1392109990119934,
        0,
        0.4653639793395996,
        -0.03750533610582352,
        0,
        0.5026154518127441,
        -0.03760776296257973,
        0,
        0.5026063919067383,
        -7.450580596923828e-7,
        0,
        0.4686453342437744,
        -7.450580596923828e-7,
        0,
        0.5452852249145508,
        -0.03750533610582352,
        0,
        0.5420036315917969,
        -7.450580596923828e-7,
        0,
        0.015664100646972656,
        -0.037118010222911835,
        0,
        0.005298614501953125,
        -7.450580596923828e-7,
        0,
        0,
        0,
        0,
        0.0008902549743652344,
        -0.03629259392619133,
        0,
        0.036679744720458984,
        -7.450580596923828e-7,
        0,
        0.03995990753173828,
        -0.03750533610582352,
        0,
        0.0035619735717773438,
        -0.0724974200129509,
        0,
        0.016933441162109375,
        -0.07341998815536499,
        0,
        0.049704551696777344,
        -0.07387077808380127,
        0,
        0.008005142211914062,
        -0.10852760076522827,
        0,
        0.019116878509521484,
        -0.10860654711723328,
        0,
        0.06561517715454102,
        -0.10799169540405273,
        0,
        1.0093600749969482,
        -0.0740726888179779,
        0,
        0.9609441757202148,
        -0.07387077808380127,
        0,
        1.0603532791137695,
        -0.07387077808380127,
        0,
        1.0093600749969482,
        -0.10828696191310883,
        0,
        0.945033073425293,
        -0.10799169540405273,
        0,
        1.0762643814086914,
        -0.10799169540405273,
        0,
        0.5026860237121582,
        -0.10828696191310883,
        0,
        0.4397091865539551,
        -0.10799169540405273,
        0,
        0.570939302444458,
        -0.10799169540405273,
        0,
        0.5026416778564453,
        -0.0740726888179779,
        0,
        0.45561957359313965,
        -0.07387077808380127,
        0,
        0.5550289154052734,
        -0.07387077808380127,
        0,
        0.022809982299804688,
        -0.14607708156108856,
        0,
        0.08720970153808594,
        -0.13883137702941895,
        0,
        0.2956104278564453,
        -0.44237661361694336,
        0,
        0.27991414070129395,
        -0.39232444763183594,
        0,
        0.3120903968811035,
        -0.4884908199310303,
        0,
        0.3295454978942871,
        -0.5307101011276245,
        0,
        0.34816646575927734,
        -0.569087028503418,
        0,
        0.36814022064208984,
        -0.6036838293075562,
        0,
        0.3896498680114746,
        -0.6345711946487427,
        0,
        0.41287660598754883,
        -0.6618288159370422,
        0,
        0.3652958869934082,
        -0.6371991038322449,
        0,
        0.3287010192871094,
        -0.615058183670044,
        0,
        0.25330018997192383,
        -0.5888343453407288,
        0,
        0.2704153060913086,
        -0.571747362613678,
        0,
        0.29903507232666016,
        -0.5940822958946228,
        0,
        0.24292659759521484,
        -0.5480351448059082,
        0,
        0.21663475036621094,
        -0.523002564907074,
        0,
        0.19160127639770508,
        -0.4967101812362671,
        0,
        0.12843704223632812,
        -0.4426250159740448,
        0,
        0.16789007186889648,
        -0.46922093629837036,
        0,
        0.1455550193786621,
        -0.44060152769088745,
        0,
        0.12465143203735352,
        -0.4109206199645996,
        0,
        0.10522890090942383,
        -0.3802497386932373,
        0,
        0.06556272506713867,
        -0.31537503004074097,
        0,
        0.08733463287353516,
        -0.34866276383399963,
        0,
        0.07101249694824219,
        -0.3162357807159424,
        0,
        0.05630064010620117,
        -0.2830471098423004,
        0,
        0.04323530197143555,
        -0.2491765022277832,
        0,
        0.03212404251098633,
        -0.2163746953010559,
        0,
        0.03184843063354492,
        -0.21470555663108826,
        0,
        0.014211654663085938,
        -0.1442963182926178,
        0,
        0.02216625213623047,
        -0.17971743643283844,
        0,
        0.2197294682264328,
        -1.4811509847640991,
        0,
        0.22243838012218475,
        -1.499411702156067,
        0,
        0.14859063923358917,
        -1.5085186958312988,
        0,
        0.14777812361717224,
        -1.5002702474594116,
        0,
        0.2893359065055847,
        -1.4544481039047241,
        0,
        0.2957502603530884,
        -1.486691951751709,
        0,
        0.3557826578617096,
        -1.4202264547348022,
        0,
        0.3683496117591858,
        -1.470391035079956,
        0,
        0.4182245135307312,
        -1.3785680532455444,
        0,
        0.4400615990161896,
        -1.450547456741333,
        0,
        0.4757751226425171,
        -1.3295732736587524,
        0,
        0.5107135772705078,
        -1.4272096157073975,
        0,
        0.5274941325187683,
        -1.2733598947525024,
        0,
        0.5801351070404053,
        -1.4004331827163696,
        0,
        0.5723733305931091,
        -1.2100647687911987,
        0,
        0.6481587290763855,
        -1.3702834844589233,
        0,
        0.6093156337738037,
        -1.1398385763168335,
        0,
        0.7146211862564087,
        -1.3368322849273682,
        0,
        0.6371104717254639,
        -1.0628515481948853,
        0,
        0.7793620228767395,
        -1.300160527229309,
        0,
        0.6544033288955688,
        -0.9792889356613159,
        0,
        0.842225193977356,
        -1.2603566646575928,
        0,
        0.6581543684005737,
        -0.8953980207443237,
        0,
        0.9030598998069763,
        -1.2175167798995972,
        0,
        0.0743848979473114,
        -1.513992190361023,
        0,
        0.07843261957168579,
        -1.5117605924606323,
        0,
        0,
        -1.5158181190490723,
        0,
        0,
        -1.5155938863754272,
        0,
        -0.0743848979473114,
        -1.513992190361023,
        0,
        -0.07438208907842636,
        -1.513768196105957,
        0,
        -0.14859063923358917,
        -1.5085186958312988,
        0,
        -0.1485850214958191,
        -1.5082956552505493,
        0,
        -0.22243838012218475,
        -1.499411702156067,
        0,
        -0.22242997586727142,
        -1.4991899728775024,
        0,
        -0.2957502603530884,
        -1.486691951751709,
        0,
        -0.2957390248775482,
        -1.4864723682403564,
        0,
        -0.3683496117591858,
        -1.470391035079956,
        0,
        -0.36833566427230835,
        -1.4701738357543945,
        0,
        -0.4400615990161896,
        -1.450547456741333,
        0,
        -0.44004496932029724,
        -1.4503334760665894,
        0,
        -0.5107135772705078,
        -1.4272096157073975,
        0,
        -0.5106942057609558,
        -1.4269990921020508,
        0,
        -0.5801351070404053,
        -1.4004331827163696,
        0,
        -0.5801131129264832,
        -1.400226354598999,
        0,
        -0.6481587290763855,
        -1.3702834844589233,
        0,
        -0.6481342315673828,
        -1.3700810670852661,
        0,
        -0.7146211862564087,
        -1.3368322849273682,
        0,
        -0.714594304561615,
        -1.3366347551345825,
        0,
        -0.7793620228767395,
        -1.300160527229309,
        0,
        -0.7793324589729309,
        -1.2999687194824219,
        0,
        -0.842225193977356,
        -1.2603566646575928,
        0,
        -0.8421934843063354,
        -1.260170578956604,
        0,
        -0.9030598998069763,
        -1.2175167798995972,
        0,
        -0.9030256271362305,
        -1.217336893081665,
        0,
        -0.9617183208465576,
        -1.1717437505722046,
        0,
        -0.9616818428039551,
        -1.1715703010559082,
        0,
        -1.0180602073669434,
        -1.1231476068496704,
        0,
        -1.0180219411849976,
        -1.1229817867279053,
        0,
        -1.07194983959198,
        -1.071845293045044,
        0,
        -1.0719091892242432,
        -1.0716869831085205,
        0,
        -1.1232563257217407,
        -1.0179616212844849,
        0,
        -1.123213768005371,
        -1.0178110599517822,
        0,
        -1.171857476234436,
        -0.961625337600708,
        0,
        -1.1718133687973022,
        -0.9614832401275635,
        0,
        -1.217634916305542,
        -0.9029723405838013,
        0,
        -1.217589020729065,
        -0.9028388261795044,
        0,
        -1.2604795694351196,
        -0.8421438932418823,
        0,
        -1.2604318857192993,
        -0.8420193791389465,
        0,
        -1.3002873659133911,
        -0.7792869806289673,
        0,
        -1.3002382516860962,
        -0.7791718244552612,
        0,
        -1.3369625806808472,
        -0.7145525813102722,
        0,
        -1.3369123935699463,
        -0.714447021484375,
        0,
        -1.370416522026062,
        -0.64809650182724,
        0,
        -1.3703646659851074,
        -0.6480007767677307,
        0,
        -1.4005693197250366,
        -0.5800793766975403,
        0,
        -1.4005162715911865,
        -0.579993724822998,
        0,
        -1.427348256111145,
        -0.510664701461792,
        0,
        -1.4272942543029785,
        -0.5105893015861511,
        0,
        -1.4506888389587402,
        -0.4400198757648468,
        0,
        -1.4506337642669678,
        -0.43995484709739685,
        0,
        -1.4705342054367065,
        -0.3683149218559265,
        0,
        -1.4704785346984863,
        -0.36826059222221375,
        0,
        -1.4868369102478027,
        -0.295722633600235,
        0,
        -1.4867808818817139,
        -0.295678973197937,
        0,
        -1.4995577335357666,
        -0.222417950630188,
        0,
        -1.4995012283325195,
        -0.22238510847091675,
        0,
        -1.5086658000946045,
        -0.14857754111289978,
        0,
        -1.5086088180541992,
        -0.14855562150478363,
        0,
        -1.5141394138336182,
        -0.07437832653522491,
        0,
        -1.5140823125839233,
        -0.07436735928058624,
        0,
        0.6602792739868164,
        -0.8063479661941528,
        0,
        0.9617183208465576,
        -1.1717437505722046,
        0,
        1.3713022470474243,
        0.1870453655719757,
        0,
        1.4444284439086914,
        0.32039833068847656,
        0,
        1.3371813297271729,
        0.20295622944831848,
        0,
        1.402141809463501,
        0.16545119881629944,
        0,
        1.0978572368621826,
        0.13882988691329956,
        0,
        1.1244792938232422,
        0.16545119881629944,
        0,
        1.066178798675537,
        0.3226233124732971,
        0,
        1.1553187370300293,
        0.1870453655719757,
        0,
        0.6499950885772705,
        0.1870453655719757,
        0,
        0.5722286701202393,
        0.32039833068847656,
        0,
        0.6191561222076416,
        0.16545119881629944,
        0,
        0.9389283657073975,
        0.32404834032058716,
        0,
        0.8318562507629395,
        0.20295622944831848,
        0,
        0.8659772872924805,
        0.1870453655719757,
        0,
        0.8968169689178467,
        0.16545119881629944,
        0,
        0.3606534004211426,
        0.1870453655719757,
        0,
        0.3914933204650879,
        0.16545119881629944,
        0,
        0.42920351028442383,
        0.3143233358860016,
        0,
        0.32653236389160156,
        0.20295622944831848,
        0,
        0.10364341735839844,
        0.23673832416534424,
        0,
        0.1138315200805664,
        0.16545119881629944,
        0,
        0.1446700096130371,
        0.1870453655719757,
        0,
        0.17879104614257812,
        0.20295622944831848,
        0,
        1.064000129699707,
        -1.0860013961791992,
        0,
        1.1232563257217407,
        -1.0179616212844849,
        0,
        1.07194983959198,
        -1.071845293045044,
        0,
        1.171857476234436,
        -0.961625337600708,
        0,
        1.2627203464508057,
        0.3793492019176483,
        0,
        1.2258052825927734,
        0.21270030736923218,
        0,
        1.2633106708526611,
        0.21598157286643982,
        0,
        0.7560138702392578,
        0.3793492019176483,
        0,
        0.7579865455627441,
        0.21598157286643982,
        0,
        0.7954907417297363,
        0.21270030736923218,
        0,
        0.7204813957214355,
        0.21270030736923218,
        0,
        0.41811466217041016,
        0.13882988691329956,
        0,
        0.4744713306427002,
        -0.3580864667892456,
        0,
        0.44792747497558594,
        -0.29404914379119873,
        0,
        1.007335901260376,
        0.12987661361694336,
        0,
        0.5010154247283936,
        -0.4221237897872925,
        0,
        0.8849854469299316,
        0.37708866596221924,
        0,
        0.6085443496704102,
        0.5006946325302124,
        0,
        0.31520795822143555,
        0.026137709617614746,
        0,
        0.2886638641357422,
        0.09017515182495117,
        0,
        0.3417520523071289,
        -0.03789961338043213,
        0,
        0.36829566955566406,
        -0.101936936378479,
        0,
        0.26212000846862793,
        0.15421247482299805,
        0,
        0.23557615280151367,
        0.21824991703033447,
        0,
        0.580647349357605,
        -0.6142359972000122,
        0,
        0.5541033744812012,
        -0.5501984357833862,
        0,
        1.180266261100769,
        0.006270647048950195,
        0,
        0.6071914434432983,
        -0.6782733201980591,
        0,
        0.2500929832458496,
        0.28027963638305664,
        0,
        1.3008158206939697,
        0.21270030736923218,
        0,
        1.1894400119781494,
        0.20295622944831848,
        0,
        0.6841154098510742,
        0.20295622944831848,
        0,
        0.592534065246582,
        0.13882988691329956,
        0,
        0.29016733169555664,
        0.21270030736923218,
        0,
        0.24930715560913086,
        0.3793492019176483,
        0,
        0.25266218185424805,
        0.21598157286643982,
        0,
        0.21515655517578125,
        0.21270030736923218,
        0,
        1.0180602073669434,
        -1.1231476068496704,
        0,
        1.2839999198913574,
        -0.916001558303833,
        0,
        1.217634916305542,
        -0.9029723405838013,
        0,
        1.2604795694351196,
        -0.8421438932418823,
        0,
        1.3369625806808472,
        -0.7145525813102722,
        0,
        1.3002873659133911,
        -0.7792869806289673,
        0,
        0.5275595188140869,
        -0.48616111278533936,
        0,
        0.4705994129180908,
        0.6062408089637756,
        0,
        0.26480674743652344,
        0.3382991552352905,
        0,
        0.6337354183197021,
        -0.742310643196106,
        0,
        0.9706873893737793,
        0.03750384598970413,
        0,
        1.0093600749969482,
        0.03760627284646034,
        0,
        1.0506091117858887,
        0.03750384598970413,
        0,
        0.9345166683197021,
        0.253482460975647,
        0,
        1.0093600749969482,
        0.32369130849838257,
        0,
        0.4213836193084717,
        -0.2300117015838623,
        0,
        0.3948395252227783,
        -0.16597437858581543,
        0,
        1.4760125875473022,
        0.03750384598970413,
        0,
        1.5278027057647705,
        -0.0019452422857284546,
        0,
        1.5141394138336182,
        -0.074379101395607,
        0,
        1.4005693197250366,
        -0.5800793766975403,
        0,
        1.4299999475479126,
        -0.6470014452934265,
        0,
        1.427348256111145,
        -0.510664701461792,
        0,
        1.4506888389587402,
        -0.4400198757648468,
        0,
        1.370416522026062,
        -0.64809650182724,
        0,
        1.3597257137298584,
        -0.08390676975250244,
        0,
        1.4287623167037964,
        0.13882988691329956,
        0,
        1.4800002574920654,
        -0.36400142312049866,
        0,
        1.4662680625915527,
        0.07386928796768188,
        0,
        1.5328623056411743,
        -0.003237307071685791,
        0,
        1.5086658000946045,
        -0.14857754111289978,
        0,
        1.5322521924972534,
        -0.05173051357269287,
        0,
        1.4503566026687622,
        0.10799020528793335,
        0,
        1.4995577335357666,
        -0.222417950630188,
        0,
        1.4705342054367065,
        -0.3683149218559265,
        0,
        1.4868369102478027,
        -0.295722633600235,
        0,
        0.9234387874603271,
        0.13882988691329956,
        0,
        1.0093600749969482,
        0.13920950889587402,
        0,
        0.3583993911743164,
        0.6478466987609863,
        0,
        0.49984216690063477,
        0.31706079840660095,
        0,
        0.32419919967651367,
        0.6394528150558472,
        0,
        0.5027446746826172,
        0.13920950889587402,
        0,
        0.4653639793395996,
        0.03750384598970413,
        0,
        0.5026154518127441,
        0.03760627284646034,
        0,
        0.5452852249145508,
        0.03750384598970413,
        0,
        0.015664100646972656,
        0.03711652010679245,
        0,
        0.0008902549743652344,
        0.036291103810071945,
        0,
        0.03995990753173828,
        0.03750384598970413,
        0,
        0.0035619735717773438,
        0.07249592989683151,
        0,
        0.016933441162109375,
        0.0734184980392456,
        0,
        0.049704551696777344,
        0.07386928796768188,
        0,
        0.019116878509521484,
        0.10860505700111389,
        0,
        0.008005142211914062,
        0.10852611064910889,
        0,
        0.06561517715454102,
        0.10799020528793335,
        0,
        1.0093600749969482,
        0.07407119870185852,
        0,
        0.9609441757202148,
        0.07386928796768188,
        0,
        1.0603532791137695,
        0.07386928796768188,
        0,
        1.0093600749969482,
        0.10828547179698944,
        0,
        0.945033073425293,
        0.10799020528793335,
        0,
        1.0762643814086914,
        0.10799020528793335,
        0,
        0.4397091865539551,
        0.10799020528793335,
        0,
        0.5026860237121582,
        0.10828547179698944,
        0,
        0.570939302444458,
        0.10799020528793335,
        0,
        0.5026416778564453,
        0.07407119870185852,
        0,
        0.45561957359313965,
        0.07386928796768188,
        0,
        0.5550289154052734,
        0.07386928796768188,
        0,
        0.022809982299804688,
        0.14607559144496918,
        0,
        0.08720970153808594,
        0.13882988691329956,
        0,
        0.27991414070129395,
        0.39232301712036133,
        0,
        0.2956104278564453,
        0.4423750638961792,
        0,
        0.3120903968811035,
        0.4884892702102661,
        0,
        0.3295454978942871,
        0.5307085514068604,
        0,
        0.34816646575927734,
        0.5690855979919434,
        0,
        0.36814022064208984,
        0.6036823391914368,
        0,
        0.3896498680114746,
        0.6345696449279785,
        0,
        0.41287660598754883,
        0.6618273258209229,
        0,
        0.3652958869934082,
        0.6371976137161255,
        0,
        0.3287010192871094,
        0.6150566935539246,
        0,
        0.25330018997192383,
        0.5888328552246094,
        0,
        0.29903507232666016,
        0.5940808057785034,
        0,
        0.2704153060913086,
        0.5717458724975586,
        0,
        0.24292659759521484,
        0.5480336546897888,
        0,
        0.21663475036621094,
        0.5230010747909546,
        0,
        0.19160127639770508,
        0.49670863151550293,
        0,
        0.12843704223632812,
        0.4426235258579254,
        0,
        0.16789007186889648,
        0.469219446182251,
        0,
        0.1455550193786621,
        0.44060003757476807,
        0,
        0.12465143203735352,
        0.4109191298484802,
        0,
        0.10522890090942383,
        0.3802482485771179,
        0,
        0.06556272506713867,
        0.3153735399246216,
        0,
        0.08733463287353516,
        0.34866127371788025,
        0,
        0.07101249694824219,
        0.316234290599823,
        0,
        0.05630064010620117,
        0.28304561972618103,
        0,
        0.04323530197143555,
        0.24917501211166382,
        0,
        0.03184843063354492,
        0.21470406651496887,
        0,
        0.03212404251098633,
        0.21637320518493652,
        0,
        0.014211654663085938,
        0.1442948281764984,
        0,
        0.02216625213623047,
        0.17971594631671906,
        0
    ],
    [
        0.09637947380542755,
        -1.1260777711868286,
        0,
        0.021446362137794495,
        -1.1154718399047852,
        0,
        -0.10822245478630066,
        -1.0986930131912231,
        0,
        -0.16200768947601318,
        -1.092059850692749,
        0,
        0.17009270191192627,
        -1.136683702468872,
        0,
        -0.21540266275405884,
        -1.0827958583831787,
        0,
        0.242141991853714,
        -1.147289514541626,
        0,
        -0.26827874779701233,
        -1.0709233283996582,
        0,
        0.31204938888549805,
        -1.1578954458236694,
        0,
        -0.3205084204673767,
        -1.0564707517623901,
        0,
        0.3792908191680908,
        -1.1685014963150024,
        0,
        -0.37196603417396545,
        -1.0394731760025024,
        0,
        0.44328397512435913,
        -1.179107427597046,
        0,
        -0.422527551651001,
        -1.019971251487732,
        0,
        0.5033714175224304,
        -1.1897133588790894,
        0,
        -0.47207111120224,
        -0.998012363910675,
        0,
        0.5587998628616333,
        -1.2003192901611328,
        0,
        -0.5204774141311646,
        -0.9736491441726685,
        0,
        0.6086952686309814,
        -1.2109252214431763,
        0,
        -0.5676298141479492,
        -0.9469401240348816,
        0,
        0.6520301103591919,
        -1.2215310335159302,
        0,
        -0.6134148836135864,
        -0.917949914932251,
        0,
        0.6875805854797363,
        -1.2321369647979736,
        0,
        -0.6577221155166626,
        -0.8867483735084534,
        0,
        -0.050129327923059464,
        -1.1048659086227417,
        0,
        -0.05417648330330849,
        -1.1026790142059326,
        0,
        0,
        -1.104188323020935,
        0,
        0,
        -1.1040090322494507,
        0,
        0.05417986586689949,
        -1.102858304977417,
        0,
        0.05417648330330849,
        -1.1026790142059326,
        0,
        0.10822921991348267,
        -1.0988714694976807,
        0,
        0.10822245478630066,
        -1.0986930131912231,
        0,
        0.162017822265625,
        -1.0922372341156006,
        0,
        0.16200768947601318,
        -1.092059850692749,
        0,
        0.21541611850261688,
        -1.0829716920852661,
        0,
        0.21540266275405884,
        -1.0827958583831787,
        0,
        0.2682954668998718,
        -1.0710973739624023,
        0,
        0.26827874779701233,
        -1.0709233283996582,
        0,
        0.32052844762802124,
        -1.0566424131393433,
        0,
        0.3205084204673767,
        -1.0564707517623901,
        0,
        0.37198927998542786,
        -1.0396418571472168,
        0,
        0.37196603417396545,
        -1.0394731760025024,
        0,
        0.4225538969039917,
        -1.020137071609497,
        0,
        0.422527551651001,
        -1.019971251487732,
        0,
        0.4721006453037262,
        -0.9981744289398193,
        0,
        0.47207111120224,
        -0.998012363910675,
        0,
        0.5205100178718567,
        -0.9738072752952576,
        0,
        0.5204774141311646,
        -0.9736491441726685,
        0,
        0.5676653981208801,
        -0.9470939636230469,
        0,
        0.5676298141479492,
        -0.9469401240348816,
        0,
        0.6134532690048218,
        -0.9180991053581238,
        0,
        0.6134148836135864,
        -0.917949914932251,
        0,
        0.6577632427215576,
        -0.8868923187255859,
        0,
        0.6577221155166626,
        -0.8867483735084534,
        0,
        0.7004885673522949,
        -0.8535491228103638,
        0,
        0.7004446983337402,
        -0.8534104824066162,
        0,
        0.7415264248847961,
        -0.8181495666503906,
        0,
        0.7414801120758057,
        -0.818016767501831,
        0,
        0.7807778120040894,
        -0.7807790637016296,
        0,
        0.7807291150093079,
        -0.7806522846221924,
        0,
        0.8181482553482056,
        -0.7415276765823364,
        0,
        0.8180971145629883,
        -0.7414071559906006,
        0,
        0.8535478115081787,
        -0.7004896402359009,
        0,
        0.8534945249557495,
        -0.7003759741783142,
        0,
        0.8868910074234009,
        -0.6577642560005188,
        0,
        0.8868356347084045,
        -0.6576573252677917,
        0,
        0.9180976152420044,
        -0.6134541630744934,
        0,
        0.9180402159690857,
        -0.6133545637130737,
        0,
        0.9470924735069275,
        -0.5676663517951965,
        0,
        0.9470332264900208,
        -0.567574143409729,
        0,
        0.9738056659698486,
        -0.5205107927322388,
        0,
        0.9737448692321777,
        -0.5204262137413025,
        0,
        0.9981728792190552,
        -0.4721013307571411,
        0,
        0.9981105327606201,
        -0.4720246493816376,
        0,
        1.0201354026794434,
        -0.422554612159729,
        0,
        1.0200716257095337,
        -0.42248597741127014,
        0,
        1.0396403074264526,
        -0.3719898760318756,
        0,
        1.039575457572937,
        -0.37192943692207336,
        0,
        1.0566407442092896,
        -0.32052895426750183,
        0,
        1.0565747022628784,
        -0.3204768896102905,
        0,
        1.071095585823059,
        -0.26829588413238525,
        0,
        1.0710285902023315,
        -0.26825234293937683,
        0,
        1.0829699039459229,
        -0.21541647613048553,
        0,
        1.0829023122787476,
        -0.21538150310516357,
        0,
        1.0922353267669678,
        -0.1620180904865265,
        0,
        1.0921671390533447,
        -0.16199177503585815,
        0,
        1.0988696813583374,
        -0.1082293912768364,
        0,
        1.0988010168075562,
        -0.10821183770895004,
        0,
        1.1028565168380737,
        -0.05417997017502785,
        0,
        1.1027876138687134,
        -0.05417116731405258,
        0,
        1.1041866540908813,
        -6.360002089422778e-7,
        0,
        1.104117512702942,
        -6.360002089422778e-7,
        0,
        0.7138700485229492,
        -1.2427430152893066,
        0,
        -0.7004446983337402,
        -0.8534104824066162,
        0,
        2.6377081871032715,
        -0.3597858250141144,
        0,
        2.5720760822296143,
        -0.39039045572280884,
        0,
        2.765000343322754,
        -0.6290000081062317,
        0,
        2.6970279216766357,
        -0.31824934482574463,
        0,
        2.111737012863159,
        -0.26704302430152893,
        0,
        2.0389997959136963,
        -0.6144999265670776,
        0,
        2.1629436016082764,
        -0.31824934482574463,
        0,
        2.222263813018799,
        -0.3597858250141144,
        0,
        1.2502696514129639,
        -0.3597858250141144,
        0,
        1.1909492015838623,
        -0.31824934482574463,
        0,
        1.1055352687835693,
        -0.6146638989448547,
        0,
        1.7660000324249268,
        -0.597000002861023,
        0,
        1.6657137870788574,
        -0.3597858250141144,
        0,
        1.6000819206237793,
        -0.39039045572280884,
        0,
        1.7250337600708008,
        -0.31824934482574463,
        0,
        0.6937189102172852,
        -0.3597858250141144,
        0,
        0.8280830383300781,
        -0.6018584370613098,
        0,
        0.7530393600463867,
        -0.31824934482574463,
        0,
        0.628087043762207,
        -0.39039045572280884,
        0,
        0.2065892219543457,
        -0.4541683495044708,
        0,
        0.2782745361328125,
        -0.3597858250141144,
        0,
        0.21895456314086914,
        -0.31824934482574463,
        0,
        0.3439064025878906,
        -0.39039045572280884,
        0,
        -0.6869999766349792,
        -0.8100000023841858,
        0,
        -0.7807291150093079,
        -0.7806522846221924,
        0,
        -0.8180971145629883,
        -0.7414071559906006,
        0,
        -0.8534945249557495,
        -0.7003759741783142,
        0,
        2.4301931858062744,
        -0.7488768696784973,
        0,
        2.429985761642456,
        -0.41544485092163086,
        0,
        2.357844829559326,
        -0.40913331508636475,
        0,
        1.458113193511963,
        -0.7277568578720093,
        0,
        1.5301322937011719,
        -0.40913331508636475,
        0,
        1.457991600036621,
        -0.41544485092163086,
        0,
        1.385850429534912,
        -0.40913331508636475,
        0,
        0.8042459487915039,
        -0.26704302430152893,
        0,
        0.9600982666015625,
        -1.3169844150543213,
        0,
        1.477936029434204,
        -1.3460599184036255,
        0,
        0.9952738285064697,
        -1.3275903463363647,
        0,
        0.9249229431152344,
        -1.3063786029815674,
        0,
        1.675985336303711,
        -1.3920599222183228,
        0,
        1.4227449893951416,
        -1.3710598945617676,
        0,
        1.1711506843566895,
        -1.380620002746582,
        0,
        1.2063260078430176,
        -1.3912259340286255,
        0,
        1.1359753608703613,
        -1.3700140714645386,
        0,
        1.1008000373840332,
        -1.3594081401824951,
        0,
        1.241502046585083,
        -1.4018319845199585,
        0,
        1.276677131652832,
        -1.412437915802002,
        0,
        0.8193963766098022,
        -1.274560809135437,
        0,
        1.0966664552688599,
        -1.3140599727630615,
        0,
        0.8545718193054199,
        -1.285166621208191,
        0,
        0.7842210531234741,
        -1.2639548778533936,
        0,
        1.3529131412506104,
        -1.4210362434387207,
        0,
        2.502126932144165,
        -0.40913331508636475,
        0,
        2.287895441055298,
        -0.39039045572280884,
        0,
        1.3159008026123047,
        -0.39039045572280884,
        0,
        1.1397428512573242,
        -0.26704302430152893,
        0,
        0.558138370513916,
        -0.40913331508636475,
        0,
        0.48603391647338867,
        -0.7277568578720093,
        0,
        0.48599720001220703,
        -0.41544485092163086,
        0,
        0.41385650634765625,
        -0.40913331508636475,
        0,
        -0.7414801120758057,
        -0.818016767501831,
        0,
        -0.8454679250717163,
        -0.6309999227523804,
        0,
        -0.8868356347084045,
        -0.6576573252677917,
        0,
        -0.9180402159690857,
        -0.6133545637130737,
        0,
        -0.9737448692321777,
        -0.5204262137413025,
        0,
        -0.9470332264900208,
        -0.567574143409729,
        0,
        0.8897473812103271,
        -1.2957725524902344,
        0,
        1.18399977684021,
        -1.3630000352859497,
        0,
        1.2832715511322021,
        -1.4158990383148193,
        0,
        0.7490456104278564,
        -1.2533488273620605,
        0,
        1.867124080657959,
        -0.07214176654815674,
        0,
        1.9441397190093994,
        -0.07214803248643875,
        0,
        1.9441397190093994,
        -6.360002089422778e-7,
        0,
        1.8734357357025146,
        -6.360002089422778e-7,
        0,
        2.020853042602539,
        -0.07214176654815674,
        0,
        2.0145413875579834,
        -6.360002089422778e-7,
        0,
        1.9218170642852783,
        -0.60589998960495,
        0,
        1.5153169631958008,
        -1.3580598831176758,
        0,
        1.0304491519927979,
        -1.3381963968276978,
        0,
        1.065624475479126,
        -1.3488022089004517,
        0,
        2.8391189575195312,
        -0.07214176654815674,
        0,
        -1.0542360544204712,
        -0.05123956874012947,
        0,
        -1.0563511848449707,
        0.0005963172297924757,
        0,
        2.8454298973083496,
        -6.360002089422778e-7,
        0,
        -1.1027876138687134,
        -0.05417116731405258,
        0,
        -1.104117512702942,
        -6.360002089422778e-7,
        0,
        -1.0200716257095337,
        -0.42248597741127014,
        0,
        -1.039575457572937,
        -0.37192943692207336,
        0,
        -0.9839358925819397,
        -0.39999979734420776,
        0,
        -1.0565747022628784,
        -0.3204768896102905,
        0,
        -0.9981105327606201,
        -0.4720246493816376,
        0,
        0.7133500576019287,
        -1.3140599727630615,
        0,
        2.748234272003174,
        -0.26704302430152893,
        0,
        -1.0464036464691162,
        -0.20799972116947174,
        0,
        2.820375919342041,
        -0.14209091663360596,
        0,
        -1.0516961812973022,
        -0.10313661396503448,
        0,
        -1.0988010168075562,
        -0.10821183770895004,
        0,
        -1.049049735069275,
        -0.1551274210214615,
        0,
        2.78977108001709,
        -0.2077227234840393,
        0,
        -1.0921671390533447,
        -0.16199177503585815,
        0,
        -1.0710285902023315,
        -0.26825234293937683,
        0,
        -1.0829023122787476,
        -0.21538150310516357,
        0,
        1.776240587234497,
        -0.26704302430152893,
        0,
        1.9441397190093994,
        -0.26706641912460327,
        0,
        0.9666671752929688,
        -0.608261227607727,
        0,
        0.9110002517700195,
        -1.2920000553131104,
        0,
        0.7160000801086426,
        -1.1710000038146973,
        0,
        0.9666671752929688,
        -0.26706641912460327,
        0,
        0.8951301574707031,
        -0.07214176654815674,
        0,
        0.9666671752929688,
        -0.07214803248643875,
        0,
        0.9666671752929688,
        -6.360002089422778e-7,
        0,
        0.9014418125152588,
        -6.360002089422778e-7,
        0,
        1.0488591194152832,
        -0.07214176654815674,
        0,
        1.0425472259521484,
        -6.360002089422778e-7,
        0,
        0.035805702209472656,
        -0.07093658298254013,
        0,
        0.029125213623046875,
        -6.360002089422778e-7,
        0,
        0,
        0,
        0,
        0.0017132759094238281,
        -0.06980903446674347,
        0,
        0.07055330276489258,
        -6.360002089422778e-7,
        0,
        0.07686424255371094,
        -0.07214176654815674,
        0,
        0.006850242614746094,
        -0.13944925367832184,
        0,
        0.04222297668457031,
        -0.1404605507850647,
        0,
        0.09560728073120117,
        -0.14209091663360596,
        0,
        0.015398025512695312,
        -0.2087535262107849,
        0,
        0.04835796356201172,
        -0.20907364785671234,
        0,
        0.12621164321899414,
        -0.2077227234840393,
        0,
        1.9441397190093994,
        -0.14210332930088043,
        0,
        1.848381519317627,
        -0.14209091663360596,
        0,
        2.03959584236145,
        -0.14209091663360596,
        0,
        1.9441397190093994,
        -0.2077409029006958,
        0,
        1.817777156829834,
        -0.2077227234840393,
        0,
        2.0702009201049805,
        -0.2077227234840393,
        0,
        0.9666671752929688,
        -0.2077409029006958,
        0,
        0.8457822799682617,
        -0.2077227234840393,
        0,
        1.0982062816619873,
        -0.2077227234840393,
        0,
        0.9666671752929688,
        -0.14210332930088043,
        0,
        0.876387357711792,
        -0.14209091663360596,
        0,
        1.0676021575927734,
        -0.14209091663360596,
        0,
        0.06171846389770508,
        -0.2775159776210785,
        0,
        0.16774845123291016,
        -0.26704302430152893,
        0,
        1.1451630592346191,
        -1.3954122066497803,
        0,
        1.2139663696289062,
        -1.4073508977890015,
        0,
        1.0770297050476074,
        -1.3801120519638062,
        0,
        1.0097074508666992,
        -1.361436128616333,
        0,
        0.9434027671813965,
        -1.3395318984985352,
        0,
        0.8782529830932617,
        -1.314400553703308,
        0,
        0.8144135475158691,
        -1.2861027717590332,
        0,
        0.7520408630371094,
        -1.254706859588623,
        0,
        0.6912827491760254,
        -1.2202879190444946,
        0,
        0.6322875022888184,
        -1.182929277420044,
        0,
        0.4759998321533203,
        -1.024999976158142,
        0,
        0.520146369934082,
        -1.0997596979141235,
        0,
        0.5751957893371582,
        -1.1427210569381714,
        0,
        0.4672708511352539,
        -1.0541491508483887,
        0,
        0.41669702529907227,
        -1.0059988498687744,
        0,
        0.3685469627380371,
        -0.9554252028465271,
        0,
        0.26649999618530273,
        -0.7900000810623169,
        0,
        0.32293701171875,
        -0.9025496244430542,
        0,
        0.27997541427612305,
        -0.8474998474121094,
        0,
        0.23976707458496094,
        -0.7904084324836731,
        0,
        0.2024083137512207,
        -0.7314127683639526,
        0,
        0.14349985122680664,
        -0.5609999895095825,
        0,
        0.16798973083496094,
        -0.6706550121307373,
        0,
        0.13659381866455078,
        -0.608281672000885,
        0,
        0.10829591751098633,
        -0.5444429516792297,
        0,
        0.08316469192504883,
        -0.4792926013469696,
        0,
        0.08299970626831055,
        -0.40550002455711365,
        0,
        0.06126070022583008,
        -0.41298753023147583,
        0,
        0.027336597442626953,
        -0.2775549292564392,
        0,
        0.04263639450073242,
        -0.3456876277923584,
        0,
        0.09637947380542755,
        1.1260764598846436,
        0,
        -0.16200768947601318,
        1.0920586585998535,
        0,
        -0.10822245478630066,
        1.098691701889038,
        0,
        0.021446362137794495,
        1.1154705286026,
        0,
        0.17009270191192627,
        1.136682391166687,
        0,
        -0.21540266275405884,
        1.0827945470809937,
        0,
        0.242141991853714,
        1.1472883224487305,
        0,
        -0.26827874779701233,
        1.0709220170974731,
        0,
        0.31204938888549805,
        1.1578941345214844,
        0,
        -0.3205084204673767,
        1.056469440460205,
        0,
        0.3792908191680908,
        1.168500304222107,
        0,
        -0.37196603417396545,
        1.0394718647003174,
        0,
        0.44328397512435913,
        1.1791061162948608,
        0,
        -0.422527551651001,
        1.0199699401855469,
        0,
        0.5033714175224304,
        1.1897120475769043,
        0,
        -0.47207111120224,
        0.99801105260849,
        0,
        0.5587998628616333,
        1.2003179788589478,
        0,
        -0.5204774141311646,
        0.9736478328704834,
        0,
        0.6086952686309814,
        1.2109239101409912,
        0,
        -0.5676298141479492,
        0.9469388127326965,
        0,
        0.6520301103591919,
        1.2215297222137451,
        0,
        -0.6134148836135864,
        0.9179486036300659,
        0,
        0.6875805854797363,
        1.2321356534957886,
        0,
        -0.6577221155166626,
        0.8867470622062683,
        0,
        -0.05417648330330849,
        1.1026777029037476,
        0,
        -0.050129327923059464,
        1.1048647165298462,
        0,
        -3.469446951953614e-16,
        1.1040078401565552,
        0,
        -3.469446951953614e-16,
        1.10418701171875,
        0,
        0.05417648330330849,
        1.1026777029037476,
        0,
        0.05417986586689949,
        1.1028571128845215,
        0,
        0.10822245478630066,
        1.098691701889038,
        0,
        0.10822921991348267,
        1.0988701581954956,
        0,
        0.16200768947601318,
        1.0920586585998535,
        0,
        0.162017822265625,
        1.0922359228134155,
        0,
        0.21540266275405884,
        1.0827945470809937,
        0,
        0.21541611850261688,
        1.082970380783081,
        0,
        0.26827874779701233,
        1.0709220170974731,
        0,
        0.2682954668998718,
        1.0710960626602173,
        0,
        0.3205084204673767,
        1.056469440460205,
        0,
        0.32052844762802124,
        1.0566411018371582,
        0,
        0.37196603417396545,
        1.0394718647003174,
        0,
        0.37198927998542786,
        1.0396406650543213,
        0,
        0.422527551651001,
        1.0199699401855469,
        0,
        0.4225538969039917,
        1.020135760307312,
        0,
        0.47207111120224,
        0.99801105260849,
        0,
        0.4721006453037262,
        0.9981731176376343,
        0,
        0.5204774141311646,
        0.9736478328704834,
        0,
        0.5205100178718567,
        0.9738059639930725,
        0,
        0.5676298141479492,
        0.9469388127326965,
        0,
        0.5676653981208801,
        0.9470926523208618,
        0,
        0.6134148836135864,
        0.9179486036300659,
        0,
        0.6134532690048218,
        0.9180977940559387,
        0,
        0.6577221155166626,
        0.8867470622062683,
        0,
        0.6577632427215576,
        0.8868910074234009,
        0,
        0.7004446983337402,
        0.8534091711044312,
        0,
        0.7004885673522949,
        0.8535478115081787,
        0,
        0.7414801120758057,
        0.818015456199646,
        0,
        0.7415264248847961,
        0.8181482553482056,
        0,
        0.7807291150093079,
        0.7806509733200073,
        0,
        0.7807778120040894,
        0.7807778120040894,
        0,
        0.8180971145629883,
        0.7414059042930603,
        0,
        0.8181482553482056,
        0.7415263652801514,
        0,
        0.8534945249557495,
        0.7003747224807739,
        0,
        0.8535478115081787,
        0.7004883885383606,
        0,
        0.8868356347084045,
        0.6576560735702515,
        0,
        0.8868910074234009,
        0.6577629446983337,
        0,
        0.9180402159690857,
        0.6133533120155334,
        0,
        0.9180976152420044,
        0.6134528517723083,
        0,
        0.9470332264900208,
        0.567572832107544,
        0,
        0.9470924735069275,
        0.5676650404930115,
        0,
        0.9737448692321777,
        0.5204249024391174,
        0,
        0.9738056659698486,
        0.5205094814300537,
        0,
        0.9981105327606201,
        0.4720233380794525,
        0,
        0.9981728792190552,
        0.47210007905960083,
        0,
        1.0200716257095337,
        0.42248469591140747,
        0,
        1.0201354026794434,
        0.4225533604621887,
        0,
        1.039575457572937,
        0.3719281852245331,
        0,
        1.0396403074264526,
        0.37198859453201294,
        0,
        1.0565747022628784,
        0.32047563791275024,
        0,
        1.0566407442092896,
        0.32052770256996155,
        0,
        1.0710285902023315,
        0.26825106143951416,
        0,
        1.071095585823059,
        0.2682946026325226,
        0,
        1.0829023122787476,
        0.2153802216053009,
        0,
        1.0829699039459229,
        0.21541519463062286,
        0,
        1.0921671390533447,
        0.16199049353599548,
        0,
        1.0922353267669678,
        0.16201680898666382,
        0,
        1.0988010168075562,
        0.10821057111024857,
        0,
        1.0988696813583374,
        0.10822810977697372,
        0,
        1.1027876138687134,
        0.054169900715351105,
        0,
        1.1028565168380737,
        0.05417869985103607,
        0,
        0.7138700485229492,
        1.2427417039871216,
        0,
        -0.7004446983337402,
        0.8534091711044312,
        0,
        2.6377081871032715,
        0.3597845435142517,
        0,
        2.765000343322754,
        0.6289987564086914,
        0,
        2.5720760822296143,
        0.39038920402526855,
        0,
        2.6970279216766357,
        0.31824806332588196,
        0,
        2.111737012863159,
        0.26704174280166626,
        0,
        2.1629436016082764,
        0.31824806332588196,
        0,
        2.0389997959136963,
        0.6144986748695374,
        0,
        2.222263813018799,
        0.3597845435142517,
        0,
        1.2502696514129639,
        0.3597845435142517,
        0,
        1.1055352687835693,
        0.6146626472473145,
        0,
        1.1909492015838623,
        0.31824806332588196,
        0,
        1.7660000324249268,
        0.5969987511634827,
        0,
        1.6000819206237793,
        0.39038920402526855,
        0,
        1.6657137870788574,
        0.3597845435142517,
        0,
        1.7250337600708008,
        0.31824806332588196,
        0,
        0.6937189102172852,
        0.3597845435142517,
        0,
        0.7530393600463867,
        0.31824806332588196,
        0,
        0.8280830383300781,
        0.6018571853637695,
        0,
        0.628087043762207,
        0.39038920402526855,
        0,
        0.2065892219543457,
        0.45416709780693054,
        0,
        0.21895456314086914,
        0.31824806332588196,
        0,
        0.2782745361328125,
        0.3597845435142517,
        0,
        0.3439064025878906,
        0.39038920402526855,
        0,
        -0.6869999766349792,
        0.8099986910820007,
        0,
        -0.8180971145629883,
        0.7414059042930603,
        0,
        -0.7807291150093079,
        0.7806509733200073,
        0,
        -0.8534945249557495,
        0.7003747224807739,
        0,
        2.4301931858062744,
        0.748875617980957,
        0,
        2.357844829559326,
        0.40913206338882446,
        0,
        2.429985761642456,
        0.4154435694217682,
        0,
        1.458113193511963,
        0.7277555465698242,
        0,
        1.457991600036621,
        0.4154435694217682,
        0,
        1.5301322937011719,
        0.40913206338882446,
        0,
        1.385850429534912,
        0.40913206338882446,
        0,
        0.8042459487915039,
        0.26704174280166626,
        0,
        0.9600982666015625,
        1.3169831037521362,
        0,
        0.9952738285064697,
        1.3275890350341797,
        0,
        1.477936029434204,
        1.3460586071014404,
        0,
        0.9249229431152344,
        1.3063772916793823,
        0,
        1.675985336303711,
        1.3920586109161377,
        0,
        1.4227449893951416,
        1.3710585832595825,
        0,
        1.1711506843566895,
        1.3806188106536865,
        0,
        1.2063260078430176,
        1.3912246227264404,
        0,
        1.1359753608703613,
        1.3700127601623535,
        0,
        1.1008000373840332,
        1.35940682888031,
        0,
        1.241502046585083,
        1.4018306732177734,
        0,
        1.276677131652832,
        1.412436604499817,
        0,
        0.8193963766098022,
        1.274559497833252,
        0,
        0.8545718193054199,
        1.2851653099060059,
        0,
        1.0966664552688599,
        1.3140586614608765,
        0,
        0.7842210531234741,
        1.2639535665512085,
        0,
        1.3529131412506104,
        1.4210349321365356,
        0,
        2.502126932144165,
        0.40913206338882446,
        0,
        2.287895441055298,
        0.39038920402526855,
        0,
        1.3159008026123047,
        0.39038920402526855,
        0,
        1.1397428512573242,
        0.26704174280166626,
        0,
        0.558138370513916,
        0.40913206338882446,
        0,
        0.48603391647338867,
        0.7277555465698242,
        0,
        0.48599720001220703,
        0.4154435694217682,
        0,
        0.41385650634765625,
        0.40913206338882446,
        0,
        -0.7414801120758057,
        0.818015456199646,
        0,
        -0.8454679250717163,
        0.6309986114501953,
        0,
        -0.8868356347084045,
        0.6576560735702515,
        0,
        -0.9180402159690857,
        0.6133533120155334,
        0,
        -0.9737448692321777,
        0.5204249024391174,
        0,
        -0.9470332264900208,
        0.567572832107544,
        0,
        0.8897473812103271,
        1.2957712411880493,
        0,
        1.18399977684021,
        1.3629987239837646,
        0,
        1.2832715511322021,
        1.4158977270126343,
        0,
        0.7490456104278564,
        1.253347635269165,
        0,
        1.867124080657959,
        0.07214049249887466,
        0,
        1.9441397190093994,
        0.07214676588773727,
        0,
        2.020853042602539,
        0.07214049249887466,
        0,
        1.5153169631958008,
        1.3580585718154907,
        0,
        1.9218170642852783,
        0.6058987379074097,
        0,
        1.0304491519927979,
        1.3381950855255127,
        0,
        1.065624475479126,
        1.3488008975982666,
        0,
        2.8391189575195312,
        0.07214049249887466,
        0,
        -1.0570619106292725,
        0.05241752415895462,
        0,
        -1.1027876138687134,
        0.054169900715351105,
        0,
        -1.0200716257095337,
        0.42248469591140747,
        0,
        -0.9839358925819397,
        0.3999984860420227,
        0,
        -1.039575457572937,
        0.3719281852245331,
        0,
        -1.0565747022628784,
        0.32047563791275024,
        0,
        -0.9981105327606201,
        0.4720233380794525,
        0,
        0.7133500576019287,
        1.3140586614608765,
        0,
        2.748234272003174,
        0.26704174280166626,
        0,
        -1.0464036464691162,
        0.20799846947193146,
        0,
        2.820375919342041,
        0.14208965003490448,
        0,
        -1.056502342224121,
        0.10429912060499191,
        0,
        -1.0988010168075562,
        0.10821057111024857,
        0,
        -1.0536071062088013,
        0.15627716481685638,
        0,
        2.78977108001709,
        0.20772144198417664,
        0,
        -1.0921671390533447,
        0.16199049353599548,
        0,
        -1.0710285902023315,
        0.26825106143951416,
        0,
        -1.0829023122787476,
        0.2153802216053009,
        0,
        1.776240587234497,
        0.26704174280166626,
        0,
        1.9441397190093994,
        0.2670651376247406,
        0,
        0.9110002517700195,
        1.2919987440109253,
        0,
        0.9666671752929688,
        0.6082599759101868,
        0,
        0.7160000801086426,
        1.1709986925125122,
        0,
        0.9666671752929688,
        0.2670651376247406,
        0,
        0.8951301574707031,
        0.07214049249887466,
        0,
        0.9666671752929688,
        0.07214676588773727,
        0,
        1.0488591194152832,
        0.07214049249887466,
        0,
        0.035805702209472656,
        0.07093531638383865,
        0,
        0.0017132759094238281,
        0.0698077604174614,
        0,
        0.07686424255371094,
        0.07214049249887466,
        0,
        0.006850242614746094,
        0.13944798707962036,
        0,
        0.04222297668457031,
        0.14045926928520203,
        0,
        0.09560728073120117,
        0.14208965003490448,
        0,
        0.04835796356201172,
        0.20907236635684967,
        0,
        0.015398025512695312,
        0.20875225961208344,
        0,
        0.12621164321899414,
        0.20772144198417664,
        0,
        1.9441397190093994,
        0.14210206270217896,
        0,
        1.848381519317627,
        0.14208965003490448,
        0,
        2.03959584236145,
        0.14208965003490448,
        0,
        1.9441397190093994,
        0.20773962140083313,
        0,
        1.817777156829834,
        0.20772144198417664,
        0,
        2.0702009201049805,
        0.20772144198417664,
        0,
        0.8457822799682617,
        0.20772144198417664,
        0,
        0.9666671752929688,
        0.20773962140083313,
        0,
        1.0982062816619873,
        0.20772144198417664,
        0,
        0.9666671752929688,
        0.14210206270217896,
        0,
        0.876387357711792,
        0.14208965003490448,
        0,
        1.0676021575927734,
        0.14208965003490448,
        0,
        0.06171846389770508,
        0.2775146961212158,
        0,
        0.16774845123291016,
        0.26704174280166626,
        0,
        1.2139663696289062,
        1.4073495864868164,
        0,
        1.1451630592346191,
        1.3954108953475952,
        0,
        1.0770297050476074,
        1.380110740661621,
        0,
        1.0097074508666992,
        1.361434817314148,
        0,
        0.9434027671813965,
        1.33953058719635,
        0,
        0.8782529830932617,
        1.314399242401123,
        0,
        0.8144135475158691,
        1.2861015796661377,
        0,
        0.7520408630371094,
        1.254705548286438,
        0,
        0.6912827491760254,
        1.2202866077423096,
        0,
        0.6322875022888184,
        1.1829280853271484,
        0,
        0.4759998321533203,
        1.024998664855957,
        0,
        0.5751957893371582,
        1.1427197456359863,
        0,
        0.520146369934082,
        1.0997583866119385,
        0,
        0.4672708511352539,
        1.0541478395462036,
        0,
        0.41669702529907227,
        1.0059975385665894,
        0,
        0.3685469627380371,
        0.955423891544342,
        0,
        0.26649999618530273,
        0.7899987697601318,
        0,
        0.32293701171875,
        0.9025483131408691,
        0,
        0.27997541427612305,
        0.8474985361099243,
        0,
        0.23976707458496094,
        0.790407121181488,
        0,
        0.2024083137512207,
        0.7314115166664124,
        0,
        0.14349985122680664,
        0.5609987378120422,
        0,
        0.16798973083496094,
        0.670653760433197,
        0,
        0.13659381866455078,
        0.6082804203033447,
        0,
        0.10829591751098633,
        0.5444416999816895,
        0,
        0.08316469192504883,
        0.47929131984710693,
        0,
        0.06126070022583008,
        0.41298627853393555,
        0,
        0.08299970626831055,
        0.40549877285957336,
        0,
        0.027336597442626953,
        0.27755364775657654,
        0,
        0.04263639450073242,
        0.3456863462924957,
        0
    ]
];

/**
 * [meshMorphs description] - sorted by absoluted timeing
 * In 100 absolute timeline, morph target weight for the system is evaulated by combination of [idx].weight(0-1) - [idx-1].weight(0-1) that totals to 1 
 * e.g.: at time 43 set -> meshMorphs[3].weight(0.3) AND meshMorphs[7].weight(0.7)
 * See: https://docs.blender.org/manual/en/latest/animation/shape_keys/introduction.html#animation-shapekeys-relative-vs-absolute
 * @type {Array}
 */
const meshMorphs = [
    {
        id: "m_Cutout_Left",
        idx: 0, // meshMorphPositions index
        time: 10
    },
    {
        id: "m_Cutout_Center",
        idx: 2, // meshMorphPositions index
        time: 20
    },
    {
        id: "m_Cutout_Right",
        idx: 4, // meshMorphPositions index
        time: 30
    },
    {
        id: "m_Cutout_Stepped",
        idx: 5, // meshMorphPositions index
        time: 40
    },
    {
        id: "m_CoreDefault_Tip_S",
        idx: 1, // meshMorphPositions index
        time: 50
    },
    {
        id: "m_CoreLarge_Tip_L",
        idx: 7, // meshMorphPositions index
        time: 60
    },
    {
        id: "m_CoreLarge_Tip_S",
        idx: 6, // meshMorphPositions index
        time: 70
    },
    {
        id: "m_CoreSmall_Tip_L",
        idx: 3, // meshMorphPositions index
        time: 80
    },
    {
        id: "m_CoreSmall_Tip_S",
        idx: 8, // meshMorphPositions index
        time: 90
    }
];

/**
 * [fixFloat description]
 * @param  {[type]} n [description]
 * @return {[type]}   [description]
 */
const fixFloat = function(n) {
	return (Math.round((n)*1000)/1000);
};


/**
 * [sortArrayByNumericValue description]
 * @param  {[type]} array     [description]
 * @param  {[type]} direction [description]
 * @return {[type]}           [description]
 */
const sortArrayByNumericValue = function(array, direction) {
  const sort =  direction.toLowerCase() === "desc" ? -1 : 1; 
  return array.sort((a, b) => (a > b) ? sort*1 : sort*-1);
};

/**
 * [objectMap description]
 * @param  {[type]}   obj [description]
 * @param  {Function} fn  [description]
 * @return {[type]}       [description]
 */
const objectMap = function(obj, fn) {
  return Object.fromEntries(
    Object.entries(obj).map(
      ([k, v], i) => [k, fn(v, k, i)]
    )
  )
};

/**
 * [exportJson description]
 * @param  {[type]} name [description]
 * @param  {[type]} data [description]
 * @return {[type]}      [description]
 */
const exportJson = function(name, data) {
    const hiddenElement = document.createElement('a');
    hiddenElement.href = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(data));
    hiddenElement.target = '_blank';
    hiddenElement.download = name+".json";
    hiddenElement.click();
};

/**
 * [description]
 * @return {[type]} [description]
 */
const importJson = async function() {

    return new Promise(async function(resolve, reject) {
        
        let inputFile = document.createElement("input");
        inputFile.type = "file";
        inputFile.multiple = false;
        inputFile.style.display = "none";
        document.body.appendChild(inputFile);               
    
        // Input Change listener
        inputFile.addEventListener("change", function(e) {
          var file = e.currentTarget.files[0];
    
          // Read File
          if (file.type && file.type !== "application/json") {
            console.log('File is not supported.', file.type, file);
            reject("File is not supported.");
            return;
          }
    
          const reader = new FileReader();
          reader.addEventListener('load', (event) => {
            const dataSource = event.target.result;
    
            try {
              inputFile.parentNode.removeChild(inputFile);
              const dataObject = JSON.parse(dataSource);               
              resolve({
                name: file.name
                ,data: dataObject
              });
            } catch(error) {
              console.error("Faild to parse the file.", error);
              reject("Failed to parse the file.");
            }
            
          });
          reader.readAsText(file);      
          
        }); 
        // open dialog              
        inputFile.click(); 
    
    });

};

/**
 * [htmlToDomFragment description]
 * @param  {[type]} s [description]
 * @return {[type]}   [description]
 */
const htmlToDomFragment = function(s) {
  var t = document.createElement('div');
  //if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) {
  if (isIE()) {
    t.innerHTML = '<br>' + s;
    t.removeChild(t.firstChild);
  } else {
    t.innerHTML = s;
  }
  if (t.childNodes.length == 1) {
    return (t.removeChild(t.firstChild));
  } else {
    var fragment = document.createDocumentFragment();
    while (t.firstChild) {
      fragment.appendChild(t.firstChild);
    }
    return fragment;
  }
};

/**
 * [isIE description]
 * @return {Boolean} [description]
 */
const isIE = function(){
  var ua = window.navigator.userAgent; //Check the userAgent property of the window.navigator object
  var msie = ua.indexOf('MSIE '); // IE 10 or older
  var trident = ua.indexOf('Trident/'); //IE 11
  return (msie > 0 || trident > 0);
};

class Material {


	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		/**
		 * [constructor description]
		 * @param  {...[type]} options.props [description]
		 * @return {[type]}                  [description]
		 */
		constructor({...props}) {
			
			// Super
			const { color, depth, graphicsDevice } = props;
	    	
			// Props
			this.colorsrc= color;
			this.color = new Color((color.r/255),(color.g/255),(color.b/255), (color.a||1) ); // rgb values in 0.0-1.0 scale
			this.depth = depth;
			this.graphicsDevice = graphicsDevice;

			// Init
			this.init();
	        
		}

		

	////////////////////////
	// INITIALIZE
	////////////////////////

		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {

			// Create Material
			this.createMaterial();

		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////
	
		/**
		 * [getMaterial description]
		 * @return {[type]} [description]
		 */
		getMaterial() {
			return this.material;
		}

		updateMaterial() {
			this.material.update();
		}

	////////////////////////
	// METHODS
	////////////////////////


		/**
		 * [createMaterial description]
		 * @return {[type]} [description]
		 */
		createMaterial() {

			this.material = new StandardMaterial();


			
			// ORIG:
				// this.material.emissive = this.color;
			// NEW 
				
					// TEXUTRE
						
						this.texture = new Texture(this.graphicsDevice, {
					        format: PIXELFORMAT_R8_G8_B8_A8,
					        autoMipmap: true
					        // ,mipmaps: true
					        // ,premultiplyAlpha: true
					    });
					    var opacity = document.createElement("canvas");
						var ctx = opacity.getContext("2d");
						// ctx.fillStyle = "rgba(255,255,255,0.5);" //"+this.color.a+")";
						ctx.fillStyle = "rgba("+this.colorsrc.r+","+this.colorsrc.g+","+this.colorsrc.b+","+(this.colorsrc.axx||0.69)+")";
						ctx.fillRect(0, 0, opacity.width, opacity.height);
					    
					    this.texture.setSource(opacity);//document.getElementById("texture"));
					    this.texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
					    this.texture.magFilter = FILTER_LINEAR;
					    this.texture.addressU = ADDRESS_CLAMP_TO_EDGE;
					    this.texture.addressV = ADDRESS_CLAMP_TO_EDGE;
					
					    this.material.emissiveMap = this.texture;
    					this.material.opacityMap = this.texture;
    					// this.material.diffuseMap = this.texture;

					// DIFFUSE COLOR and OPACITV
					
						
						//this.material.opacity = 0.5; // opacity doesn't work with depthWrite/Test
						
						this.material.id = this.material.name = "blade"+this.depth;
						
						// DIFUSSE COLOR - WORKING
							this.material.diffuse = this.color;
							// this.material.opacity = this.color.a;
							
						// EMISIVE COLOR
							// this.material.emissiveTint = true;
							// this.material.emissive = this.color;
							// this.material.opacityTint = true;

						
						

						// SHADER
							// var shaderDefinition = {
							//     attributes: {
							//         aPosition: SEMANTIC_POSITION
							//     },
							//     vshader: [
							//         "attribute vec3 aPosition;",
							//         "",
							//         "void main(void)",
							//         "{",
							//         "    gl_Position = vec4(aPosition, 1.0);",
							//         "}"
							//     ].join("\n"),
							//     fshader: [
							//         "precision " + this.graphicsDevice.precision + " float;",
							//         "",
							//         "void main(void)",
							//         "{",
							//         "    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);",
							//         "}"
							//     ].join("\n")
							// };

							// this.shader = new Shader(this.graphicsDevice, shaderDefinition);

							// this.material.setShader(this.shader);


						this.material.depthTest = true; //true;
						this.material.depthWrite = true; //true;
						
						// this.material.instancingCount = 1;
						// this.material.onUpdateShader = function(options) {
						//     options.useInstancing = true;
						//     return options;
						// };

// this.material.onUpdateShader = function(options) {
//         options.useInstancing = true;
//         return options;
//     };
    
//     const transformVS = `

// out vec4 color;

// mat4 getModelMatrix() {
//     color = vec4(instance_line1.w, instance_line2.w, instance_line3.w, instance_line4.w);
//     return mat4(
//         vec4(instance_line1.xyz, 0.0), 
//         vec4(instance_line2.xyz, 0.0), 
//         vec4(instance_line3.xyz, 0.0), 
//         vec4(instance_line4.xyz, 1.0)
//     );
// }

// vec4 getPosition() {
//     dModelMatrix = getModelMatrix();
//     vec3 localPos = vertex_position;
//     vec4 posW = dModelMatrix * vec4(localPos, 1.0);
//     dPositionW = posW.xyz;
//     vec4 screenPos = matrix_viewProjection * posW;
//     return screenPos;
// }
// vec3 getWorldPosition() {
//     return dPositionW;
// }
// `;
    
//     const emissivePS = `

// in vec4 color;

// vec3 getEmission() {
//     return color.rgb;
// }
// `;
//     this.material.chunks.transformVS = transformVS;
//     this.material.chunks.emissivePS = emissivePS;

						// this.material.alphaToCoverage = true;
						// this.material.alphaTest = 0; //false; //true;

						// this.material.opacityFadesSpecular = false; // set if you want to set alphaFade instead of opacity

						// this.material.depthBias = 10*this.depth;
						// 
						// this.material.useMorphPosition = true;
						// this.material.useMorphNormal = true;
						// this.material.useInstancing = true;

					// TEXTURE
						
						/*
						// Create a 8x8x24-bit texture
							var texture = new Texture(this.graphicsDevice, {
							    width: 8,
							    height: 8,
							    format: PIXELFORMAT_R8_G8_B8_A8,
							    // premultiplyAlpha: true
							});
						// Fill the texture with a gradient
							// var pixels = texture.lock();
							// var count = 0;
							// for (var i = 0; i < 8; i++) {
							//     for (var j = 0; j < 8; j++) {
							//         pixels[count++] = i * 32;
							//         pixels[count++] = j * 32;
							//         pixels[count++] = 255;
							//     }
							// }
							// texture.unlock();
						// Set from IMG
							texture.setSource(document.getElementById("texture"));
							texture.diffuseMapChannel = "rgba";
						// Add to material
							this.material.diffuseMap = texture;
						*/
					
				// this.material.alphaToCoverage = true;
				// this.material.slopeDepthBias = 10*this.depth;
				
				//this.material.redWrite=this.material.greenWrite=this.material.blueWrite=this.material.alphaWrite=false;

				// this.material.alphaFade = 0.5;
				// this.material.opacityFadesSpecular = false;
				// this.material.blend = false;
				// this.material.blendSrc = BLENDMODE_SRC_ALPHA;
				// this.material.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
				

				// this.material.emissiveTint = true;
				// this.material.emissive = this.color;
				// this.material.opacityTint = true;
				// slot.materials[name].opacity = 0; // use non-1 value so that opacity is included
				// slot.materials[name].opacityMap = texture;
				// slot.materials[name].opacityMapChannel = "a";
				// slot.materials[name].depthWrite = false;
				// slot.materials[name].cull = pc.CULLFACE_NONE;
				// slot.materials[name].blendType = pc.BLEND_PREMULTIPLIED;

			this.material.cull = CULLFACE_NONE; // front and back face visible (https://developer.playcanvas.com/en/api/pc.Material.html#cull)

			// OLD - not depth test/write
				// this.material.depthTest = false;
				// this.material.depthWrite = false;

			// NEW - render depth
				
				// // this.material.alphaToCoverage = true; ???				
				// this.material.slopeDepthBias = 10*this.depth;
				// this.material.depthBias = this.depth/10000;
									this.material.blendType = BLEND_PREMULTIPLIED; //BLEND_NORMAL;
				// this.material.alphaTest = true;
				// this.material.alphaWrite = true;
				// this.material.alphaToCoverage = false;

			// this.material.specular.set(1, 1, 1);			
			// this.material.bumpiness = 0;
			// this.material.shininess = 50;
			// this.material.metalness = 0.3;
			// this.material.useMetalness = true;
			
			this.material.update();

			// this.material.alphaTest = false;
			// this.material.blend = true;
			// 	this.material.blendSrc = BLENDMODE_SRC_ALPHA;
			// 	this.material.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;

			// 	this.material.update();

			return;

			// this.material.diffuse = this.color;
			// // This will disable blending (other option is to use layers: https://forum.playcanvas.com/t/solved-layer-problem-trying-to-put-and-entity-on-top-of-an-another/9153/15)
			// // this.material.depthTest = false;
			// // this.material.depthWrite = false;

			// this.material.specular.set(1, 1, 1);
			// this.material.blendType = BLEND_NORMAL;
			// this.material.fresnelModel = FRESNEL_NONE;
			// this.material.shadingModel = SPECULAR_PHONG;
			// this.material.bumpiness = 0;
			// this.material.shininess = 50;
			// this.material.metalness = 0.3;
			// this.material.useMetalness = true;
			// this.material.cull = CULLFACE_NONE; // front and back face visible (https://developer.playcanvas.com/en/api/pc.Material.html#cull)
			// this.material.update();

		}
	
}

const defaultColors = {

	blank: 		{r: 255, g: 0, b: 0},

	// CUSTOM
	// blade1: 	{r: 159, g: 132, b: 189},
	// blade2: 	{r: 235, g: 195, b: 219},
	// blade3: 	{r: 230, g: 228, b: 206},
	// blade4: 	{r: 13, g: 31, b: 45},
	// blade5: 	{r: 158, g: 163, b: 176},
	// blade6: 	{r: 228, g: 195, b: 173},
	// blade7: 	{r: 208, g: 0, b: 0},
	// blade8: 	{r: 63, g: 136, b: 197},
	// blade9: 	{r: 19, g: 111, b: 99},
	// blade10: 	{r: 214, g: 246, b: 221},
	// blade11: 	{r: 244, g: 152, b: 156},
	// blade12: 	{r: 172, g: 236, b: 247},
	// blade13: 	{r: 255, g: 164, b: 108},
	// blade14: 	{r: 105, g: 221, b: 255},
	// blade15: 	{r: 216, g: 225, b: 255},
	// blade16: 	{r: 190, g: 146, b: 162}

	// FBX
	blade1: 	{r: 0.061965, g: 75.735, b: 72.675, a: 0.964},
	blade2: 	{r: 1.02, g: 65.025, b: 32.385, a: 0.976},
	blade3: 	{r: 8.67, g: 69.87, b: 13.26, a: 0.978},
	blade4: 	{r: 89.76, g: 125.97, b: 7.14, a: 0.945},
	blade5: 	{r: 176.205, g: 167.79, b: 8.16, a: 0.914},
	blade6: 	{r: 202.215, g: 120.36, b: 7.65, a: 0.919},
	blade7: 	{r: 187.935, g: 56.1, b: 6.63, a: 0.939},
	blade8: 	{r: 179.52, g: 23.97, b: 6.375, a: 0.949},
	blade9: 	{r: 176.205, g: 10.2, b: 6.63, a: 0.953},
	blade10: 	{r: 176.205, g: 10.455, b: 23.46, a: 0.949},
	blade11: 	{r: 134.385, g: 10.2, b: 57.885, a: 0.950},
	blade12: 	{r: 59.415, g: 6.885, b: 56.865, a: 0.970},
	blade13: 	{r: 2.805, g: 10.455, b: 47.94, a: 0.985},
	blade14: 	{r: 0, g: 20.91, b: 74.715, a: 0.977},
	blade15: 	{r: 0, g: 55.08, b: 107.61, a: 0.960},
	blade16: 	{r: 0, g: 83.13, b: 106.335, a: 0.954}

};

class EventHandle {
  constructor(owner, name, fn) {
    this.owner = owner;
    this.name = name;
    this.fn = fn;
  }

  unbind() {
    if (!this.owner) return;
    this.owner.unbind(this.name, this.fn);
    this.owner = null;
    this.name = null;
    this.fn = null;
  }

  call() {
    if (!this.fn) return;
    this.fn.call(this.owner, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
  }

  on(name, fn) {
    return this.owner.on(name, fn);
  }

}

class Events {
  constructor() {
    Object.defineProperty(this, '_events', {
      enumerable: false,
      configurable: false,
      writable: true,
      value: {}
    });
    this._suspendEvents = false;
    this._additionalEmitters = [];
  }

  get suspendEvents() {
    return this._suspendEvents;
  }

  set suspendEvents(value) {
    this._suspendEvents = !!value;
  }

  on(name, fn) {
    const events = this._events[name];

    if (events === undefined) {
      this._events[name] = [fn];
    } else {
      if (events.indexOf(fn) === -1) events.push(fn);
    }

    return new EventHandle(this, name, fn);
  }

  once(name, fn) {
    const evt = this.on(name, (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) => {
      fn.call(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      evt.unbind();
    });
    return evt;
  }

  emit(name, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    if (this._suspendEvents) return;
    let events = this._events[name];

    if (events && events.length) {
      events = events.slice(0);

      for (let i = 0; i < events.length; i++) {
        if (!events[i]) continue;

        try {
          events[i].call(this, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        } catch (ex) {
          console.info('%c%s %c(event error)', 'color: #06f', name, 'color: #f00');
          console.log(ex.stack);
        }
      }
    }

    if (this._additionalEmitters.length) {
      const emitters = this._additionalEmitters.slice();

      emitters.forEach(emitter => {
        emitter.emit(name, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      });
    }

    return this;
  }

  unbind(name, fn) {
    if (name) {
      const events = this._events[name];
      if (!events) return this;

      if (fn) {
        const i = events.indexOf(fn);

        if (i !== -1) {
          if (events.length === 1) {
            delete this._events[name];
          } else {
            events.splice(i, 1);
          }
        }
      } else {
        delete this._events[name];
      }
    } else {
      this._events = {};
    }

    return this;
  }

  addEmitter(emitter) {
    if (!this._additionalEmitters.includes(emitter)) {
      this._additionalEmitters.push(emitter);
    }
  }

  removeEmitter(emitter) {
    const idx = this._additionalEmitters.indexOf(emitter);

    if (idx !== -1) {
      this._additionalEmitters.splice(idx, 1);
    }
  }

}

class Observer extends Events {
  constructor(data, options = {}) {
    super();
    this._destroyed = false;
    this._path = '';
    this._keys = [];
    this._data = {};
    this._pathsWithDuplicates = null;

    if (options.pathsWithDuplicates) {
      this._pathsWithDuplicates = {};

      for (let i = 0; i < options.pathsWithDuplicates.length; i++) {
        this._pathsWithDuplicates[options.pathsWithDuplicates[i]] = true;
      }
    }

    this.patch(data);
    this._parent = options.parent || null;
    this._parentPath = options.parentPath || '';
    this._parentField = options.parentField || null;
    this._parentKey = options.parentKey || null;
    this._latestFn = options.latestFn || null;
    this._silent = false;

    const propagate = function propagate(evt) {
      return function (path, arg1, arg2, arg3) {
        if (!this._parent) return;
        let key = this._parentKey;

        if (!key && this._parentField instanceof Array) {
          key = this._parentField.indexOf(this);
          if (key === -1) return;
        }

        path = this._parentPath + '.' + key + '.' + path;
        let state;
        if (this._silent) state = this._parent.silence();

        this._parent.emit(path + ':' + evt, arg1, arg2, arg3);

        this._parent.emit('*:' + evt, path, arg1, arg2, arg3);

        if (this._silent) this._parent.silenceRestore(state);
      };
    };

    this.on('*:set', propagate('set'));
    this.on('*:unset', propagate('unset'));
    this.on('*:insert', propagate('insert'));
    this.on('*:remove', propagate('remove'));
    this.on('*:move', propagate('move'));
  }

  static _splitPath(path) {
    const cache = Observer._splitPathsCache;
    let result = cache[path];

    if (!result) {
      result = path.split('.');
      cache[path] = result;
    } else {
      result = result.slice();
    }

    return result;
  }

  silence() {
    this._silent = true;
    const historyState = this.history && this.history.enabled;
    if (historyState) this.history.enabled = false;
    const syncState = this.sync && this.sync.enabled;
    if (syncState) this.sync.enabled = false;
    return [historyState, syncState];
  }

  silenceRestore(state) {
    this._silent = false;
    if (state[0]) this.history.enabled = true;
    if (state[1]) this.sync.enabled = true;
  }

  _prepare(target, key, value, silent, remote) {
    let i;
    let state;
    const path = (target._path ? target._path + '.' : '') + key;
    const type = typeof value;

    target._keys.push(key);

    if (type === 'object' && value instanceof Array) {
      target._data[key] = value.slice(0);

      for (i = 0; i < target._data[key].length; i++) {
        if (typeof target._data[key][i] === 'object' && target._data[key][i] !== null) {
          if (target._data[key][i] instanceof Array) {
            target._data[key][i].slice(0);
          } else {
            target._data[key][i] = new Observer(target._data[key][i], {
              parent: this,
              parentPath: path,
              parentField: target._data[key],
              parentKey: null
            });
          }
        } else {
          state = this.silence();
          this.emit(path + '.' + i + ':set', target._data[key][i], null, remote);
          this.emit('*:set', path + '.' + i, target._data[key][i], null, remote);
          this.silenceRestore(state);
        }
      }

      if (silent) state = this.silence();
      this.emit(path + ':set', target._data[key], null, remote);
      this.emit('*:set', path, target._data[key], null, remote);
      if (silent) this.silenceRestore(state);
    } else if (type === 'object' && value instanceof Object) {
      if (typeof target._data[key] !== 'object') {
        target._data[key] = {
          _path: path,
          _keys: [],
          _data: {}
        };
      }

      for (i in value) {
        if (typeof value[i] === 'object') {
          this._prepare(target._data[key], i, value[i], true, remote);
        } else {
          state = this.silence();
          target._data[key]._data[i] = value[i];

          target._data[key]._keys.push(i);

          this.emit(path + '.' + i + ':set', value[i], null, remote);
          this.emit('*:set', path + '.' + i, value[i], null, remote);
          this.silenceRestore(state);
        }
      }

      if (silent) state = this.silence();
      this.emit(path + ':set', value, undefined, remote);
      this.emit('*:set', path, value, undefined, remote);
      if (silent) this.silenceRestore(state);
    } else {
      if (silent) state = this.silence();
      target._data[key] = value;
      this.emit(path + ':set', value, undefined, remote);
      this.emit('*:set', path, value, undefined, remote);
      if (silent) this.silenceRestore(state);
    }

    return true;
  }

  set(path, value, silent, remote, force) {
    let i;
    let valueOld;

    let keys = Observer._splitPath(path);

    const length = keys.length;
    const key = keys[length - 1];
    let node = this;
    let nodePath = '';
    let obj = this;
    let state;

    for (i = 0; i < length - 1; i++) {
      if (node instanceof Array) {
        node = node[keys[i]];

        if (node instanceof Observer) {
          path = keys.slice(i + 1).join('.');
          obj = node;
        }
      } else {
        if (i < length && typeof node._data[keys[i]] !== 'object') {
          if (node._data[keys[i]]) obj.unset((node.__path ? node.__path + '.' : '') + keys[i]);
          node._data[keys[i]] = {
            _path: path,
            _keys: [],
            _data: {}
          };

          node._keys.push(keys[i]);
        }

        if (i === length - 1 && node.__path) nodePath = node.__path + '.' + keys[i];
        node = node._data[keys[i]];
      }
    }

    if (node instanceof Array) {
      const ind = parseInt(key, 10);
      if (node[ind] === value && !force) return;
      valueOld = node[ind];

      if (valueOld instanceof Observer) {
        valueOld = valueOld.json();
      } else {
        valueOld = obj.json(valueOld);
      }

      node[ind] = value;

      if (value instanceof Observer) {
        value._parent = obj;
        value._parentPath = nodePath;
        value._parentField = node;
        value._parentKey = null;
      }

      if (silent) state = obj.silence();
      obj.emit(path + ':set', value, valueOld, remote);
      obj.emit('*:set', path, value, valueOld, remote);
      if (silent) obj.silenceRestore(state);
      return true;
    } else if (node._data && !node._data.hasOwnProperty(key)) {
      if (typeof value === 'object') {
        return obj._prepare(node, key, value, false, remote);
      }

      node._data[key] = value;

      node._keys.push(key);

      if (silent) state = obj.silence();
      obj.emit(path + ':set', value, null, remote);
      obj.emit('*:set', path, value, null, remote);
      if (silent) obj.silenceRestore(state);
      return true;
    }

    if (typeof value === 'object' && value instanceof Array) {
      if (value.equals(node._data[key]) && !force) return false;
      valueOld = node._data[key];
      if (!(valueOld instanceof Observer)) valueOld = obj.json(valueOld);

      if (node._data[key] && node._data[key].length === value.length) {
        state = obj.silence();

        if (value.length === 0) {
          node._data[key] = value;
        }

        for (i = 0; i < node._data[key].length; i++) {
          if (node._data[key][i] instanceof Observer) {
            node._data[key][i].patch(value[i], true);
          } else if (node._data[key][i] !== value[i]) {
            node._data[key][i] = value[i];
            obj.emit(path + '.' + i + ':set', node._data[key][i], valueOld && valueOld[i] || null, remote);
            obj.emit('*:set', path + '.' + i, node._data[key][i], valueOld && valueOld[i] || null, remote);
          }
        }

        obj.silenceRestore(state);
      } else {
        node._data[key] = [];
        value.forEach(val => {
          this._doInsert(node, key, val, undefined, true);
        });
        state = obj.silence();

        for (i = 0; i < node._data[key].length; i++) {
          obj.emit(path + '.' + i + ':set', node._data[key][i], valueOld && valueOld[i] || null, remote);
          obj.emit('*:set', path + '.' + i, node._data[key][i], valueOld && valueOld[i] || null, remote);
        }

        obj.silenceRestore(state);
      }

      if (silent) state = obj.silence();
      obj.emit(path + ':set', value, valueOld, remote);
      obj.emit('*:set', path, value, valueOld, remote);
      if (silent) obj.silenceRestore(state);
      return true;
    } else if (typeof value === 'object' && value instanceof Object) {
      let changed = false;
      valueOld = node._data[key];
      if (!(valueOld instanceof Observer)) valueOld = obj.json(valueOld);
      keys = Object.keys(value);

      if (!node._data[key] || !node._data[key]._data) {
        if (node._data[key]) {
          obj.unset((node.__path ? node.__path + '.' : '') + key);
        } else {
          changed = true;
        }

        node._data[key] = {
          _path: path,
          _keys: [],
          _data: {}
        };
      }

      let c;

      for (const n in node._data[key]._data) {
        if (!value.hasOwnProperty(n)) {
          c = obj.unset(path + '.' + n, true);
          if (c) changed = true;
        } else if (node._data[key]._data.hasOwnProperty(n)) {
          if (!obj._equals(node._data[key]._data[n], value[n])) {
            c = obj.set(path + '.' + n, value[n], true);
            if (c) changed = true;
          }
        } else {
          c = obj._prepare(node._data[key], n, value[n], true, remote);
          if (c) changed = true;
        }
      }

      for (i = 0; i < keys.length; i++) {
        if (value[keys[i]] === undefined && node._data[key]._data.hasOwnProperty(keys[i])) {
          c = obj.unset(path + '.' + keys[i], true);
          if (c) changed = true;
        } else if (typeof value[keys[i]] === 'object') {
          if (node._data[key]._data.hasOwnProperty(keys[i])) {
            c = obj.set(path + '.' + keys[i], value[keys[i]], true);
            if (c) changed = true;
          } else {
            c = obj._prepare(node._data[key], keys[i], value[keys[i]], true, remote);
            if (c) changed = true;
          }
        } else if (!obj._equals(node._data[key]._data[keys[i]], value[keys[i]])) {
          if (typeof value[keys[i]] === 'object') {
            c = obj.set(node._data[key]._path + '.' + keys[i], value[keys[i]], true);
            if (c) changed = true;
          } else if (node._data[key]._data[keys[i]] !== value[keys[i]]) {
            changed = true;
            if (node._data[key]._keys.indexOf(keys[i]) === -1) node._data[key]._keys.push(keys[i]);
            node._data[key]._data[keys[i]] = value[keys[i]];
            state = obj.silence();
            obj.emit(node._data[key]._path + '.' + keys[i] + ':set', node._data[key]._data[keys[i]], null, remote);
            obj.emit('*:set', node._data[key]._path + '.' + keys[i], node._data[key]._data[keys[i]], null, remote);
            obj.silenceRestore(state);
          }
        }
      }

      if (changed) {
        if (silent) state = obj.silence();
        const val = obj.json(node._data[key]);
        obj.emit(node._data[key]._path + ':set', val, valueOld, remote);
        obj.emit('*:set', node._data[key]._path, val, valueOld, remote);
        if (silent) obj.silenceRestore(state);
        return true;
      }

      return false;
    }

    let data;

    if (!node.hasOwnProperty('_data') && node.hasOwnProperty(key)) {
      data = node;
    } else {
      data = node._data;
    }

    if (data[key] === value && !force) return false;
    if (silent) state = obj.silence();
    valueOld = data[key];
    if (!(valueOld instanceof Observer)) valueOld = obj.json(valueOld);
    data[key] = value;
    obj.emit(path + ':set', value, valueOld, remote);
    obj.emit('*:set', path, value, valueOld, remote);
    if (silent) obj.silenceRestore(state);
    return true;
  }

  has(path) {
    const keys = Observer._splitPath(path);

    let node = this;

    for (let i = 0, len = keys.length; i < len; i++) {
      if (node == undefined) return undefined;

      if (node._data) {
        node = node._data[keys[i]];
      } else {
        node = node[keys[i]];
      }
    }

    return node !== undefined;
  }

  get(path, raw) {
    const keys = Observer._splitPath(path);

    let node = this;

    for (let i = 0; i < keys.length; i++) {
      if (node == undefined) return undefined;

      if (node._data) {
        node = node._data[keys[i]];
      } else {
        node = node[keys[i]];
      }
    }

    if (raw) return node;

    if (node == null) {
      return null;
    }

    return this.json(node);
  }

  getRaw(path) {
    return this.get(path, true);
  }

  _equals(a, b) {
    if (a === b) {
      return true;
    } else if (a instanceof Array && b instanceof Array && a.equals(b)) {
      return true;
    }

    return false;
  }

  unset(path, silent, remote) {
    let i;

    const keys = Observer._splitPath(path);

    const key = keys[keys.length - 1];
    let node = this;
    let obj = this;

    for (i = 0; i < keys.length - 1; i++) {
      if (node instanceof Array) {
        node = node[keys[i]];

        if (node instanceof Observer) {
          path = keys.slice(i + 1).join('.');
          obj = node;
        }
      } else {
        node = node._data[keys[i]];
      }
    }

    if (!node._data || !node._data.hasOwnProperty(key)) return false;
    let valueOld = node._data[key];
    if (!(valueOld instanceof Observer)) valueOld = obj.json(valueOld);

    if (node._data[key] && node._data[key]._data) {
      for (i = node._data[key]._keys.length - 1; i >= 0; i--) {
        obj.unset(path + '.' + node._data[key]._keys[i], true);
      }
    }

    node._keys.splice(node._keys.indexOf(key), 1);

    delete node._data[key];
    let state;
    if (silent) state = obj.silence();
    obj.emit(path + ':unset', valueOld, remote);
    obj.emit('*:unset', path, valueOld, remote);
    if (silent) obj.silenceRestore(state);
    return true;
  }

  remove(path, ind, silent, remote) {
    const keys = Observer._splitPath(path);

    const key = keys[keys.length - 1];
    let node = this;
    let obj = this;

    for (let i = 0; i < keys.length - 1; i++) {
      if (node instanceof Array) {
        node = node[parseInt(keys[i], 10)];

        if (node instanceof Observer) {
          path = keys.slice(i + 1).join('.');
          obj = node;
        }
      } else if (node._data && node._data.hasOwnProperty(keys[i])) {
        node = node._data[keys[i]];
      } else {
        return;
      }
    }

    if (!node._data || !node._data.hasOwnProperty(key) || !(node._data[key] instanceof Array)) return;
    const arr = node._data[key];
    if (arr.length < ind) return;
    let value = arr[ind];

    if (value instanceof Observer) {
      value._parent = null;
    } else {
      value = obj.json(value);
    }

    arr.splice(ind, 1);
    let state;
    if (silent) state = obj.silence();
    obj.emit(path + ':remove', value, ind, remote);
    obj.emit('*:remove', path, value, ind, remote);
    if (silent) obj.silenceRestore(state);
    return true;
  }

  removeValue(path, value, silent, remote) {
    const keys = Observer._splitPath(path);

    const key = keys[keys.length - 1];
    let node = this;
    let obj = this;

    for (let i = 0; i < keys.length - 1; i++) {
      if (node instanceof Array) {
        node = node[parseInt(keys[i], 10)];

        if (node instanceof Observer) {
          path = keys.slice(i + 1).join('.');
          obj = node;
        }
      } else if (node._data && node._data.hasOwnProperty(keys[i])) {
        node = node._data[keys[i]];
      } else {
        return;
      }
    }

    if (!node._data || !node._data.hasOwnProperty(key) || !(node._data[key] instanceof Array)) return;
    const arr = node._data[key];
    const ind = arr.indexOf(value);

    if (ind === -1) {
      return;
    }

    if (arr.length < ind) return;
    value = arr[ind];

    if (value instanceof Observer) {
      value._parent = null;
    } else {
      value = obj.json(value);
    }

    arr.splice(ind, 1);
    let state;
    if (silent) state = obj.silence();
    obj.emit(path + ':remove', value, ind, remote);
    obj.emit('*:remove', path, value, ind, remote);
    if (silent) obj.silenceRestore(state);
    return true;
  }

  insert(path, value, ind, silent, remote) {
    const keys = Observer._splitPath(path);

    const key = keys[keys.length - 1];
    let node = this;
    let obj = this;

    for (let i = 0; i < keys.length - 1; i++) {
      if (node instanceof Array) {
        node = node[parseInt(keys[i], 10)];

        if (node instanceof Observer) {
          path = keys.slice(i + 1).join('.');
          obj = node;
        }
      } else if (node._data && node._data.hasOwnProperty(keys[i])) {
        node = node._data[keys[i]];
      } else {
        return;
      }
    }

    if (!node._data || !node._data.hasOwnProperty(key) || !(node._data[key] instanceof Array)) return;
    const arr = node._data[key];
    value = obj._doInsert(node, key, value, ind);

    if (ind === undefined) {
      ind = arr.length - 1;
    }

    let state;
    if (silent) state = obj.silence();
    obj.emit(path + ':insert', value, ind, remote);
    obj.emit('*:insert', path, value, ind, remote);
    if (silent) obj.silenceRestore(state);
    return true;
  }

  _doInsert(node, key, value, ind, allowDuplicates) {
    const arr = node._data[key];

    if (typeof value === 'object' && !(value instanceof Observer) && value !== null) {
      if (value instanceof Array) {
        value = value.slice(0);
      } else {
        value = new Observer(value);
      }
    }

    const path = node._path ? `${node._path}.${key}` : key;

    if (value !== null && !allowDuplicates && (!this._pathsWithDuplicates || !this._pathsWithDuplicates[path])) {
      if (arr.indexOf(value) !== -1) {
        return;
      }
    }

    if (ind === undefined) {
      arr.push(value);
    } else {
      arr.splice(ind, 0, value);
    }

    if (value instanceof Observer) {
      value._parent = this;
      value._parentPath = path;
      value._parentField = arr;
      value._parentKey = null;
    } else {
      value = this.json(value);
    }

    return value;
  }

  move(path, indOld, indNew, silent, remote) {
    const keys = Observer._splitPath(path);

    const key = keys[keys.length - 1];
    let node = this;
    let obj = this;

    for (let i = 0; i < keys.length - 1; i++) {
      if (node instanceof Array) {
        node = node[parseInt(keys[i], 10)];

        if (node instanceof Observer) {
          path = keys.slice(i + 1).join('.');
          obj = node;
        }
      } else if (node._data && node._data.hasOwnProperty(keys[i])) {
        node = node._data[keys[i]];
      } else {
        return;
      }
    }

    if (!node._data || !node._data.hasOwnProperty(key) || !(node._data[key] instanceof Array)) return;
    const arr = node._data[key];
    if (arr.length < indOld || arr.length < indNew || indOld === indNew) return;
    let value = arr[indOld];
    arr.splice(indOld, 1);
    if (indNew === -1) indNew = arr.length;
    arr.splice(indNew, 0, value);
    if (!(value instanceof Observer)) value = obj.json(value);
    let state;
    if (silent) state = obj.silence();
    obj.emit(path + ':move', value, indNew, indOld, remote);
    obj.emit('*:move', path, value, indNew, indOld, remote);
    if (silent) obj.silenceRestore(state);
    return true;
  }

  patch(data, removeMissingKeys) {
    if (typeof data !== 'object') return;

    for (const key in data) {
      if (typeof data[key] === 'object' && !this._data.hasOwnProperty(key)) {
        this._prepare(this, key, data[key]);
      } else if (this._data[key] !== data[key]) {
        this.set(key, data[key]);
      }
    }

    if (removeMissingKeys) {
      for (const key in this._data) {
        if (!data.hasOwnProperty(key)) {
          this.unset(key);
        }
      }
    }
  }

  json(target) {
    let key, n;
    let obj = {};
    const node = target === undefined ? this : target;
    let len, nlen;

    if (node instanceof Object && node._keys) {
      len = node._keys.length;

      for (let i = 0; i < len; i++) {
        key = node._keys[i];
        const value = node._data[key];
        const type = typeof value;

        if (type === 'object' && value instanceof Array) {
          obj[key] = value.slice(0);
          nlen = obj[key].length;

          for (n = 0; n < nlen; n++) {
            if (typeof obj[key][n] === 'object') obj[key][n] = this.json(obj[key][n]);
          }
        } else if (type === 'object' && value instanceof Object) {
          obj[key] = this.json(value);
        } else {
          obj[key] = value;
        }
      }
    } else {
      if (node === null) {
        return null;
      } else if (typeof node === 'object' && node instanceof Array) {
        obj = node.slice(0);
        len = obj.length;

        for (n = 0; n < len; n++) {
          obj[n] = this.json(obj[n]);
        }
      } else if (typeof node === 'object') {
        for (key in node) {
          if (node.hasOwnProperty(key)) obj[key] = node[key];
        }
      } else {
        obj = node;
      }
    }

    return obj;
  }

  forEach(fn, target, path = '') {
    const node = target || this;

    for (let i = 0; i < node._keys.length; i++) {
      const key = node._keys[i];
      const value = node._data[key];
      const type = this.schema && this.schema.has(path + key) && this.schema.get(path + key).type.name.toLowerCase() || typeof value;

      if (type === 'object' && value instanceof Array) {
        fn(path + key, 'array', value, key);
      } else if (type === 'object' && value instanceof Object) {
        fn(path + key, 'object', value, key);
        this.forEach(fn, value, path + key + '.');
      } else {
        fn(path + key, type, value, key);
      }
    }
  }

  latest() {
    return this._latestFn ? this._latestFn() : this;
  }

  destroy() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit('destroy');
    this.unbind();
  }

  get latestFn() {
    return this._latestFn;
  }

  set latestFn(value) {
    this._latestFn = value;
  }

}

Observer._splitPathsCache = {};

function ___$insertStyle(css) {
    if (!css || typeof window === 'undefined') {
        return;
    }
    const style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
}

var FLEX = 'pcui-flex';
var GRID = 'pcui-grid';
var HIDDEN = 'pcui-hidden';
var SCROLLABLE = 'pcui-scrollable';
var RESIZABLE = 'pcui-resizable';
var READONLY = 'pcui-readonly';
var DISABLED = 'pcui-disabled';
var COLLAPSIBLE = 'pcui-collapsible';
var COLLAPSED = 'pcui-collapsed';
var FOCUS = 'pcui-focus';
var MULTIPLE_VALUES = 'pcui-multiple-values';
var ERROR = 'pcui-error';
var FLASH = 'flash';
var NOT_FLEXIBLE = 'pcui-not-flexible';
var DEFAULT_MOUSEDOWN = 'pcui-default-mousedown';
var FONT_REGULAR = 'font-regular';
var FONT_BOLD = 'font-bold';

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular, .pcui-element {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n@-webkit-keyframes pcui-flash-animation {\n  from {\n    outline-color: #f60;\n  }\n  to {\n    outline-color: rgba(255, 102, 0, 0);\n  }\n}\n@keyframes pcui-flash-animation {\n  from {\n    outline-color: #f60;\n  }\n  to {\n    outline-color: rgba(255, 102, 0, 0);\n  }\n}\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-element {\n  border: 0 solid #232e30;\n}\n.pcui-element.flash {\n  outline: 1px solid #f60;\n  -webkit-animation: pcui-flash-animation 200ms ease-in-out forwards;\n  animation: pcui-flash-animation 200ms ease-in-out forwards;\n}\n.pcui-element:focus {\n  outline: none;\n}\n.pcui-element::-moz-focus-inner {\n  border: 0;\n}\n\n.pcui-element.pcui-hidden {\n  display: none;\n}");

const CLASS_ELEMENT = 'pcui-element';

// these are properties that are
// available as Element properties and
// can also be set through the Element constructor
const SIMPLE_CSS_PROPERTIES = [
    'flexDirection',
    'flexGrow',
    'flexBasis',
    'flexShrink',
    'flexWrap',
    'alignItems',
    'alignSelf',
    'justifyContent',
    'justifySelf'
];

// Stores Element types by name and default arguments
const ELEMENT_REGISTRY = {};

/**
 * @event
 * @name Element#enable
 * @description Fired when the Element gets enabled
 */

/**
 * @event
 * @name Element#disable
 * @description Fired when the Element gets disabled
 */

/**
 * @event
 * @name Element#hide
 * @description Fired when the Element gets hidden
 */

/**
 * @event
 * @name Element#hideToRoot
 * @description Fired when the Element or any of its parent get hidden
 */

/**
 * @event
 * @name Element#show
 * @description Fired when the Element stops being hidden
 */

/**
 * @event
 * @name Element#showToRoot
 * @description Fired when the Element and all of its parents become visible
 */

/**
 * @event
 * @name Element#readOnly
 * @param {boolean} readOnly - Whether the Element is now read only
 * @description Fired when the readOnly property of an Element changes
 */

/**
 * @event
 * @name Element#parent
 * @description Fired when the Element's parent gets set
 * @param {Element} parent - The new parent
 */

/**
 * @event
 * @name Element#click
 * @description Fired when the mouse is clicked on the Element but only if the Element is enabled.
 * @param {Event} evt - The native mouse event.
 */

/**
 * @event
 * @name Element#hover
 * @description Fired when the mouse starts hovering on the Element
 * @param {Event} evt - The native mouse event.
 */

/**
 * @event
 * @name Element#hoverend
 * @description Fired when the mouse stops hovering on the Element
 * @param {Event} evt - The native mouse event.
 */

/**
 * @event
 * @name Element#destroy
 * @description Fired after the element has been destroyed.
 * @param {HTMLElement} dom - The DOM element
 * @param {Element} element - The element
 */

/**
 * @event
 * @name Element#hoverend
 * @description Fired when the mouse stops hovering on the Element
 * @param {Event} evt - The native mouse event.
 */

/**
 * @name Element
 * @class
 * @classdesc The base class for all UI elements.
 * @augments Events
 * @property {boolean} enabled=true Gets / sets whether the Element or its parent chain is enabled or not. Defaults to true.
 * @property {HTMLElement} dom Gets the root DOM node for this Element.
 * @property {Element} parent Gets the parent Element.
 * @property {boolean} hidden Gets / sets whether the Element is hidden.
 * @property {boolean} hiddenToRoot Gets whether the Element is hidden all the way up to the root. If the Element itself or any of its parents are hidden then this is true.
 * @property {boolean} readOnly Gets / sets whether the Element is read only.
 * @property {boolean} ignoreParent Gets / sets whether the Element will ignore parent events & variable states.
 * @property {number} [width=null] Gets / sets the width of the Element in pixels. Can also be an empty string to remove it.
 * @property {number} [height=null] Gets / sets the height of the Element in pixels. Can also be an empty string to remove it.
 * @property {number} tabIndex Gets / sets the tabIndex of the Element.
 * @property {boolean} error Gets / sets whether the Element is in an error state.
 * @property {BindingBase} binding Gets / sets the Binding object for the element.
 * @property {CSSStyleDeclaration} style Shortcut to pcui.Element.dom.style.
 * @property {DOMTokenList} class Shortcut to pcui.Element.dom.classList.
 */
class Element$1 extends Events {
    /**
     * Creates a new Element.
     *
     * @param {HTMLElement} dom - The DOM element that this pcui.Element wraps.
     * @param {object} args - The arguments. All settable properties can also be set through the constructor.
     * @param {string} [args.id] - The desired id for the Element HTML node.
     * @param {string|string[]} [args.class] - The CSS class or classes we want to add to the element.
     * @param {boolean} [args.isRoot] - If true then this is the root element. Set this to true for the topmost Element in your page.
     */
    constructor(dom, args) {
        super();

        if (!args) args = {};

        this._destroyed = false;
        this._parent = null;

        this._domEventClick = this._onClick.bind(this);
        this._domEventMouseOver = this._onMouseOver.bind(this);
        this._domEventMouseOut = this._onMouseOut.bind(this);
        this._eventsParent = [];

        this._dom = dom || args.dom || document.createElement('div');

        if (args.id !== undefined) {
            this._dom.id = args.id;
        }

        // add ui reference
        this._dom.ui = this;

        // add event listeners
        this._dom.addEventListener('click', this._domEventClick);
        this._dom.addEventListener('mouseover', this._domEventMouseOver);
        this._dom.addEventListener('mouseout', this._domEventMouseOut);

        // add element class
        this._dom.classList.add(CLASS_ELEMENT);

        // add font regular class
        this._dom.classList.add(FONT_REGULAR);

        // add user classes
        if (args.class) {
            if (Array.isArray(args.class)) {
                for (let i = 0; i < args.class.length; i++) {
                    this._dom.classList.add(args.class[i]);
                }
            } else {
                this._dom.classList.add(args.class);
            }
        }

        this.enabled = args.enabled !== undefined ? args.enabled : true;
        this._hiddenParents = !args.isRoot;
        this.hidden = args.hidden || false;
        this.readOnly = args.readOnly || false;
        this.ignoreParent = args.ignoreParent || false;

        if (args.width !== undefined) {
            this.width = args.width;
        }
        if (args.height !== undefined) {
            this.height = args.height;
        }
        if (args.tabIndex !== undefined) {
            this.tabIndex = args.tabIndex;
        }

        // copy CSS properties from args
        for (const key in args) {
            if (args[key] === undefined) continue;
            if (SIMPLE_CSS_PROPERTIES.indexOf(key) !== -1) {
                this[key] = args[key];
            }
        }

        // set the binding object
        if (args.binding) {
            this.binding = args.binding;
        }

        this._flashTimeout = null;
    }

    /**
     * @name Element#link
     * @description Links the specified observers and paths to the Element's data binding.
     * @param {Observer|Observer[]} observers - An array of observers or a single observer.
     * @param {string|string[]} paths - A path for the observer(s) or an array of paths that maps to each separate observer.
     */
    link(observers, paths) {
        if (this._binding) {
            this._binding.link(observers, paths);
        }
    }


    /**
     * @name Element#unlink
     * @description Unlinks the Element from its observers
     */
    unlink() {
        if (this._binding) {
            this._binding.unlink();
        }
    }

    /**
     * @name Element#flash
     * @description Triggers a flash animation on the Element.
     */
    flash() {
        if (this._flashTimeout) return;

        this.classAdd(FLASH);
        this._flashTimeout = setTimeout(function () {
            this._flashTimeout = null;
            this.classRemove(FLASH);
        }.bind(this), 200);
    }

    _onClick(evt) {
        if (this.enabled) {
            this.emit('click', evt);
        }
    }

    _onMouseOver(evt) {
        this.emit('hover', evt);
    }

    _onMouseOut(evt) {
        this.emit('hoverend', evt);
    }

    _onHiddenToRootChange(hiddenToRoot) {
        if (hiddenToRoot) {
            this.emit('hideToRoot');
        } else {
            this.emit('showToRoot');
        }
    }

    _onEnabledChange(enabled) {
        if (enabled) {
            this.classRemove(DISABLED);
        } else {
            this.classAdd(DISABLED);
        }

        this.emit(enabled ? 'enable' : 'disable');
    }

    _onParentDestroy() {
        this.destroy();
    }

    _onParentDisable() {
        if (this._ignoreParent) return;
        if (this._enabled) {
            this._onEnabledChange(false);
        }
    }

    _onParentEnable() {
        if (this._ignoreParent) return;
        if (this._enabled) {
            this._onEnabledChange(true);
        }
    }

    _onParentShowToRoot() {
        const oldHiddenToRoot = this.hiddenToRoot;
        this._hiddenParents = false;
        if (oldHiddenToRoot !== this.hiddenToRoot) {
            this._onHiddenToRootChange(this.hiddenToRoot);
        }
    }

    _onParentHideToRoot() {
        const oldHiddenToRoot = this.hiddenToRoot;
        this._hiddenParents = true;
        if (oldHiddenToRoot !== this.hiddenToRoot) {
            this._onHiddenToRootChange(this.hiddenToRoot);
        }
    }

    _onReadOnlyChange(readOnly) {
        if (readOnly) {
            this.classAdd(READONLY);
        } else {
            this.classRemove(READONLY);
        }

        this.emit('readOnly', readOnly);
    }

    _onParentReadOnlyChange(readOnly) {
        if (this._ignoreParent) return;
        if (readOnly) {
            if (!this._readOnly) {
                this._onReadOnlyChange(true);
            }
        } else {
            if (!this._readOnly) {
                this._onReadOnlyChange(false);
            }
        }

    }

    /**
     * @name Element#classAdd
     * @description Adds the specified class to the DOM element but checks if the classList contains it first.
     * @param {string} cls - The class to add
     */
    classAdd(cls) {
        var classList = this._dom.classList;
        if (!classList.contains(cls)) {
            classList.add(cls);
        }
    }

    /**
     * @name Element#classRemove
     * @description Removes the specified class from the DOM element but checks if the classList contains it first.
     * @param {string} cls - The class to remove
     */
    classRemove(cls) {
        var classList = this._dom.classList;
        if (classList.contains(cls)) {
            classList.remove(cls);
        }
    }

    /**
     * @name Element#destroy
     * @description Destroys the Element and its events.
     */
    destroy() {
        if (this._destroyed) return;

        this._destroyed = true;

        if (this.binding) {
            this.binding = null;
        } else {
            this.unlink();
        }

        if (this.parent) {
            const parent = this.parent;

            for (let i = 0; i < this._eventsParent.length; i++) {
                this._eventsParent[i].unbind();
            }
            this._eventsParent.length = 0;


            // remove element from parent
            // check if parent has been destroyed already
            // because we do not want to be emitting events
            // on a destroyed parent after it's been destroyed
            // as it is easy to lead to null exceptions
            if (parent.remove && !parent._destroyed) {
                parent.remove(this);
            }

            // set parent to null and remove from
            // parent dom just in case parent.remove above
            // didn't work because of an override or other condition
            this._parent = null;

            // Do not manually call removeChild for elements whose parent has already been destroyed.
            // For example when we destroy a TreeViewItem that has many child nodes, that will trigger every child Element to call dom.parentElement.removeChild(dom).
            // But we don't need to remove all these DOM elements from their parents since the root DOM element is destroyed anyway.
            // This has a big impact on destroy speed in certain cases.
            if (!parent._destroyed && this._dom && this._dom.parentElement) {
                this._dom.parentElement.removeChild(this._dom);
            }

        }

        const dom = this._dom;
        if (dom) {
            // remove event listeners
            dom.removeEventListener('click', this._domEventClick);
            dom.removeEventListener('mouseover', this._domEventMouseOver);
            dom.removeEventListener('mouseout', this._domEventMouseOut);

            // remove ui reference
            delete dom.ui;

            this._dom = null;
        }

        this._domEventClick = null;
        this._domEventMouseOver = null;
        this._domEventMouseOut = null;

        if (this._flashTimeout) {
            clearTimeout(this._flashTimeout);
        }

        this.emit('destroy', dom, this);

        this.unbind();
    }

    /**
     * @static
     * @param {string} type - The type we want to reference this Element by
     * @param {object} cls - The actual class of the Element
     * @param {object} [defaultArguments] - Default arguments when creating this type
     */
    static register(type, cls, defaultArguments) {
        ELEMENT_REGISTRY[type] = { cls, defaultArguments };
    }

    /**
     * @static
     * @param {string} type - The type we want to unregister
     */
    static unregister(type) {
        delete ELEMENT_REGISTRY[type];
    }

    /**
     * @static
     * @param {string} type - The type of the Element (registered by pcui.Element#register)
     * @param {object} args - Arguments for the Element
     * @returns {Element} A new pcui.Element of the desired type
     */
    static create(type, args) {
        const entry = ELEMENT_REGISTRY[type];
        if (!entry) {
            console.error('Invalid type passed to pcui.Element#create', type);
            return;
        }

        const cls = entry.cls;
        const clsArgs = {};

        if (entry.defaultArguments) {
            Object.assign(clsArgs, entry.defaultArguments);
        }
        if (args) {
            Object.assign(clsArgs, args);
        }

        return new cls(clsArgs);
    }

    set enabled(value) {
        if (this._enabled === value) return;

        // remember if enabled in hierarchy
        const enabled = this.enabled;

        this._enabled = value;

        // only fire event if hierarchy state changed
        if (enabled !== value) {
            this._onEnabledChange(value);
        }
    }

    get enabled() {
        if (this._ignoreParent) return this._enabled;
        return this._enabled && (!this._parent || this._parent.enabled);
    }

    set ignoreParent(value) {
        this._ignoreParent = value;
        this._onEnabledChange(this.enabled);
        this._onReadOnlyChange(this.readOnly);
    }

    get ignoreParent() {
        return this._ignoreParent;
    }

    get dom() {
        return this._dom;
    }

    set parent(value) {
        if (value === this._parent) return;

        const oldEnabled = this.enabled;
        const oldReadonly = this.readOnly;
        const oldHiddenToRoot = this.hiddenToRoot;

        if (this._parent) {
            for (let i = 0; i < this._eventsParent.length; i++) {
                this._eventsParent[i].unbind();
            }
            this._eventsParent.length = 0;
        }

        this._parent = value;

        if (this._parent) {
            this._eventsParent.push(this._parent.once('destroy', this._onParentDestroy.bind(this)));
            this._eventsParent.push(this._parent.on('disable', this._onParentDisable.bind(this)));
            this._eventsParent.push(this._parent.on('enable', this._onParentEnable.bind(this)));
            this._eventsParent.push(this._parent.on('readOnly', this._onParentReadOnlyChange.bind(this)));
            this._eventsParent.push(this._parent.on('showToRoot', this._onParentShowToRoot.bind(this)));
            this._eventsParent.push(this._parent.on('hideToRoot', this._onParentHideToRoot.bind(this)));

            this._hiddenParents = this._parent.hiddenToRoot;
        } else {
            this._hiddenParents = true;
        }

        this.emit('parent', this._parent);

        const newEnabled = this.enabled;
        if (newEnabled !== oldEnabled) {
            this._onEnabledChange(newEnabled);
        }

        const newReadonly = this.readOnly;
        if (newReadonly !== oldReadonly) {
            this._onReadOnlyChange(newReadonly);
        }

        const hiddenToRoot = this.hiddenToRoot;
        if (hiddenToRoot !== oldHiddenToRoot) {
            this._onHiddenToRootChange(hiddenToRoot);
        }
    }

    get parent() {
        return this._parent;
    }

    set hidden(value) {
        if (value === this._hidden) return;

        const oldHiddenToRoot = this.hiddenToRoot;

        this._hidden = value;

        if (value) {
            this.classAdd(HIDDEN);
        } else {
            this.classRemove(HIDDEN);
        }

        this.emit(value ? 'hide' : 'show');

        if (this.hiddenToRoot !== oldHiddenToRoot) {
            this._onHiddenToRootChange(this.hiddenToRoot);
        }
    }

    get hidden() {
        return this._hidden;
    }

    get hiddenToRoot() {
        return this._hidden || this._hiddenParents;
    }

    set readOnly(value) {
        if (this._readOnly === value) return;
        this._readOnly = value;

        this._onReadOnlyChange(value);
    }

    get readOnly() {
        if (this._ignoreParent) return this._readOnly;
        return this._readOnly || !!(this._parent && this._parent.readOnly);
    }

    set error(value) {
        if (this._hasError === value) return;
        this._hasError = value;
        if (value) {
            this.classAdd(ERROR);
        } else {
            this.classRemove(ERROR);
        }
    }

    get error() {
        return this._hasError;
    }

    get style() {
        return this._dom.style;
    }

    get class() {
        return this._dom.classList;
    }

    set width(value) {
        if (typeof value === 'number') {
            value += 'px';
        }
        this.style.width = value;
    }

    get width() {
        return this._dom.clientWidth;
    }

    set height(value) {
        if (typeof value === 'number') {
            value += 'px';
        }
        this.style.height = value;
    }

    get height() {
        return this._dom.clientHeight;
    }

    set tabIndex(value) {
        this._dom.tabIndex = value;
    }

    get tabIndex() {
        return this._dom.tabIndex;
    }

    set binding(value) {
        if (this._binding === value) return;

        let prevObservers;
        let prevPaths;

        if (this._binding) {
            prevObservers = this._binding.observers;
            prevPaths = this._binding.paths;

            this.unlink();
            this._binding.element = null;
            this._binding = null;
        }

        this._binding = value;

        if (this._binding) {
            this._binding.element = this;
            if (prevObservers && prevPaths) {
                this.link(prevObservers, prevPaths);
            }
        }
    }

    get binding() {
        return this._binding;
    }

    get destroyed() {
        return this._destroyed;
    }

    /*  Backwards Compatibility */
    // we should remove those after we migrate
    set disabled(value) {
        this.enabled = !value;
    }

    get disabled() {
        return !this.enabled;
    }

    set element(value) {
        this.dom = value;
    }

    get element() {
        return this.dom;
    }

    set innerElement(value) {
        this.domContent = value;
    }

    get innerElement() {
        return this.domContent;
    }
}

// utility function to expose a CSS property
// via an Element.prototype property
function exposeCssProperty(name) {
    Object.defineProperty(Element$1.prototype, name, {
        get: function () {
            return this.style[name];
        },
        set: function (value) {
            this.style[name] = value;
        }
    });
}

// expose rest of CSS properties
SIMPLE_CSS_PROPERTIES.forEach(exposeCssProperty);

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont, .pcui-text-input.pcui-multiple-values:before, .pcui-text-input > input {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-text-input {\n  display: inline-block;\n  border: 1px solid #293538;\n  border-radius: 2px;\n  box-sizing: border-box;\n  margin: 6px;\n  min-height: 24px;\n  height: 24px;\n  background-color: #2c393c;\n  vertical-align: top;\n  transition: color 100ms, background-color 100ms, box-shadow 100ms;\n  position: relative;\n  color: #b1b8ba;\n}\n.pcui-text-input > input {\n  height: 100%;\n  width: calc(100% - 16px);\n  padding: 0 6px;\n  line-height: 1;\n  color: inherit;\n  background: transparent;\n  border: none;\n  outline: none;\n  box-shadow: none;\n}\n.pcui-text-input:before {\n  color: inherit;\n}\n\n.pcui-text-input.pcui-multiple-values:before {\n  position: absolute;\n  padding: 0 8px;\n  content: \"...\";\n  white-space: nowrap;\n  top: 5px;\n  font-size: 12px;\n}\n\n.pcui-text-input:not(.pcui-disabled):not(.pcui-readonly):hover {\n  background-color: #293538;\n  color: #ffffff;\n}\n.pcui-text-input:not(.pcui-disabled):not(.pcui-readonly):not(.pcui-error):hover {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-text-input:not(.pcui-disabled):not(.pcui-readonly).pcui-focus {\n  background-color: #20292b;\n  box-shadow: 0 0 0 1px rgba(255, 102, 0, 0.3);\n}\n\n.pcui-text-input.pcui-focus:after, .pcui-text-input.pcui-focus:before, .pcui-text-input:hover:after, .pcui-text-input:hover:before {\n  display: none;\n}\n\n.pcui-text-input.pcui-readonly {\n  background-color: rgba(44, 57, 60, 0.7);\n  border-color: transparent;\n}\n\n.pcui-text-input.pcui-disabled {\n  color: #5b7073;\n}\n\n.pcui-text-input.pcui-error {\n  color: #b1b8ba;\n  box-shadow: 0 0 0 1px #d34141;\n}\n\n.pcui-text-input[placeholder] {\n  position: relative;\n}\n.pcui-text-input[placeholder]:after {\n  content: attr(placeholder);\n  background-color: #2c393c;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 0 8px;\n  line-height: 22px;\n  font-size: 10px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #829193;\n  pointer-events: none;\n}");

const CLASS_TEXT_INPUT = 'pcui-text-input';

/**
 * @name TextInput
 * @class
 * @classdesc The TextInput is an input element of type text.
 * @augments Element
 * @mixes IBindable
 * @mixes IFocusable
 * @property {string} placeholder Gets / sets the placeholder label that appears on the right of the input.
 * @property {HTMLElement} input Gets the HTML input element.
 * @property {boolean} renderChanges If true then the TextInput will flash when its text changes.
 * @property {boolean} blurOnEnter=true Gets / sets whether pressing Enter will blur (unfocus) the field. Defaults to true.
 * @property {boolean} blurOnEscape=true Gets / sets whether pressing Escape will blur (unfocus) the field. Defaults to true.
 * @property {boolean} keyChange Gets / sets whether any key up event will cause a change event to be fired.} args
 * @property {Function} onValidate A function that validates the value that is entered into the input and returns true if it is valid or false otherwise.
 * If false then the input will be set in an error state and the value will not propagate to the binding.
 */
class TextInput extends Element$1 {
    /**
     * Creates a new TextInput.
     *
     * @param {object} args - The arguments. Extends the pcui.Element constructor arguments. All settable properties can also be set through the constructor.
     */
    constructor(args) {
        if (!args) args = {};
        super(args.dom ? args.dom : document.createElement('div'), args);

        this.class.add(CLASS_TEXT_INPUT);

        let input = args.input;
        if (!input) {
            input = document.createElement('input');
            input.type = 'text';
        }

        input.ui = this;
        input.tabIndex = 0;
        input.autocomplete = "off";
        this._domInput = input;

        this._domEvtChange = this._onInputChange.bind(this);
        this._domEvtFocus = this._onInputFocus.bind(this);
        this._domEvtBlur = this._onInputBlur.bind(this);
        this._domEvtKeyDown = this._onInputKeyDown.bind(this);
        this._domEvtKeyUp = this._onInputKeyUp.bind(this);
        this._domEvtCtxMenu = this._onInputCtxMenu.bind(this);

        this._domInput.addEventListener('change', this._domEvtChange);
        this._domInput.addEventListener('focus', this._domEvtFocus);
        this._domInput.addEventListener('blur', this._domEvtBlur);
        this._domInput.addEventListener('keydown', this._domEvtKeyDown);
        this._domInput.addEventListener('contextmenu', this._domEvtCtxMenu, false);
        this.dom.appendChild(this._domInput);

        this._suspendInputChangeEvt = false;

        if (args.value !== undefined) {
            this.value = args.value;
        }
        this.placeholder = args.placeholder || null;
        this.renderChanges = args.renderChanges || false;
        this.blurOnEnter = (args.blurOnEnter !== undefined ? args.blurOnEnter : true);
        this.blurOnEscape = (args.blurOnEscape !== undefined ? args.blurOnEscape : true);
        this.keyChange = args.keyChange || false;
        this._prevValue = null;

        if (args.onValidate) {
            this.onValidate = args.onValidate;
        }

        this.on('change', () => {
            if (this.renderChanges) {
                this.flash();
            }
        });

        this.on('disable', this._updateInputReadOnly.bind(this));
        this.on('enable', this._updateInputReadOnly.bind(this));
        this.on('readOnly', this._updateInputReadOnly.bind(this));
        this._updateInputReadOnly();
    }

    _onInputChange(evt) {
        if (this._suspendInputChangeEvt) return;

        if (this._onValidate) {
            const error = !this._onValidate(this.value);
            this.error = error;
            if (error) {
                return;
            }
        } else {
            this.error = false;
        }

        this.emit('change', this.value);

        if (this._binding) {
            this._binding.setValue(this.value);
        }
    }

    _onInputFocus(evt) {
        this.class.add(FOCUS);
        this.emit('focus', evt);
        this._prevValue = this.value;
    }

    _onInputBlur(evt) {
        this.class.remove(FOCUS);
        this.emit('blur', evt);
    }

    _onInputKeyDown(evt) {
        if (evt.keyCode === 13 && this.blurOnEnter) {
            // do not fire input change event on blur
            // if keyChange is true (because a change event)
            // will have already been fired before for the current
            // value
            this._suspendInputChangeEvt = this.keyChange;
            this._domInput.blur();
            this._suspendInputChangeEvt = false;
        } else if (evt.keyCode === 27) {
            this._suspendInputChangeEvt = true;
            const prev = this._domInput.value;
            this._domInput.value = this._prevValue;
            this._suspendInputChangeEvt = false;

            // manually fire change event
            if (this.keyChange && prev !== this._prevValue) {
                this._onInputChange(evt);
            }

            if (this.blurOnEscape) {
                this._domInput.blur();
            }
        }

        this.emit('keydown', evt);
    }

    _onInputKeyUp(evt) {
        if (evt.keyCode !== 27) {
            this._onInputChange(evt);
        }

        this.emit('keyup', evt);
    }

    _onInputCtxMenu(evt) {
        this._domInput.select();
    }

    _updateInputReadOnly() {
        const readOnly = !this.enabled || this.readOnly;
        if (readOnly) {
            this._domInput.setAttribute('readonly', true);
        } else {
            this._domInput.removeAttribute('readonly');
        }
    }

    _updateValue(value) {
        this.class.remove(MULTIPLE_VALUES);

        if (value && typeof (value) === 'object') {
            if (Array.isArray(value)) {
                let isObject = false;
                for (let i = 0; i < value.length; i++) {
                    if (value[i] && typeof value[i] === 'object') {
                        isObject = true;
                        break;
                    }
                }

                value = isObject ? '[Not available]' : value.map((val) => {
                    return val === null ? 'null' : val;
                }).join(',');
            } else {
                value = '[Not available]';
            }
        }

        if (value === this.value) return false;

        this._suspendInputChangeEvt = true;
        this._domInput.value = (value === null || value === undefined) ? '' : value;
        this._suspendInputChangeEvt = false;

        this.emit('change', value);

        return true;
    }

    /**
     * @name TextInput#focus
     * @description Focuses the Element.
     * @param {boolean} select - If true then this will also select the text after focusing.
     */
    focus(select) {
        this._domInput.focus();
        if (select) {
            this._domInput.select();
        }
    }

    /**
     * @name TextInput#blur
     * @description Blurs (unfocuses) the Element.
     */
    blur() {
        this._domInput.blur();
    }

    destroy() {
        if (this._destroyed) return;
        this._domInput.removeEventListener('change', this._domEvtChange);
        this._domInput.removeEventListener('focus', this._domEvtFocus);
        this._domInput.removeEventListener('blur', this._domEvtBlur);
        this._domInput.removeEventListener('keydown', this._domEvtKeyDown);
        this._domInput.removeEventListener('keyup', this._domEvtKeyUp);
        this._domInput.removeEventListener('contextmenu', this._domEvtCtxMenu);
        this._domInput = null;

        super.destroy();
    }

    set value(value) {
        const changed = this._updateValue(value);

        if (changed) {
            // reset error
            this.error = false;
        }

        if (changed && this._binding) {
            this._binding.setValue(value);
        }
    }

    get value() {
        return this._domInput.value;
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        let different = false;
        const value = values[0];
        for (let i = 1; i < values.length; i++) {
            if (values[i] !== value) {
                different = true;
                break;
            }
        }

        if (different) {
            this._updateValue(null);
            this.class.add(MULTIPLE_VALUES);
        } else {
            this._updateValue(values[0]);
        }
    }

    set placeholder(value) {
        if (value) {
            this.dom.setAttribute('placeholder', value);
        } else {
            this.dom.removeAttribute('placeholder');
        }
    }

    get placeholder() {
        return this.dom.getAttribute('placeholder');
    }

    set keyChange(value) {
        if (this._keyChange === value) return;

        this._keyChange = value;
        if (value) {
            this._domInput.addEventListener('keyup', this._domEvtKeyUp);
        } else {
            this._domInput.removeEventListener('keyup', this._domEvtKeyUp);
        }
    }

    get keyChange() {
        return this._keyChange;
    }

    get input() {
        return this._domInput;
    }

    set onValidate(value) {
        this._onValidate = value;
    }

    get onValidate() {
        return this._onValidate;
    }
}

Element$1.register('string', TextInput, { renderChanges: true });

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont, .pcui-text-area-input > textarea {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-text-area-input {\n  min-height: 48px;\n  height: auto;\n}\n.pcui-text-area-input > textarea {\n  resize: none;\n  height: 100%;\n  width: calc(100% - 16px);\n  padding: 0 8px;\n  line-height: 22px;\n  color: inherit;\n  background: transparent;\n  border: none;\n  outline: none;\n  box-shadow: none;\n  min-height: 44px;\n  min-width: 172px;\n}\n\n.pcui-text-area-input.pcui-text-area-input-resizable-none > textarea {\n  resize: none;\n}\n\n.pcui-text-area-input.pcui-text-area-input-resizable-both > textarea {\n  resize: both;\n}\n\n.pcui-text-area-input.pcui-text-area-input-resizable-horizontal > textarea {\n  resize: horizontal;\n}\n\n.pcui-text-area-input.pcui-text-area-input-resizable-vertical > textarea {\n  resize: vertical;\n}");

const CLASS_TEXT_AREA_INPUT = 'pcui-text-area-input';
const CLASS_TEXT_AREA_INPUT_RESIZABLE = CLASS_TEXT_AREA_INPUT + '-resizable';
const CLASS_TEXT_AREA_INPUT_RESIZABLE_NONE = CLASS_TEXT_AREA_INPUT_RESIZABLE + '-none';
const CLASS_TEXT_AREA_INPUT_RESIZABLE_BOTH = CLASS_TEXT_AREA_INPUT_RESIZABLE + '-both';
const CLASS_TEXT_AREA_INPUT_RESIZABLE_HORIZONTAL = CLASS_TEXT_AREA_INPUT_RESIZABLE + '-horizontal';
const CLASS_TEXT_AREA_INPUT_RESIZABLE_VERTICAL = CLASS_TEXT_AREA_INPUT_RESIZABLE + '-vertical';

/**
 * @name TextAreaInput
 * @class
 * @classdesc The TextAreaInput wraps a textarea element. It has the same interface as pcui.TextInput.
 * @augments TextInput
 * @property {string} [resizable=none] Sets whether the size of the text area input can be modified by the user. Can be one of 'none', 'both', 'horizontal' or 'vertical'.
 */
class TextAreaInput extends TextInput {
    /**
     * Creates a new TextAreaInput.
     *
     * @param {object} args - The arguments. Extends the pcui.TextInput constructor arguments.
     */
    constructor(args) {
        args = Object.assign({
            input: document.createElement('textarea')
        }, args);

        super(args);

        this.class.add(CLASS_TEXT_AREA_INPUT);
        switch (args.resizable) {
            case 'both':
                this.class.add(CLASS_TEXT_AREA_INPUT_RESIZABLE_BOTH);
                break;
            case 'horizontal':
                this.class.add(CLASS_TEXT_AREA_INPUT_RESIZABLE_HORIZONTAL);
                break;
            case 'vertical':
                this.class.add(CLASS_TEXT_AREA_INPUT_RESIZABLE_VERTICAL);
                break;
            case 'none':
            default:
                this.class.add(CLASS_TEXT_AREA_INPUT_RESIZABLE_NONE);
                break;
        }
    }

    _onInputKeyDown(evt) {
        if ((evt.keyCode === 27 && this.blurOnEscape) || (evt.keyCode === 13 && this.blurOnEnter && !evt.shiftKey)) {
            this._domInput.blur();
        }

        this.emit('keydown', evt);
    }
}

Element$1.register('text', TextAreaInput, { renderChanges: true });

___$insertStyle(".pcui-numeric-input-slider-control {\n  display: none;\n  position: absolute;\n  width: 10px;\n  height: 10px;\n  right: 3px;\n  border: 2px solid #20292b;\n  background-color: #293538;\n  border-radius: 100px;\n  z-index: 9999;\n  transform: translateY(-50%);\n  top: 50%;\n  cursor: ew-resize;\n}\n\n.pcui-numeric-input-slider-control:after {\n  content: \"\\e408\";\n  font-size: 15px;\n  font-family: \"pc-icon\";\n  position: absolute;\n  left: -5px;\n  top: -5px;\n  transform: rotateZ(90deg);\n}\n\n.pcui-numeric-input-slider-control:hover {\n  opacity: 50%;\n  color: #b1b8ba;\n}\n\n.pcui-numeric-input-slider-control-active {\n  opacity: 100% !important;\n  color: #7f7 !important;\n}\n\n.pcui-numeric-input-slider-control-hidden {\n  display: none !important;\n}\n\n.pcui-numeric-input:hover .pcui-numeric-input-slider-control {\n  display: block;\n}\n\n.pcui-numeric-input.pcui-disabled:hover .pcui-numeric-input-slider-control {\n  display: none;\n}\n\n.pcui-numeric-input.pcui-disabled .pcui-numeric-input-slider-control, .pcui-numeric-input.pcui-readonly .pcui-numeric-input-slider-control {\n  display: none;\n}");

const CLASS_NUMERIC_INPUT = 'pcui-numeric-input';
const CLASS_NUMERIC_INPUT_SLIDER_CONTROL = CLASS_NUMERIC_INPUT + '-slider-control';
const CLASS_NUMERIC_INPUT_SLIDER_CONTROL_ACTIVE = CLASS_NUMERIC_INPUT_SLIDER_CONTROL + '-active';
const CLASS_NUMERIC_INPUT_SLIDER_CONTROL_HIDDEN = CLASS_NUMERIC_INPUT_SLIDER_CONTROL + '-hidden';

const REGEX_COMMA = /,/g;

/**
 * @name NumericInput
 * @class
 * @classdesc The NumericInput represents an input element that holds numbers.
 * @property {number} [min=0] Gets / sets the minimum value this field can take.
 * @property {number} [max=1] Gets / sets the maximum value this field can take.
 * @property {number} [precision=7] Gets / sets the maximum number of decimals a value can take.
 * @property {number} [step=0.01] Gets / sets the amount that the value will be increased or decreased when using the arrow keys. Holding Shift will use 10x the step.
 * @property {boolean} [hideSlider=true] Hide the input mouse drag slider.
 * @augments TextInput
 */
class NumericInput extends TextInput {
    /**
     * Creates a new NumericInput.
     *
     * @param {object} args - The arguments. Extends the pcui.TextInput constructor arguments.
     * @param {boolean} [args.allowNull] - Gets / sets whether the value can be null. If not then it will be 0 instead of null.
     */
    constructor(args) {
        // make copy of args
        args = Object.assign({}, args);
        const value = args.value;
        // delete value because we want to set it after
        // the other arguments
        delete args.value;
        const renderChanges = args.renderChanges || false;
        delete args.renderChanges;

        super(args);

        this.class.add(CLASS_NUMERIC_INPUT);

        this._min = args.min !== undefined ? args.min : null;
        this._max = args.max !== undefined ? args.max : null;
        this._allowNull = args.allowNull || false;
        this._precision = Number.isFinite(args.precision) ? args.precision : 7;

        if (Number.isFinite(args.step)) {
            this._step = args.step;
        } else if (Number.isFinite(args.precision)) {
            this._step = 1 / Math.pow(10, args.precision);
        } else {
            this._step = 1;
        }

        this._oldValue = undefined;
        this.value = value;

        this._historyCombine = false;
        this._historyPostfix = null;
        this._sliderPrevValue = 0;

        this.renderChanges = renderChanges;

        this._domEvtPointerLock = null;
        this._domEvtSliderMouseDown = null;
        this._domEvtSliderMouseUp = null;
        this._domEvtMouseWheel = null;


        if (!args.hideSlider) {
            this._sliderControl = new Element$1();
            this._sliderControl.class.add(CLASS_NUMERIC_INPUT_SLIDER_CONTROL);
            this.dom.append(this._sliderControl.dom);

            let sliderUsed = false;
            this._domEvtSliderMouseDown = () => {                

                this._sliderControl.dom.requestPointerLock();
                this._sliderMovement = 0.0;
                this._sliderPrevValue = this.value;
                sliderUsed = true;
                if (this.binding) {
                    this._historyCombine = this.binding.historyCombine;
                    this._historyPostfix = this.binding.historyPostfix;

                    this.binding.historyCombine = true;
                    this.binding.historyPostfix = `(${Date.now()})`;
                }
            };

            this._domEvtSliderMouseUp = () => {
                document.exitPointerLock();
                if (!sliderUsed) return;
                sliderUsed = false;
                this.value = this._sliderPrevValue + this._sliderMovement;

                if (this.binding) {
                    this.binding.historyCombine = this._historyCombine;
                    this.binding.historyPostfix = this._historyPostfix;

                    this._historyCombine = false;
                    this._historyPostfix = null;
                }
            };

            this._domEvtPointerLock = this._pointerLockChangeAlert.bind(this);

            this._domEvtMouseWheel = this._updatePosition.bind(this);

            

            this._sliderControl.dom.addEventListener('mousedown', this._domEvtSliderMouseDown, false);
            this._sliderControl.dom.addEventListener('mouseup', this._domEvtSliderMouseUp, false);

            document.addEventListener('pointerlockchange', this._domEvtPointerLock, false);
            document.addEventListener('mozpointerlockchange', this._domEvtPointerLock, false);
        }
    }

    _updatePosition(evt) {
        let movement = 0;
        if (evt.constructor === WheelEvent) {
            movement = evt.deltaY;
        } else if (evt.constructor === MouseEvent) {
            movement = evt.movementX;
        }
        // move one step every 100 pixels
        this._sliderMovement += movement / 100 * this._step;
        this.value = this._sliderPrevValue + this._sliderMovement;
    }

    _onInputChange(evt) {
        // get the content of the input and pass it
        // through our value setter
        this.value = this._domInput.value;
    }

    _onInputKeyDown(evt) {
        if (!this.enabled || this.readOnly) return super._onInputKeyDown(evt);

        // increase / decrease value with arrow keys
        if (evt.keyCode === 38 || evt.keyCode === 40) {
            const inc = (evt.shiftKey ? 10 : 1) * (evt.keyCode === 40 ? -1 : 1);
            this.value += this.step * inc;
            return;
        }

        super._onInputKeyDown(evt);
    }

    _isScrolling() {
        if (!this._sliderControl) return false;
        return (document.pointerLockElement === this._sliderControl.dom ||
            document.mozPointerLockElement === this._sliderControl.dom);
    }

    _pointerLockChangeAlert() {
        if (this._isScrolling()) {

            this._sliderControl.dom.addEventListener("mousemove", this._domEvtMouseWheel, false);
            this._sliderControl.dom.addEventListener("wheel", this._domEvtMouseWheel, false);
            this._sliderControl.class.add(CLASS_NUMERIC_INPUT_SLIDER_CONTROL_ACTIVE);
        } else {
            this._sliderControl.dom.removeEventListener("mousemove", this._domEvtMouseWheel, false);
            this._sliderControl.dom.removeEventListener("wheel", this._domEvtMouseWheel, false);
            this._sliderControl.class.remove(CLASS_NUMERIC_INPUT_SLIDER_CONTROL_ACTIVE);
        }
    }

    _normalizeValue(value) {
        try {
            if (typeof value === 'string') {
                // replace commas with dots (for some international keyboards)
                value = value.replace(REGEX_COMMA, '.');

                // remove spaces
                value = value.replace(/\s/g, '');

                // sanitize input to only allow short mathematical expressions to be evaluated
                value = value.match(/^[*/+\-0-9().]+$/);
                if (value !== null && value[0].length < 20) {
                    var expression = value[0];
                    var operators = ['+', '-', '/', '*'];
                    operators.forEach((operator) => {
                        var expressionArr = expression.split(operator);
                        expressionArr.forEach((_, i) => {
                            expressionArr[i] = expressionArr[i].replace(/^0+/, '');
                        });
                        expression = expressionArr.join(operator);
                    });
                    // eslint-disable-next-line
                    value = Function('"use strict";return (' + expression + ')')();
                }
            }
        } catch (error) {
            value = null;
        }

        if (value === null || isNaN(value)) {
            if (this._allowNull) {
                return null;
            }

            value = 0;
        }

        // clamp between min max
        if (this.min !== null && value < this.min) {
            value = this.min;
        }
        if (this.max !== null && value > this.max) {
            value = this.max;
        }

        // fix precision
        if (this.precision !== null) {
            value = parseFloat(Number(value).toFixed(this.precision));
        }

        return value;
    }

    _updateValue(value, force) {
        const different = (value !== this._oldValue || force);

        // always set the value to the input because
        // we always want it to show an actual number or nothing
        this._oldValue = value;
        this._domInput.value = value;

        this.class.remove(MULTIPLE_VALUES);

        if (different) {
            this.emit('change', value);
        }

        return different;
    }

    set value(value) {
        value = this._normalizeValue(value);

        const forceUpdate = this.class.contains(MULTIPLE_VALUES) && value === null && this._allowNull;
        const changed = this._updateValue(value, forceUpdate);

        if (changed && this.binding) {
            this.binding.setValue(value);
        }
        if (this._sliderControl) {
            this._sliderControl.class.remove(CLASS_NUMERIC_INPUT_SLIDER_CONTROL_HIDDEN);
        }
    }

    get value() {
        const val = super.value;
        return val !== '' ? parseFloat(val) : null;
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        let different = false;
        const value = this._normalizeValue(values[0]);
        for (let i = 1; i < values.length; i++) {
            if (value !== this._normalizeValue(values[i])) {
                different = true;
                break;
            }
        }

        if (different) {
            this._updateValue(null);
            this.class.add(MULTIPLE_VALUES);
            if (this._sliderControl) {
                this._sliderControl.class.add(CLASS_NUMERIC_INPUT_SLIDER_CONTROL_HIDDEN);
            }
        } else {
            this._updateValue(value);
            if (this._sliderControl) {
                this._sliderControl.class.remove(CLASS_NUMERIC_INPUT_SLIDER_CONTROL_HIDDEN);
            }
        }
    }

    set min(value) {
        if (this._min === value) return;
        this._min = value;

        // reset value
        if (this._min !== null) {
            this.value = this.value; // eslint-disable-line no-self-assign
        }
    }

    get min() {
        return this._min;
    }

    set max(value) {
        if (this._max === value) return;
        this._max = value;

        // reset value
        if (this._max !== null) {
            this.value = this.value; // eslint-disable-line no-self-assign
        }
    }

    get max() {
        return this._max;
    }

    set precision(value) {
        if (this._precision === value) return;
        this._precision = value;

        // reset value
        if (this._precision !== null) {
            this.value = this.value; // eslint-disable-line no-self-assign
        }
    }

    get precision() {
        return this._precision;
    }

    set step(value) {
        this._step = value;
    }

    get step() {
        return this._step;
    }

    destroy() {
        if (this.destroyed) return;

        if (this._domEvtSliderMouseDown) {
            this._sliderControl.dom.removeEventListener('mousedown', this._domEvtSliderMouseDown);
            this._sliderControl.dom.removeEventListener('mouseup', this._domEvtSliderMouseUp);
        }

        if (this._domEvtMouseWheel) {
            this._sliderControl.dom.removeEventListener("mousemove", this._domEvtMouseWheel, false);
            this._sliderControl.dom.removeEventListener("wheel", this._domEvtMouseWheel, false);
        }

        if (this._domEvtPointerLock) {
            document.removeEventListener('pointerlockchange', this._domEvtPointerLock, false);
            document.removeEventListener('mozpointerlockchange', this._domEvtPointerLock, false);
        }

        super.destroy();
    }
}

Element$1.register('number', NumericInput, { renderChanges: true });

var utils = { };


// utils.deepCopy
utils.deepCopy = function deepCopy(data) {
    if (data == null || typeof (data) !== 'object')
        return data;

    if (data instanceof Array) {
        var arr = [];
        for (var i = 0; i < data.length; i++) {
            arr[i] = deepCopy(data[i]);
        }
        return arr;
    }

    var obj = { };
    for (var key in data) {
        if (data.hasOwnProperty(key))
            obj[key] = deepCopy(data[key]);
    }
    return obj;

};

utils.isMobile = function () {
    return /Android/i.test(navigator.userAgent) ||
      /iPhone|iPad|iPod/i.test(navigator.userAgent);
};

/**
 * @name utils.implements
 * @description Adds properties and methods from the sourceClass
 * to the targetClass but only if properties with the same name do not
 * already exist in the targetClass.
 * @param {object} targetClass - The target class.
 * @param {object} sourceClass - The source class.
 * @example utils.implements(pcui.Container, pcui.IContainer);
 */
utils.implements = function (targetClass, sourceClass) {
    var properties = Object.getOwnPropertyDescriptors(sourceClass.prototype);
    for (var key in properties) {
        if (targetClass.prototype.hasOwnProperty(key)) {
            delete properties[key];
        }
    }

    Object.defineProperties(targetClass.prototype, properties);
};

/**
 * @name utils.proxy
 * @description Creates new properties on the target class that get / set
 * the properties of the member.
 * @param {object} targetClass - The target class
 * @param {string} memberName - The name of the member of the target class that properties will be proxied to.
 * @param {string[]} properties - A list of properties to be proxied.
 * @example
 * utils.proxy(pcui.SliderInput, '_numericInput', ['max', 'min', 'placeholder']);
 */
utils.proxy = function (targetClass, memberName, properties) {
    properties.forEach((property) => {
        Object.defineProperty(targetClass.prototype, property, {
            get: function () {
                return this[memberName][property];
            },
            set: function (value) {
                this[memberName][property] = value;
            }
        });
    });
};

// String.startsWith
if (!String.prototype.startsWith) {
    // eslint-disable-next-line
    Object.defineProperty(String.prototype, 'startsWith', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function (str) {
            var that = this;
            var ceil = str.length;
            for (var i = 0; i < ceil; i++)
                if (that[i] !== str[i]) return false;
            return true;
        }
    });
}

// String.endsWith polyfill
if (!String.prototype.endsWith) {
    // eslint-disable-next-line
    Object.defineProperty(String.prototype, 'endsWith', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function (str) {
            var that = this;
            for (var i = 0, ceil = str.length; i < ceil; i++)
                if (that[i + that.length - ceil] !== str[i])
                    return false;
            return true;
        }
    });
}

// Appends query parameter to string (supposedly the string is a URL)
// automatically figuring out if the separator should be ? or &.
// Example: url.appendQuery('t=123').appendQuery('q=345');
if (!String.prototype.appendQuery) {
    // eslint-disable-next-line
    Object.defineProperty(String.prototype, 'appendQuery', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function (queryParameter) {
            var separator = this.indexOf('?') !== -1 ? '&' : '?';
            return this + separator + queryParameter;
        }
    });
}

utils.arrayEquals = function (lhs, rhs) {
    if (!lhs)
        return false;

    if (!rhs)
        return false;

    if (lhs.length !== rhs.length)
        return false;

    for (var i = 0, l = lhs.length; i < l; i++) {
        if (this[i] instanceof Array && rhs[i] instanceof Array) {
            if (!this[i].equals(rhs[i]))
                return false;
        } else if (this[i] !== rhs[i]) {
            return false;
        }
    }
    return true;
};

// element.classList.add polyfill
(function () {
    var dummy  = document.createElement('div'),
        dtp    = DOMTokenList.prototype,
        add    = dtp.add,
        rem    = dtp.remove;

    dummy.classList.add('class1', 'class2');

    // Older versions of the HTMLElement.classList spec didn't allow multiple
    // arguments, easy to test for
    if (!dummy.classList.contains('class2')) {
        dtp.add    = function () {
            Array.prototype.forEach.call(arguments, add.bind(this));
        };
        dtp.remove = function () {
            Array.prototype.forEach.call(arguments, rem.bind(this));
        };
    }
})();

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect, .pcui-slider {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-slider {\n  display: inline-flex;\n  height: 24px;\n  margin: 6px;\n  align-items: center;\n}\n.pcui-slider > .pcui-numeric-input {\n  flex: 1;\n  margin-left: 0;\n}\n\n.pcui-slider-container {\n  flex: 3;\n}\n\n.pcui-slider-bar {\n  position: relative;\n  width: calc(100% - 18px);\n  height: 4px;\n  margin: 9px 8px;\n  background-color: #2c393c;\n  border: 1px solid #293538;\n}\n\n.pcui-slider-handle {\n  position: absolute;\n  top: -7px;\n  left: 0;\n  margin-left: -9px;\n  width: 8px;\n  height: 16px;\n  background-color: #5b7073;\n  border: 1px solid #293538;\n  transition: left 100ms ease;\n}\n.pcui-slider-handle:hover, .pcui-slider-handle:focus {\n  outline: none;\n}\n\n.pcui-slider-active {\n  cursor: ew-resize;\n}\n.pcui-slider-active .pcui-slider-bar {\n  border-color: #20292b;\n  background-color: #20292b;\n}\n.pcui-slider-active .pcui-slider-handle {\n  border-color: #20292b;\n  background-color: #ffffff;\n  transition: none;\n}\n\n.pcui-slider:not(.pcui-disabled):not(.pcui-readonly):hover {\n  cursor: pointer;\n}\n.pcui-slider:not(.pcui-disabled):not(.pcui-readonly) .pcui-slider-handle:focus, .pcui-slider:not(.pcui-disabled):not(.pcui-readonly) .pcui-slider-handle:hover {\n  cursor: ew-resize;\n  outline: none;\n  border-color: #20292b;\n  background-color: #ffffff;\n}\n\n.pcui-slider.pcui-readonly .pcui-numeric-input {\n  flex: 1;\n}\n.pcui-slider.pcui-readonly .pcui-slider-bar {\n  display: none;\n}\n\n.pcui-slider.pcui-multiple-values .pcui-slider-handle {\n  display: none;\n}");

const CLASS_SLIDER = 'pcui-slider';
const CLASS_SLIDER_CONTAINER = CLASS_SLIDER + '-container';
const CLASS_SLIDER_BAR = CLASS_SLIDER + '-bar';
const CLASS_SLIDER_HANDLE = CLASS_SLIDER + '-handle';
const CLASS_SLIDER_ACTIVE = CLASS_SLIDER + '-active';

const IS_CHROME = /Chrome\//.test(navigator.userAgent);

// fields that are proxied between the slider and the numeric input
const PROXY_FIELDS = [
    'allowNull',
    'max',
    'min',
    'keyChange',
    'placeholder',
    'precision',
    'renderChanges',
    'step'
];

/**
 * @name SliderInput
 * @class
 * @classdesc The SliderInput shows a pcui.NumericInput and a slider widget next to it. It acts as a proxy
 * of the NumericInput.
 * @property {number} min=0 Gets / sets the minimum value that the numeric input field can take.
 * @property {number} max=1 Gets / sets the maximum value that the numeric input field can take.
 * @property {number} sliderMin=0 Gets / sets the minimum value that the slider field can take.
 * @property {number} sliderMax=1 Gets / sets the maximum value that the slider field can take.
 * @property {number} pre Gets / sets the maximum number of decimals a value can take.
 * @property {number} step Gets / sets the amount that the value will be increased or decreased when using the arrow keys. Holding Shift will use 10x the step.
 * @property {boolean} allowNull Gets / sets whether the value can be null. If not then it will be 0 instead of null.
 * @augments Element
 * @mixes IBindable
 * @mixes IFocusable
 */
class SliderInput extends Element$1 {
    /**
     * Creates a new SliderInput.
     *
     * @param {object} args - The arguments. Extends the pcui.NumericInput constructor arguments.
     */
    constructor(args) {
        args = Object.assign({}, args);

        const inputArgs = {};
        PROXY_FIELDS.forEach((field) => {
            inputArgs[field] = args[field];
        });

        if (inputArgs.precision === undefined) {
            inputArgs.precision = 2;
        }

        // binding should only go to the slider
        // and the slider will propagate changes to the numeric input
        delete inputArgs.binding;

        super(args.dom ? args.dom : document.createElement('div'), args);

        if (args.pre) this.precision = args.pre;

        this.class.add(CLASS_SLIDER);

        this._historyCombine = false;
        this._historyPostfix = null;

        this._numericInput = new NumericInput({ ...inputArgs, hideSlider: true });

        // propagate change event
        this._numericInput.on('change', this._onValueChange.bind(this));
        // propagate focus / blur events
        this._numericInput.on('focus', () => {
            this.emit('focus');
        });

        this._numericInput.on('blur', () => {
            this.emit('blur');
        });

        this._sliderMin = (args.sliderMin !== undefined ? args.sliderMin : this.min || 0);
        this._sliderMax = (args.sliderMax !== undefined ? args.sliderMax : this.max || 1);

        this.dom.appendChild(this._numericInput.dom);
        this._numericInput.parent = this;

        this._domSlider = document.createElement('div');
        this._domSlider.classList.add(CLASS_SLIDER_CONTAINER);
        this.dom.appendChild(this._domSlider);

        this._domBar = document.createElement('div');
        this._domBar.classList.add(CLASS_SLIDER_BAR);
        this._domBar.ui = this;
        this._domSlider.appendChild(this._domBar);

        this._domHandle = document.createElement('div');
        this._domHandle.ui = this;
        this._domHandle.tabIndex = 0;
        this._domHandle.classList.add(CLASS_SLIDER_HANDLE);
        this._domBar.appendChild(this._domHandle);
        this._cursorHandleOffset = 0;

        this._domMouseDown = this._onMouseDown.bind(this);
        this._domMouseMove = this._onMouseMove.bind(this);
        this._domMouseUp = this._onMouseUp.bind(this);
        this._domTouchStart = this._onTouchStart.bind(this);
        this._domTouchMove = this._onTouchMove.bind(this);
        this._domTouchEnd = this._onTouchEnd.bind(this);
        this._domKeyDown = this._onKeyDown.bind(this);

        this._touchId = null;

        this._domSlider.addEventListener('mousedown', this._domMouseDown);
        this._domSlider.addEventListener('touchstart', this._domTouchStart, { passive: true });
        this._domHandle.addEventListener('keydown', this._domKeyDown);

        if (args.value !== undefined) {
            this.value = args.value;
        }

        // update the handle in case a 0 value has been
        // passed through the constructor
        if (this.value === 0) {
            this._updateHandle(0);
        }
    }

    _onMouseDown(evt) {
        if (evt.button !== 0 || !this.enabled || this.readOnly) return;

        //console.log("_onMouseDown", evt.pageX);

        this._onSlideStart(evt.pageX);
    }

    _onMouseMove(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        //console.log("_onMouseMove", evt.pageX);

        this._onSlideMove(evt.pageX);
    }

    _onMouseUp(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        //console.log("_onMouseDown", evt.pageX);

        this._onSlideEnd(evt.pageX);
    }

    _onTouchStart(evt) {
        if (!this.enabled || this.readOnly) return;

        for (let i = 0; i < evt.changedTouches.length; i++) {
            const touch = evt.changedTouches[i];
            if (!touch.target.ui || touch.target.ui !== this)
                continue;

            this._touchId = touch.identifier;
            this._onSlideStart(touch.pageX);
            break;
        }
    }

    _onTouchMove(evt) {
        for (let i = 0; i < evt.changedTouches.length; i++) {
            const touch = evt.changedTouches[i];

            if (touch.identifier !== this._touchId)
                continue;

            evt.stopPropagation();
            evt.preventDefault();

            this._onSlideMove(touch.pageX);
            break;
        }
    }

    _onTouchEnd(evt) {
        for (let i = 0; i < evt.changedTouches.length; i++) {
            const touch = evt.changedTouches[i];

            if (touch.identifier !== this._touchId)
                continue;

            evt.stopPropagation();
            evt.preventDefault();

            this._onSlideEnd(touch.pageX);
            this._touchId = null;
            break;
        }
    }

    _onKeyDown(evt) {
        if (evt.keyCode === 27) {
            this.blur();
            return;
        }

        if (!this.enabled || this.readOnly) return;

        // move slider with left / right arrow keys
        if (evt.keyCode !== 37 && evt.keyCode !== 39) return;

        evt.stopPropagation();
        evt.preventDefault();
        let x = evt.keyCode === 37 ? -1 : 1;
        if (evt.shiftKey) {
            x *= 10;
        }

        this.value += x * this.step;
    }

    _updateHandle(value) {
        const left = Math.max(0, Math.min(1, ((value || 0) - this._sliderMin) / (this._sliderMax - this._sliderMin))) * 100;
        const handleWidth = this._domHandle.getBoundingClientRect().width;
        this._domHandle.style.left = `calc(${left}% + ${handleWidth / 2}px)`;
    }

    _onValueChange(value) {
        this._updateHandle(value);
        this.emit('change', value);

        if (this._binding) {
            this._binding.setValue(value);
        }
    }

    // Calculates the distance in pixels between
    // the cursor x and the middle of the handle.
    // If the cursor is not on the handle sets the offset to 0
    _calculateCursorHandleOffset(pageX) {
        // not sure why but the left side needs a margin of a couple of pixels
        // to properly determine if the cursor is on the handle (in Chrome)
        const margin = IS_CHROME ? 2 : 0;
        const rect = this._domHandle.getBoundingClientRect();
        const left = rect.left - margin;
        const right = rect.right;
        if (pageX >= left && pageX <= right) {
            this._cursorHandleOffset = pageX - (left + (right - left) / 2);
        } else {
            this._cursorHandleOffset = 0;
        }

        return this._cursorHandleOffset;
    }

    _onSlideStart(pageX) {
        this._domHandle.focus();

        // CUSTOM
            // if (window.self !== window.top) {

            //     if (this._touchId === null) {
            //         window.top.addEventListener('mousemove', this._domMouseMove);
            //         window.top.addEventListener('mouseup', this._domMouseUp);
            //     } else {
            //         window.top.addEventListener('touchmove', this._domTouchMove);
            //         window.top.addEventListener('touchend', this._domTouchEnd);
            //     }

            // } 
            // else {

                if (this._touchId === null) {
                    window.addEventListener('mousemove', this._domMouseMove);
                    window.addEventListener('mouseup', this._domMouseUp);
                } else {
                    window.addEventListener('touchmove', this._domTouchMove);
                    window.addEventListener('touchend', this._domTouchEnd);
                }

            // }

        // ORIG
            // if (this._touchId === null) {
            //     window.addEventListener('mousemove', this._domMouseMove);
            //     window.addEventListener('mouseup', this._domMouseUp);
            // } else {
            //     window.addEventListener('touchmove', this._domTouchMove);
            //     window.addEventListener('touchend', this._domTouchEnd);
            // }

        this.class.add(CLASS_SLIDER_ACTIVE);

        // calculate the cursor - handle offset. If there is
        // an offset that means the cursor is on the handle so
        // do not move the handle until the cursor moves.
        if (!this._calculateCursorHandleOffset(pageX)) {
            this._onSlideMove(pageX);
        }

        if (this.binding) {
            this._historyCombine = this.binding.historyCombine;
            this._historyPostfix = this.binding.historyPostfix;

            this.binding.historyCombine = true;
            this.binding.historyPostfix = `(${Date.now()})`;
        }
    }

    _onSlideMove(pageX) {
        const rect = this._domBar.getBoundingClientRect();
        // reduce pageX by the initial cursor - handle offset
        pageX -= this._cursorHandleOffset;
        const x = Math.max(0, Math.min(1, (pageX - rect.left) / rect.width));

        const range = this._sliderMax - this._sliderMin;
        let value = (x * range) + this._sliderMin;
        value = parseFloat(value.toFixed(this.precision));

        this.value = value;
    }

    _onSlideEnd(pageX) {
        // when slide ends only move the handle if the cursor is no longer
        // on the handle
        if (!this._calculateCursorHandleOffset(pageX)) {
            this._onSlideMove(pageX);
        }

        this.class.remove(CLASS_SLIDER_ACTIVE);

        // CUSTOM
            // if (window.self !== window.top) {

            //     if (this._touchId === null) {
            //         window.top.removeEventListener('mousemove', this._domMouseMove);
            //         window.top.removeEventListener('mouseup', this._domMouseUp);
            //     } else {
            //         window.top.removeEventListener('touchmove', this._domTouchMove);
            //         window.top.removeEventListener('touchend', this._domTouchEnd);
            //     }


            // }
             // else {

                if (this._touchId === null) {
                    window.removeEventListener('mousemove', this._domMouseMove);
                    window.removeEventListener('mouseup', this._domMouseUp);
                } else {
                    window.removeEventListener('touchmove', this._domTouchMove);
                    window.removeEventListener('touchend', this._domTouchEnd);
                }

            // }


        // ORIG
            // if (this._touchId === null) {
            //     window.removeEventListener('mousemove', this._domMouseMove);
            //     window.removeEventListener('mouseup', this._domMouseUp);
            // } else {
            //     window.removeEventListener('touchmove', this._domTouchMove);
            //     window.removeEventListener('touchend', this._domTouchEnd);
            // }

        if (this.binding) {
            this.binding.historyCombine = this._historyCombine;
            this.binding.historyPostfix = this._historyPostfix;

            this._historyCombine = false;
            this._historyPostfix = null;
        }

    }

    focus() {
        this._numericInput.focus();
    }

    blur() {
        this._domHandle.blur();
        this._numericInput.blur();
    }

    destroy() {
        if (this._destroyed) return;
        this._domSlider.removeEventListener('mousedown', this._domMouseDown);
        this._domSlider.removeEventListener('touchstart', this._domTouchStart);

        this._domHandle.removeEventListener('keydown', this._domKeyDown);

        this.dom.removeEventListener('mouseup', this._domMouseUp);
        this.dom.removeEventListener('mousemove', this._domMouseMove);
        this.dom.removeEventListener('touchmove', this._domTouchMove);
        this.dom.removeEventListener('touchend', this._domTouchEnd);
        super.destroy();
    }

    set sliderMin(value) {
        if (this._sliderMin === value) return;

        this._sliderMin = value;
        this._updateHandle(this.value);
    }

    get sliderMin() {
        return this._sliderMin;
    }

    set sliderMax(value) {
        if (this._sliderMax === value) return;

        this._sliderMax = value;
        this._updateHandle(this.value);
    }

    get sliderMax() {
        return this._sliderMax;
    }

    set value(value) {
        this._numericInput.value = value;
        if (this._numericInput.class.contains(MULTIPLE_VALUES)) {
            this.class.add(MULTIPLE_VALUES);
        } else {
            this.class.remove(MULTIPLE_VALUES);
        }
    }

    get value() {
        return this._numericInput.value;
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        this._numericInput.values = values;
        if (this._numericInput.class.contains(MULTIPLE_VALUES)) {
            this.class.add(MULTIPLE_VALUES);
        } else {
            this.class.remove(MULTIPLE_VALUES);
        }
    }
}

utils.proxy(SliderInput, '_numericInput', PROXY_FIELDS);

Element$1.register('slider', SliderInput, { renderChanges: true });

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-vector-input {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-vector-input:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-vector-input {\n  flex-direction: row;\n  align-items: center;\n}\n.pcui-vector-input > .pcui-numeric-input {\n  flex: 1;\n  margin: 6px 3px;\n}\n.pcui-vector-input > .pcui-numeric-input:first-child {\n  margin-left: 0;\n}\n.pcui-vector-input > .pcui-numeric-input:last-child {\n  margin-right: 0;\n}");

const CLASS_VECTOR_INPUT = 'pcui-vector-input';

/**
 * @name VectorInput
 * @class
 * @classdesc A vector input
 * @augments Element
 * @mixes IBindable
 * @mixes IFocusable
 */
class VectorInput extends Element$1 {
    /**
     * Creates a new pcui.VectorInput.
     *
     * @param {object} args - The arguments.
     * @param {number} [args.dimensions=3] - The number of dimensions in the vector. Can be between 2 to 4. Defaults to 3.
     * @param {number} [args.min] - The minimum value for each vector element.
     * @param {number} [args.max] - The maximum value for each vector element.
     * @param {number} [args.precision] - The decimal precision for each vector element.
     * @param {number} [args.step] - The incremental step when using arrow keys for each vector element.
     * @param {boolean} [args.renderChanges] - If true each vector element will flash on changes.
     * @param {string[]|string} [args.placeholder] - The placeholder string for each vector element.
     */
    constructor(args) {
        args = Object.assign({}, args);

        // set binding after inputs have been created
        const binding = args.binding;
        delete args.binding;

        super(args.dom ? args.dom : document.createElement('div'), args);

        this.class.add(CLASS_VECTOR_INPUT);

        const dimensions = Math.max(2, Math.min(4, args.dimensions || 3));

        const onInputChange = this._onInputChange.bind(this);
        this._inputs = new Array(dimensions);
        for (let i = 0; i < this._inputs.length; i++) {
            this._inputs[i] = new NumericInput({
                min: args.min,
                max: args.max,
                precision: args.precision,
                step: args.step,
                renderChanges: args.renderChanges,
                placeholder: args.placeholder ? (Array.isArray(args.placeholder) ? args.placeholder[i] : args.placeholder) : null
            });
            this._inputs[i].on('change', onInputChange);
            this._inputs[i].on('focus', () => {
                this.emit('focus');
            });
            this._inputs[i].on('blur', () => {
                this.emit('blur');
            });
            this.dom.appendChild(this._inputs[i].dom);
            this._inputs[i].parent = this;
        }

        // set the binding after the inputs have been created
        // because we rely on them in the overriden setter
        if (binding) {
            this.binding = binding;
        }

        this._applyingChange = false;

        if (args.value !== undefined) {
            this.value = args.value;
        }

    }

    _onInputChange() {
        if (this._applyingChange) return;

        // check if any of our inputs have the multiple_values class
        // and if so inherit it for us as well
        let showingMultipleValues = false;
        for (let i = 0; i < this._inputs.length; i++) {
            if (this._inputs[i].class.contains(MULTIPLE_VALUES)) {
                showingMultipleValues = true;
                break;
            }
        }

        if (showingMultipleValues) {
            this.class.add(MULTIPLE_VALUES);
        } else {
            this.class.remove(MULTIPLE_VALUES);
        }

        this.emit('change', this.value);
    }

    _updateValue(value) {
        this.class.remove(MULTIPLE_VALUES);

        if (JSON.stringify(this.value) === JSON.stringify(value)) return false;

        this._applyingChange = true;

        for (let i = 0; i < this._inputs.length; i++) {
            // disable binding for each individual input when we use
            // the 'value' setter for the whole vector value. That is because
            // we do not want the individual inputs to emit their own binding events
            // since we are setting the whole vector value here
            const binding = this._inputs[i].binding;
            let applyingChange = false;
            if (binding) {
                applyingChange = binding.applyingChange;
                binding.applyingChange = true;
            }
            this._inputs[i].value = (value && value[i] !== undefined ? value[i] : null);
            if (binding) {
                binding.applyingChange = applyingChange;
            }
        }

        this.emit('change', this.value);

        this._applyingChange = false;

        return true;
    }

    link(observers, paths) {
        super.link(observers, paths);
        observers = Array.isArray(observers) ? observers : [observers];
        paths = Array.isArray(paths) ? paths : [paths];

        const useSinglePath = paths.length === 1 || observers.length !== paths.length;
        if (useSinglePath) {
            for (let i = 0; i < this._inputs.length; i++) {
                // link observers to path.i for each dimension
                this._inputs[i].link(observers, paths[0] + `.${i}`);
            }
        } else {
            for (let i = 0; i < this._inputs.length; i++) {
                // link observers to paths[i].i for each dimension
                this._inputs[i].link(observers, paths.map(path => `${path}.${i}`));
            }

        }
    }

    unlink() {
        super.unlink();
        for (let i = 0; i < this._inputs.length; i++) {
            this._inputs[i].unlink();
        }
    }

    focus() {
        this._inputs[0].focus();
    }

    blur() {
        for (let i = 0; i < this._inputs.length; i++) {
            this._inputs[i].blur();
        }
    }

    set value(value) {
        if (typeof value === 'string') {
            try {
                // try to parse the string
                value = JSON.parse(value);
                // if the string could be converted to an array but some of it's values aren't numbers
                // then use a default array also
                if (Array.isArray(value) && value.some(i => !Number.isFinite(i))) {
                    throw new Error('VectorInput value set to string which doesn\'t contain an array of numbers');
                }
            } catch (e) {
                console.error(e);
                value = [];
            }
        }
        if (!Array.isArray(value)) {
            value = [];
        }

        const changed = this._updateValue(value);

        if (changed && this._binding) {
            this._binding.setValue(value);
        }
    }

    get value() {
        const value = new Array(this._inputs.length);
        for (let i = 0; i < this._inputs.length; i++) {
            value[i] = this._inputs[i].value;
        }

        return value;
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        // create an array for each dimension (e.g. one array for x one for y one for z)
        values = this._inputs.map((_, i) => values.map((arr) => {
            return arr ? arr[i] : undefined;
        }));

        this._inputs.forEach((input, i) => {
            input.values = values[i];
        });
    }

    // override binding setter to set a binding clone to
    // each input
    set binding(value) {
        super.binding = value;
        for (let i = 0; i < this._inputs.length; i++) {
            this._inputs[i].binding = (value ? value.clone() : null);
        }
    }

    // we have to override the getter too because
    // we have overriden the setter
    get binding() {
        return super.binding;
    }

    set placeholder(value) {
        for (let i = 0; i < this._inputs.length; i++) {
            this._inputs[i].placeholder = value[i] || value || null;
        }
    }

    get placeholder() {
        return this._inputs.map(input => input.placeholder);
    }

    get inputs() {
        return this._inputs.slice();
    }
}

// add proxied properties
[
    'min',
    'max',
    'precision',
    'step',
    'renderChanges'
].forEach((property) => {
    Object.defineProperty(VectorInput.prototype, property, {
        get: function () {
            return this._inputs[0][property];
        },
        set: function (value) {
            for (let i = 0; i < this._inputs.length; i++) {
                this._inputs[i][property] = value;
            }
        }
    });
});

Element$1.register('vec2', VectorInput, { dimensions: 2, renderChanges: true });
Element$1.register('vec3', VectorInput, { dimensions: 3, renderChanges: true });
Element$1.register('vec4', VectorInput, { dimensions: 4, renderChanges: true });

___$insertStyle("@charset \"UTF-8\";\n@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-boolean-input.pcui-boolean-input-ticked:after {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-boolean-input.pcui-boolean-input-ticked:after {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.pcui-boolean-input {\n  display: inline-block;\n  position: relative;\n  box-sizing: border-box;\n  background-color: #2c393c;\n  color: #fff;\n  width: 14px;\n  height: 14px;\n  line-height: 1;\n  overflow: hidden;\n  margin: 6px;\n  transition: opacity 100ms, background-color 100ms, box-shadow 100ms;\n}\n.pcui-boolean-input:focus {\n  outline: none;\n}\n\n.pcui-boolean-input.pcui-boolean-input-ticked {\n  background-color: #b1b8ba;\n}\n.pcui-boolean-input.pcui-boolean-input-ticked:after {\n  content: \"\\e372\";\n  color: #20292b;\n  background-color: inherit;\n  font-size: 19px;\n  display: block;\n  margin-top: -2px;\n  margin-left: -2px;\n}\n\n.pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly):focus {\n  cursor: pointer;\n  background-color: #293538;\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:hover, .pcui-boolean-input:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:focus {\n  background-color: #b1b8ba;\n}\n\n.pcui-boolean-input.pcui-disabled {\n  opacity: 0.4;\n}\n\n.pcui-boolean-input.pcui-multiple-values:after {\n  position: absolute;\n  font-size: 17px;\n  font-weight: bold;\n  color: #b1b8ba;\n  left: 4px;\n  top: -3px;\n  content: \"-\";\n}\n\n.pcui-boolean-input-toggle {\n  display: inline-block;\n  position: relative;\n  width: 30px;\n  height: 16px;\n  border-radius: 8px;\n  flex-shrink: 0;\n  border: 1px solid #293538;\n  box-sizing: border-box;\n  background-color: #364346;\n  color: #fff;\n  line-height: 1;\n  overflow: hidden;\n  margin: 6px;\n  transition: opacity 100ms, background-color 100ms, box-shadow 100ms;\n}\n.pcui-boolean-input-toggle:focus {\n  outline: none;\n}\n.pcui-boolean-input-toggle:after {\n  content: \" \";\n  position: absolute;\n  top: 1px;\n  left: 1px;\n  width: 12px;\n  height: 12px;\n  border-radius: 6px;\n  background-color: #5b7073;\n  transition: left 100ms ease, background-color 100ms ease;\n}\n\n.pcui-boolean-input-toggle.pcui-boolean-input-ticked {\n  border-color: #293538;\n}\n.pcui-boolean-input-toggle.pcui-boolean-input-ticked:after {\n  left: 15px;\n  background-color: #69b875;\n}\n\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):focus {\n  cursor: pointer;\n  border-color: #20292b;\n  background-color: #20292b;\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):hover:after, .pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly):focus:after {\n  background-color: #d34141;\n}\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:hover, .pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:focus {\n  border-color: #20292b;\n  background-color: #20292b;\n}\n.pcui-boolean-input-toggle:not(.pcui-disabled):not(.pcui-readonly).pcui-boolean-input-ticked:after {\n  background-color: #7f7;\n}\n\n.pcui-boolean-input-toggle.pcui-readonly {\n  opacity: 0.7;\n}\n\n.pcui-boolean-input-toggle.pcui-disabled {\n  opacity: 0.4;\n}\n\n.pcui-boolean-input-toggle.pcui-multiple-values:after {\n  left: 8px;\n  background-color: rgba(155, 161, 163, 0.25);\n}");

const CLASS_BOOLEAN_INPUT = 'pcui-boolean-input';
const CLASS_BOOLEAN_INPUT_TICKED = CLASS_BOOLEAN_INPUT + '-ticked';
const CLASS_BOOLEAN_INPUT_TOGGLE = CLASS_BOOLEAN_INPUT + '-toggle';

/**
 * @name BooleanInput
 * @class
 * @classdesc A checkbox element.
 * @property {boolean} renderChanges If true the input will flash when changed.
 * @augments Element
 * @mixes IBindable
 * @mixes IFocusable
 */
class BooleanInput extends Element$1 {
    /**
     * Creates a new pcui.BooleanInput.
     *
     * @param {object} args - The arguments.
     * @param {string} [args.type] - The type of checkbox currently can be null or 'toggle'.
     */
    constructor(args) {
        args = Object.assign({
            tabIndex: 0
        }, args);

        super(args.dom ? args.dom : document.createElement('div'), args);

        if (args.type === 'toggle') {
            this.class.add(CLASS_BOOLEAN_INPUT_TOGGLE);
        } else {
            this.class.add(CLASS_BOOLEAN_INPUT);
        }
        this.class.add(NOT_FLEXIBLE);

        this._domEventKeyDown = this._onKeyDown.bind(this);
        this._domEventFocus = this._onFocus.bind(this);
        this._domEventBlur = this._onBlur.bind(this);

        this.dom.addEventListener('keydown', this._domEventKeyDown);
        this.dom.addEventListener('focus', this._domEventFocus);
        this.dom.addEventListener('blur', this._domEventBlur);

        this._value = null;
        if (args.value !== undefined) {
            this.value = args.value;
        }

        this.renderChanges = args.renderChanges;
    }

    _onClick(evt) {
        if (this.enabled) {
            this.focus();
        }

        if (this.enabled && !this.readOnly) {
            this.value = !this.value;
        }

        return super._onClick(evt);
    }

    _onKeyDown(evt) {
        if (evt.keyCode === 27) {
            this.blur();
            return;
        }

        if (!this.enabled || this.readOnly) return;

        if (evt.keyCode === 32) {
            evt.stopPropagation();
            evt.preventDefault();
            this.value = !this.value;
        }
    }

    _onFocus() {
        this.emit('focus');
    }

    _onBlur() {
        this.emit('blur');
    }

    _updateValue(value) {
        this.class.remove(MULTIPLE_VALUES);

        if (value === this.value) return false;

        this._value = value;

        if (value) {
            this.class.add(CLASS_BOOLEAN_INPUT_TICKED);
        } else {
            this.class.remove(CLASS_BOOLEAN_INPUT_TICKED);
        }

        if (this.renderChanges) {
            this.flash();
        }

        this.emit('change', value);

        return true;
    }

    focus() {
        this.dom.focus();
    }

    blur() {
        this.dom.blur();
    }

    destroy() {
        if (this._destroyed) return;

        this.dom.removeEventListener('keydown', this._domEventKeyDown);
        this.dom.removeEventListener('focus', this._domEventFocus);
        this.dom.removeEventListener('blur', this._domEventBlur);

        super.destroy();
    }

    set value(value) {
        const changed = this._updateValue(value);
        if (changed && this._binding) {
            this._binding.setValue(value);
        }
    }

    get value() {
        return this._value;
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        let different = false;
        const value = values[0];
        for (let i = 1; i < values.length; i++) {
            if (values[i] !== value) {
                different = true;
                break;
            }
        }

        if (different) {
            this._updateValue(null);
            this.class.add(MULTIPLE_VALUES);
        } else {
            this._updateValue(values[0]);
        }
    }
}

Element$1.register('boolean', BooleanInput, { renderChanges: true });

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont, .pcui-label.pcui-multiple-values:before {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect, .pcui-label.pcui-selectable:hover {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-label {\n  display: inline-block;\n  box-sizing: border-box;\n  margin: 6px;\n  vertical-align: middle;\n  transition: opacity 100ms;\n  color: #b1b8ba;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  user-select: none;\n}\n\n.pcui-label.pcui-default-mousedown {\n  user-select: initial;\n}\n\n.pcui-label.pcui-multiple-values {\n  position: relative;\n  color: transparent;\n}\n.pcui-label.pcui-multiple-values:before {\n  content: \"...\";\n  color: #b1b8ba;\n  white-space: nowrap;\n  font-size: 12px;\n}\n\n.pcui-label.pcui-error {\n  color: #d34141;\n}\n\n.pcui-label.pcui-selectable:hover {\n  color: #f60;\n  text-decoration: underline;\n}\n\n.pcui-label[placeholder] {\n  position: relative;\n}\n.pcui-label[placeholder]:after {\n  content: attr(placeholder);\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 0 8px;\n  color: #999;\n  pointer-events: none;\n}");

const CLASS_LABEL = 'pcui-label';

/**
 * @name Label
 * @class
 * @classdesc The Label is a simple span element that displays some text.
 * @property {string} placeholder Gets / sets the placeholder label that appears on the right of the label.
 * @property {string} text Gets / sets the text of the Label.
 * @property {boolean} renderChanges If true then the Label will flash when its text changes.
 * @augments Element
 * @mixes IBindable
 */
class Label extends Element$1 {
    /**
     * Creates a new Label.
     *
     * @param {object} args - The arguments. Extends the pcui.Element constructor arguments. All settable properties can also be set through the constructor.
     * @param {boolean} [args.unsafe] - If true then the innerHTML property will be used to set the text. Otherwise textContent will be used instead.
     * @param {boolean} [args.nativeTooltip] - If true then use the text of the label as the native HTML tooltip.
     * @param {boolean} [args.allowTextSelection] - If true then the label can be clicked to select text.
     */
    constructor(args) {
        if (!args) args = {};

        super(args.dom ? args.dom : document.createElement('span'), args);

        this.class.add(CLASS_LABEL);

        this._unsafe = args.unsafe || false;
        this.text = args.text || args.value || '';

        if (args.allowTextSelection) {
            this.class.add(DEFAULT_MOUSEDOWN);
        }

        if (args.nativeTooltip) {
            this.dom.title = this.text;
        }
        this.placeholder = args.placeholder || null;

        this.renderChanges = args.renderChanges || false;

        this.on('change', () => {
            if (this.renderChanges) {
                this.flash();
            }
        });
    }

    _updateText(value) {
        this.class.remove(MULTIPLE_VALUES);

        if (this._text === value) return false;

        this._text = value;

        if (this._unsafe) {
            this._dom.innerHTML = value;
        } else {
            this._dom.textContent = value;
        }

        this.emit('change', value);

        return true;
    }

    set text(value) {
        if (value === undefined || value === null) {
            value = '';
        }

        const changed = this._updateText(value);

        if (changed && this._binding) {
            this._binding.setValue(value);
        }
    }

    get text() {
        return this._text;
    }

    set value(value) {
        this.text = value;
    }

    get value() {
        return this.text;
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        let different = false;
        const value = values[0];
        for (let i = 1; i < values.length; i++) {
            if (values[i] !== value) {
                different = true;
                break;
            }
        }

        if (different) {
            this._updateText('');
            this.class.add(MULTIPLE_VALUES);
        } else {
            this._updateText(values[0]);
        }
    }

    set placeholder(value) {
        if (value) {
            this.dom.setAttribute('placeholder', value);
        } else {
            this.dom.removeAttribute('placeholder');
        }
    }

    get placeholder() {
        return this.dom.getAttribute('placeholder');
    }
}

Element$1.register('label', Label);

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-button[data-icon]:before {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-button[data-icon]:before {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect, .pcui-button {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-button {\n  font-family: inherit;\n  display: inline-block;\n  border: 1px solid #20292b;\n  border-radius: 2px;\n  box-sizing: border-box;\n  background-color: #2c393c;\n  color: #b1b8ba;\n  padding: 0 8px;\n  margin: 6px;\n  height: 28px;\n  line-height: 28px;\n  max-height: 100%;\n  vertical-align: middle;\n  font-size: 12px;\n  font-weight: 600;\n  text-align: center;\n  white-space: nowrap;\n  cursor: pointer;\n  transition: color 100ms, opacity 100ms, box-shadow 100ms;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.pcui-button[data-icon]:before {\n  content: attr(data-icon);\n  font-weight: 100;\n  font-size: inherit;\n  margin-right: 6px;\n  vertical-align: middle;\n}\n.pcui-button[data-icon]:empty:before {\n  margin-right: 0;\n}\n\n.pcui-button:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-button:not(.pcui-disabled):not(.pcui-readonly):focus {\n  color: #ffffff;\n  background-color: #2c393c;\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-button:not(.pcui-disabled):not(.pcui-readonly):active {\n  background-color: #20292b;\n  box-shadow: none;\n}\n\n.pcui-button.pcui-readonly {\n  opacity: 0.7;\n  cursor: default;\n}\n\n.pcui-button.pcui-disabled {\n  opacity: 0.4;\n  cursor: default;\n}\n\n.pcui-button.pcui-small {\n  height: 24px;\n  line-height: 24px;\n  font-size: 10px;\n}");

const CLASS_BUTTON = 'pcui-button';

/**
 * @name Button
 * @class
 * @classdesc Represents a button.
 * @augments Element
 * @property {string} [text=Click Me] Gets / sets the text of the button
 * @property {string} size Gets / sets the 'size' type of the button. Can be null or 'small'.
 * @property {string} [icon=E401] The CSS code for an icon for the button. e.g. E401 (notice we omit the '\' character).
 * @mixes IFocusable
 */
class Button extends Element$1 {
    /**
     * Creates a new Button.
     *
     * @param {object} args - The arguments. Extends the pcui.Element constructor arguments. All settable properties can also be set through the constructor.
     * @param {boolean} [args.unsafe] - If true then the innerHTML property will be used to set the text. Otherwise textContent will be used instead.
     */
    constructor(args) {
        if (!args) args = {};

        super(args.dom ? args.dom : document.createElement('button'), args);

        this.class.add(CLASS_BUTTON);

        this._unsafe = args.unsafe || false;

        this.text = args.text || '';
        this.size = args.size || null;
        this.icon = args.icon || '';

        this._domEventKeyDown = this._onKeyDown.bind(this);
        this.dom.addEventListener('keydown', this._onKeyDown.bind(this));
    }

    // click on enter
    // blur on escape
    _onKeyDown(evt) {
        if (evt.keyCode === 27) {
            this.blur();
        } else if (evt.keyCode === 13) {
            this._onClick(evt);
        }
    }

    _onClick(evt) {
        this.blur();
        if (this.readOnly) return;

        super._onClick(evt);
    }

    focus() {
        this.dom.focus();
    }

    blur() {
        this.dom.blur();
    }

    destroy() {
        if (this._destroyed) return;

        this.dom.removeEventListener('keydown', this._domEventKeyDown);
        super.destroy();
    }

    set text(value) {
        if (this._text === value) return;
        this._text = value;
        if (this._unsafe) {
            this.dom.innerHTML = value;
        } else {
            this.dom.textContent = value;
        }
    }

    get text() {
        return this._text;
    }

    set icon(value) {
        if (this._icon === value || !value.match(/^E[0-9]{0,4}$/)) return;
        this._icon = value;
        if (value) {
            // set data-icon attribute but first convert the value to a code point
            this.dom.setAttribute('data-icon', String.fromCodePoint(parseInt(value, 16)));
        } else {
            this.dom.removeAttribute('data-icon');
        }
    }

    get icon() {
        return this._icon;
    }

    set size(value) {
        if (this._size === value) return;
        if (this._size) {
            this.class.remove('pcui-' + this._size);
            this._size = null;
        }

        this._size = value;

        if (this._size) {
            this.class.add('pcui-' + this._size);
        }
    }

    get size() {
        return this._size;
    }
}

Element$1.register('button', Button);

___$insertStyle(".pcui-container {\n  position: relative;\n  min-width: 0;\n  min-height: 0;\n}\n\n.pcui-container.pcui-resizable > .pcui-resizable-handle {\n  position: absolute;\n  z-index: 1;\n  opacity: 0;\n  background-color: transparent;\n}\n.pcui-container.pcui-resizable > .pcui-resizable-handle:hover {\n  opacity: 1;\n}\n.pcui-container.pcui-resizable.pcui-resizable-resizing > .pcui-resizable-handle {\n  opacity: 1;\n}\n.pcui-container.pcui-resizable.pcui-resizable-left > .pcui-resizable-handle, .pcui-container.pcui-resizable.pcui-resizable-right > .pcui-resizable-handle {\n  top: 0;\n  bottom: 0;\n  width: 1px;\n  height: auto;\n  cursor: ew-resize;\n}\n.pcui-container.pcui-resizable.pcui-resizable-left > .pcui-resizable-handle {\n  left: 0;\n  border-left: 3px solid #20292b;\n}\n.pcui-container.pcui-resizable.pcui-resizable-right > .pcui-resizable-handle {\n  right: 0;\n  border-right: 3px solid #20292b;\n}\n.pcui-container.pcui-resizable.pcui-resizable-top > .pcui-resizable-handle, .pcui-container.pcui-resizable.pcui-resizable-bottom > .pcui-resizable-handle {\n  left: 0;\n  right: 0;\n  width: auto;\n  height: 1px;\n  cursor: ns-resize;\n}\n.pcui-container.pcui-resizable.pcui-resizable-top > .pcui-resizable-handle {\n  top: 0;\n  border-top: 3px solid #20292b;\n}\n.pcui-container.pcui-resizable.pcui-resizable-bottom > .pcui-resizable-handle {\n  bottom: 0;\n  border-bottom: 3px solid #20292b;\n}\n\n.pcui-container-dragged {\n  outline: 2px solid #ffffff;\n  box-sizing: border-box;\n  opacity: 0.7;\n  z-index: 1;\n}\n\n.pcui-container-dragged-child {\n  outline: 1px dotted #f60;\n  box-sizing: border-box;\n}");

const RESIZE_HANDLE_SIZE = 4;

const VALID_RESIZABLE_VALUES = [
    null,
    'top',
    'right',
    'bottom',
    'left'
];

const CLASS_RESIZING = RESIZABLE + '-resizing';
const CLASS_RESIZABLE_HANDLE = 'pcui-resizable-handle';
const CLASS_CONTAINER = 'pcui-container';

const CLASS_DRAGGED = CLASS_CONTAINER + '-dragged';
const CLASS_DRAGGED_CHILD = CLASS_DRAGGED + '-child';

/**
 * @event
 * @name Container#append
 * @description Fired when a child Element gets added to the Container
 * @param {Element} element - The element that was added
 */

/**
 * @event
 * @name Container#remove
 * @description Fired when a child Element gets removed from the Container
 * @param {Element} element - The element that was removed
 */

/**
 * @event
 * @name Container#scroll
 * @description Fired when the container is scrolled.
 * @param {Event} evt - The native scroll event.
 */

/**
 * @event
 * @name Container#resize
 * @description Fired when the container gets resized using the resize handle.
 */

/**
 * @name Container
 * @class
 * @classdesc A container is the basic building block for Elements that are grouped together.
 * A container can contain any other element including other containers.
 * @augments Element
 * @mixes IContainer
 * @mixes IFlex
 * @mixes IGrid
 * @mixes IScrollable
 * @mixes IResizable
 */
class Container extends Element$1 {
    /**
     * Creates a new Container.
     *
     * @param {object} args - The arguments. Extends the pcui.Element constructor arguments. All settable properties can also be set through the constructor.
     * @param {HTMLElement} [args.dom] - The DOM element to use for the container. If unspecified a new element will be created.
     */
    constructor(args) {
        if (!args) args = {};

        const dom = args.dom || document.createElement('div');

        super(dom, args);

        this.class.add(CLASS_CONTAINER);

        this._domEventScroll = this._onScroll.bind(this);
        this.domContent = this._dom;

        // scroll
        this._scrollable = false;
        if (args.scrollable) {
            this.scrollable = true;
        }

        // flex
        this._flex = false;
        this.flex = !!args.flex;

        // grid
        this._grid = false;
        let grid = !!args.grid;
        if (grid) {
            if (this.flex) {
                console.error('Invalid pcui.Container arguments: "grid" and "flex" cannot both be true.');
                grid = false;
            }
        }
        this.grid = grid;

        // resize related
        this._domResizeHandle = null;
        this._domEventResizeStart = this._onResizeStart.bind(this);
        this._domEventResizeMove = this._onResizeMove.bind(this);
        this._domEventResizeEnd = this._onResizeEnd.bind(this);
        this._domEventResizeTouchStart = this._onResizeTouchStart.bind(this);
        this._domEventResizeTouchMove = this._onResizeTouchMove.bind(this);
        this._domEventResizeTouchEnd = this._onResizeTouchEnd.bind(this);
        this._resizeTouchId = null;
        this._resizeData = null;
        this._resizeHorizontally = true;

        this.resizable = args.resizable || null;
        this._resizeMin = 100;
        this._resizeMax = 300;

        if (args.resizeMin !== undefined) {
            this.resizeMin = args.resizeMin;
        }
        if (args.resizeMax !== undefined) {
            this.resizeMax = args.resizeMax;
        }

        this._draggedStartIndex = -1;
    }

    /**
     * @name Container#append
     * @description Appends an element to the container.
     * @param {Element} element - The element to append.
     * @fires 'append'
     */
    append(element) {
        const dom = this._getDomFromElement(element);
        this._domContent.appendChild(dom);
        this._onAppendChild(element);
    }

    /**
     * @name Container#appendBefore
     * @description Appends an element to the container before the specified reference element.
     * @param {Element} element - The element to append.
     * @param {Element} referenceElement - The element before which the element will be appended.
     * @fires 'append'
     */
    appendBefore(element, referenceElement) {
        const dom = this._getDomFromElement(element);
        this._domContent.appendChild(dom);
        const referenceDom =  referenceElement && this._getDomFromElement(referenceElement);

        this._domContent.insertBefore(dom, referenceDom);

        this._onAppendChild(element);
    }

    /**
     * @name Container#appendAfter
     * @description Appends an element to the container just after the specified reference element.
     * @param {Element} element - The element to append.
     * @param {Element} referenceElement - The element after which the element will be appended.
     * @fires 'append'
     */
    appendAfter(element, referenceElement) {
        const dom = this._getDomFromElement(element);
        const referenceDom = referenceElement && this._getDomFromElement(referenceElement);

        const elementBefore = referenceDom ? referenceDom.nextSibling : null;
        if (elementBefore) {
            this._domContent.insertBefore(dom, elementBefore);
        } else {
            this._domContent.appendChild(dom);
        }

        this._onAppendChild(element);
    }

    /**
     * @name Container#prepend
     * @description Inserts an element in the beginning of the container.
     * @param {Element} element - The element to prepend.
     * @fires 'append'
     */
    prepend(element) {
        const dom = this._getDomFromElement(element);
        const first = this._domContent.firstChild;
        if (first) {
            this._domContent.insertBefore(dom, first);
        } else {
            this._domContent.appendChild(dom);
        }

        this._onAppendChild(element);
    }

    /**
     * @name Container#remove
     * @description Removes the specified child element from the container.
     * @param {Element} element - The element to remove.
     * @fires 'remove'
     */
    remove(element) {
        if (element.parent !== this) return;

        const dom = this._getDomFromElement(element);
        this._domContent.removeChild(dom);

        this._onRemoveChild(element);
    }

    /**
     * @name Container#move
     * @description Moves the specified child at the specified index.
     * @param {Element} element - The element to move.
     * @param {number} index - The index
     */
    move(element, index) {
        let idx = -1;
        for (let i = 0; i < this.dom.childNodes.length; i++) {
            if (this.dom.childNodes[i].ui === element) {
                idx = i;
                break;
            }
        }

        if (idx === -1) {
            this.appendBefore(element, this.dom.childNodes[index]);
        } else if (index !== idx) {
            this.remove(element);
            if (index < idx) {
                this.appendBefore(element, this.dom.childNodes[index]);
            } else {
                this.appendAfter(element, this.dom.childNodes[index - 1]);
            }
        }
    }

    /**
     * @name Container#clear
     * @description Clears all children from the container.
     * @fires 'remove' for each child element.
     */
    clear() {
        let i = this._domContent.childNodes.length;
        while (i--) {
            const node = this._domContent.childNodes[i];
            if (node.ui && node.ui !== this) {
                node.ui.destroy();
            }
        }

        if (this._domResizeHandle) {
            this._domResizeHandle.removeEventListener('mousedown', this._domEventResizeStart);
            this._domResizeHandle.removeEventListener('touchstart', this._domEventResizeTouchStart, { passive: false });
            this._domResizeHandle = null;
        }

        this._domContent.innerHTML = '';

        if (this.resizable) {
            this._createResizeHandle();
            this._dom.appendChild(this._domResizeHandle);
        }
    }

    // Used for backwards compatibility with the legacy ui framework
    _getDomFromElement(element) {
        if (element.dom) {
            return element.dom;
        }

        if (element.element) {
            // console.log('Legacy ui.Element passed to pcui.Container', this.class, element.class);
            return element.element;
        }

        return element;
    }

    _onAppendChild(element) {
        element.parent = this;
        this.emit('append', element);
    }

    _onRemoveChild(element) {
        element.parent = null;
        this.emit('remove', element);
    }

    _onScroll(evt) {
        this.emit('scroll', evt);
    }

    _createResizeHandle() {
        const handle = document.createElement('div');
        handle.classList.add(CLASS_RESIZABLE_HANDLE);
        handle.ui = this;

        handle.addEventListener('mousedown', this._domEventResizeStart);
        handle.addEventListener('touchstart', this._domEventResizeTouchStart, { passive: false });

        this._domResizeHandle = handle;
    }

    _onResizeStart(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        window.addEventListener('mousemove', this._domEventResizeMove);
        window.addEventListener('mouseup', this._domEventResizeEnd);

        this._resizeStart();
    }

    _onResizeMove(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        this._resizeMove(evt.clientX, evt.clientY);
    }

    _onResizeEnd(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        window.removeEventListener('mousemove', this._domEventResizeMove);
        window.removeEventListener('mouseup', this._domEventResizeEnd);

        this._resizeEnd();
    }

    _onResizeTouchStart(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        for (let i = 0; i < evt.changedTouches.length; i++) {
            const touch = evt.changedTouches[i];
            if (touch.target === this._domResizeHandle) {
                this._resizeTouchId = touch.identifier;
            }
        }

        window.addEventListener('touchmove', this._domEventResizeTouchMove);
        window.addEventListener('touchend', this._domEventResizeTouchEnd);

        this._resizeStart();
    }

    _onResizeTouchMove(evt) {
        for (let i = 0; i < evt.changedTouches.length; i++) {
            const touch = evt.changedTouches[i];
            if (touch.identifier !== this._resizeTouchId) {
                continue;
            }

            evt.stopPropagation();
            evt.preventDefault();

            this._resizeMove(touch.clientX, touch.clientY);

            break;
        }
    }

    _onResizeTouchEnd(evt) {
        for (let i = 0; i < evt.changedTouches.length; i++) {
            const touch = evt.changedTouches[i];
            if (touch.identifier === this._resizeTouchId) {
                continue;
            }

            this._resizeTouchId = null;

            evt.preventDefault();
            evt.stopPropagation();

            window.removeEventListener('touchmove', this._domEventResizeTouchMove);
            window.removeEventListener('touchend', this._domEventResizeTouchEnd);

            this._resizeEnd();

            break;
        }
    }

    _resizeStart() {
        this.class.add(CLASS_RESIZING);
    }

    _resizeMove(x, y) {
        // if we haven't initialized resizeData do so now
        if (!this._resizeData) {
            this._resizeData = {
                x: x,
                y: y,
                width: this.dom.clientWidth,
                height: this.dom.clientHeight
            };

            return;
        }

        if (this._resizeHorizontally) {
            // horizontal resizing
            let offsetX = this._resizeData.x - x;

            if (this._resizable === 'right') {
                offsetX = -offsetX;
            }

            this.width = RESIZE_HANDLE_SIZE + Math.max(this._resizeMin, Math.min(this._resizeMax, (this._resizeData.width + offsetX)));
        } else {
            // vertical resizing
            let offsetY = this._resizeData.y - y;

            if (this._resizable === 'bottom') {
                offsetY = -offsetY;
            }

            this.height = Math.max(this._resizeMin, Math.min(this._resizeMax, (this._resizeData.height + offsetY)));
        }

        this.emit('resize');
    }

    _resizeEnd() {
        this._resizeData = null;
        this.class.remove(CLASS_RESIZING);
    }

    /**
     * Resize the container
     *
     * @param {number} x - The amount of pixels to resize the width
     * @param {number} y - The amount of pixels to resize the height
     */
    resize(x, y) {
        x = x || 0;
        y = y || 0;

        this._resizeStart();
        this._resizeMove(0, 0);
        this._resizeMove(-x + RESIZE_HANDLE_SIZE, -y);
        this._resizeEnd();
    }

    _getDraggedChildIndex(draggedChild) {
        for (let i = 0; i < this.dom.childNodes.length; i++) {
            if (this.dom.childNodes[i].ui === draggedChild) {
                return i;
            }
        }

        return -1;
    }

    _onChildDragStart(evt, childPanel) {
        this.class.add(CLASS_DRAGGED_CHILD);

        this._draggedStartIndex = this._getDraggedChildIndex(childPanel);

        childPanel.class.add(CLASS_DRAGGED);

        this._draggedHeight = childPanel.height;

        this.emit('child:dragstart', childPanel, this._draggedStartIndex);
    }

    _onChildDragMove(evt, childPanel) {
        const rect = this.dom.getBoundingClientRect();

        const dragOut = (evt.clientX < rect.left || evt.clientX > rect.right || evt.clientY < rect.top || evt.clientY > rect.bottom);

        const childPanelIndex = this._getDraggedChildIndex(childPanel);

        if (dragOut) {
            childPanel.class.remove(CLASS_DRAGGED);
            if (this._draggedStartIndex !== childPanelIndex) {
                this.remove(childPanel);
                if (this._draggedStartIndex < childPanelIndex) {
                    this.appendBefore(childPanel, this.dom.childNodes[this._draggedStartIndex]);
                } else {
                    this.appendAfter(childPanel, this.dom.childNodes[this._draggedStartIndex - 1]);
                }
            }

            return;
        }

        childPanel.class.add(CLASS_DRAGGED);

        const y = evt.clientY - rect.top;
        let ind = null;

        // hovered script
        for (let i = 0; i < this.dom.childNodes.length; i++) {
            const otherPanel = this.dom.childNodes[i].ui;
            const otherTop = otherPanel.dom.offsetTop;
            if (i < childPanelIndex) {
                if (y <= otherTop + otherPanel.header.height) {
                    ind = i;
                    break;
                }
            } else if (i > childPanelIndex) {
                if (y + childPanel.height >= otherTop + otherPanel.height) {
                    ind = i;
                    break;
                }
            }
        }

        if (ind !== null && childPanelIndex !== ind) {
            this.remove(childPanel);
            if (ind < childPanelIndex) {
                this.appendBefore(childPanel, this.dom.childNodes[ind]);
            } else {
                this.appendAfter(childPanel, this.dom.childNodes[ind - 1]);
            }
        }
    }

    _onChildDragEnd(evt, childPanel) {
        this.class.remove(CLASS_DRAGGED_CHILD);

        childPanel.class.remove(CLASS_DRAGGED);

        const index = this._getDraggedChildIndex(childPanel);

        this.emit('child:dragend', childPanel, index, this._draggedStartIndex);

        this._draggedStartIndex = -1;
    }

    forEachChild(fn) {
        for (let i = 0; i < this.dom.childNodes.length; i++) {
            const node = this.dom.childNodes[i].ui;
            if (node) {
                const result = fn(node, i);
                if (result === false) {
                    // early out
                    break;
                }
            }
        }
    }

    /**
     * If the current node contains a root, recursively append it's children to this node
     * and return it. Otherwise return the current node. Also add each child to the parent
     * under its keyed name.
     *
     * @param {object} node - The current element in the dom structure which must be recursively
     * traversed and appended to it's parent
     *
     * @returns {Element} - The recursively appended element node
     *
     */
    _buildDomNode(node) {
        const keys = Object.keys(node);
        let rootNode;
        if (keys.includes('root')) {
            rootNode = this._buildDomNode(node.root);
            node.children.forEach((childNode) => {
                const childNodeElement = this._buildDomNode(childNode);
                if (childNodeElement !== null) {
                    rootNode.append(childNodeElement);
                }
            });
        } else {
            rootNode = node[keys[0]];
            this[`_${keys[0]}`] = rootNode;
        }
        return rootNode;
    }

    /**
     * Takes an array of pcui elements, each of which can contain their own child elements, and
     * appends them to this container. These child elements are traversed recursively using
     * _buildDomNode.
     *
     * @param {Array} dom - An array of child pcui elements to append to this container.
     *
     * @example
     * buildDom([
     *     {
     *         child1: pcui.Label()
     *     },
     *     {
     *         root: {
     *             container1: pcui.Container()
     *         },
     *         children: [
     *             {
     *                 child2: pcui.Label()
     *             },
     *             {
     *                 child3: pcui.Label()
     *             }
     *         ]
     *     }
     * ]);
     */
    buildDom(dom) {
        dom.forEach((node) => {
            const builtNode = this._buildDomNode(node);
            this.append(builtNode);
        });
    }

    destroy() {
        if (this._destroyed) return;
        this.domContent = null;

        if (this._domResizeHandle) {
            this._domResizeHandle.removeEventListener('mousedown', this._domEventResizeStart);
            window.removeEventListener('mousemove', this._domEventResizeMove);
            window.removeEventListener('mouseup', this._domEventResizeEnd);

            this._domResizeHandle.removeEventListener('touchstart', this._domEventResizeTouchStart);
            window.removeEventListener('touchmove', this._domEventResizeTouchMove);
            window.removeEventListener('touchend', this._domEventResizeTouchEnd);
        }

        this._domResizeHandle = null;
        this._domEventResizeStart = null;
        this._domEventResizeMove = null;
        this._domEventResizeEnd = null;
        this._domEventResizeTouchStart = null;
        this._domEventResizeTouchMove = null;
        this._domEventResizeTouchEnd = null;
        this._domEventScroll = null;

        super.destroy();
    }

    set flex(value) {
        if (value === this._flex) return;

        this._flex = value;

        if (value) {
            this.classAdd(FLEX);
        } else {
            this.classRemove(FLEX);
        }
    }

    get flex() {
        return this._flex;
    }

    set grid(value) {
        if (value === this._grid) return;

        this._grid = value;

        if (value) {
            this.classAdd(GRID);
        } else {
            this.classRemove(GRID);
        }
    }

    get grid() {
        return this._grid;
    }

    set scrollable(value) {
        if (this._scrollable === value) return;

        this._scrollable = value;

        if (value) {
            this.classAdd(SCROLLABLE);
        } else {
            this.classRemove(SCROLLABLE);
        }

    }

    get scrollable() {
        return this._scrollable;
    }

    set resizable(value) {
        if (value === this._resizable) return;

        if (VALID_RESIZABLE_VALUES.indexOf(value) === -1) {
            console.error('Invalid resizable value: must be one of ' + VALID_RESIZABLE_VALUES.join(','));
            return;
        }

        // remove old class
        if (this._resizable) {
            this.classRemove(`${RESIZABLE}-${this._resizable}`);
        }

        this._resizable = value;
        this._resizeHorizontally = (value === 'right' || value === 'left');

        if (value) {
            // add resize class and create / append resize handle
            this.classAdd(RESIZABLE);
            this.classAdd(`${RESIZABLE}-${value}`);

            if (!this._domResizeHandle) {
                this._createResizeHandle();
            }
            this._dom.appendChild(this._domResizeHandle);
        } else {
            // remove resize class and resize handle
            this.classRemove(RESIZABLE);
            if (this._domResizeHandle) {
                this._dom.removeChild(this._domResizeHandle);
            }
        }
    }

    get resizable() {
        return this._resizable;
    }

    set resizeMin(value) {
        this._resizeMin = Math.max(0, Math.min(value, this._resizeMax));
    }

    get resizeMin() {
        return this._resizeMin;
    }

    set resizeMax(value) {
        this._resizeMax = Math.max(this._resizeMin, value);
    }

    get resizeMax() {
        return this._resizeMax;
    }

    // The internal dom element used as a the container of all children.
    // Can be overriden by derived classes
    set domContent(value) {
        if (this._domContent === value) return;

        if (this._domContent) {
            this._domContent.removeEventListener('scroll', this._domEventScroll);
        }

        this._domContent = value;

        if (this._domContent) {
            this._domContent.addEventListener('scroll', this._domEventScroll);
        }
    }

    get domContent() {
        return this._domContent;
    }
}

Element$1.register('container', Container);

___$insertStyle(".pcui-code {\n  background: #20292b;\n  overflow: auto;\n}\n.pcui-code .pcui-code-inner {\n  color: #f60;\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 10px;\n  white-space: pre;\n}");

const CLASS_ROOT$7 = 'pcui-code';
const CLASS_INNER$1 = CLASS_ROOT$7 + '-inner';

/**
 * @name Code
 * @augments Container
 * @property {string} text The Text to display in the code block
 * @class
 * @classdesc Represents a code block.
 */
class Code extends Container {
    /**
     * Creates a new spinner.
     *
     * @param {object} [args] - The arguments
     * @param {string} [args.text] - The text to display in the code block;
     */
    constructor(args) {
        if (!args) args = {};
        super(args);
        this.class.add(CLASS_ROOT$7);

        this._inner = new Label();
        this.append(this._inner);
        this._inner.class.add(CLASS_INNER$1);
        if (args.text) {
            this.text = args.text;
        }
    }

    set text(value) {
        this._text = value;
        this._inner.text = value;
    }

    get text() {
        return this._text;
    }
}

Element$1.register('code', Code);

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .pcui-panel-header-title, .pcui-panel-header, .font-icon, .pcui-panel.pcui-collapsible > .pcui-panel-header:before {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-panel.pcui-collapsible > .pcui-panel-header:before {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-panel-header > .pcui-panel-sortable-icon {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-panel-header > .pcui-panel-sortable-icon:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-panel {\n  background-color: #364346;\n}\n\n.pcui-panel-header {\n  background-color: #293538;\n  color: #ffffff;\n  font-size: 12px;\n  white-space: nowrap;\n  padding-left: 10px;\n  flex-shrink: 0;\n  align-items: center;\n}\n\n.pcui-panel-header-title {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex: 1;\n  color: inherit;\n  font-size: inherit;\n  white-space: inherit;\n  margin: 0 auto 0 0;\n}\n\n.pcui-panel-content {\n  flex: 1;\n}\n\n.pcui-panel.pcui-collapsible {\n  transition: height 100ms, width 100ms;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header {\n  cursor: pointer;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header:before {\n  left: 0;\n  content: \"\\e179\";\n  font-size: 14px;\n  margin-right: 10px;\n  text-align: center;\n  color: #f60;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header:hover {\n  color: #ffffff;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-header:hover:before {\n  color: #ffffff;\n}\n.pcui-panel.pcui-collapsible.pcui-panel-normal > .pcui-panel-header:before {\n  content: \"\\e183\";\n  font-weight: 200;\n}\n.pcui-panel.pcui-collapsible > .pcui-panel-content {\n  transition: visibility 100ms;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed {\n  overflow: hidden;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed > .pcui-panel-content {\n  visibility: hidden;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed > .pcui-panel-header:before {\n  content: \"\\e180\";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-normal > .pcui-panel-header:before {\n  content: \"\\e184\";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal > .pcui-panel-header {\n  width: 2048px;\n  -webkit-transform: rotate(90deg);\n  -moz-transform: rotate(90deg);\n  -ms-transform: rotate(90deg);\n  -o-transform: rotate(90deg);\n  transform: rotate(90deg);\n  -webkit-transform-origin: 0% 100%;\n  -moz-transform-origin: 0% 100%;\n  -ms-transform-origin: 0% 100%;\n  -o-transform-origin: 0% 100%;\n  transform-origin: 0% 100%;\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal > .pcui-panel-header:before {\n  content: \"\\e177\";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal.pcui-panel-normal > .pcui-panel-header:before {\n  content: \"\\e181\";\n}\n.pcui-panel.pcui-collapsible.pcui-collapsed.pcui-panel-horizontal > .pcui-panel-content {\n  transition: none;\n}\n\n.pcui-panel.pcui-resizable.pcui-collapsible.pcui-collapsed > .pcui-resizable-handle {\n  display: none;\n}\n.pcui-panel.pcui-resizable.pcui-resizable-resizing {\n  transition: none;\n}\n.pcui-panel.pcui-resizable.pcui-resizable-resizing > .pcui-panel-content {\n  transition: none;\n}\n\n.pcui-panel-header > .pcui-panel-sortable-icon {\n  color: #5b7073;\n  transition: color 100ms;\n  flex-direction: row;\n  align-items: center;\n  margin: 0 10px 0 0;\n  height: 100%;\n}\n.pcui-panel-header > .pcui-panel-sortable-icon:before {\n  content: \" \";\n  border-left: 1px solid #364346;\n  margin-right: 10px;\n  height: calc(100% - 14px);\n  flex-shrink: 0;\n}\n.pcui-panel-header > .pcui-panel-sortable-icon:after {\n  content: \".. .. ..\";\n  white-space: normal;\n  width: 12px;\n  line-height: 5px;\n  overflow: hidden;\n  height: 24px;\n  font-size: 22px;\n  letter-spacing: 1px;\n  flex-shrink: 0;\n}\n\n.pcui-panel:not(.pcui-disabled):not(.pcui-readonly) > .pcui-panel-header > .pcui-panel-sortable-icon:hover {\n  color: #ffffff;\n  cursor: move;\n}\n\n.pcui-panel:not(.pcui-collapsible) > .pcui-panel-header > .pcui-panel-sortable-icon:before {\n  display: none;\n}\n\n.pcui-panel-remove {\n  align-self: flex-end;\n  order: 100;\n}\n.pcui-panel-remove:before {\n  line-height: 30px;\n}\n\n.pcui-panel.pcui-readonly .pcui-panel-remove {\n  display: none;\n}\n\n.pcui-panel-header > .pcui-button {\n  flex-shrink: 0;\n  margin: 1px;\n  background-color: transparent;\n  border: 0;\n}\n\n.pcui-panel.pcui-disabled > .pcui-panel-header {\n  background-color: #303d40;\n  color: #999;\n}\n\n.pcui-subpanel {\n  box-sizing: border-box;\n  margin: 6px;\n  border: 1px solid #293538;\n  border-radius: 2px;\n  background-color: #2c393c;\n  color: #b1b8ba;\n  font-size: 12px;\n}\n.pcui-subpanel .pcui-button {\n  background-color: #364346;\n  border-color: #293538;\n}\n.pcui-subpanel .pcui-button:not(.pcui-disabled):not(.pcui-readonly):hover, .pcui-subpanel .pcui-button:not(.pcui-disabled):not(.pcui-readonly):focus {\n  background-color: #364346;\n}\n.pcui-subpanel .pcui-button:not(.pcui-disabled):not(.pcui-readonly):active {\n  background-color: #2c393c;\n}");

const CLASS_PANEL = 'pcui-panel';
const CLASS_PANEL_HEADER = CLASS_PANEL + '-header';
const CLASS_PANEL_HEADER_TITLE = CLASS_PANEL_HEADER + '-title';
const CLASS_PANEL_CONTENT = CLASS_PANEL + '-content';
const CLASS_PANEL_HORIZONTAL = CLASS_PANEL + '-horizontal';
const CLASS_PANEL_SORTABLE_ICON = CLASS_PANEL + '-sortable-icon';
const CLASS_PANEL_REMOVE = CLASS_PANEL + '-remove';

// TODO: document panelType

/**
 * @event
 * @name Panel#collapse
 * @description Fired when the panel gets collapsed
 */

/**
 * @event
 * @name Panel#expand
 * @description Fired when the panel gets expanded
 */

/**
 * @name Panel
 * @class
 * @classdesc The Panel is a pcui.Container that itself contains a header container and a content container. The
 * respective pcui.Container functions work using the content container. One can also append elements to the header of the Panel.
 * @property {boolean} flex Gets / sets whether the container supports flex layout. Defaults to false. Cannot co-exist with grid.
 * @property {boolean} grid Gets / sets whether the container supports grid layout. Defaults to false. Cannot co-exist with flex.
 * @property {boolean} sortable Gets / sets whether the panel can be reordered
 * @property {boolean} collapseHorizontally Gets / sets whether the panel collapses horizontally - this would be the case for side panels. Defaults to false.
 * @property {boolean} removable Gets / sets whether the panel can be removed
 * @property {number} headerSize=32 The height of the header in pixels. Defaults to 32.
 * @property {string} headerText The header text of the panel. Defaults to the empty string.
 * @property {Container} header Gets the header container.
 * @property {Container} content Gets the content container.
 * @augments Container
 * @mixes IContainer
 * @mixes IFlex
 * @mixes IGrid
 * @mixes ICollapsible
 * @mixes IScrollable
 * @mixes IResizable
 */
class Panel extends Container {
    /**
     * Creates a new Panel.
     *
     * @param {object} args - The arguments. Extends the pcui.Container constructor arguments. All settable properties can also be set through the constructor.
     */
    constructor(args) {
        if (!args) args = {};

        const panelArgs = Object.assign({}, args);
        panelArgs.flex = true;
        delete panelArgs.grid;
        delete panelArgs.flexDirection;
        delete panelArgs.scrollable;

        super(panelArgs);

        this.class.add(CLASS_PANEL);

        if (args.panelType) {
            this.class.add(CLASS_PANEL + '-' + args.panelType);
        }

        // do not call reflow on every update while
        // we are initializing
        this._suspendReflow = true;

        // initialize header container
        this._initializeHeader(args);

        // initialize content container
        this._initializeContent(args);

        // header size
        this.headerSize = args.headerSize !== undefined ? args.headerSize : 32;

        this._domEvtDragStart = this._onDragStart.bind(this);
        this._domEvtDragMove = this._onDragMove.bind(this);
        this._domEvtDragEnd = this._onDragEnd.bind(this);

        // collapse related
        this._reflowTimeout = null;
        this._widthBeforeCollapse = null;
        this._heightBeforeCollapse = null;

        this.collapsible = args.collapsible || false;
        this.collapsed = args.collapsed || false;
        this.collapseHorizontally = args.collapseHorizontally || false;

        this._iconSort = null;
        this.sortable = args.sortable || false;

        this._btnRemove = null;
        this.removable = args.removable || false;

        // set the contents container to be the content DOM element
        // from now on calling append functions on the panel will append themn
        // elements to the contents container
        this.domContent = this._containerContent.dom;

        // execute reflow now after all fields have been initialized
        this._suspendReflow = false;
        this._reflow();
    }

    _initializeHeader(args) {
        // header container
        this._containerHeader = new Container({
            flex: true,
            flexDirection: 'row',
            class: [CLASS_PANEL_HEADER, FONT_BOLD]
        });

        // header title
        this._labelTitle = new Label({
            text: args.headerText,
            class: [CLASS_PANEL_HEADER_TITLE, FONT_BOLD]
        });
        this._containerHeader.append(this._labelTitle);

        // use native click listener because the pcui.Element#click event is only fired
        // if the element is enabled. However we still want to catch header click events in order
        // to collapse them
        this._containerHeader.dom.addEventListener('click', this._onHeaderClick.bind(this));

        this.append(this._containerHeader);
    }

    _onHeaderClick(evt) {
        if (!this._collapsible) return;
        if (evt.target !== this.header.dom && evt.target !== this._labelTitle.dom) return;

        // toggle collapsed
        this.collapsed = !this.collapsed;
    }

    _onClickRemove(evt) {
        evt.preventDefault();
        evt.stopPropagation();

        this.emit('click:remove');
    }

    _initializeContent(args) {
        // containers container
        this._containerContent = new Container({
            class: CLASS_PANEL_CONTENT,
            grid: args.grid,
            flex: args.flex,
            flexDirection: args.flexDirection,
            scrollable: args.scrollable,
            dom: args.container
        });

        this.append(this._containerContent);
    }

    // Collapses or expands the panel as needed
    _reflow() {
        if (this._suspendReflow) {
            return;
        }

        if (this._reflowTimeout) {
            cancelAnimationFrame(this._reflowTimeout);
            this._reflowTimeout = null;
        }

        if (this.hidden || !this.collapsible) return;

        if (this.collapsed && this.collapseHorizontally) {
            this._containerHeader.style.top = -this.headerSize + 'px';
        } else {
            this._containerHeader.style.top = '';
        }

        // we rely on the content width / height and we have to
        // wait for 1 frame before we can get the final values back
        this._reflowTimeout = requestAnimationFrame(() => {
            this._reflowTimeout = null;

            if (this.collapsed) {
                // remember size before collapse
                if (!this._widthBeforeCollapse) {
                    this._widthBeforeCollapse = this.style.width;
                }
                if (!this._heightBeforeCollapse) {
                    this._heightBeforeCollapse = this.style.height;
                }

                if (this._collapseHorizontally) {
                    this.height = '';
                    this.width = this.headerSize;
                } else {
                    this.height = this.headerSize;
                }

                // add collapsed class after getting the width and height
                // because if we add it before then because of overflow:hidden
                // we might get innacurate width/heights.
                this.class.add(COLLAPSED);
            } else {
                // remove collapsed class first and the restore width and height
                // (opposite order of collapsing)
                this.class.remove(COLLAPSED);

                if (this._collapseHorizontally) {
                    this.height = '';
                    if (this._widthBeforeCollapse !== null) {
                        this.width = this._widthBeforeCollapse;
                    }
                } else {
                    if (this._heightBeforeCollapse !== null) {
                        this.height = this._heightBeforeCollapse;
                    }
                }

                // reset before collapse vars
                this._widthBeforeCollapse = null;
                this._heightBeforeCollapse = null;
            }
        });
    }

    _onDragStart(evt) {
        if (this.disabled || this.readOnly) return;

        evt.stopPropagation();
        evt.preventDefault();

        window.addEventListener('mouseup', this._domEvtDragEnd);
        window.addEventListener('mouseleave', this._domEvtDragEnd);
        window.addEventListener('mousemove', this._domEvtDragMove);

        this.emit('dragstart');
        if (this.parent && this.parent._onChildDragStart) {
            this.parent._onChildDragStart(evt, this);
        }
    }

    _onDragMove(evt) {
        this.emit('dragmove');
        if (this.parent && this.parent._onChildDragStart) {
            this.parent._onChildDragMove(evt, this);
        }
    }

    _onDragEnd(evt) {
        window.removeEventListener('mouseup', this._domEvtDragEnd);
        window.removeEventListener('mouseleave', this._domEvtDragEnd);
        window.removeEventListener('mousemove', this._domEvtDragMove);

        if (this._draggedChild === this) {
            this._draggedChild = null;
        }

        this.emit('dragend');
        if (this.parent && this.parent._onChildDragStart) {
            this.parent._onChildDragEnd(evt, this);
        }
    }


    destroy() {
        if (this._destroyed) return;
        if (this._reflowTimeout) {
            cancelAnimationFrame(this._reflowTimeout);
            this._reflowTimeout = null;
        }

        window.removeEventListener('mouseup', this._domEvtDragEnd);
        window.removeEventListener('mouseleave', this._domEvtDragEnd);
        window.removeEventListener('mousemove', this._domEvtDragMove);

        super.destroy();
    }

    set collapsible(value) {
        if (value === this._collapsible) return;

        this._collapsible = value;

        if (value) {
            this.classAdd(COLLAPSIBLE);
        } else {
            this.classRemove(COLLAPSIBLE);
        }

        this._reflow();

        if (this.collapsed) {
            this.emit(value ? 'collapse' : 'expand');
        }

    }

    get collapsible() {
        return this._collapsible;
    }

    set collapsed(value) {
        if (this._collapsed === value) return;

        this._collapsed = value;

        this._reflow();

        if (this.collapsible) {
            this.emit(value ? 'collapse' : 'expand');
        }
    }

    get collapsed() {
        return this._collapsed;
    }

    set sortable(value) {
        if (this._sortable === value) return;

        this._sortable = value;

        if (value) {
            this._iconSort = new Label({
                class: CLASS_PANEL_SORTABLE_ICON
            });

            this._iconSort.dom.addEventListener('mousedown', this._domEvtDragStart);

            this.header.prepend(this._iconSort);
        } else if (this._iconSort) {
            this._iconSort.destroy();
            this._iconSort = null;
        }
    }

    get sortable() {
        return this._sortable;
    }

    set removable(value) {
        if (this.removable === value) return;

        if (value) {
            this._btnRemove = new Button({
                icon: 'E289',
                class: CLASS_PANEL_REMOVE
            });
            this._btnRemove.on('click', this._onClickRemove.bind(this));
            this.header.append(this._btnRemove);
        } else {
            this._btnRemove.destroy();
            this._btnRemove = null;
        }
    }

    get removable() {
        return !!this._btnRemove;
    }

    set collapseHorizontally(value) {
        if (this._collapseHorizontally === value) return;

        this._collapseHorizontally = value;
        if (value) {
            this.classAdd(CLASS_PANEL_HORIZONTAL);
        } else {
            this.classRemove(CLASS_PANEL_HORIZONTAL);
        }

        this._reflow();
    }

    get collapseHorizontally() {
        return this._collapseHorizontally;
    }

    get content() {
        return this._containerContent;
    }

    get header() {
        return this._containerHeader;
    }

    set headerText(value) {
        this._labelTitle.text = value;
    }

    get headerText() {
        return this._labelTitle.text;
    }

    set headerSize(value) {
        this._headerSize = value;
        const style = this._containerHeader.dom.style;
        style.height = Math.max(0, value) + 'px';
        style.lineHeight = style.height;
        this._reflow();
    }

    get headerSize() {
        return this._headerSize;
    }
}

Element$1.register('panel', Panel);

___$insertStyle(".noSelect, .pcui-overlay-inner {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-overlay {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-overlay:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-overlay {\n  position: absolute;\n  width: auto;\n  height: auto;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 101;\n  transition: opacity 100ms, visibility 100ms;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n}\n\n.pcui-overlay-inner {\n  position: absolute;\n  width: auto;\n  height: auto;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-color: rgba(32, 41, 43, 0.7);\n}\n\n.pcui-overlay-clickable > .pcui-overlay-inner {\n  cursor: pointer;\n}\n\n.pcui-overlay-transparent > .pcui-overlay-inner {\n  background-color: transparent;\n}\n\n.pcui-overlay-content {\n  background-color: #364346;\n  transition: width 100ms, height 100ms, margin-left 100ms, margin-top 100ms;\n  box-shadow: 7px 7px 7px rgba(0, 0, 0, 0.15);\n}");

const CLASS_OVERLAY = 'pcui-overlay';
const CLASS_OVERLAY_INNER = CLASS_OVERLAY + '-inner';
const CLASS_OVERLAY_CLICKABLE = CLASS_OVERLAY + '-clickable';
const CLASS_OVERLAY_TRANSPARENT = CLASS_OVERLAY + '-transparent';
const CLASS_OVERLAY_CONTENT = CLASS_OVERLAY + '-content';

/**
 * @name Overlay
 * @class
 * @classdesc An overlay element.
 * @property {boolean} clickable Whether the overlay can be hidden by clicking on it.
 * @property {boolean} transparent Whether the overlay is transparent.
 * @augments Container
 */
class Overlay extends Container {
    /**
     * Creates a new pcui.Overlay.
     *
     * @param {object} args - The arguments.
     */
    constructor(args) {
        if (!args) args = {};
        super(args);

        this.class.add(CLASS_OVERLAY);

        this._domClickableOverlay = document.createElement('div');
        this._domClickableOverlay.ui = this;
        this._domClickableOverlay.classList = CLASS_OVERLAY_INNER;
        this.dom.appendChild(this._domClickableOverlay);

        this._domEventMouseDown = this._onMouseDown.bind(this);
        this._domClickableOverlay.addEventListener('mousedown', this._domEventMouseDown);

        this.domContent = document.createElement('div');
        this.domContent.ui = this;
        this.domContent.classList.add(CLASS_OVERLAY_CONTENT);
        this.dom.appendChild(this.domContent);

        this.clickable = args.clickable || false;
        this.transparent = args.transparent || false;
    }

    _onMouseDown(evt) {
        if (!this.clickable) return;

        // some field might be in focus
        document.body.blur();

        // wait till blur is done
        requestAnimationFrame(() => {
            this.hidden = true;
        });

        evt.preventDefault();
    }

    /**
     * @name Overlay#position
     * @description Position the overlay at specific x, y coordinates.
     * @param {number} x - The x coordinate
     * @param {number} y - The y coordinate
     */
    position(x, y) {
        const area = this._domClickableOverlay.getBoundingClientRect();
        const rect = this.domContent.getBoundingClientRect();

        x = Math.max(0, Math.min(area.width - rect.width, x));
        y = Math.max(0, Math.min(area.height - rect.height, y));

        this.domContent.style.position = 'absolute';
        this.domContent.style.left = `${x}px`;
        this.domContent.style.top = `${y}px`;
    }

    destroy() {
        if (this._destroyed) return;
        this._domClickableOverlay.removeEventListener('mousedown', this._domEventMouseDown);
        super.destroy();
    }

    set clickable(value) {
        if (value) {
            this.class.add(CLASS_OVERLAY_CLICKABLE);
        } else {
            this.class.remove(CLASS_OVERLAY_CLICKABLE);
        }
    }

    get clickable() {
        return this.class.contains(CLASS_OVERLAY_CLICKABLE);
    }

    set transparent(value) {
        if (value) {
            this.class.add(CLASS_OVERLAY_TRANSPARENT);
        } else {
            this.class.remove(CLASS_OVERLAY_TRANSPARENT);
        }
    }

    get transparent() {
        return this.class.contains(CLASS_OVERLAY_TRANSPARENT);
    }
}

Element$1.register('overlay', Overlay);

___$insertStyle(".pcui-divider {\n  height: 1px;\n  background-color: #2c393c;\n  margin: 6px 0;\n}");

const CLASS_ROOT$6 = 'pcui-divider';

/**
 * @name Divider
 * @augments Element
 * @class
 * @classdesc Represents a vertical division between two elements
 */
class Divider extends Element$1 {
    constructor(args) {
        if (!args) args = {};
        super(args.dom ? args.dom : document.createElement('div'), args);

        this.class.add(CLASS_ROOT$6);
    }
}

Element$1.register('divider', Divider);

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-infobox[data-icon]:not(.pcui-hidden):before {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-infobox[data-icon]:not(.pcui-hidden):before {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.pcui-infobox {\n  box-sizing: border-box;\n  margin: 6px;\n  padding: 12px;\n  border: 1px solid #293538;\n  border-radius: 2px;\n  background-color: #2c393c;\n  color: #b1b8ba;\n  font-size: 12px;\n}\n.pcui-infobox :first-child {\n  color: #ffffff;\n  margin-bottom: 2px;\n}\n.pcui-infobox[data-icon]:not(.pcui-hidden) {\n  display: grid;\n  grid: auto-flow/min-content 1fr;\n}\n.pcui-infobox[data-icon]:not(.pcui-hidden):before {\n  content: attr(data-icon);\n  font-weight: 100;\n  font-size: 16px;\n  margin-right: 12px;\n  vertical-align: middle;\n  grid-column: 1;\n  grid-row: 1/3;\n}");

const CLASS_INFOBOX = 'pcui-infobox';

/**
 * @name InfoBox
 * @class
 * @classdesc Represents an information box.
 * @augments Container
 * @property {string} icon=E401 The CSS code for an icon for the info box. e.g. E401 (notice we omit the '\' character).
 * @property {string} title=Title Gets / sets the 'title' of the info box
 * @property {string} text=Text Gets / sets the 'text' of the info box
 */
class InfoBox extends Container {
    /**
     * Creates a new InfoBox.
     *
     * @param {object} args - The arguments. Extends the pcui.Container constructor arguments. All settable properties can also be set through the constructor.
     * @param {boolean} [args.unsafe] - If true then the innerHTML property will be used to set the title/text. Otherwise textContent will be used instead.
     */
    constructor(args) {
        if (!args) args = {};
        super(args);

        this.class.add(CLASS_INFOBOX);
        this._titleElement = new Element$1();
        this._textElement = new Element$1();
        this.append(this._titleElement);
        this.append(this._textElement);

        this._unsafe = args.unsafe || false;

        this.icon = args.icon || '';
        this.title = args.title || '';
        this.text = args.text || '';
    }

    set icon(value) {
        if (this._icon === value) return;
        this._icon = value;
        if (value) {
            // set data-icon attribute but first convert the value to a code point
            this.dom.setAttribute('data-icon', String.fromCodePoint(parseInt(value, 16)));
        } else {
            this.dom.removeAttribute('data-icon');
        }
    }

    get icon() {
        return this._icon;
    }

    set title(value) {
        if (this._title === value) return;
        this._title = value;
        if (this._unsafe) {
            this._titleElement.dom.innerHTML = value;
        } else {
            this._titleElement.dom.textContent = value;
        }
    }

    get title() {
        return this._title;
    }

    set text(value) {
        if (this._text === value) return;
        this._text = value;
        if (this._unsafe) {
            this._textElement.dom.innerHTML = value;
        } else {
            this._textElement.dom.textContent = value;
        }
    }

    get text() {
        return this._text;
    }
}

Element$1.register('infobox', InfoBox);

// calculate, how many string `a`
// requires edits, to become string `b`
const searchStringEditDistance = function (a, b) {
    // Levenshtein distance
    // https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    if (a === b) return 0;

    var i, j;
    var matrix = [];

    for (i = 0; i <= b.length; i++)
        matrix[i] = [i];

    for (j = 0; j <= a.length; j++)
        matrix[0][j] = j;

    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
            }
        }
    }

    return matrix[b.length][a.length];
};


// calculate, how many characters string `b`
// contains of a string `a`
const searchCharsContains = function (a, b) {
    if (a === b)
        return a.length;

    var contains = 0;
    var ind = { };
    var i;

    for (i = 0; i < b.length; i++)
        ind[b.charAt(i)] = true;

    for (i = 0; i < a.length; i++) {
        if (ind[a.charAt(i)])
            contains++;
    }

    return contains;
};


// tokenize string into array of tokens
const searchStringTokenize = function (name) {
    var tokens = [];

    // camelCase
    // upperCASE123
    var string = name.replace(/([^A-Z])([A-Z][^A-Z])/g, '$1 $2').replace(/([A-Z0-9]{2,})/g, ' $1');

    // space notation
    // dash-notation
    // underscore_notation
    var parts = string.split(/(\s|\-|_)/g);

    // filter valid tokens
    for (var i = 0; i < parts.length; i++) {
        parts[i] = parts[i].toLowerCase().trim();
        if (parts[i] && parts[i] !== '-' && parts[i] !== '_')
            tokens.push(parts[i]);
    }

    return tokens;
};


const _searchItems = function (items, search, args) {
    var results = [];

    for (var i = 0; i < items.length; i++) {
        var item = items[i];

        // direct hit
        if (item.subFull !== Infinity) {
            results.push(item);

            if (item.edits === Infinity)
                item.edits = 0;

            if (item.sub === Infinity)
                item.sub = item.subFull;

            continue;
        } else if (item.name === search || item.name.indexOf(search) === 0) {
            results.push(item);

            if (item.edits === Infinity)
                item.edits = 0;

            if (item.sub === Infinity)
                item.sub = 0;

            continue;
        }

        // check if name contains enough of search characters
        var contains = searchCharsContains(search, item.name);
        if (contains / search.length < args.containsCharsTolerance)
            continue;

        var editsCandidate = Infinity;
        var subCandidate = Infinity;

        // for each token
        for (var t = 0; t < item.tokens.length; t++) {
            // direct token match
            if (item.tokens[t] === search) {
                editsCandidate = 0;
                subCandidate = t;
                break;
            }

            var edits = searchStringEditDistance(search, item.tokens[t]);

            if ((subCandidate === Infinity || edits < editsCandidate) && item.tokens[t].indexOf(search) !== -1) {
                // search is a substring of a token
                subCandidate = t;
                editsCandidate = edits;
                continue;
            } else if (subCandidate === Infinity && edits < editsCandidate) {
                // new edits candidate, not a substring of a token
                if ((edits / Math.max(search.length, item.tokens[t].length)) <= args.editsDistanceTolerance) {
                    // check if edits tolerance is satisfied
                    editsCandidate = edits;
                }
            }
        }

        // no match candidate
        if (editsCandidate === Infinity)
            continue;

        // add new result
        results.push(item);
        item.edits = item.edits === Infinity ? editsCandidate : item.edits + editsCandidate;
        item.sub = item.sub === Infinity ? subCandidate : item.sub + subCandidate;
    }

    return results;
};

// perform search through items
// items is an array with arrays of two values
// where first value is a string to be searched by
// and second value is an object to be found
//
// [
//     [ 'camera', {object} ],
//     [ 'New Entity', {object} ],
//     [ 'Sun', {object} ]
// ]
//
const searchItems = function (items, search, args) {
    let i;

    search = (search || '').toLowerCase().trim();

    if (!search)
        return [];

    var searchTokens = searchStringTokenize(search);
    if (!searchTokens.length)
        return [];

    args = args || { };
    args.containsCharsTolerance = args.containsCharsTolerance || 0.5;
    args.editsDistanceTolerance = args.editsDistanceTolerance || 0.5;

    var records = [];

    for (i = 0; i < items.length; i++) {
        var subInd = items[i][0].toLowerCase().trim().indexOf(search);

        records.push({
            name: items[i][0],
            item: items[i][1],
            tokens: searchStringTokenize(items[i][0]),
            edits: Infinity,
            subFull: (subInd !== -1) ? subInd : Infinity,
            sub: Infinity
        });
    }

    // search each token
    for (i = 0; i < searchTokens.length; i++)
        records = _searchItems(records, searchTokens[i], args);

    // sort result first by substring? then by edits number
    records.sort((a, b) => {
        if (a.subFull !== b.subFull) {
            return a.subFull - b.subFull;
        } else if (a.sub !== b.sub) {
            return a.sub - b.sub;
        } else if (a.edits !== b.edits) {
            return a.edits - b.edits;
        }
        return a.name.length - b.name.length;
    });

    // return only items without match information
    for (i = 0; i < records.length; i++)
        records[i] = records[i].item;

    // limit number of results
    if (args.hasOwnProperty('limitResults') && records.length > args.limitResults) {
        records = records.slice(0, args.limitResults);
    }

    return records;
};

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-select-input-create-new > .pcui-label:last-child:before, .pcui-select-input-list .pcui-label.pcui-selected:after, .pcui-select-input-icon:after {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-select-input-create-new > .pcui-label:last-child:before, .pcui-select-input-list .pcui-label.pcui-selected:after, .pcui-select-input-icon:after {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont, .pcui-select-input-tag > .pcui-label, .pcui-select-input-list .pcui-label, .pcui-select-input-value {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-select-input-container-value, .pcui-select-input {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-select-input-container-value:not(.pcui-hidden), .pcui-select-input:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-select-input {\n  box-sizing: border-box;\n  margin: 6px;\n  border-radius: 2px;\n  min-width: 0;\n}\n\n.pcui-select-input-container-value {\n  background-color: #2c393c;\n  transition: box-shadow 100ms, opacity 100ms;\n}\n\n.pcui-select-input-shadow {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  transition: box-shadow 100ms;\n  border-radius: 2px;\n  pointer-events: none;\n  z-index: 1;\n}\n\n.pcui-select-input-value {\n  margin: 0;\n  padding: 0 24px 0 8px;\n  height: 24px;\n  line-height: 24px;\n  font-size: 12px;\n  transition: background-color 100ms, color 100ms;\n}\n.pcui-select-input-value:not(.pcui-hidden) {\n  display: block;\n}\n\n.pcui-select-input-textinput {\n  margin: 0;\n}\n\n.pcui-select-input-textinput:not(.pcui-disabled):not(.pcui-readonly):not(.pcui-error).pcui-focus, .pcui-select-input-textinput:not(.pcui-disabled):not(.pcui-readonly):not(.pcui-error):hover {\n  box-shadow: none;\n}\n\n.pcui-select-input-icon {\n  position: absolute;\n  right: 6px;\n  color: #5b7073;\n  pointer-events: none;\n  transition: color 100ms;\n  margin: 0;\n  height: 24px;\n  line-height: 24px;\n}\n.pcui-select-input-icon:after {\n  content: \"\\e159\";\n  vertical-align: middle;\n}\n\n.pcui-select-input.pcui-open .pcui-select-input-shadow {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-select-input.pcui-open .pcui-select-input-value {\n  color: #ffffff;\n  background-color: #20292b;\n}\n.pcui-select-input.pcui-open .pcui-select-input-icon:after {\n  color: #ffffff;\n  content: \"\\e157\";\n}\n\n.pcui-select-input-list {\n  position: absolute;\n  z-index: 1;\n  top: 100%;\n  width: 100%;\n  max-height: 200px;\n  overflow-y: auto;\n  background-color: #293538;\n}\n.pcui-select-input-list .pcui-label {\n  font-size: 12px;\n  height: 22px;\n  line-height: 22px;\n  padding: 0 24px 0 6px;\n  margin: 0;\n  transition: background-color 100ms, color 100ms;\n}\n.pcui-select-input-list .pcui-label:not(.pcui-hidden) {\n  display: block;\n}\n.pcui-select-input-list .pcui-label.pcui-selected {\n  color: #ffffff;\n}\n.pcui-select-input-list .pcui-label.pcui-selected:after {\n  content: \"\\e133\";\n  color: #5b7073;\n  position: absolute;\n  right: 6px;\n}\n\n.pcui-select-input-fit-height .pcui-select-input-list {\n  top: initial;\n  bottom: 100%;\n}\n.pcui-select-input-fit-height .pcui-select-input-shadow {\n  top: initial;\n  bottom: 0;\n}\n\n.pcui-select-input-tags:not(.pcui-select-input-tags-empty) {\n  margin-top: 1px;\n  flex-wrap: wrap;\n}\n\n.pcui-select-input-tag {\n  background-color: #293538;\n  align-items: center;\n  border-radius: 2px;\n  border: 1px solid #232e30;\n  margin-right: 2px;\n  margin-top: 2px;\n  min-width: 0;\n  height: 18px;\n}\n.pcui-select-input-tag > * {\n  margin: 0;\n  background-color: transparent;\n  border: 0;\n}\n.pcui-select-input-tag > .pcui-label {\n  padding: 0 5px 0 8px;\n}\n.pcui-select-input-tag > .pcui-button {\n  padding: 0 5px;\n  height: 18px;\n  line-height: 18px;\n  flex-shrink: 0;\n}\n.pcui-select-input-tag > .pcui-button:not(.pcui-disabled):not(.pcui-readonly):hover {\n  box-shadow: none;\n  color: #d34141;\n}\n\n.pcui-select-input-tag-not-everywhere > .pcui-label {\n  opacity: 0.5;\n}\n.pcui-select-input-tag-not-everywhere > .pcui-label:before {\n  content: \"*\";\n  margin-right: 5px;\n}\n\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-container-value:hover .pcui-select-input-shadow {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-container-value:hover .pcui-select-input-icon {\n  color: #9ba1a3;\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly).pcui-focus .pcui-select-input-shadow {\n  box-shadow: 0 0 2px 1px rgba(255, 102, 0, 0.3);\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly).pcui-focus .pcui-select-input-icon {\n  color: #9ba1a3;\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-value:hover {\n  color: #ffffff;\n  background-color: #20292b;\n  cursor: pointer;\n}\n.pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-list > *:hover, .pcui-select-input:not(.pcui-disabled):not(.pcui-readonly) .pcui-select-input-list > .pcui-select-input-label-highlighted {\n  background-color: #20292b;\n  color: #ffffff;\n  cursor: pointer;\n}\n\n.pcui-select-input-create-new > .pcui-label {\n  padding-right: 6px;\n}\n.pcui-select-input-create-new > .pcui-label:last-child {\n  flex-shrink: 0;\n  margin-left: auto;\n}\n.pcui-select-input-create-new > .pcui-label:last-child:before {\n  content: \"\\e120\";\n  margin-right: 6px;\n}\n\n.pcui-select-input.pcui-disabled {\n  opacity: 0.4;\n}\n\n.pcui-select-input.pcui-readonly .pcui-select-input-icon {\n  display: none;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-multi .pcui-select-input-container-value {\n  display: none;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-multi .pcui-select-input-tag > .pcui-button {\n  display: none;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-allow-input:not(.pcui-select-input-multi) {\n  opacity: 0.7;\n}\n.pcui-select-input.pcui-readonly.pcui-select-input-allow-input:not(.pcui-select-input-multi) .pcui-select-input-textinput:after {\n  display: none;\n}");

const CLASS_SELECT_INPUT = 'pcui-select-input';
const CLASS_SELECT_INPUT_CONTAINER_VALUE = CLASS_SELECT_INPUT + '-container-value';
const CLASS_MULTI_SELECT = CLASS_SELECT_INPUT + '-multi';
const CLASS_ALLOW_INPUT = 'pcui-select-input-allow-input';
const CLASS_VALUE = CLASS_SELECT_INPUT + '-value';
const CLASS_ICON$1 = CLASS_SELECT_INPUT + '-icon';
const CLASS_INPUT = CLASS_SELECT_INPUT + '-textinput';
const CLASS_LIST = CLASS_SELECT_INPUT + '-list';
const CLASS_TAGS = CLASS_SELECT_INPUT + '-tags';
const CLASS_TAGS_EMPTY = CLASS_SELECT_INPUT + '-tags-empty';
const CLASS_TAG = CLASS_SELECT_INPUT + '-tag';
const CLASS_TAG_NOT_EVERYWHERE = CLASS_SELECT_INPUT + '-tag-not-everywhere';
const CLASS_SHADOW = CLASS_SELECT_INPUT + '-shadow';
const CLASS_FIT_HEIGHT = CLASS_SELECT_INPUT + '-fit-height';
const CLASS_SELECTED$2 = 'pcui-selected';
const CLASS_HIGHLIGHTED = CLASS_SELECT_INPUT + '-label-highlighted';
const CLASS_CREATE_NEW = CLASS_SELECT_INPUT + '-create-new';
const CLASS_OPEN$1 = 'pcui-open';

const DEFAULT_BOTTOM_OFFSET = 25;


/**
 * @name SelectInput
 * @class
 * @classdesc An input that allows selecting from a dropdown or entering tags.
 * @property {boolean} renderChanges If true then the input will flash when its value changes.
 * @property {string} placeholder The placeholder text to show next to the current value.
 * @property {boolean} multiSelect If true then the input value becomes an array allowing the selection of multiple options. Defaults to false.
 * @property {object[]} options The dropdown options of the input. Contains an array of objects with the following format {v: Any, t: String} where v is the value and t is the text of the option.
 * @property {Array} invalidOptions An array of values against which new values are checked before they are created. If a value is in the array it will not be created.
 * @augments Element
 * @mixes IBindable
 * @mixes IFocusable
 */
class SelectInput extends Element$1 {
    /**
     * Creates a new SelectInput.
     *
     * @param {object} args - The arguments. Extends the pcui.Element constructor arguments.
     * @param {boolean} [args.allowNull] - If true then null is a valid input value. Defaults to false.
     * @param {boolean} [args.allowInput] - If true then a text field is shown for the user to search for values or enter new ones. Defaults to false.
     * @param {boolean} [args.allowCreate] - If true then the input allows creating new values from the text field. Only used when allowInput is true. Defaults to false.
     * @param {Function} [args.createFn] - A function to be executed when the user selects to create a new value. The function takes the new value as a parameter.
     * @param {string} [args.createLabelText] - The placeholder text to show when creating a new value. Used when allowInput and allowCreate are both true.
     * @param {string} [args.type] - The type of each value. Can be one of 'string', 'number' or 'boolean'.
     */
    constructor(args) {
        if (!args) args = {};

        // main container
        const container = new Container({ dom: args.dom });
        super(container.dom, args);
        this._container = container;
        this._container.parent = this;

        this.class.add(CLASS_SELECT_INPUT);

        this._containerValue = new Container({
            class: CLASS_SELECT_INPUT_CONTAINER_VALUE
        });
        this._container.append(this._containerValue);

        // focus / hover shadow element
        this._domShadow = document.createElement('div');
        this._domShadow.classList.add(CLASS_SHADOW);
        this._containerValue.append(this._domShadow);

        this._allowInput = args.allowInput || false;
        if (this._allowInput) {
            this.class.add(CLASS_ALLOW_INPUT);
        }

        this._allowCreate = args.allowCreate || false;
        this._createFn = args.createFn;
        this._createLabelText = args.createLabelText || null;

        // displays current value
        this._labelValue = new Label({
            class: CLASS_VALUE,
            tabIndex: 0
        });
        this._labelValue.on('click', this._onValueClick.bind(this));
        this._containerValue.append(this._labelValue);

        this._timeoutLabelValueTabIndex = null;

        // dropdown icon
        this._labelIcon = new Label({
            class: CLASS_ICON$1,
            hidden: args.allowInput && args.multiSelect
        });
        this._containerValue.append(this._labelIcon);

        // input for searching or adding new entries
        this._input = new TextInput({
            class: CLASS_INPUT,
            blurOnEnter: false,
            keyChange: true
        });
        this._containerValue.append(this._input);

        this._lastInputValue = '';
        this._suspendInputChange = false;
        this._input.on('change', this._onInputChange.bind(this));
        this._input.on('keydown', this._onInputKeyDown.bind(this));
        this._input.on('focus', this._onFocus.bind(this));
        this._input.on('blur', this._onBlur.bind(this));

        if (args.placeholder) {
            this.placeholder = args.placeholder;
        }

        // dropdown list
        this._containerOptions = new Container({
            class: CLASS_LIST,
            hidden: true
        });
        this._containerValue.append(this._containerOptions);

        // tags container
        this._containerTags = new Container({
            class: CLASS_TAGS,
            flex: true,
            flexDirection: 'row',
            hidden: true
        });
        this._container.append(this._containerTags);

        if (args.multiSelect) {
            this.class.add(CLASS_MULTI_SELECT);
            this._containerTags.hidden = false;
        }

        // events
        this._domEvtKeyDown = this._onKeyDown.bind(this);
        this._domEvtFocus = this._onFocus.bind(this);
        this._domEvtBlur = this._onBlur.bind(this);
        this._domEvtMouseDown = this._onMouseDown.bind(this);
        this._domEvtWindowMouseDown = this._onWindowMouseDown.bind(this);
        this._domEvtWheel = this._onWheel.bind(this);

        this._labelValue.dom.addEventListener('keydown', this._domEvtKeyDown);
        this._labelValue.dom.addEventListener('focus', this._domEvtFocus);
        this._labelValue.dom.addEventListener('blur', this._domEvtBlur);
        this._labelValue.dom.addEventListener('mousedown', this._domEvtMouseDown);

        this._containerOptions.dom.addEventListener('wheel', this._domEvtWheel, { passive: true });

        this.on('hide', this.close.bind(this));

        this._type = args.type || 'string';

        this._optionsIndex = {};
        this._labelsIndex = {};
        this._labelHighlighted = null;
        this.invalidOptions = args.invalidOptions;
        this.options = args.options || [];
        this._optionsFn = args.optionsFn;

        this._allowNull = args.allowNull || false;

        this._values = null;

        if (args.value !== undefined) {
            this.value = args.value;
        } else if (args.defaultValue) {
            this.value = args.defaultValue;
        } else {
            this.value = null;
        }

        this.renderChanges = args.renderChanges || false;

        this.on('change', () => {
            this._updateInputFieldsVisibility();

            if (this.renderChanges && !this.multiSelect) {
                this._labelValue.flash();
            }
        });

        this._updateInputFieldsVisibility(false);
    }

    _initializeCreateLabel() {
        const container = new Container({
            class: CLASS_CREATE_NEW,
            flex: true,
            flexDirection: 'row'
        });

        const label = new Label({
            text: this._input.value,
            tabIndex: -1
        });
        container.append(label);

        let evtChange = this._input.on('change', (value) => {
            // check if label is destroyed
            // during change event
            if (label.destroyed) return;
            label.text = value;
            if (this.invalidOptions && this.invalidOptions.indexOf(value) !== -1) {
                if (!container.hidden) {
                    container.hidden = true;
                    this._resizeShadow();
                }
            } else {
                if (container.hidden) {
                    container.hidden = false;
                    this._resizeShadow();
                }
            }
        });

        container.on('click', (e) => {
            e.stopPropagation();

            const text = label.text;

            this.focus();
            this.close();

            if (this._createFn) {
                this._createFn(text);
            } else if (text) {
                this._onSelectValue(text);
            }
        });

        label.on('destroy', () => {
            evtChange.unbind();
            evtChange = null;
        });

        const labelCreateText = new Label({
            text: this._createLabelText
        });
        container.append(labelCreateText);

        this._containerOptions.append(container);

        return container;
    }

    _convertSingleValue(value) {
        if (value === null && this._allowNull) return value;

        if (this._type === 'string') {
            if (!value) {
                value = '';
            } else {
                value = value.toString();
            }
        } else if (this._type === 'number') {
            if (!value) {
                value = 0;
            } else {
                value = parseInt(value, 10);
            }
        } else if (this._type === 'boolean') {
            return !!value;
        }

        return value;
    }

    _convertValue(value) {
        if (value === null && this._allowNull) return value;

        if (this.multiSelect) {
            if (!Array.isArray(value)) return value;

            return value.map(val => this._convertSingleValue(val));
        }

        return this._convertSingleValue(value);
    }

    // toggle dropdown list
    _onValueClick() {
        if (!this.enabled || this.readOnly) return;

        this.toggle();
    }

    // Update our value with the specified selected option
    _onSelectValue(value) {
        value = this._convertSingleValue(value);

        if (!this.multiSelect) {
            this.value = value;
            return;
        }

        if (this._values) {
            let dirty = false;
            this._values.forEach((arr) => {
                if (!arr) {
                    arr = [value];
                    dirty = true;
                } else {
                    if (arr.indexOf(value) === -1) {
                        arr.push(value);
                        dirty = true;
                    }
                }
            });

            if (dirty) {
                this._onMultipleValuesChange(this._values);

                this.emit('change', this.value);

                if (this._binding) {
                    this._binding.addValues([value]);
                }
            }
        } else {
            if (!this._value || !Array.isArray(this._value)) {
                this.value = [value];
            } else {
                if (this._value.indexOf(value) === -1) {
                    this._value.push(value);

                    this._addTag(value);

                    this.emit('change', this.value);

                    if (this._binding) {
                        this._binding.addValues([value]);
                    }
                }
            }
        }
    }

    _highlightLabel(label) {
        if (this._labelHighlighted === label) return;

        if (this._labelHighlighted) {
            this._labelHighlighted.class.remove(CLASS_HIGHLIGHTED);
        }

        this._labelHighlighted = label;

        if (this._labelHighlighted) {
            this._labelHighlighted.class.add(CLASS_HIGHLIGHTED);

                // scroll into view if necessary
            const labelTop = this._labelHighlighted.dom.offsetTop;
            const scrollTop = this._containerOptions.dom.scrollTop;
            if (labelTop < scrollTop) {
                this._containerOptions.dom.scrollTop = labelTop;
            } else if (labelTop + this._labelHighlighted.height > this._containerOptions.height + scrollTop) {
                this._containerOptions.dom.scrollTop = labelTop + this._labelHighlighted.height - this._containerOptions.height;
            }
        }
    }

    // when the value is changed show the correct title
    _onValueChange(value) {
        if (!this.multiSelect) {
            this._labelValue.value = this._optionsIndex[value] || '';

            value = '' + value;
            for (var key in this._labelsIndex) {
                if (key === value) {
                    this._labelsIndex[key].class.add(CLASS_SELECTED$2);
                } else {
                    this._labelsIndex[key].class.remove(CLASS_SELECTED$2);
                }
            }
        } else {
            this._labelValue.value = '';
            this._containerTags.clear();
            this._containerTags.class.add(CLASS_TAGS_EMPTY);

            if (value && Array.isArray(value)) {
                value.forEach((val) => {
                    this._addTag(val);
                    if (this._labelsIndex[val]) {
                        this._labelsIndex[val].class.add(CLASS_SELECTED$2);
                    }
                });

                for (const key in this._labelsIndex) {
                    if (value.indexOf(this._convertSingleValue(key)) !== -1) {
                        this._labelsIndex[key].class.add(CLASS_SELECTED$2);
                    } else {
                        this._labelsIndex[key].class.remove(CLASS_SELECTED$2);
                    }
                }
            }
        }
    }

    _onMultipleValuesChange(values) {
        this._labelValue.value = '';
        this._containerTags.clear();
        this._containerTags.class.add(CLASS_TAGS_EMPTY);

        const tags = {};
        const valueCounts = {};
        values.forEach((arr) => {
            if (!arr) return;
            arr.forEach((val) => {
                if (!tags[val]) {
                    tags[val] = this._addTag(val);
                    valueCounts[val] = 1;
                } else {
                    valueCounts[val]++;
                }
            });
        });

        // add special class to tags that do not exist everywhere
        for (var val in valueCounts) {
            if (valueCounts[val] !== values.length) {
                tags[val].class.add(CLASS_TAG_NOT_EVERYWHERE);
                if (this._labelsIndex[val]) {
                    this._labelsIndex[val].class.remove(CLASS_SELECTED$2);
                }
            }
        }
    }

    _addTag(value) {
        const container = new Container({
            flex: true,
            flexDirection: 'row',
            class: CLASS_TAG
        });

        container.append(new Label({
            text: this._optionsIndex[value] || value
        }));

        const btnRemove = new Button({
            size: 'small',
            icon: 'E132',
            tabIndex: -1
        });

        container.append(btnRemove);

        btnRemove.on('click', () => this._removeTag(container, value));

        this._containerTags.append(container);
        this._containerTags.class.remove(CLASS_TAGS_EMPTY);

        if (this._labelsIndex[value]) {
            this._labelsIndex[value].class.add(CLASS_SELECTED$2);
        }

        container.value = value;

        return container;
    }

    _removeTag(tagElement, value) {
        tagElement.destroy();

        if (this._labelsIndex[value]) {
            this._labelsIndex[value].class.remove(CLASS_SELECTED$2);
        }

        if (this._values) {
            this._values.forEach((arr) => {
                if (!arr) return;
                const idx = arr.indexOf(value);
                if (idx !== -1) {
                    arr.splice(idx, 1);
                }
            });
        } else if (this._value && Array.isArray(this._value)) {
            const idx = this._value.indexOf(value);
            if (idx !== -1) {
                this._value.splice(idx, 1);
            }
        }

        this.emit('change', this.value);

        if (this._binding) {
            this._binding.removeValues([value]);
        }
    }

    _onInputChange(value) {
        if (this._suspendInputChange) return;

        if (this._lastInputValue === value) return;

        this.open();

        this._lastInputValue = value;

        this._filterOptions(value);
    }

    _filterOptions(filter) {
        // first remove all options
        // then search the options for best matches
        // and add them back in best match order
        const containerDom = this._containerOptions.dom;
        while (containerDom.firstChild) {
            containerDom.removeChild(containerDom.lastChild);
        }

        if (filter) {
            const searchOptions = this.options.map((option) => {
                return [option.t, option.v];
            });
            const searchResults = searchItems(searchOptions, filter);
            searchResults.forEach((value) => {
                containerDom.appendChild(this._labelsIndex[value].dom);
            });

        } else {
            this.options.forEach((option) => {
                containerDom.appendChild(this._labelsIndex[option.v].dom);
            });
        }

        // append create label in the end
        if (this._createLabelContainer) {
            containerDom.appendChild(this._createLabelContainer.dom);
        }

        if (containerDom.firstChild) {
            this._highlightLabel(containerDom.firstChild.ui);
        }

        this._resizeShadow();
    }

    _onInputKeyDown(evt) {
        if (evt.keyCode === 13 && this.enabled && !this.readOnly) {
            evt.stopPropagation();
            evt.preventDefault();

            // on enter
            let value;

            if (this._labelHighlighted && this._labelHighlighted._optionValue !== undefined) {
                value = this._labelHighlighted._optionValue;
            } else {
                value = this._input.value;
            }

            if (value !== undefined) {
                this.focus();
                this.close();

                if (this._optionsIndex[value]) {
                    this._onSelectValue(value);
                } else if (this._allowCreate) {
                    if (this._createFn) {
                        this._createFn(value);
                    } else {
                        this._onSelectValue(value);
                    }
                }

                return;
            }
        }

        this._onKeyDown(evt);
    }

    _onWindowMouseDown(evt) {
        if (this.dom.contains(evt.target)) return;
        this.close();
    }

    _onKeyDown(evt) {
        // close options on ESC and blur
        if (evt.keyCode === 27) {
            this.close();
            return;
        }

        // handle tab
        if (evt.keyCode === 9) {
            this.close();
            return;
        }

        if (!this.enabled || this.readOnly) return;

        if (evt.keyCode === 13 && !this._allowInput) {
            if (this._labelHighlighted && this._labelHighlighted._optionValue !== undefined) {
                this._onSelectValue(this._labelHighlighted._optionValue);
                this.close();
            }

            return;
        }

        if ([38, 40].indexOf(evt.keyCode) === -1) {
            return;
        }

        evt.stopPropagation();
        evt.preventDefault();

        if ((this._allowInput || this.multiSelect) && this._containerOptions.hidden) {
            this.open();
            return;
        }

        if (this._containerOptions.hidden) {
            if (!this._options.length) return;

            let index = -1;
            for (let i = 0; i < this._options.length; i++) {
                if (this._options[i].v === this.value) {
                    index = i;
                    break;
                }
            }

            if (evt.keyCode === 38) {
                index--;
            } else if (evt.keyCode === 40) {
                index++;
            }

            if (index >= 0 && index < this._options.length) {
                this._onSelectValue(this._options[index].v);
            }
        } else {
            if (!this._containerOptions.dom.childNodes.length) return;

            if (!this._labelHighlighted) {
                this._highlightLabel(this._containerOptions.dom.childNodes[0].ui);
            } else {
                let highlightedLabelDom = this._labelHighlighted.dom;
                do {
                    if (evt.keyCode === 38) {
                        highlightedLabelDom = highlightedLabelDom.previousSibling;
                    } else if (evt.keyCode === 40) {
                        highlightedLabelDom = highlightedLabelDom.nextSibling;
                    }
                } while (highlightedLabelDom && highlightedLabelDom.ui.hidden);

                if (highlightedLabelDom) {
                    this._highlightLabel(highlightedLabelDom.ui);
                }
            }
        }
    }

    _resizeShadow() {
        this._domShadow.style.height = (this._containerValue.height + this._containerOptions.height) + 'px';
    }

    _onMouseDown() {
        if (!this._allowInput) {
            this.focus();
        }
    }

    _onFocus() {
        this.class.add(FOCUS);
        this.emit('focus');
        if (!this._input.hidden) {
            this.open();
        }
    }

    _onBlur() {
        this.class.remove(FOCUS);
        this.emit('blur');
    }

    _onWheel(evt) {
        // prevent scrolling on other stuff like the viewport
        // when we are scrolling on the select input
        evt.stopPropagation();
    }

    _updateInputFieldsVisibility(focused) {
        let showInput = false;
        let focusInput = false;

        if (this._allowInput) {
            if (focused) {
                showInput = true;
                focusInput = true;
            } else {
                showInput = this.multiSelect || !this._labelsIndex[this.value];
            }
        }

        this._labelValue.hidden = showInput;
        this._labelIcon.hidden = showInput;
        this._input.hidden = !showInput;

        if (focusInput) {
            this._input.focus();
        }

        if (!this._labelValue.hidden) {
            // prevent label from being focused
            // right after input gets unfocused
            this._labelValue.tabIndex = -1;

            if (!this._timeoutLabelValueTabIndex) {
                this._timeoutLabelValueTabIndex = requestAnimationFrame(() => {
                    this._timeoutLabelValueTabIndex = null;
                    this._labelValue.tabIndex = 0;
                });
            }
        }

    }

    focus() {
        if (this._input.hidden) {
            this._labelValue.dom.focus();
        } else {
            this._input.focus();
        }
    }

    blur() {
        if (this._allowInput) {
            this._input.blur();
        } else {
            this._labelValue.dom.blur();
        }
    }

    /**
     * @name SelectInput#open
     * @description Opens the dropdown menu
     */
    open() {
        if (!this._containerOptions.hidden || !this.enabled || this.readOnly) return;

        this._updateInputFieldsVisibility(true);

        // auto-update options if necessary
        if (this._optionsFn) {
            this.options = this._optionsFn();
        }

        if (this._containerOptions.dom.childNodes.length === 0) return;

        // highlight label that displays current value
        this._containerOptions.forEachChild((label) => {
            label.hidden = false;
            if (label._optionValue === this.value) {
                this._highlightLabel(label);
            }
        });
        if (!this._labelHighlighted) {
            this._highlightLabel(this._containerOptions.dom.childNodes[0].ui);
        }

        // show options
        this._containerOptions.hidden = false;
        this.class.add(CLASS_OPEN$1);

        // register keydown on entire window
        window.addEventListener('keydown', this._domEvtKeyDown);
        // register mousedown on entire window
        window.addEventListener('mousedown', this._domEvtWindowMouseDown);

        // if the dropdown list goes below the window show it above the field
        const startField = this._allowInput ? this._input.dom : this._labelValue.dom;
        const rect = startField.getBoundingClientRect();
        let fitHeight = (rect.bottom + this._containerOptions.height + DEFAULT_BOTTOM_OFFSET >= window.innerHeight);
        if (fitHeight && rect.top - this._containerOptions.height < 0) {
            // if showing it above the field means that some of it will not be visible
            // then show it below instead and adjust the max height to the maximum available space
            fitHeight = false;
            this._containerOptions.style.maxHeight = (window.innerHeight - rect.bottom - DEFAULT_BOTTOM_OFFSET) + 'px';
        }

        if (fitHeight) {
            this.class.add(CLASS_FIT_HEIGHT);
        } else {
            this.class.remove(CLASS_FIT_HEIGHT);
        }

        // resize the outer shadow to fit the element and the dropdown list
        // we need this because the dropdown list is position: absolute
        this._resizeShadow();
    }

    /**
     * @name SelectInput#close
     * @description Closes the dropdown menu
     */
    close() {
        // there is a potential bug here if the user has set a max height
        // themselves then this will be overriden
        this._containerOptions.style.maxHeight = '';

        this._highlightLabel(null);

        this._updateInputFieldsVisibility(false);

        this._suspendInputChange = true;
        this._input.value = '';
        if (this._lastInputValue) {
            this._lastInputValue = '';
            this._filterOptions(null);
        }
        this._suspendInputChange = false;

        if (this._containerOptions.hidden) return;

        this._containerOptions.hidden = true;

        this._domShadow.style.height = '';

        this.class.remove(CLASS_OPEN$1);
        window.removeEventListener('keydown', this._domEvtKeyDown);
        window.removeEventListener('mousedown', this._domEvtWindowMouseDown);
    }

    /**
     * @name SelectInput#toggle
     * @description Toggles the dropdown menu
     */
    toggle() {
        if (this._containerOptions.hidden) {
            this.open();
        } else {
            this.close();
        }
    }

    unlink() {
        super.unlink();

        if (!this._containerOptions.hidden) {
            this.close();
        }
    }

    destroy() {
        if (this._destroyed) return;

        this._labelValue.dom.removeEventListener('keydown', this._domEvtKeyDown);
        this._labelValue.dom.removeEventListener('mousedown', this._domEvtMouseDown);
        this._labelValue.dom.removeEventListener('focus', this._domEvtFocus);
        this._labelValue.dom.removeEventListener('blur', this._domEvtBlur);

        this._containerOptions.dom.removeEventListener('wheel', this._domEvtWheel);

        window.removeEventListener('keydown', this._domEvtKeyDown);
        window.removeEventListener('mousedown', this._domEvtWindowMouseDown);

        if (this._timeoutLabelValueTabIndex) {
            cancelAnimationFrame(this._timeoutLabelValueTabIndex);
            this._timeoutLabelValueTabIndex = null;
        }

        super.destroy();
    }

    set options(value) {
        if (this._options && this._options === value) return;

        this._containerOptions.clear();
        this._labelHighlighted = null;
        this._optionsIndex = {};
        this._labelsIndex = {};
        this._options = value;

        // store each option value -> title pair in the optionsIndex
        this._options.forEach((option) => {
            this._optionsIndex[option.v] = option.t;
            if (option.v === '') return;

            const label = new Label({
                text: option.t,
                tabIndex: -1
            });

            label._optionValue = option.v;

            // store labels in an index too
            this._labelsIndex[option.v] = label;

            // on clicking an option set it as the value and close the dropdown list
            label.on('click', (e) => {
                e.stopPropagation();
                this._onSelectValue(option.v);
                this.close();
            });
            this._containerOptions.append(label);
        });

        this._createLabelContainer = null;
        if (this._createLabelText) {
            this._createLabelContainer = this._initializeCreateLabel();
        }

        if (this.multiSelect && this._values) {
            this._onMultipleValuesChange(this._values);
        } else {
            this._onValueChange(this.value);
        }

        if (this._lastInputValue) {
            this._filterOptions(this._lastInputValue);
        }
    }

    get options() {
        return this._options.slice();
    }

    set invalidOptions(value) {
        this._invalidOptions = value || null;
    }

    get invalidOptions() {
        return this._invalidOptions;
    }

    get multiSelect() {
        return this.class.contains(CLASS_MULTI_SELECT);
    }

    set value(value) {
        this._values = null;

        this._suspendInputChange = true;
        this._input.value = '';
        if (this._lastInputValue) {
            this._lastInputValue = '';
            this._filterOptions(null);
        }
        this._suspendInputChange = false;

        this.class.remove(MULTIPLE_VALUES);

        value = this._convertValue(value);

        if (this._value === value || this.multiSelect && this._value && this._value.equals(value)) {
            // if the value is null because we are showing multiple values
            // but someone wants to actually set the value of all observers to null
            // then make sure we do not return early
            if (value !== null || !this._allowNull || !this.class.contains(MULTIPLE_VALUES)) {
                return;
            }
        }

        this._value = value;
        this._onValueChange(value);

        this.emit('change', value);

        if (this._binding) {
            this._binding.setValue(value);
        }
    }

    get value() {
        if (!this.multiSelect) {
            return this._value;
        }

        // if multi-select then construct an array
        // value from the tags that are currently visible
        const result = [];
        this._containerTags.dom.childNodes.forEach((dom) => {
            result.push(dom.ui.value);
        });

        return result;
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        values = values.map(this._convertValue.bind(this));

        let different = false;
        const value = values[0];
        const multiSelect = this.multiSelect;

        this._values = null;

        for (let i = 1; i < values.length; i++) {
            if (values[i] !== value && (!multiSelect || !values[i] || !values[i].equals(value))) {
                different = true;
                break;
            }
        }

        if (different) {
            this._labelValue.values = values;

            // show all different tags
            if (multiSelect) {
                this._values = values;
                this._value = null;
                this._onMultipleValuesChange(this._values);
                this.emit('change', this.value);
            } else {
                if (this._value !== null) {
                    this._value = null;
                    this.emit('change', null);
                }
            }

            this.class.add(MULTIPLE_VALUES);
        } else {
            this.value = values[0];
        }
    }

    set placeholder(value) {
        this._input.placeholder = value;
    }

    get placeholder() {
        return this._input.placeholder;
    }
}

Element$1.register('select', SelectInput, { renderChanges: true });
Element$1.register('multiselect', SelectInput, { multiSelect: true, renderChanges: true });
Element$1.register('tags', SelectInput, { allowInput: true, allowCreate: true, multiSelect: true, renderChanges: true });

___$insertStyle("@keyframes animation-spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.pcui-spinner {\n  display: inline-block;\n  margin: 6px;\n  vertical-align: middle;\n}\n.pcui-spinner > path {\n  animation-name: animation-spin;\n  animation-duration: 750ms;\n  animation-iteration-count: infinite;\n  animation-timing-function: linear;\n  transform-origin: center;\n}\n.pcui-spinner.pcui-error > path {\n  animation: none;\n  fill: #ff2020;\n}\n.pcui-spinner.pcui-error > path.pcui-spinner-highlight {\n  fill: #ff7777;\n}");

const CLASS_ROOT$5 = 'pcui-spinner';

function createSmallThick(size, dom) {
    const spinner = dom || document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    spinner.classList.add('spin');
    spinner.setAttribute('width', size);
    spinner.setAttribute('height', size);
    spinner.setAttribute('viewBox', '0 0 14 14');
    spinner.setAttribute('fill', 'none');
    spinner.innerHTML = '<path d="M7 14C3.13871 14 0 10.8613 0 7C0 3.13871 3.13871 0 7 0C10.8613 0 14 3.13871 14 7C14 10.8613 10.8613 14 7 14ZM7 2.25806C4.38064 2.25806 2.25806 4.38064 2.25806 7C2.25806 9.61935 4.38064 11.7419 7 11.7419C9.61935 11.7419 11.7419 9.61935 11.7419 7C11.7419 4.38064 9.61935 2.25806 7 2.25806Z" fill="#773417"/><path class="pcui-spinner-highlight" d="M7 14V11.7419C9.61935 11.7419 11.7419 9.61935 11.7419 7H14C14 10.8613 10.8613 14 7 14Z" fill="#FF6600"/>';
    return spinner;
}
/**
 * @name Spinner
 * @augments Element
 * @class
 * @classdesc Represents a spinning icon
 */
class Spinner extends Element$1 {
    /**
     * Creates a new spinner.
     *
     * @param {object} [args] - The arguments
     * @param {number} [args.size=12] - The pixel size of the spinner
     */
    constructor(args) {
        args = Object.assign({
            type: Spinner.TYPE_SMALL_THICK
        }, args);

        let dom = null;

        if (args.type === Spinner.TYPE_SMALL_THICK) {
            dom = createSmallThick(args.size || 12, args.dom);
        }

        super(dom, args);

        this.class.add(CLASS_ROOT$5);
    }
}

Spinner.TYPE_SMALL_THICK = 'small-thick';

___$insertStyle(".pcui-progress {\n  height: 4px;\n  background-color: #20292b;\n  transition: opacity 100ms;\n  width: 100%;\n}\n.pcui-progress .pcui-progress-inner {\n  width: 0%;\n  height: inherit;\n  background: #f60;\n  background: -webkit-gradient(left top, right bottom, color-stop(0%, #ff6600), color-stop(25%, #ff6600), color-stop(26%, #a84300), color-stop(50%, #a84300), color-stop(51%, #ff6600), color-stop(75%, #ff6600), color-stop(76%, #a84300), color-stop(100%, #a84300));\n  background: -webkit-linear-gradient(-45deg, #ff6600 0%, #ff6600 25%, #a84300 26%, #a84300 50%, #ff6600 51%, #ff6600 75%, #a84300 76%, #a84300 100%);\n  background: -moz-linear-gradient(-45deg, #ff6600 0%, #ff6600 25%, #a84300 26%, #a84300 50%, #ff6600 51%, #ff6600 75%, #a84300 76%, #a84300 100%);\n  background: -ms-linear-gradient(-45deg, #ff6600 0%, #ff6600 25%, #a84300 26%, #a84300 50%, #ff6600 51%, #ff6600 75%, #a84300 76%, #a84300 100%);\n  background: -o-linear-gradient(-45deg, #ff6600 0%, #ff6600 25%, #a84300 26%, #a84300 50%, #ff6600 51%, #ff6600 75%, #a84300 76%, #a84300 100%);\n  background: linear-gradient(135deg, #ff6600 0%, #ff6600 25%, #a84300 26%, #a84300 50%, #ff6600 51%, #ff6600 75%, #a84300 76%, #a84300 100%);\n  background-position: 0px 0px;\n  background-size: 24px 24px;\n  background-repeat: repeat;\n  -webkit-animation: pcui-progress-background 1000ms linear infinite;\n  animation: pcui-progress-background 1000ms linear infinite;\n}\n\n.pcui-progress.pcui-error .pcui-progress-inner {\n  background: #f60;\n  background: -webkit-gradient(left top, right bottom, color-stop(0%, #ff7777), color-stop(25%, #ff7777), color-stop(26%, #ff2020), color-stop(50%, #ff2020), color-stop(51%, #ff7777), color-stop(75%, #ff7777), color-stop(76%, #ff2020), color-stop(100%, #ff2020));\n  background: -webkit-linear-gradient(-45deg, #ff7777 0%, #ff7777 25%, #ff2020 26%, #ff2020 50%, #ff7777 51%, #ff7777 75%, #ff2020 76%, #ff2020 100%);\n  background: -moz-linear-gradient(-45deg, #ff7777 0%, #ff7777 25%, #ff2020 26%, #ff2020 50%, #ff7777 51%, #ff7777 75%, #ff2020 76%, #ff2020 100%);\n  background: -ms-linear-gradient(-45deg, #ff7777 0%, #ff7777 25%, #ff2020 26%, #ff2020 50%, #ff7777 51%, #ff7777 75%, #ff2020 76%, #ff2020 100%);\n  background: -o-linear-gradient(-45deg, #ff7777 0%, #ff7777 25%, #ff2020 26%, #ff2020 50%, #ff7777 51%, #ff7777 75%, #ff2020 76%, #ff2020 100%);\n  background: linear-gradient(135deg, #ff7777 0%, #ff7777 25%, #ff2020 26%, #ff2020 50%, #ff7777 51%, #ff7777 75%, #ff2020 76%, #ff2020 100%);\n  background-position: 0px 0px;\n  background-size: 24px 24px;\n  background-repeat: repeat;\n  -webkit-animation: none;\n  animation: none;\n}\n\n@-webkit-keyframes pcui-progress-background {\n  from {\n    background-position: 0px 0;\n  }\n  to {\n    background-position: 24px 0;\n  }\n}\n@keyframes pcui-progress-background {\n  from {\n    background-position: 0px 0;\n  }\n  to {\n    background-position: 24px 0;\n  }\n}");

const CLASS_ROOT$4 = 'pcui-progress';
const CLASS_INNER = CLASS_ROOT$4 + '-inner';
/**
 * @name Progress
 * @class
 * @classdesc Represents a bar that can highlight progress of an activity.
 * @augments Container
 * @property {number} value Gets / sets the value of the progress bar (between 0 and 100).
 */
class Progress extends Container {
    constructor(args) {
        if (!args) args = {};
        super(args);
        this.class.add(CLASS_ROOT$4);

        this._inner = new Element$1();
        this.append(this._inner);
        this._inner.class.add(CLASS_INNER);

        if (args.value !== undefined) {
            this.value = args.value;
        }
    }

    set value(val) {
        if (this._value === val) return;

        this._value = val;
        this._inner.width = `${this._value}%`;
        this.emit('change', val);
    }

    get value() {
        return this._value;
    }
}

Element$1.register('progress', Progress);

___$insertStyle(".pcui-contextmenu {\n  box-sizing: border-box;\n  border: 1px solid #293538;\n  border-radius: 2px;\n  background-color: #2c393c;\n  color: #b1b8ba;\n  font-size: 12px;\n  font-weight: 400;\n  display: none;\n  position: fixed;\n  z-index: 9999;\n}\n\n.pcui-contextmenu-active {\n  display: block;\n}\n\n.pcui-contextmenu div {\n  background-color: #2c393c;\n  width: 150px;\n  position: absolute;\n}\n.pcui-contextmenu div:before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: -1;\n  box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);\n}\n\n.pcui-contextmenu-parent {\n  cursor: auto !important;\n}\n.pcui-contextmenu-parent div {\n  display: none;\n}\n\n.pcui-contextmenu-parent:hover div {\n  display: block;\n}\n\n.pcui-contextmenu-parent-active div {\n  display: block;\n}\n\n.pcui-contextmenu {\n  div-font-weight: bold;\n}\n.pcui-contextmenu div:hover {\n  background-color: #364346;\n  cursor: pointer;\n}\n.pcui-contextmenu div.pcui-contextmenu-parent:after {\n  content: \"\\e160\";\n  font-family: \"pc-icon\";\n  font-size: 14px;\n  text-align: center;\n  background-color: transparent;\n  color: #9ba1a3;\n  line-height: 14px;\n  position: absolute;\n  right: 4px;\n  top: 50%;\n  transform: translateY(-50%);\n}");

const CLASS_ContextMenu = 'pcui-contextmenu';
const CLASS_ContextMenu_active = CLASS_ContextMenu + '-active';
const CLASS_ContextMenu_parent = CLASS_ContextMenu + '-parent';
const CLASS_ContextMenu_child = CLASS_ContextMenu + '-child';
const CLASS_ContextMenu_parent_active = CLASS_ContextMenu_parent + '-active';

/**
 * @name ContextMenu
 * @class
 * @classdesc Represents a context menu.
 */
class ContextMenu {
    /**
     * Creates a new ContextMenu.
     *
     * @param {object} args - The arguments. Extends the pcui.Container constructor arguments. All settable properties can also be set through the constructor.
     * @param {object[]} [args.items] - The array of items used to populate the array. Example item: { 'text': 'Hello World', 'onClick': () => console.log('Hello World') }.
     * @param {object} [args.dom] - The dom element to attach this context menu to.
     * @param {object} [args.triggerElement] - The dom element that will trigger the context menu to open when right clicked. If undefined args.dom will be used.
     */
    constructor(args) {
        if (!args) args = {};

        this._menu = new Container({ dom: args.dom });
        this._menu.contextMenu = this;
        this.args = args;
        this._menu.class.add(CLASS_ContextMenu);
        var menu = this._menu;

        var removeMenu = () => {
            this._menu.class.remove(CLASS_ContextMenu_active);
            document.removeEventListener('click', removeMenu);
        };

        var triggerElement = args.triggerElement || args.dom.parentElement;
        if (triggerElement) {
            this._contextMenuEvent = triggerElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                menu.class.add(CLASS_ContextMenu_active);
                var maxMenuHeight = args.items.length * 27.0;
                var maxMenuWidth = 150.0;
                var left = e.clientX;
                var top = e.clientY;
                if (maxMenuHeight + top > window.innerHeight) {
                    var topDiff = (maxMenuHeight + top) - window.innerHeight;
                    top -= topDiff;
                }
                if (maxMenuWidth + left > window.innerWidth) {
                    var leftDiff = (maxMenuWidth + left) - window.innerWidth;
                    left -= leftDiff;
                }
                menu.dom.setAttribute("style", `left: ${left}px; top: ${top}px`);
                document.addEventListener('click', removeMenu);
            });

            var mouseLeaveTimeout;
            menu.dom.addEventListener('mouseleave', () => {
                mouseLeaveTimeout = setTimeout(() => {
                    removeMenu();
                }, 500);
            });
            menu.dom.addEventListener('mouseenter', () => {
                if (mouseLeaveTimeout) {
                    clearTimeout(mouseLeaveTimeout);

                }
            });
        }

        if (!args.items) return;

        args.items.forEach((menuItem, i) => {
            var menuItemElement = new Container();
            menuItemElement.dom.setAttribute("style", `top: ${i * 27.0}px`);
            if (menuItem.onClick) {
                menuItemElement.on('click', (e) => {
                    e.stopPropagation();
                    removeMenu();
                    menuItem.onClick(e);
                });
            }
            var menuItemLabel = new Label({ text: menuItem.text });
            menuItemElement.append(menuItemLabel);
            this._menu.dom.append(menuItemElement.dom);
            if (menuItem.items) {
                menuItem.items.forEach((childItem, j) => {
                    var childMenuItemElement = new Container({ class: CLASS_ContextMenu_child });
                    childMenuItemElement.dom.setAttribute("style", `top: ${j * 27.0}px; left: 150px;`);
                    childMenuItemElement.on('click', (e) => {
                        e.stopPropagation();
                        removeMenu();
                        childItem.onClick(e);
                    });
                    var childMenuItemLabel = new Label({ text: childItem.text });
                    childMenuItemElement.append(childMenuItemLabel);
                    menuItemElement.append(childMenuItemElement);
                });
                menuItemElement.class.add(CLASS_ContextMenu_parent);
            }
            menuItemElement.dom.addEventListener('mouseover', (e) => {
                // if (!e.fromElement.classList.contains('pcui-contextmenu-parent')) return;
                this._menu.forEachChild(node => node.class.remove(CLASS_ContextMenu_parent_active));
                menuItemElement.class.add(CLASS_ContextMenu_parent_active);

                var maxMenuHeight = menuItem.items ? menuItem.items.length * 27.0 : 0.0;
                var maxMenuWidth = 150.0;
                var left = e.clientX + maxMenuWidth > window.innerWidth ? -maxMenuWidth + 2.0 : maxMenuWidth;
                var top = 0;
                if (e.clientY + maxMenuHeight > window.innerHeight) {
                    top = -maxMenuHeight + 27.0;
                }
                menuItemElement.forEachChild((node, j) => {
                    if (j === 0) return;
                    node.dom.setAttribute("style", `top: ${top + (j - 1) * 27.0}px; left: ${left}px;`);
                });
            });
        });
    }
}

Element$1.register('contextmenu', ContextMenu);

___$insertStyle("@charset \"UTF-8\";\n@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-treeview-item:not(.pcui-treeview-item-empty) > .pcui-treeview-item-contents:before, .pcui-treeview-item-icon:after {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-treeview-item:not(.pcui-treeview-item-empty) > .pcui-treeview-item-contents:before, .pcui-treeview-item-icon:after {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect, .pcui-treeview {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-treeview {\n  min-width: max-content;\n}\n\n.pcui-treeview-item {\n  position: relative;\n  padding-left: 24px;\n}\n.pcui-treeview-item:before {\n  content: \" \";\n  position: absolute;\n  background-color: #313e41;\n  width: 2px;\n  left: 14px;\n  top: -12px;\n  bottom: 12px;\n}\n.pcui-treeview-item:last-child:before {\n  height: 25px;\n  bottom: auto;\n}\n\n.pcui-treeview-item.pcui-disabled > .pcui-treeview-item-contents > .pcui-treeview-item-text {\n  opacity: 0.4;\n}\n\n.pcui-treeview-item-contents {\n  position: relative;\n  color: #b1b8ba;\n  margin-left: 3px;\n  border: 1px solid transparent;\n  align-items: center;\n  height: 24px;\n  box-sizing: border-box;\n}\n.pcui-treeview-item-contents:hover {\n  cursor: pointer;\n  color: #ffffff;\n  background-color: #2c393c;\n}\n.pcui-treeview-item-contents:hover > .pcui-treeview-item-icon {\n  color: #ffffff;\n}\n\n.pcui-treeview-item-icon {\n  color: #5b7073;\n  margin: 0 2px 0 0;\n  flex-shrink: 0;\n}\n.pcui-treeview-item-icon:before {\n  content: \" \";\n  position: absolute;\n  background-color: #313e41;\n  left: -12px;\n  top: 10px;\n  width: 24px;\n  height: 2px;\n}\n.pcui-treeview-item-icon:after {\n  content: \"\\e360\";\n  display: inline-block;\n  vertical-align: sub;\n  width: 22px;\n  height: 22px;\n  position: relative;\n  z-index: 1;\n  text-align: center;\n}\n\n.pcui-treeview-item-text {\n  margin: 0;\n  flex-shrink: 0;\n  position: relative;\n  z-index: 1;\n  transition: opacity 100ms;\n  padding-right: 8px;\n  color: inherit;\n}\n\n.pcui-treeview-item-contents.pcui-treeview-item-selected {\n  background-color: #20292b;\n  color: #ffffff;\n}\n.pcui-treeview-item-contents.pcui-treeview-item-selected > .pcui-treeview-item-icon {\n  color: #ffffff;\n}\n\n.pcui-treeview-item:not(.pcui-treeview-item-empty) > .pcui-treeview-item-contents:before {\n  content: \"\\e120\";\n  position: absolute;\n  font-size: 10px;\n  font-weight: bold;\n  text-align: center;\n  color: #b1b8ba;\n  background-color: #2c393c;\n  top: 0;\n  left: -24px;\n  width: 16px;\n  height: 16px;\n  line-height: 16px;\n  margin: 3px;\n  cursor: pointer;\n  z-index: 1;\n}\n.pcui-treeview-item:not(.pcui-treeview-item-empty).pcui-treeview-item-open > .pcui-treeview-item-contents:before {\n  content: \"\\e121\";\n}\n\n.pcui-treeview > .pcui-treeview-item {\n  padding-left: 0;\n}\n.pcui-treeview > .pcui-treeview-item:before {\n  content: none;\n}\n.pcui-treeview > .pcui-treeview-item > .pcui-treeview-item-contents {\n  margin-left: 0;\n}\n.pcui-treeview > .pcui-treeview-item > .pcui-treeview-item-contents > .pcui-treeview-item-icon:before {\n  content: none;\n}\n.pcui-treeview > .pcui-treeview-item > .pcui-treeview-item-contents > .pcui-treeview-item-icon:after {\n  margin-left: 0;\n}\n.pcui-treeview > .pcui-treeview-item > .pcui-treeview-item {\n  padding-left: 21px;\n}\n.pcui-treeview > .pcui-treeview-item > .pcui-treeview-item:before {\n  left: 11px;\n}\n\n.pcui-treeview:not(.pcui-treeview-filtering) > .pcui-treeview-item .pcui-treeview-item:not(.pcui-treeview-item-open):not(.pcui-treeview-item-empty) > .pcui-treeview-item {\n  display: none;\n}\n\n.pcui-treeview-item-dragged > .pcui-treeview-item-contents {\n  background-color: rgba(44, 57, 60, 0.5);\n  color: #ffffff;\n}\n\n.pcui-treeview-drag-handle {\n  position: fixed;\n  width: 32px;\n  height: 20px;\n  top: 0;\n  bottom: 0;\n  z-index: 4;\n  margin-top: -1px;\n  margin-left: -1px;\n}\n.pcui-treeview-drag-handle.before {\n  border-top: 4px solid #f60;\n  padding-right: 8px;\n  height: 24px;\n}\n.pcui-treeview-drag-handle.inside {\n  border: 4px solid #f60;\n}\n.pcui-treeview-drag-handle.after {\n  border-bottom: 4px solid #f60;\n  padding-right: 8px;\n  height: 24px;\n}\n\n.pcui-treeview-item-contents:after {\n  content: \" \";\n  display: block;\n  clear: both;\n}\n\n.pcui-treeview-item.pcui-treeview-item-rename > .pcui-treeview-item-contents > .pcui-treeview-item-text {\n  display: none;\n}\n.pcui-treeview-item.pcui-treeview-item-rename > .pcui-treeview-item-contents > .pcui-text-input {\n  margin: 0;\n  flex-grow: 1;\n  box-shadow: none !important;\n  border: 0;\n  background-color: transparent;\n}\n.pcui-treeview-item.pcui-treeview-item-rename > .pcui-treeview-item-contents > .pcui-text-input > input {\n  font-family: inherit;\n  font-size: 14px;\n  padding: 0;\n}\n\n.pcui-treeview.pcui-treeview-filtering .pcui-treeview-item {\n  padding-left: 0;\n}\n.pcui-treeview.pcui-treeview-filtering .pcui-treeview-item::before {\n  display: none;\n}\n.pcui-treeview.pcui-treeview-filtering .pcui-treeview-item:not(.pcui-treeview-filtering-result) > .pcui-treeview-item-contents {\n  display: none;\n}\n.pcui-treeview.pcui-treeview-filtering .pcui-treeview-item-contents {\n  margin-left: 0;\n}\n\n.pcui-treeview-filtering-result .pcui-treeview-item-contents:before,\n.pcui-treeview-filtering-result .pcui-treeview-item-icon:before {\n  display: none;\n}");

___$insertStyle(".noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-label-group {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-label-group:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-label-group {\n  align-items: center;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  margin: 6px;\n}\n.pcui-label-group > .pcui-label:first-child {\n  width: 100px;\n  flex-shrink: 0;\n  margin: 0;\n}\n.pcui-label-group > .pcui-element:not(:first-child) {\n  margin: 0 0 0 6px;\n}\n.pcui-label-group > .pcui-element:nth-child(2):not(.pcui-not-flexible) {\n  flex: 1;\n}\n.pcui-label-group > .pcui-vector-input > .pcui-numeric-input {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.pcui-label-group-align-top > .pcui-label:first-child {\n  align-self: flex-start;\n  margin-top: 4px;\n}\n\n.pcui-label-group.pcui-disabled > .pcui-label:first-child {\n  opacity: 0.4;\n}");

const CLASS_LABEL_GROUP = 'pcui-label-group';
const CLASS_LABEL_TOP = CLASS_LABEL_GROUP + '-align-top';

/**
 * @name LabelGroup
 * @class
 * @classdesc Represents a group of a Label and a Element. Useful for rows of labeled fields.
 * @augments Container
 * @property {string} text - Gets / sets the label text.
 * @property {Element} field - Gets the field. This can only be set through the constructor by passing it in the arguments.
 * @property {Element} label - Gets the label element.
 * @property {boolean} labelAlignTop - Whether to align the label at the top of the group. Defaults to false which aligns it at the center.
 */
class LabelGroup extends Container {
    /**
     * Creates a new LabelGroup.
     *
     * @param {object} args - The arguments. Extends the Element arguments. Any settable property can also be set through the constructor.
     * @param {boolean} [args.nativeTooltip] - If true then use the text as the HTML tooltip of the label.
     */
    constructor(args) {
        if (!args) args = {};

        super(args);

        this.class.add(CLASS_LABEL_GROUP);

        this._label = new Label({
            text: args.text || 'Label',
            nativeTooltip: args.nativeTooltip
        });
        this.append(this._label);

        this._field = args.field;
        if (this._field) {
            this.append(this._field);
        }

        this.labelAlignTop = args.labelAlignTop || false;
    }

    get label() {
        return this._label;
    }

    get field() {
        return this._field;
    }

    set text(value) {
        this._label.text = value;
    }

    get text() {
        return this._label.text;
    }

    set labelAlignTop(value) {
        if (value) {
            this.class.add(CLASS_LABEL_TOP);
        } else {
            this.class.remove(CLASS_LABEL_TOP);
        }
    }

    get labelAlignTop() {
        return this.class.contains(CLASS_LABEL_TOP);
    }
}

Element$1.register('labelgroup', LabelGroup);

/**
 * @name BindingBase
 * @class
 * @classdesc Base class for data binding between IBindable Elements and Observers.
 * @property {Element} element The element
 * @property {Observer[]} observers The linked observers
 * @property {string[]} paths The linked paths
 * @property {boolean} applyingChange Whether the binding is currently applying a change either to the observers or the element.
 * @property {boolean} linked Whether the binding is linked to observers.
 * @property {boolean} historyEnabled Whether history is enabled for the binding. A valid history object must have been provided first.
 * @property {boolean} historyCombine If a history module is used whether to combine history actions when applying changes to observers.
 * @property {string} historyName The name of the history action when applying changes to observers.
 * @property {string} historyPrefix A string to prefix the historyName with.
 * @property {string} historyPostfix A string to postfix the historyName with.
 */
class BindingBase extends Events {
    /**
     * Creates a new binding.
     *
     * @param {object} args - The arguments.
     * @param {IBindable} [args.element] - The IBindable element.
     * @param {History} [args.history] - The history object which will be used to record undo / redo actions.
     * If none is provided then no history will be recorded.
     * @param {string} [args.historyPrefix] - A prefix that will be used for the name of every history action.
     * @param {string} [args.historyPostfix] - A postfix that will be used for the name of every history action.
     * @param {string} [args.historyName] - The name of each history action.
     * @param {boolean} [args.historyCombine] - Whether to combine history actions.
     */
    constructor(args) {
        super();

        if (!args) args = {};

        // the observers we are binding to
        this._observers = null;
        // the paths to use for the observers
        this._paths = null;

        this._applyingChange = false;
        this._element = args.element || null;

        this._history = args.history || null;
        this._historyPrefix = args.historyPrefix || null;
        this._historyPostfix = args.historyPostfix || null;
        this._historyName = args.historyName || null;
        this._historyCombine = args.historyCombine || false;

        this._linked = false;
    }

    // Returns the path at the specified index
    // or the path at the first index if it doesn't exist.
    _pathAt(paths, index) {
        return paths[index] || paths[0];
    }

    /**
     * @name BindingBase#link
     * @description Links the specified observers to the specified paths.
     * @param {Observer[]|Observer} observers - The observer(s).
     * @param {string[]|string} paths - The path(s). The behaviour of the binding depends on how many paths are passed.
     * If an equal amount of paths and observers are passed then the binding will map each path to each observer at each index.
     * If more observers than paths are passed then the path at index 0 will be used for all observers.
     * If one observer and multiple paths are passed then all of the paths will be used for the observer (e.g. for curves).
     */
    link(observers, paths) {
        if (this._observers) {
            this.unlink();
        }

        this._observers = Array.isArray(observers) ? observers : [observers];
        this._paths = Array.isArray(paths) ? paths : [paths];

        this._linked = true;
    }

    /**
     * @name BindingBase#unlink
     * @description Unlinks the observers and paths.
     */
    unlink() {
        this._observers = null;
        this._paths = null;
        this._linked = false;
    }

    /**
     * @name BindingBase#clone
     * @description Clones the binding. To be implemented by derived classes.
     */
    clone() {
        throw new Error('pcui.BindingBase#clone: Not implemented');
    }

    /**
     * @name BindingBase#setValue
     * @description Sets a value to the linked observers at the linked paths.
     * @param {*} value - The value
     */
    setValue(value) {
    }

    /**
     * @name BindingBase#setValues
     * @description Sets an array of values to the linked observers at the linked paths.
     * @param {Array<*>} values - The values
     */
    setValues(values) {
    }

    /**
     * @name BindingBase#addValue
     * @description Adds (inserts) a value to the linked observers at the linked paths.
     * @param {*} value - The value
     */
    addValue(value) {
    }

    /**
     * @name BindingBase#addValues
     * @description Adds (inserts) multiple values to the linked observers at the linked paths.
     * @param {Array<*>} values - The values
     */
    addValues(values) {
    }

    /**
     * @name BindingBase#removeValue
     * @description Removes a value from the linked observers at the linked paths.
     * @param {*} value - The value
     */
    removeValue(value) {
    }

    /**
     * @name BindingBase#removeValues
     * @description Removes multiple values from the linked observers from the linked paths.
     * @param {Array<*>} values - The values
     */
    removeValues(values) {
    }

    set element(value) {
        this._element = value;
    }

    get element() {
        return this._element;
    }

    set applyingChange(value) {
        if (this._applyingChange === value) return;

        this._applyingChange = value;
        this.emit('applyingChange', value);
    }

    get applyingChange() {
        return this._applyingChange;
    }

    get linked() {
        return this._linked;
    }

    set historyCombine(value) {
        this._historyCombine = value;
    }

    get historyCombine() {
        return this._historyCombine;
    }

    set historyName(value) {
        this._historyName = value;
    }

    get historyName() {
        return this._historyName;
    }

    set historyPrefix(value) {
        this._historyPrefix = value;
    }

    get historyPrefix() {
        return this._historyPrefix;
    }

    set historyPostfix(value) {
        this._historyPostfix = value;
    }

    get historyPostfix() {
        return this._historyPostfix;
    }

    set historyEnabled(value) {
        if (this._history) {
            this._history.enabled = value;
        }
    }

    get historyEnabled() {
        return this._history && this._history.enabled;
    }

    get observers() {
        return this._observers;
    }

    get paths() {
        return this._paths;
    }
}

/**
 * @name BindingObserversToElement
 * @class
 * @classdesc Provides one way binding between Observers and an IBindable element and Observers. Any changes from the observers
 * will be propagated to the element.
 * @augments BindingBase
 */
class BindingObserversToElement extends BindingBase {
    /**
     * Creates a new BindingObserversToElement instance.
     *
     * @param {object} args - The arguments.
     * @param {Function} args.customUpdate - Custom update function
     */
    constructor({ customUpdate, ...args } = {}) {
        super(args);

        this._customUpdate = customUpdate;
        this._events = [];
        this._updateElementHandler = this._updateElement.bind(this);
        this._updateTimeout = null;
    }

    _linkObserver(observer, path) {
        this._events.push(observer.on(path + ':set', this._deferUpdateElement.bind(this)));
        this._events.push(observer.on(path + ':unset', this._deferUpdateElement.bind(this)));
        this._events.push(observer.on(path + ':insert', this._deferUpdateElement.bind(this)));
        this._events.push(observer.on(path + ':remove', this._deferUpdateElement.bind(this)));
    }

    _deferUpdateElement() {
        if (this.applyingChange) return;
        this.applyingChange = true;

        this._updateTimeout = setTimeout(this._updateElementHandler);
    }

    _updateElement() {
        if (this._updateTimeout) {
            clearTimeout(this._updateTimeout);
            this._updateTimeout = null;
        }

        this._updateTimeout = null;
        this.applyingChange = true;

        if (typeof this._customUpdate === 'function') {
            this._customUpdate(this._element, this._observers, this._paths);
        } else if (this._observers.length === 1) {
            if (this._paths.length > 1) {
                // if using multiple paths for the single observer (e.g. curves)
                // then return an array of values for each path
                this._element.value = this._paths.map((path) => {
                    return this._observers[0].has(path) ? this._observers[0].get(path) : undefined;
                });
            } else {
                this._element.value = (this._observers[0].has(this._paths[0]) ? this._observers[0].get(this._paths[0]) : undefined);
            }
        } else {
            this._element.values = this._observers.map((observer, i) => {
                const path = this._pathAt(this._paths, i);
                return observer.has(path) ? observer.get(path) : undefined;
            });
        }

        this.applyingChange = false;
    }

    link(observers, paths) {
        super.link(observers, paths);

        // don't render changes when we link
        const renderChanges = this._element.renderChanges;
        if (renderChanges) {
            this._element.renderChanges = false;
        }

        this._updateElement();

        if (renderChanges) {
            this._element.renderChanges = renderChanges;
        }

        if (this._observers.length === 1) {
            if (this._paths.length > 1) {
                for (let i = 0; i < this._paths.length; i++) {
                    this._linkObserver(this._observers[0], this._paths[i]);
                }
                return;
            }
        }

        for (let i = 0; i < this._observers.length; i++) {
            this._linkObserver(this._observers[i], this._pathAt(this._paths, i));
        }
    }

    unlink() {
        for (let i = 0; i < this._events.length; i++) {
            this._events[i].unbind();
        }
        this._events.length = 0;

        if (this._updateTimeout) {
            clearTimeout(this._updateTimeout);
            this._updateTimeout = null;
        }

        super.unlink();
    }

    clone() {
        return new BindingObserversToElement({
            customUpdate: this._customUpdate
        });
    }
}

___$insertStyle(".noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-gridview-item {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-gridview-item:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-gridview-item {\n  box-sizing: border-box;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  width: 104px;\n}\n.pcui-gridview-item:not(.pcui-disabled) {\n  cursor: pointer;\n}\n.pcui-gridview-item:not(.pcui-disabled):not(.pcui-gridview-item-selected):hover {\n  background-color: #293538;\n}\n\n.pcui-gridview-item-selected {\n  background-color: #20292b;\n}\n\n.pcui-gridview-item-text {\n  max-width: 100px;\n  font-size: 12px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  margin: 0;\n  padding: 0 2px;\n}");

___$insertStyle(".noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex, .pcui-gridview {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden), .pcui-gridview:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-gridview {\n  flex-direction: row;\n  flex-wrap: wrap;\n  align-content: flex-start;\n}");

___$insertStyle(".pcui-array-input {\n  margin: 6px;\n  min-width: 0;\n}\n.pcui-array-input > .pcui-numeric-input {\n  margin: 0 0 6px 0;\n}\n\n.pcui-array-input.pcui-array-empty > .pcui-numeric-input {\n  margin: 0;\n}\n\n.pcui-array-input-item > * {\n  margin-top: 1px;\n  margin-bottom: 1px;\n}\n.pcui-array-input-item > *:first-child:not(.pcui-not-flexible):not(.pcui-panel-header) {\n  flex: 1;\n}\n.pcui-array-input-item > .pcui-button {\n  margin-left: -3px;\n  margin-right: 0;\n  background-color: transparent;\n  border: 0;\n}\n\n.pcui-array-input-item-asset > .pcui-button {\n  margin-top: 36px;\n}\n\n.pcui-array-input.pcui-readonly .pcui-array-input-item-delete {\n  display: none;\n}");

const CLASS_ARRAY_INPUT = 'pcui-array-input';
const CLASS_ARRAY_EMPTY = 'pcui-array-empty';
const CLASS_ARRAY_SIZE = CLASS_ARRAY_INPUT + '-size';
const CLASS_ARRAY_CONTAINER = CLASS_ARRAY_INPUT + '-items';
const CLASS_ARRAY_ELEMENT = CLASS_ARRAY_INPUT + '-item';
const CLASS_ARRAY_DELETE = CLASS_ARRAY_ELEMENT + '-delete';

/**
 * @event
 * @name ArrayInput#linkElement
 * @param {Element} element - The array element
 * @param {number} index - The index of the array element
 * @param {string} path - The path linked
 * @description Fired when an array element is linked to observers
 */

/**
 * @event
 * @name ArrayInput#unlinkElement
 * @param {Element} element - The array element
 * @param {number} index - The index of the array element
 * @description Fired when an array element is unlinked from observers
 */

/**
 * @name ArrayInput
 * @class
 * @classdesc Element that allows editing an array of values.
 * @property {boolean} renderChanges - If true the input will flash when changed.
 * @augments Element
 * @mixes IBindable
 * @mixes IFocusable
 */
class ArrayInput extends Element$1 {
    /**
     * Creates a new ArrayInput.
     *
     * @param {object} args - The arguments.
     * @param {string} [args.type] - The type of values that the array can hold.
     * @param {boolean} [args.fixedSize] - If true then editing the number of elements that the array has will not be allowed.
     * @param {object} [args.elementArgs] - Arguments for each array Element.
     */
    constructor(args) {
        args = Object.assign({}, args);

        // remove binding because we want to set it later
        const binding = args.binding;
        delete args.binding;

        const container = new Container({
            dom: args.dom,
            flex: true
        });

        super(container.dom, args);

        this._container = container;
        this._container.parent = this;

        this.class.add(CLASS_ARRAY_INPUT, CLASS_ARRAY_EMPTY);

        this._usePanels = args.usePanels || false;

        this._fixedSize = !!args.fixedSize;

        this._inputSize = new NumericInput({
            class: [CLASS_ARRAY_SIZE],
            placeholder: 'Array Size',
            value: 0,
            hideSlider: true,
            step: 1,
            precision: 0,
            min: 0,
            readOnly: this._fixedSize
        });
        this._inputSize.on('change', this._onSizeChange.bind(this));
        this._inputSize.on('focus', this._onFocus.bind(this));
        this._inputSize.on('blur', this._onBlur.bind(this));
        this._suspendSizeChangeEvt = false;
        this._container.append(this._inputSize);

        this._containerArray = new Container({
            class: CLASS_ARRAY_CONTAINER,
            hidden: true
        });
        this._containerArray.on('append', () => {
            this._containerArray.hidden = false;
        });
        this._containerArray.on('remove', () => {
            this._containerArray.hidden = this._arrayElements.length == 0;
        });
        this._container.append(this._containerArray);
        this._suspendArrayElementEvts = false;
        this._arrayElementChangeTimeout = null;

        this._getDefaultFn = args.getDefaultFn || null;

        let valueType = args.elementArgs && args.elementArgs.type || args.type;
        if (!ArrayInput.DEFAULTS.hasOwnProperty(valueType)) {
            valueType = 'string';
        }

        delete args.dom;

        this._valueType = valueType;
        this._elementType = args.type;
        this._elementArgs = args.elementArgs || args;

        this._arrayElements = [];

        // set binding now
        this.binding = binding;

        this._values = [];

        if (args.value) {
            this.value = args.value;
        }

        this.renderChanges = args.renderChanges || false;
    }

    _onSizeChange(size) {
        // if size is explicitely 0 then add empty class
        // size can also be null with multi-select so do not
        // check just !size
        if (size === 0) {
            this.class.add(CLASS_ARRAY_EMPTY);
        } else {
            this.class.remove(CLASS_ARRAY_EMPTY);
        }

        if (size === null) return;
        if (this._suspendSizeChangeEvt) return;

        // initialize default value for each new array element
        let defaultValue;
        const initDefaultValue = () => {
            if (this._getDefaultFn) {
                defaultValue = this._getDefaultFn();
            } else {
                defaultValue = ArrayInput.DEFAULTS[this._valueType];
                if (this._valueType === 'curveset') {
                    defaultValue = utils.deepCopy(defaultValue);
                    if (Array.isArray(this._elementArgs.curves)) {
                        for (let i = 0; i < this._elementArgs.curves.length; i++) {
                            defaultValue.keys.push([0, 0]);
                        }
                    }
                } else if (this._valueType === 'gradient') {
                    defaultValue = utils.deepCopy(defaultValue);
                    if (this._elementArgs.channels) {
                        for (let i = 0; i < this._elementArgs.channels; i++) {
                            defaultValue.keys.push([0, 1]);
                        }
                    }
                }
            }
        };

        // resize array
        const values = this._values.map((array) => {
            if (!array) {
                array = new Array(size);
                for (let i = 0; i < size; i++) {
                    array[i] = utils.deepCopy(ArrayInput.DEFAULTS[this._valueType]);
                    if (defaultValue === undefined) initDefaultValue();
                    array[i] = utils.deepCopy(defaultValue);
                }
            } else if (array.length < size) {
                const newArray = new Array(size - array.length);
                for (let i = 0; i < newArray.length; i++) {
                    newArray[i] = utils.deepCopy(ArrayInput.DEFAULTS[this._valueType]);
                    if (defaultValue === undefined) initDefaultValue();
                    newArray[i] = utils.deepCopy(defaultValue);
                }
                array = array.concat(newArray);
            } else {
                const newArray = new Array(size);
                for (let i = 0; i < size; i++) {
                    newArray[i] = utils.deepCopy(array[i]);
                }
                array = newArray;
            }

            return array;
        });

        if (!values.length) {
            const array = new Array(size);
            for (let i = 0; i < size; i++) {
                array[i] = utils.deepCopy(ArrayInput.DEFAULTS[this._valueType]);
                if (defaultValue === undefined) initDefaultValue();
                array[i] = utils.deepCopy(defaultValue);
            }
            values.push(array);
        }

        this._updateValues(values, true);
    }

    _onFocus() {
        this.emit('focus');
    }

    _onBlur() {
        this.emit('blur');
    }

    _createArrayElement() {
        const args = Object.assign({}, this._elementArgs);
        if (args.binding) {
            args.binding = args.binding.clone();
        } else if (this._binding) {
            args.binding = this._binding.clone();
        }

        // set renderChanges after value is set
        // to prevent flashing on initial value set
        args.renderChanges = false;

        let container;
        if (this._usePanels) {
            container = new Panel({
                headerText: `[${this._arrayElements.length}]`,
                removable: !this._fixedSize,
                collapsible: true,
                class: [CLASS_ARRAY_ELEMENT, CLASS_ARRAY_ELEMENT + '-' + this._elementType]
            });
        } else {
            container = new Container({
                flex: true,
                flexDirection: 'row',
                alignItems: 'center',
                class: [CLASS_ARRAY_ELEMENT, CLASS_ARRAY_ELEMENT + '-' + this._elementType]
            });
        }

        if (this._elementType === 'json' && args.attributes) {
            args.attributes = args.attributes.map((attr) => {
                if (!attr.path) return attr;

                // fix paths to include array element index
                attr = Object.assign({}, attr);
                const parts = attr.path.split('.');
                parts.splice(parts.length - 1, 0, this._arrayElements.length);
                attr.path = parts.join('.');

                return attr;
            });
        }

        const element = Element$1.create(this._elementType, args);
        container.append(element);

        element.renderChanges = this.renderChanges;

        const entry = {
            container: container,
            element: element
        };

        this._arrayElements.push(entry);

        if (!this._usePanels) {
            if (!this._fixedSize) {
                const btnDelete = new Button({
                    icon: 'E289',
                    size: 'small',
                    class: CLASS_ARRAY_DELETE,
                    tabIndex: -1 // skip buttons on tab
                });
                btnDelete.on('click', () => {
                    this._removeArrayElement(entry);
                });

                container.append(btnDelete);
            }
        } else {
            container.on('click:remove', () => {
                this._removeArrayElement(entry);
            });
        }

        element.on('change', (value) => {
            this._onArrayElementChange(entry, value);
        });

        this._containerArray.append(container);

        return entry;
    }

    _removeArrayElement(entry) {
        const index = this._arrayElements.indexOf(entry);
        if (index === -1) return;

        // remove row from every array in values
        const values = this._values.map((array) => {
            if (!array) return null;
            array.splice(index, 1);
            return array;
        });

        this._updateValues(values, true);
    }

    _onArrayElementChange(entry, value) {
        if (this._suspendArrayElementEvts) return;

        const index = this._arrayElements.indexOf(entry);
        if (index === -1) return;

        // Set the value to the same row of every array in values.
        this._values.forEach((array) => {
            if (array && array.length > index) {
                array[index] = value;
            }
        });

        // use a timeout here because when our values change they will
        // first emit change events on each array element. However since the
        // whole array changed we are going to fire a 'change' event later from
        // our '_updateValues' function. We only want to emit a 'change' event
        // here when only the array element changed value and not the whole array so
        // wait a bit and fire the change event later otherwise the _updateValues function
        // will cancel this timeout and fire a change event for the whole array instead
        this._arrayElementChangeTimeout = setTimeout(() => {
            this._arrayElementChangeTimeout = null;
            this.emit('change', this.value);
        });
    }

    _linkArrayElement(element, index) {
        const observers = this._binding.observers;
        const paths = this._binding.paths;
        const useSinglePath = paths.length === 1 || observers.length !== paths.length;
        element.unlink();
        element.value = null;

        this.emit('unlinkElement', element, index);

        const path = (useSinglePath ? paths[0] + `.${index}` : paths.map(path => `${path}.${index}`));
        element.link(observers, path);

        this.emit('linkElement', element, index, path);
    }

    _updateValues(values, applyToBinding) {
        this._values = values || [];

        this._suspendArrayElementEvts = true;
        this._suspendSizeChangeEvt = true;

        // apply values to the binding
        if (applyToBinding && this._binding) {
            this._binding.setValues(values);
        }

        // each row of this array holds
        // all the values for that row
        const valuesPerRow = [];
        // holds the length of each array
        const arrayLengths = [];

        values.forEach((array) => {
            if (!array) return;

            arrayLengths.push(array.length);

            array.forEach((item, i) => {
                if (!valuesPerRow[i]) {
                    valuesPerRow[i] = [];
                }

                valuesPerRow[i].push(item);
            });
        });

        let lastElementIndex = -1;
        for (let i = 0; i < valuesPerRow.length; i++) {
            // if the number of values on this row does not match
            // the number of arrays then stop adding rows
            if (valuesPerRow[i].length !== values.length) {
                break;
            }

            // create row if it doesn't exist
            if (!this._arrayElements[i]) {
                this._createArrayElement();
            }

            // bind to observers for that row or just display the values
            if (this._binding && this._binding.observers) {
                this._linkArrayElement(this._arrayElements[i].element, i);
            } else {
                if (valuesPerRow[i].length > 1) {
                    this._arrayElements[i].element.values = valuesPerRow[i];
                } else {
                    this._arrayElements[i].element.value = valuesPerRow[i][0];
                }
            }

            lastElementIndex = i;
        }

        // destory elements that are no longer in our values
        for (let i = this._arrayElements.length - 1; i > lastElementIndex; i--) {
            this._arrayElements[i].container.destroy();
            this._arrayElements.splice(i, 1);
        }


        this._inputSize.values = arrayLengths;

        this._suspendSizeChangeEvt = false;
        this._suspendArrayElementEvts = false;

        if (this._arrayElementChangeTimeout) {
            clearTimeout(this._arrayElementChangeTimeout);
            this._arrayElementChangeTimeout = null;
        }

        this.emit('change', this.value);
    }

    focus() {
        this._inputSize.focus();
    }

    blur() {
        this._inputSize.blur();
    }

    /**
     * @name ArrayInput#forEachArrayElement
     * @description Executes the specified function for each array element.
     * @param {Function} fn - The function with signature (element, index) => bool to execute. If the function returns
     * false then the iteration will early out.
     */
    forEachArrayElement(fn) {
        this._containerArray.forEachChild((container, i) => {
            return fn(container.dom.firstChild.ui, i);
        });
    }

    destroy() {
        if (this._destroyed) return;
        this._arrayElements.length = 0;
        super.destroy();
    }

    // override binding setter to create
    // the same type of binding on each array element too
    set binding(value) {
        super.binding = value;

        this._arrayElements.forEach((entry) => {
            entry.element.binding = value ? value.clone() : null;
        });
    }

    get binding() {
        return super.binding;
    }

    set value(value) {
        if (!Array.isArray(value)) {
            value = [];
        }

        const current = this.value || [];
        if (utils.arrayEquals(current, value)) return;

        // update values and binding
        this._updateValues(new Array(this._values.length || 1).fill(value), true);
    }

    get value() {
        // construct value from values of array elements
        return this._arrayElements.map(entry => entry.element.value);
    }

    /* eslint accessor-pairs: 0 */
    set values(values) {
        if (utils.arrayEquals(this._values, values)) return;
        // update values but do not update binding
        this._updateValues(values, false);
    }

    set renderChanges(value) {
        this._renderChanges = value;
        this._arrayElements.forEach((entry) => {
            entry.element.renderChanges = value;
        });
    }

    get renderChanges() {
        return this._renderChanges;
    }
}

ArrayInput.DEFAULTS = {
    boolean: false,
    number: 0,
    string: '',
    vec2: [0, 0],
    vec3: [0, 0, 0],
    vec4: [0, 0, 0, 0]
};

for (const type in ArrayInput.DEFAULTS) {
    Element$1.register(`array:${type}`, ArrayInput, { type: type, renderChanges: true });
}
Element$1.register('array:select', ArrayInput, { type: 'select', renderChanges: true });

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon, .pcui-menu-item-content > .pcui-label[data-icon]:before, .pcui-menu-item-has-children > .pcui-menu-item-content > .pcui-label:after {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon, .pcui-menu-item-content > .pcui-label[data-icon]:before, .pcui-menu-item-has-children > .pcui-menu-item-content > .pcui-label:after {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-menu-item {\n  position: relative;\n  background-color: #20292b;\n  width: auto;\n}\n\n.pcui-menu-item-children {\n  box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.6);\n  position: absolute;\n  z-index: 1;\n  left: 100%;\n  top: 0;\n  opacity: 0;\n  transition: opacity 100ms, visibility 100ms;\n  visibility: hidden;\n}\n\n.pcui-menu-item:hover > .pcui-menu-item-children {\n  opacity: 1;\n  visibility: visible;\n}\n\n.pcui-menu-item-has-children > .pcui-menu-item-content > .pcui-label {\n  padding-right: 32px;\n}\n.pcui-menu-item-has-children > .pcui-menu-item-content > .pcui-label:after {\n  content: \"\\e160\";\n  position: absolute;\n  right: 6px;\n}\n\n.pcui-menu-item-content {\n  min-width: 158px;\n  color: #9ba1a3;\n  border-bottom: 1px solid #263134;\n  cursor: pointer;\n}\n.pcui-menu-item-content:hover {\n  color: #ffffff;\n  background-color: #5b7073;\n}\n.pcui-menu-item-content > .pcui-label {\n  transition: none;\n}\n\n.pcui-menu-item:last-child > .pcui-menu-item-content {\n  border-bottom: none;\n}\n\n.pcui-menu-item-content > .pcui-label {\n  color: inherit;\n}\n.pcui-menu-item-content > .pcui-label[data-icon]:before {\n  content: attr(data-icon);\n  font-weight: 100;\n  font-size: inherit;\n  margin-right: 6px;\n  vertical-align: middle;\n}\n\n.pcui-menu-item.pcui-disabled .pcui-menu-item-content {\n  cursor: default;\n}\n.pcui-menu-item.pcui-disabled .pcui-menu-item-content:hover {\n  color: #9ba1a3;\n  background-color: transparent;\n}\n.pcui-menu-item.pcui-disabled .pcui-menu-item-content > .pcui-label {\n  cursor: default;\n  opacity: 0.4;\n}");

___$insertStyle("@font-face {\n  font-family: \"pc-icon\";\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot\");\n  src: url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.eot?#iefix\") format(\"embedded-opentype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff2\") format(\"woff2\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.woff\") format(\"woff\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.ttf\") format(\"truetype\"), url(\"https://playcanvas.com/static-assets/fonts/PlayIcons-Regular.svg\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n.font-smooth, .font-icon {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n}\n\n.font-thin {\n  font-weight: 100;\n  font-style: normal;\n}\n\n.font-light {\n  font-weight: 200;\n  font-style: normal;\n}\n\n.font-regular {\n  font-weight: normal;\n  font-style: normal;\n}\n\n.font-bold {\n  font-weight: bold;\n  font-style: normal;\n}\n\n.font-icon {\n  font-family: \"pc-icon\";\n}\n\n.fixedFont {\n  font-family: inconsolatamedium, Monaco, Menlo, \"Ubuntu Mono\", Consolas, source-code-pro, monospace;\n  font-weight: normal;\n  font-size: 12px;\n}\n\n.noSelect {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pcui-flex {\n  flex-direction: column;\n}\n.pcui-flex:not(.pcui-hidden) {\n  display: -webkit-flex;\n  display: flex;\n}\n\n.pcui-grid {\n  display: -ms-grid;\n  display: grid;\n}\n\n.pcui-scrollable {\n  overflow: auto;\n}\n\n.pcui-menu {\n  position: absolute;\n  z-index: 401;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  width: auto;\n  height: auto;\n}\n\n.pcui-menu-items {\n  position: fixed;\n  top: 0;\n  left: 0;\n}");

/**
 * @name BindingElementToObservers
 * @class
 * @classdesc Provides one way binding between an IBindable element and Observers. Any changes from the element
 * will be propagated to the observers.
 * @augments BindingBase
 */
class BindingElementToObservers extends BindingBase {
    clone() {
        return new BindingElementToObservers({
            history: this._history,
            historyPrefix: this._historyPrefix,
            historyPostfix: this._historyPostfix,
            historyName: this._historyName,
            historyCombine: this._historyCombine
        });
    }

    _getHistoryActionName(paths) {
        return `${this._historyPrefix || ''}${this._historyName || paths[0]}${this._historyPostfix || ''}`;
    }

    // Sets the value (or values of isArrayOfValues is true)
    // to the observers
    _setValue(value, isArrayOfValues) {
        if (this.applyingChange) return;
        if (!this._observers) return;

        this.applyingChange = true;

        // make copy of observers if we are using history
        // so that we can undo on the same observers in the future
        const observers = this._observers.slice();
        const paths = this._paths.slice();
        const context = {
            observers,
            paths
        };

        const execute = () => {
            this._setValueToObservers(observers, paths, value, isArrayOfValues);
            this.emit('history:redo', context);
        };

        if (this._history) {
            let previousValues = [];
            if (observers.length === 1 && paths.length > 1) {
                previousValues = paths.map((path) => {
                    return observers[0].has(path) ? observers[0].get(path) : undefined;
                });
            } else {
                previousValues = observers.map((observer, i) => {
                    const path = this._pathAt(paths, i);
                    return observer.has(path) ? observer.get(path) : undefined;
                });
            }

            this.emit('history:init', context);

            this._history.add({
                name: this._getHistoryActionName(paths),
                redo: execute,
                combine: this._historyCombine,
                undo: () => {
                    this._setValueToObservers(observers, paths, previousValues, true);
                    this.emit('history:undo', context);
                }
            });

        }

        execute();

        this.applyingChange = false;
    }

    _setValueToObservers(observers, paths, value, isArrayOfValues) {
        // special case for 1 observer with multiple paths (like curves)
        // in that case set each value for each path
        if (observers.length === 1 && paths.length > 1) {
            for (let i = 0; i < paths.length; i++) {
                const latest = observers[0].latest();
                if (!latest) continue;

                let history = false;
                if (latest.history) {
                    history = latest.history.enabled;
                    latest.history.enabled = false;
                }

                const path = paths[i];
                const val = value[i];
                if (value !== undefined) {
                    this._observerSet(latest, path, val);
                } else {
                    latest.unset(path);
                }

                if (history) {
                    latest.history.enabled = true;
                }
            }
            return;
        }

        for (let i = 0; i < observers.length; i++) {
            const latest = observers[i].latest();
            if (!latest) continue;

            let history = false;
            if (latest.history) {
                history = latest.history.enabled;
                latest.history.enabled = false;
            }

            const path = this._pathAt(paths, i);
            const val = isArrayOfValues ? value[i] : value;
            if (value !== undefined) {
                this._observerSet(latest, path, val);
            } else {
                latest.unset(path);
            }

            if (history) {
                latest.history.enabled = true;
            }
        }
    }

    // Handles setting a value to an observer
    // in case that value is an array
    _observerSet(observer, path, value) {
        // check if the parent of the last field in the path
        // exists in the observer because if it doesn't
        // an error is most likely going to be raised by C3
        const lastIndexDot = path.lastIndexOf('.');
        if (lastIndexDot > 0 && !observer.has(path.substring(0, lastIndexDot))) {
            return;
        }

        const isArray = Array.isArray(value);
        // we need to slice an array value before passing it to the 'set'
        // method otherwise there are cases where the Observer will be modifying
        // the same array instance
        observer.set(path, isArray && value ? value.slice() : value);
    }

    _addValues(values) {
        if (this.applyingChange) return;
        if (!this._observers) return;

        this.applyingChange = true;

        // make copy of observers if we are using history
        // so that we can undo on the same observers in the future
        const observers = this._observers.slice();
        const paths = this._paths.slice();

        const records = [];
        for (let i = 0; i < observers.length; i++) {
            const path = this._pathAt(paths, i);
            const observer = observers[i];

            values.forEach((value) => {
                if (observer.get(path).indexOf(value) === -1)  {
                    records.push({
                        observer: observer,
                        path: path,
                        value: value
                    });
                }
            });
        }

        const execute = () => {
            for (let i = 0; i < records.length; i++) {
                const latest = records[i].observer.latest();
                if (!latest) continue;

                const path = records[i].path;

                let history = false;
                if (latest.history) {
                    history = latest.history.enabled;
                    latest.history.enabled = false;
                }

                latest.insert(path, records[i].value);

                if (history) {
                    latest.history.enabled = true;
                }
            }
        };

        if (this._history && records.length) {
            this._history.add({
                name: this._getHistoryActionName(paths),
                redo: execute,
                combine: this._historyCombine,
                undo: () => {
                    for (let i = 0; i < records.length; i++) {
                        const latest = records[i].observer.latest();
                        if (!latest) continue;

                        const path = records[i].path;

                        let history = false;
                        if (latest.history) {
                            history = latest.history.enabled;
                            latest.history.enabled = false;
                        }

                        latest.removeValue(path, records[i].value);

                        if (history) {
                            latest.history.enabled = true;
                        }
                    }
                }
            });
        }

        execute();

        this.applyingChange = false;
    }

    _removeValues(values) {
        if (this.applyingChange) return;
        if (!this._observers) return;

        this.applyingChange = true;

        // make copy of observers if we are using history
        // so that we can undo on the same observers in the future
        const observers = this._observers.slice();
        const paths = this._paths.slice();

        const records = [];
        for (let i = 0; i < observers.length; i++) {
            const path = this._pathAt(paths, i);
            const observer = observers[i];

            values.forEach((value) => {
                const ind = observer.get(path).indexOf(value);
                if (ind !== -1)  {
                    records.push({
                        observer: observer,
                        path: path,
                        value: value,
                        index: ind
                    });
                }
            });
        }

        const execute = () => {
            for (let i = 0; i < records.length; i++) {
                const latest = records[i].observer.latest();
                if (!latest) continue;

                const path = records[i].path;

                let history = false;
                if (latest.history) {
                    history = latest.history.enabled;
                    latest.history.enabled = false;
                }

                latest.removeValue(path, records[i].value);

                if (history) {
                    latest.history.enabled = true;
                }
            }
        };

        if (this._history && records.length) {
            this._history.add({
                name: this._getHistoryActionName(paths),
                redo: execute,
                combine: this._historyCombine,
                undo: () => {
                    for (let i = 0; i < records.length; i++) {
                        const latest = records[i].observer.latest();
                        if (!latest) continue;

                        const path = records[i].path;

                        let history = false;
                        if (latest.history) {
                            history = latest.history.enabled;
                            latest.history.enabled = false;
                        }

                        if (latest.get(path).indexOf(records[i].value) === -1) {
                            latest.insert(path, records[i].value, records[i].index);
                        }

                        if (history) {
                            latest.history.enabled = true;
                        }
                    }
                }
            });
        }

        execute();

        this.applyingChange = false;
    }

    setValue(value) {
        this._setValue(value, false);
    }

    setValues(values) {
        // make sure we deep copy arrays because they will not be cloned when set to the observers
        values = values.slice().map(val => (Array.isArray(val) ? val.slice() : val));
        this._setValue(values, true);
    }

    addValue(value) {
        this._addValues([value]);
    }

    addValues(values) {
        this._addValues(values);
    }

    removeValue(value) {
        this._removeValues([value]);
    }

    removeValues(values) {
        this._removeValues(values);
    }
}

/**
 * @name BindingTwoWay
 * @class
 * @classdesc Provides two way data binding between Observers and IBindable elements. This means
 * that when the value of the Observers changes the IBindable will be updated and vice versa.
 * @augments BindingBase
 */
class BindingTwoWay extends BindingBase {
    /**
     * Creates a new BindingTwoWay instance.
     *
     * @param {object} args - The arguments.
     */
    constructor(args) {
        if (!args) args = {};

        super(args);

        this._bindingElementToObservers = args.bindingElementToObservers || new BindingElementToObservers(args);
        this._bindingObserversToElement = args.bindingObserversToElement || new BindingObserversToElement(args);

        this._applyingChange = false;
        this._bindingElementToObservers.on('applyingChange', (value) => {
            this.applyingChange = value;
        });
        this._bindingElementToObservers.on('history:init', (context) => {
            this.emit('history:init', context);
        });
        this._bindingElementToObservers.on('history:undo', (context) => {
            this.emit('history:undo', context);
        });
        this._bindingElementToObservers.on('history:redo', (context) => {
            this.emit('history:redo', context);
        });

        this._bindingObserversToElement.on('applyingChange', (value) => {
            this.applyingChange = value;
        });
    }

    link(observers, paths) {
        super.link(observers, paths);
        this._bindingElementToObservers.link(observers, paths);
        this._bindingObserversToElement.link(observers, paths);
    }


    unlink() {
        this._bindingElementToObservers.unlink();
        this._bindingObserversToElement.unlink();
        super.unlink();
    }

    clone() {
        return new BindingTwoWay({
            bindingElementToObservers: this._bindingElementToObservers.clone(),
            bindingObserversToElement: this._bindingObserversToElement.clone()
        });
    }

    setValue(value) {
        this._bindingElementToObservers.setValue(value);
    }

    setValues(values) {
        this._bindingElementToObservers.setValues(values);
    }

    addValue(value) {
        this._bindingElementToObservers.addValue(value);
    }

    addValues(values) {
        this._bindingElementToObservers.addValues(values);
    }

    removeValue(value) {
        this._bindingElementToObservers.removeValue(value);
    }

    removeValues(values) {
        this._bindingElementToObservers.removeValues(values);
    }

    set element(value) {
        this._element = value;
        this._bindingElementToObservers.element = value;
        this._bindingObserversToElement.element = value;
    }

    get element() {
        return this._element;
    }

    set applyingChange(value) {
        if (super.applyingChange === value) return;

        this._bindingElementToObservers.applyingChange = value;
        this._bindingObserversToElement.applyingChange = value;
        super.applyingChange = value;
    }

    get applyingChange() {
        return super.applyingChange;
    }

    set historyCombine(value) {
        this._bindingElementToObservers.historyCombine = value;
    }

    get historyCombine() {
        return this._bindingElementToObservers.historyCombine;
    }

    set historyPrefix(value) {
        this._bindingElementToObservers.historyPrefix = value;
    }

    get historyPrefix() {
        return this._bindingElementToObservers.historyPrefix;
    }

    set historyPostfix(value) {
        this._bindingElementToObservers.historyPostfix = value;
    }

    get historyPostfix() {
        return this._bindingElementToObservers.historyPostfix;
    }

    set historyEnabled(value) {
        this._bindingElementToObservers.historyEnabled = value;
    }

    get historyEnabled() {
        return this._bindingElementToObservers.historyEnabled;
    }
}

// PCUI

class BladeControls {

	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		/**
		 * [constructor description]
		 * @param  {...[type]} options.props [description]
		 * @return {[type]}                  [description]
		 */
		constructor({...props}) {
			

			// Props
			const { 
				name
				,meshMorphsIndex
				,bladeRotationOffset  
				,bladeRotation
			} = props;
			this.name = name;
			this.meshMorphsIndex = meshMorphsIndex || [];
			this.bladeRotationOffset = bladeRotationOffset || 0;
			this.bladeRotation = bladeRotation || {};


	    	// Controls
	    	this.controls = {
	    		ui: htmlToDomFragment("<div></div>")
	    		,observers: {}
	    	};

			// Init
			this.init();
	        
		}

		

	////////////////////////
	// INITIALIZE
	////////////////////////

		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {

			// Create Controls
			this.createControls();

		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////
	
		/**
		 * [getControls description]
		 * @return {[type]} [description]
		 */
		getControls(opt_key) {

			return opt_key ? this.controls[opt_key] : this.controls;

		}

	////////////////////////
	// METHODS
	////////////////////////

		/**
		 * [createControls description]
		 * @return {[type]} [description]
		 */
		createControls() {

			// Add ALL
					
				// Array of observers 


				/*
				// Toggle play/pause
				// const observerButton = new Observer({click: true});
				// observerButton.on('click:set', function(value) {
				// 	console.log("value 4", value);
				// }.bind(this));
				const button = new Button({
					enabled: true,
					height: null,
					icon: "E401",
					// click: function(e){ console.log("e",e);}.bind(this),
					// binding: new BindingTwoWay(),
					size: "",
					tabIndex:0,
					text:"Pause",
					width:null
				});
				// button.link(observerButton,'click');
				// bladeUi.appendChild(button.dom);
				this.ui.appendChild(button.dom);
				

				if (button.dom.addEventListener) {
					button.dom.addEventListener("click", function(e) {
						e.stopPropagation();
						e.preventDefault();
						if (this.animation === false)  {
							this.app.on("update", this.update, this);								
							this.animation = true;
							button.text = "Pause";
						} else {
							this.app.off();
							this.animation = false
							button.text = "Play";
						}							
					}.bind(this), false);
				} else {
					button.dom.attachEvent('click', function(e) {
						e.stopPropagation();
						e.preventDefault();
						if (this.animation === false)  {
							this.app.on("update", this.update, this);
							this.animation = true;
							button.text = "Pause";
						} else {
							this.app.off();
							this.animation = false
							button.text = "Play";
						}
					}.bind(this));
				}
				*/

				// Container
					const bladeContainer = document.createElement("DIV");

				// Blade name
					const bladeNameContainer = document.createElement("DIV");
					const bladeLabel = new Label({
						enabled: true,
						height: null,
						text: this.name.toUpperCase(),
						tabIndex:0,
						width:null
					});
					bladeNameContainer.appendChild(bladeLabel.dom);
					bladeLabel.dom.style.color = "#FF0000";
					bladeNameContainer.style.marginTop = bladeNameContainer.style.marginBottom = "15px";
					bladeContainer.appendChild(bladeNameContainer);

				// Morph Controls
					const morphContainer = document.createElement("DIV");
					const meshMorphs = this.meshMorphsIndex;
					for (var i = 0; i < meshMorphs.length; i++) {


						// TODO: Crate Evaluation Time Interpoltion 
						// https://docs.blender.org/manual/en/latest/animation/shape_keys/introduction.html#animation-shapekeys-relative-vs-absolute

						const bladeMorphLabelContainer = document.createElement("DIV");
						const label = new Label({
							enabled: true,
							height: null,
							text: "morph: "+meshMorphs[i].id,
							tabIndex:0,
							width:null
						});
						bladeMorphLabelContainer.appendChild(label.dom);
						morphContainer.appendChild(bladeMorphLabelContainer);

						// Slider
						const observer = new Observer({
							progress: 0
						});
						// observer.on('progress:set', function(value) {
						// 	// Change All blades morphTarget idx weight to value
						// 	console.log("v", value);
						// 	// for (let b in this.scope.blades) {
						// 	// 	this.scope.blades[b].updateMorphtarget(this.idx,value);
						// 	// }
						// 	this.scope.updateMorphtarget.apply(this, [this.idx,value]);

						// }.bind({
						// 	scope: this,						
						// 	idx: meshMorphs[i].idx
						// }));
						const slider = new SliderInput({
						    enabled: true, 
							height: null,
							max: 1,
							min: 0,				
							binding: new BindingTwoWay(),
							pre: 0,
							sliderMax: 1,
							sliderMin: 0,
							step: 0,
							tabIndex: 0,
							width: null
						});
						slider.link(observer,'progress');
						morphContainer.appendChild(slider.dom);


						// Add
						this.controls.observers[meshMorphs[i].id] = {
							idx: meshMorphs[i].idx
							,observer: observer
							,type: "morph"
						};
					
					}					// Add Morphs to Blade Container
					bladeContainer.appendChild(morphContainer);

				// Rotation
					const rotationContainer = document.createElement("DIV");
					for (let d in this.bladeRotation) {

						const bladeRotationLabelContainer = document.createElement("DIV");
						const label = new Label({
							enabled: true,
							height: null,
							text: "rot: "+d,
							tabIndex:0,
							width:null
						});
						bladeRotationLabelContainer.appendChild(label.dom);
						rotationContainer.appendChild(bladeRotationLabelContainer);

						// Slider
						const observer = new Observer({
							progress: this.bladeRotation[d]
						});
						/*
						observer.on('progress:set', function(value) {
							// Change All blades morphTarget idx weight to value
							console.log("v", value);
							// for (let b in this.scope.blades) {
							// 	this.scope.blades[b].updateMorphtarget(this.idx,value);
							// }
							this.scope.updateMorphtarget.apply(this, [this.idx,value]);

						}.bind({
							scope: this,						
							idx: meshMorphs[i].idx
						}));
						*/ 
						const slider = new SliderInput({
						    enabled: true, 
							height: null,
							max: 360,
							min: 0,				
							binding: new BindingTwoWay(),
							pre: 0,
							value: this.bladeRotation[d],
							sliderMax: 360,
							sliderMin: 0,
							step: 0,
							tabIndex: 0,
							width: null
						});
						slider.link(observer,'progress');
						rotationContainer.appendChild(slider.dom);

						// Add
						this.controls.observers[d] = {
							idx: d
							,observer: observer
							,type: "rotation"
						};
					
					}					// Add Morphs to Blade Container
					bladeContainer.appendChild(rotationContainer);

				// Add Blader to UI DOM
					this.controls.ui.appendChild(bladeContainer);
	
		}

}

class Blade {


	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		/**
		 * [constructor description]
		 * @param  {...[type]} options.props [description]
		 * @return {[type]}                  [description]
		 */
		constructor({...props}) {

			// Props
			const { 
				name
				,index
				,layers
				,graphicsDevice
				,controls
				,meshMorphsIndex
				,bladeRotationOffset
				,bladeRotation
				,useLayers
			} = props;	    	
			this.name = name;
			this.index = index;
			this.layers = layers;
			this.graphicsDevice = graphicsDevice;
			this.meshMorphsIndex = meshMorphsIndex;
			this.bladeRotationOffset = bladeRotationOffset;
			this.bladeRotation = bladeRotation;
			this.useLayers = useLayers || false;

			// Create Material
			this.material = new Material({
				color:defaultColors[this.name] || defaultColors['blank']
				,depth: this.index
				,graphicsDevice: this.graphicsDevice
			});


			// Morphing
			this.morphing = this.meshMorphsIndex.reduce((acc,curr)=> (acc[curr.id]=0,acc),{}); // default is 0

			// Rotation
			this.rotation = {
				x: 0,
				y: 0,
				z: 0
			};
			this.quads = {	
				x: new Quat()
				,y: new Quat()
				,z: new Quat()
				,f: new Quat()
			};

			// Create Controls
			this.hasControls = (controls === true);
			this.controls = null;

			// Init
			this.init();
	        
		}

	////////////////////////
	// INITIALIZE
	////////////////////////

		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {

			// Create Mesh
			this.createMesh();

			// Create MorphTargets
			this.createMorphTargets();

			// Create MorphInstance
			this.createMorphInstance();

			// Create MeshInstance
			this.createMeshInstance();

			// Create Entity
			this.createEntity();			

			// Set Initial Rotateion
	        this.setRotation(this.bladeRotation);

			// Create Controls
			this.createControls();

		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////
	
		/**
		 * [getEntity description]
		 * @return {[type]} [description]
		 */
		getEntity() {
			return this.entity;
		}

		/**
		 * [getMorphTargetsCount description]
		 * @return {[type]} [description]
		 */
		getMorphTargetsCount() {
			return this.morphTargets.length;
		}

		/**
		 * [getMeshMorphsIndex description]
		 * @return {[type]} [description]
		 */
		getMeshMorphsIndex() {
			return this.meshMorphsIndex;
		}

		/**
		 * [getControls description]
		 * @param  {[type]} opt_key [description]
		 * @return {[type]}         [description]
		 */
		getControls(opt_key) {
			return this.controls.getControls(opt_key);
		}

		/**
		 * [setRotation description]
		 * @param {[type]} coords      [description]
		 * @param {[type]} opt_control [description]
		 */
		setRotation(coords, opt_control) {
		
			if (opt_control !== undefined && this.hasControls) {
				// Via controls
				if (Array.isArray(opt_control)) {
					for (var i = 0; i < opt_control.length; i++) {
						this.controls.getControls().observers[opt_control[i]].observer.set('progress', coords[opt_control[i]]);
					}				} else {
					this.controls.getControls().observers[opt_control].observer.set('progress', coords[opt_control]); 
				}
			} else {

				// Update Rotation
				this.rotation = { ...this.rotation, ...coords };					

				// Calculate		        
		        this.quads.y.setFromEulerAngles(0, this.rotation.y, 0);
		        this.quads.x.setFromEulerAngles(this.rotation.x, 0, 0);
		        this.quads.z.setFromEulerAngles(0, 0, this.rotation.z);
		        this.quads.f.setFromEulerAngles(0, 0, 0);
		        this.quads.f.mul(this.quads.y).mul(this.quads.x).mul(this.quads.z);

		        // Set Rotation
		        this.entity.setLocalRotation(this.quads.f);
		        
		    }
		}

		/**
		 * [getRotation description]
		 * @param  {[type]} opt_key [description]
		 * @return {[type]}         [description]
		 */
		getRotation(opt_key) {
			return (opt_key!==undefined)?this.rotation[opt_key]:this.rotation;
			// return this.entity.getLocalRotation();
			// return this.entity.getLocalEulerAngles();
		}

		/**
		 * [getBladeRotation description]
		 * @param  {[type]} opt_key [description]
		 * @return {[type]}         [description]
		 */
		getBladeRotation(opt_key) {
			return (opt_key!==undefined)?this.bladeRotation[opt_key]:this.bladeRotation;
			// return this.entity.getLocalRotation();
			// return this.entity.getLocalEulerAngles();
		}

		/**
		 * [getStateRotation description]
		 * @return {[type]} [description]
		 */
		getStateRotation() {
			return this.rotation;
		}

		/**
		 * [getStateMorphing description]
		 * @return {[type]} [description]
		 */
		getStateMorphing() {
			return this.morphing;
		}


		/**
		 * [updateMorphtarget description]
		 * @param  {[type]} index        [description]
		 * @param  {[type]} weight      [description]
		 * @param  {[type]} opt_control [description]
		 * @return {[type]}             [description]
		 */
		updateMorphtarget(index,weight,opt_control) {

			

			// Change Morph Weight		
			if (opt_control !== undefined && this.hasControls) {
				// Via controls
				this.controls.getControls().observers[opt_control].observer.set('progress', weight); 
			} else {

				// Update Morphing
				this.morphing[this.meshMorphsIndex.find( ({ idx }) => idx === index ).id] = weight;

				// Directly
				this.morphInstance.setWeight(index,weight);	
			}

		}

		/**
		 * [setDepth description]
		 * @param {[type]} d [description]
		 */
		setDepth(d) {
			// Set
				this.meshInstance.material.depthTest = this.meshInstance.material.depthWrite = d==="e"?true:false;
				// this.meshInstance.material.blendType = d==="e"?  BLEND_PREMULTIPLIED:BLEND_NONE; //BLEND_NORMAL:BLEND_NONE;
			
			// Update
				this.meshInstance.material.update();


		}

		/**
		 * [setOpacity description]
		 * @param {[type]} v [description]
		 */
		setOpacity(v) {
			// Set
				this.meshInstance.material.opacity = v===1?0.999:v;
				// this.meshInstance.material.alphaFade = v===1?0.999:v; // use when opacityFadesSpecular === false;			

			// Update
				this.meshInstance.material.update();

		}

		translateBlade(v) {

			// this.entity.translate(0, 0, -fixFloat(this.index/1000)+v/1000);

			var p = this.entity.getPosition();
			const s = Math.abs(v) < 1 ? 1 : v;			
			this.entity.setPosition(p.x, p.y, -(fixFloat(this.index/1000)*s));

		}

	////////////////////////
	// METHODS
	////////////////////////

		/**
		 * [createMesh description]
		 * @return {[type]} [description]
		 */
		createMesh() {


			// Postions
			const positions = new Float32Array(meshPositions);
	        const uvs = new Float32Array(meshUvs);   


			this.mesh = new Mesh(this.graphicsDevice);
	        this.mesh.clear(true, false);
	        this.mesh.setPositions(positions);
	        this.mesh.setNormals(calculateNormals(positions, meshIndices));
	        this.mesh.setUvs(0, uvs);
	        this.mesh.setIndices(meshIndices);
	        this.mesh.update(PRIMITIVE_TRIANGLES);

		}

		/**
		 * [createMorphTargets description]
		 * @return {[type]} [description]
		 */
		createMorphTargets() {

			this.morphTargets = [];

	        for (var i = 0; i < meshMorphPositions.length; i++) {
	   
	            const morphPositions = new Float32Array(meshMorphPositions[i]);

	            const morphNormals = new Float32Array(
	                calculateNormals(morphPositions, meshIndices)
	            );
	            
	            const morphTarget =  new MorphTarget({
	                deltaPositions: morphPositions,
	                deltaNormals: morphNormals,
	                defaultWeight: 0
	            });  

	            this.morphTargets.push(morphTarget);
	        }

		}

		/**
		 * [createMorphInstance description]
		 * @return {[type]} [description]
		 */
		createMorphInstance() {

			this.mesh.morph = new Morph(this.morphTargets, this.graphicsDevice);
			this.morphInstance = new MorphInstance(this.mesh.morph);

		}


		/**
		 * [createMeshInstance description]
		 * @return {[type]} [description]
		 */
		createMeshInstance() {

			// reate the mesh instance
			this.meshInstance = new MeshInstance(this.mesh, this.material.getMaterial());

			// this.meshInstance.mask = 0;

			// WORKING when useLayers === false BUT doesn't work for tilted meshes
				this.meshInstance.calculateSortDistance = function(meshInstance, cameraPosition, cameraForward) {
					//console.log(cameraPosition, cameraForward);
					return cameraPosition.z>cameraForward.z?this.index:-this.index;
				}.bind(this);
		
			// TBD
				
				// this.meshInstance.calculateSortDistance = function(meshInstance, cameraPosition, cameraForward) {
				// 	//console.log(cameraPosition, cameraForward);
				// 	this.meshInstance.drawOrder = cameraPosition.z>cameraForward.z?-this.index:this.index;
				// 	return cameraPosition.z>cameraForward.z?this.index:-this.index;
				// }.bind(this);

			// Add morph instance
			this.meshInstance.morphInstance = this.morphInstance; 

		}

		/**
		 * [createEntity description]
		 * @return {[type]} [description]
		 */
		createEntity() {

			if (this.useLayers === true) {

				// get the world layer index
	    		const worldLayer = this.layers.getLayerByName("World");
	    		const idx = this.layers.getTransparentIndex(worldLayer);

				// Create Custom Layer that will holde the entity
					this.layer = new Layer();
					this.layer.id = this.layer.name = this.name;
					this.layer.opaqueSortMode = SORTMODE_MANUAL; //SORTMODE_MATERIALMESH; //SORTMODE_MANUAL;	
					this.layer.transparentSortMode = SORTMODE_MANUAL;
					// this.layer.passThrough = true;
					// this.layer.clearDepthBuffer = true;
					// this.layer.shaderPass = SHADER_DEPTH;
					this.layers.insert(this.layer, idx+1);

				// Create Entity
					this.entity = new Entity();
					this.entity.name = this.name;
					this.entity.addComponent("render", {
					    meshInstances: [this.meshInstance],
					});

				// Add Cutom layer to Entity
					this.entity.render.layers = [this.layer.id];

			} else {

				// Create Entity
					this.entity = new Entity();
					this.entity.name = this.name;
					this.entity.addComponent("render", {
					    meshInstances: [this.meshInstance],
					});

			}

			// PUSH in Z-dir so we stack blades
				// this.entity.translate(0, 0, (this.index/1000));
				// this.entity.translate(0, 0, -fixFloat(this.index/1000));

				this.entity.translate(0, 0, -fixFloat(this.index/1000));			
		
		}

		/**
		 * [createControls description]
		 * @return {[type]} [description]
		 */
		createControls() {

			// Has UI
			if (this.hasControls === true) {
			
				this.controls = new BladeControls({
					name: this.name
					,meshMorphsIndex: this.meshMorphsIndex
					,bladeRotationOffset: this.bladeRotationOffset
					,bladeRotation: this.bladeRotation
				});

			}

		}
}

// PC

const CreateOrbitCamera = ({...props}) => {

	// Props
	const { app, count, defaultZoom, defaultOrthoHeight, canZoom, useLayers } = props;

	// Orbit Camera
	var OrbitCamera = createScript('orbitCamera', app);

	OrbitCamera.attributes.add('useLayers', {type: 'boolean', default: useLayers, title: 'Add Custom layers to camera'});
	OrbitCamera.attributes.add('layerCount', {type: 'number', default: count, title: 'Custom layers count'});
	OrbitCamera.attributes.add('distanceDefault', {type: 'number', default: defaultZoom, title: 'Distance Default'});	
	OrbitCamera.attributes.add('distanceMax', {type: 'number', default: canZoom === true && defaultZoom !==null ? 0: defaultZoom, title: 'Distance Max', description: 'Setting this at 0 will give an infinite distance limit'});
	OrbitCamera.attributes.add('distanceMin', {type: 'number', default: canZoom === true && defaultZoom !==null ? 0: defaultZoom, title: 'Distance Min'});
	OrbitCamera.attributes.add('heightDefault', {type: 'number', default: defaultOrthoHeight, title: 'Distance Orthographic height'});

	// This will disable Y 360 rotation
	// OrbitCamera.attributes.add('pitchAngleMax', {type: 'number', default: 90, title: 'Pitch Angle Max (degrees)'});
	// OrbitCamera.attributes.add('pitchAngleMin', {type: 'number', default: -90, title: 'Pitch Angle Min (degrees)'});

	OrbitCamera.attributes.add('inertiaFactor', {
	    type: 'number',
	    default: 0,
	    title: 'Inertia Factor',
	    description: 'Higher value means that the camera will continue moving after the user has stopped dragging. 0 is fully responsive.'
	});

	OrbitCamera.attributes.add('focusEntity', {
	    type: 'entity',
	    title: 'Focus Entity',
	    description: 'Entity for the camera to focus on. If blank, then the camera will use the whole scene'
	});

	OrbitCamera.attributes.add('frameOnStart', {
	    type: 'boolean',
	    default: true,
	    title: 'Frame on Start',
	    description: 'Frames the entity or scene at the start of the application."'
	});

	// Property to get and set the distance between the pivot point and camera
	// Clamped between this.distanceMin and this.distanceMax
	Object.defineProperty(OrbitCamera.prototype, "distance", {
	    get: function() {
	        return this._targetDistance;
	    },

	    set: function(value) {
	        this._targetDistance = this._clampDistance(value);
	    }
	});


	// Property to get and set the pitch of the camera around the pivot point (degrees)
	// Clamped between this.pitchAngleMin and this.pitchAngleMax
	// When set at 0, the camera angle is flat, looking along the horizon
	Object.defineProperty(OrbitCamera.prototype, "pitch", {
	    get: function() {
	        return this._targetPitch;
	    },

	    set: function(value) {
	        this._targetPitch = this._clampPitchAngle(value);
	    }
	});


	// Property to get and set the yaw of the camera around the pivot point (degrees)
	Object.defineProperty(OrbitCamera.prototype, "yaw", {
	    get: function() {
	        return this._targetYaw;
	    },

	    set: function(value) {
	        this._targetYaw = value;

	        // Ensure that the yaw takes the shortest route by making sure that 
	        // the difference between the targetYaw and the actual is 180 degrees
	        // in either direction
	        var diff = this._targetYaw - this._yaw;
	        var reminder = diff % 360;
	        if (reminder > 180) {
	            this._targetYaw = this._yaw - (360 - reminder);
	        } else if (reminder < -180) {
	            this._targetYaw = this._yaw + (360 + reminder);
	        } else {
	            this._targetYaw = this._yaw + reminder;
	        }
	    }
	});


	// Property to get and set the world position of the pivot point that the camera orbits around
	Object.defineProperty(OrbitCamera.prototype, "pivotPoint", {
	    get: function() {
	        return this._pivotPoint;
	    },

	    set: function(value) {
	        this._pivotPoint.copy(value);
	    }
	});


	// Moves the camera to look at an entity and all its children so they are all in the view
	OrbitCamera.prototype.focus = function (focusEntity) {
	    // Calculate an bounding box that encompasses all the models to frame in the camera view
	    this._buildAabb(focusEntity, 0);

	    var halfExtents = this._modelsAabb.halfExtents;

	    if (this.distanceDefault !== null) {
	    	this.distance = this.distanceDefault;
		} else {
		    var distance = Math.max(halfExtents.x, Math.max(halfExtents.y, halfExtents.z));
		    distance = (distance / Math.tan(0.5 * this.entity.camera.fov * math.DEG_TO_RAD));
		    distance = (distance * 2);
		    this.distance = distance;
		}

	    this._removeInertia();

	    this._pivotPoint.copy(this._modelsAabb.center);
	};


	OrbitCamera.distanceBetween = new Vec3();

	// Set the camera position to a world position and look at a world position
	// Useful if you have multiple viewing angles to swap between in a scene
	OrbitCamera.prototype.resetAndLookAtPoint = function (resetPoint, lookAtPoint) {
	    this.pivotPoint.copy(lookAtPoint);
	    this.entity.setPosition(resetPoint);

	    this.entity.lookAt(lookAtPoint);

	    var distance = OrbitCamera.distanceBetween;
	    distance.sub2(lookAtPoint, resetPoint);
	    this.distance = distance.length();

	    this.pivotPoint.copy(lookAtPoint);

	    var cameraQuat = this.entity.getRotation();
	    this.yaw = this._calcYaw(cameraQuat);
	    this.pitch = this._calcPitch(cameraQuat, this.yaw);

	    this._removeInertia();
	    this._updatePosition();
	};


	// Set camera position to a world position and look at an entity in the scene
	// Useful if you have multiple models to swap between in a scene
	OrbitCamera.prototype.resetAndLookAtEntity = function (resetPoint, entity) {
	    this._buildAabb(entity, 0);
	    this.resetAndLookAtPoint(resetPoint, this._modelsAabb.center);
	};


	// Set the camera at a specific, yaw, pitch and distance without inertia (instant cut)
	OrbitCamera.prototype.reset = function (yaw, pitch, distance) {
	    this.pitch = pitch;
	    this.yaw = yaw;
	    this.distance = distance;

	    this._removeInertia();
	};

	/////////////////////////////////////////////////////////////////////////////////////////////
	// Private methods

	OrbitCamera.prototype.initialize = function () {

		// CUSTOM - Create Camera

			// CAMERA wt/wo layers 
			
				// const worldLayer = this.app.scene.layers.getLayerByName("World");
				// const layers = [worldLayer.id];
				
				this.entity.addComponent("camera", {
					
					// clearColor: new pc.Color(0.2, 0.2, 0.2, 0) // new pc.Color(0.2, 0.2, 0.2),
					// NEW
					projection: PROJECTION_ORTHOGRAPHIC
					,orthoHeight: this.heightDefault
					// ,cullFaces: false
					
					,clearColorBuffer: false
					,clearDepthBuffer: false
					// ,clearColorBuffer: true
					// ,clearDepthBuffer: true					
					
					,priority: 1

					// ,flipFaces: true

					// ,nearClip: 1
					// ,farClip: 100
					// ,fov: 55,
					// ,projection: pc.PROJECTION_ORTHOGRAPHIC
				});

				console.log("orbit camera layers", this.entity.camera.layers);

				if (this.useLayers  === true) {

					const layers = this.entity.camera.layers;
					for (var i = 1; i < this.layerCount+1; i++) {
						layers.push("blade"+i);
					}					this.entity.camera.layers = layers;

					// for (var i = 1; i < this.layerCount+1; i++) {
					// 	var entity = new pc.Entity();
					// 	entity.addComponent('camera', {
					// 	    // nearClip: 1,
					// 	    // farClip: 100,
					// 	    // fov: 55
					// 	    //
					// 	    // clearColorBuffer: true
					// 		// ,clearColor: new pc.Color(0.2, 0.2, 0.2, 0) // new pc.Color(0.2, 0.2, 0.2),
					// 	    // ,clearDepthBuffer: true
						    
					// 	    clearDepthBuffer: false
					// 	    ,priority: i
					// 	    // ,projection: pc.PROJECTION_ORTHOGRAPHIC
					// 	    // ,frustumCulling: true
					// 	    ,clearColorBuffer: false
					// 	    // ,cullFaces: false
						    
					// 	});
					// 	entity.camera.layers = ["blade"+i];				

					// 	this.entity.addChild(entity);
					// };		
				
				}

			// TEST - each layer will have its own camera with the priority
				
				// this.entity.addComponent("camera", {
				// 	clearColorBuffer: false
				// 	// ,clearColor: new pc.Color(0, 0, 0, 0) // new pc.Color(0.2, 0.2, 0.2),
				// 	// NEW
				// 	// ,projection: pc.PROJECTION_ORTHOGRAPHIC
				// 	// ,cullFaces: false
				// 	,clearDepthBuffer: false
				// });
				// for (var i = 1; i < this.layerCount+1; i++) {
				// 	var entity = new pc.Entity();
				// 	entity.addComponent('camera', {
				// 	    // nearClip: 1,
				// 	    // farClip: 100,
				// 	    // fov: 55
				// 	    //
				// 	    // clearColorBuffer: true
				// 		// ,clearColor: new pc.Color(0.2, 0.2, 0.2, 0) // new pc.Color(0.2, 0.2, 0.2),
				// 	    // ,clearDepthBuffer: true
					    
				// 	    clearDepthBuffer: false
				// 	    ,priority: i
				// 	    // ,projection: pc.PROJECTION_ORTHOGRAPHIC
				// 	    // ,frustumCulling: true
				// 	    ,clearColorBuffer: false
				// 	    // ,cullFaces: false
					    
				// 	});
				// 	entity.camera.layers = ["blade"+i];				

				// 	this.entity.addChild(entity);
				// };		
				
			
		// BAU

	    var self = this;
	    var onWindowResize = function () {
	        self._checkAspectRatio();
	    };

	    window.addEventListener('resize', onWindowResize, false);

	    this._checkAspectRatio();

	    // Find all the models in the scene that are under the focused entity
	    this._modelsAabb = new BoundingBox();
	    this._buildAabb(this.focusEntity || this.app.root, 0);

	    this.entity.lookAt(this._modelsAabb.center);

	    this._pivotPoint = new Vec3();
	    this._pivotPoint.copy(this._modelsAabb.center);

	    // Calculate the camera euler angle rotation around x and y axes
	    // This allows us to place the camera at a particular rotation to begin with in the scene
	    var cameraQuat = this.entity.getRotation();

	    // Preset the camera
	    this._yaw = this._calcYaw(cameraQuat);
	    this._pitch = this._clampPitchAngle(this._calcPitch(cameraQuat, this._yaw));
	    this.entity.setLocalEulerAngles(this._pitch, this._yaw, 0);

	    this._distance = 0;

	    this._targetYaw = this._yaw;
	    this._targetPitch = this._pitch;

	    // If we have ticked focus on start, then attempt to position the camera where it frames
	    // the focused entity and move the pivot point to entity's position otherwise, set the distance
	    // to be between the camera position in the scene and the pivot point
	    if (this.frameOnStart) {
	        this.focus(this.focusEntity || this.app.root);
	    } else {
	        var distanceBetween = new Vec3();
	        distanceBetween.sub2(this.entity.getPosition(), this._pivotPoint);
	        this._distance = this._clampDistance(distanceBetween.length());
	    }

	    this._targetDistance = this._distance;

	    // Reapply the clamps if they are changed in the editor
	    this.on('attr:distanceMin', function (value, prev) {
	        this._targetDistance = this._clampDistance(this._distance);
	    });

	    this.on('attr:distanceMax', function (value, prev) {
	        this._targetDistance = this._clampDistance(this._distance);
	    });

	    this.on('attr:pitchAngleMin', function (value, prev) {
	        this._targetPitch = this._clampPitchAngle(this._pitch);
	    });

	    this.on('attr:pitchAngleMax', function (value, prev) {
	        this._targetPitch = this._clampPitchAngle(this._pitch);
	    });

	    // Focus on the entity if we change the focus entity
	    this.on('attr:focusEntity', function (value, prev) {
	        if (this.frameOnStart) {
	            this.focus(value || this.app.root);
	        } else {
	            this.resetAndLookAtEntity(this.entity.getPosition(), value || this.app.root);
	        }
	    });

	    this.on('attr:frameOnStart', function (value, prev) {
	        if (value) {
	            this.focus(this.focusEntity || this.app.root);
	        }
	    });	    

	    this.on('destroy', function() {
	        window.removeEventListener('resize', onWindowResize, false);
	    });

	    // CUSTOM
	    this.on('reset', function () {
	    	// Reset Orbit to initial postion and pitch
	    	this._resetPosition();
	    });

	    this.on('projection', function (value) {
	    	switch (value) {
				case "p":
					this.entity.camera.projection = PROJECTION_PERSPECTIVE;
					break;
				case "o": 
					this.entity.camera.orthoHeight = this.heightDefault;
					this.entity.camera.projection = PROJECTION_ORTHOGRAPHIC;					
					break;
			}
		});
	};


	OrbitCamera.prototype.update = function(dt) {
	    // Add inertia, if any
	    var t = this.inertiaFactor === 0 ? 1 : Math.min(dt / this.inertiaFactor, 1);
	    this._distance = math.lerp(this._distance, this._targetDistance, t);
	    this._yaw = math.lerp(this._yaw, this._targetYaw, t);
	    this._pitch = math.lerp(this._pitch, this._targetPitch, t);

	    this._updatePosition();
	};


	OrbitCamera.prototype._updatePosition = function () {
	    // Work out the camera position based on the pivot point, pitch, yaw and distance
	    this.entity.setLocalPosition(0,0,0);
	    this.entity.setLocalEulerAngles(this._pitch, this._yaw, 0);

	    var position = this.entity.getPosition();
	    position.copy(this.entity.forward);
	    position.scale(-this._distance);
	    position.add(this.pivotPoint);
	    this.entity.setPosition(position);

	    // console.warn("\tposition", position);

	};

	// CUSTOM
	OrbitCamera.prototype._resetPosition = function () {
		
		this._targetPitch = 0;
		this._targetYaw = -0;
		this._targetDistance = this.distanceDefault;
		
	};


	OrbitCamera.prototype._removeInertia = function () {
	    this._yaw = this._targetYaw;
	    this._pitch = this._targetPitch;
	    this._distance = this._targetDistance;
	};


	OrbitCamera.prototype._checkAspectRatio = function () {
	    var height = this.app.graphicsDevice.height;
	    var width = this.app.graphicsDevice.width;

	    // Match the axis of FOV to match the aspect ratio of the canvas so
	    // the focused entities is always in frame
	    this.entity.camera.horizontalFov = height > width;
	};


	OrbitCamera.prototype._buildAabb = function (entity, modelsAdded) {
	    // Generate a AABB for all model and render components
	    var i = 0, j = 0;
	    var meshInstances = null;
	    var allMeshInstances = [];
	    
	    var renders = entity.findComponents('render');
	    for (i = 0; i < renders.length; ++i) {
	        meshInstances = renders[i].meshInstances;
	        for (j = 0; j < meshInstances.length; j++) {
	            allMeshInstances.push(meshInstances[j]);
	        }
	    }  
	    
	    var models = entity.findComponents('model');
	    for (i = 0; i < models.length; ++i) {
	        meshInstances = models[i].meshInstances;
	        for (j = 0; j < meshInstances.length; j++) {
	            allMeshInstances.push(meshInstances[j]);
	        }
	    }  

	    for (i = 0; i < allMeshInstances.length; i++) {
	        if (modelsAdded === 0) {
	            this._modelsAabb.copy(allMeshInstances[i].aabb);
	        } else {
	            this._modelsAabb.add(allMeshInstances[i].aabb);
	        }

	        modelsAdded += 1;
	    }


	    return modelsAdded;
	};


	OrbitCamera.prototype._calcYaw = function (quat) {
	    var transformedForward = new Vec3();
	    quat.transformVector(Vec3.FORWARD, transformedForward);

	    return Math.atan2(-transformedForward.x, -transformedForward.z) * math.RAD_TO_DEG;
	};


	OrbitCamera.prototype._clampDistance = function (distance) {
	    if (this.distanceMax > 0) {
	        return math.clamp(distance, this.distanceMin, this.distanceMax);
	    } else {
	        return Math.max(distance, this.distanceMin);
	    }
	};


	OrbitCamera.prototype._clampPitchAngle = function (pitch) {
	    // Negative due as the pitch is inversed since the camera is orbiting the entity
	    return math.clamp(pitch, -this.pitchAngleMax, -this.pitchAngleMin);
	};


	OrbitCamera.quatWithoutYaw = new Quat();
	OrbitCamera.yawOffset = new Quat();

	OrbitCamera.prototype._calcPitch = function(quat, yaw) {
	    var quatWithoutYaw = OrbitCamera.quatWithoutYaw;
	    var yawOffset = OrbitCamera.yawOffset;

	    yawOffset.setFromEulerAngles(0, -yaw, 0);
	    quatWithoutYaw.mul2(yawOffset, quat);

	    var transformedForward = new Vec3();

	    quatWithoutYaw.transformVector(Vec3.FORWARD, transformedForward);

	    return Math.atan2(transformedForward.y, -transformedForward.z) * math.RAD_TO_DEG;
	};

	return OrbitCamera;
};

// PC

const CreateMouseInput = ({...props}) => {

	// Props
	const { app: app$1, algowimControls } = props;

	// Mouse Input
	var MouseInput = createScript('mouseInput', app$1);

	MouseInput.attributes.add('orbitSensitivity', {
	    type: 'number', 
	    default: 0.3, 
	    title: 'Orbit Sensitivity', 
	    description: 'How fast the camera moves around the orbit. Higher is faster'
	});

	MouseInput.attributes.add('distanceSensitivity', {
	    type: 'number', 
	    default: 0.15, 
	    title: 'Distance Sensitivity', 
	    description: 'How fast the camera moves in and out. Higher is faster'
	});

	MouseInput.attributes.add('algowimControls', {
	    type: 'object', 
	    default: algowimControls, 
	    title: 'AlgoWim Controls', 
	    description: 'Object to call to disable pointer-events for overlay DOM elements on move'
	});

	// initialize code called once per entity
	MouseInput.prototype.initialize = function() {	    

	    this.orbitCamera = this.entity.script.orbitCamera;

	    if (this.orbitCamera) {
	        var self = this;
	        
	        var onMouseOut = function (e) {
	           self.onMouseOut(e);
	        };

	        // CUSTOM
	        	// this.app.mouse._target.addEventListener('pointerdown', this.onMouseDown.bind(this), false);
	        	// this.app.mouse._target.addEventListener('pointerup', this.onMouseUp.bind(this), false);
	        	// console.log(this.app.mouse);

	        // ORIG
	        	this.app.mouse.on(EVENT_MOUSEDOWN, this.onMouseDown, this);
	        	this.app.mouse.on(EVENT_MOUSEUP, this.onMouseUp, this);	        
	        	this.app.mouse.on(EVENT_MOUSEMOVE, this.onMouseMove, this);
	        	this.app.mouse.on(EVENT_MOUSEWHEEL, this.onMouseWheel, this);

	        // Listen to when the mouse travels out of the window
	        window.addEventListener('mouseout', onMouseOut, false);
	        
	        // Remove the listeners so if this entity is destroyed
	        this.on('destroy', function() {
	            this.app.mouse.off(EVENT_MOUSEDOWN, this.onMouseDown, this);
	            this.app.mouse.off(EVENT_MOUSEUP, this.onMouseUp, this);
	            this.app.mouse.off(EVENT_MOUSEMOVE, this.onMouseMove, this);
	            this.app.mouse.off(EVENT_MOUSEWHEEL, this.onMouseWheel, this);

	            window.removeEventListener('mouseout', onMouseOut, false);
	        });
	    }
	    
	    // Disabling the context menu stops the browser displaying a menu when
	    // you right-click the page
	    this.app.mouse.disableContextMenu();
	  
	    this.lookButtonDown = false;
	    this.panButtonDown = false;
	    this.lastPoint = new Vec2();
	};


	MouseInput.fromWorldPoint = new Vec3();
	MouseInput.toWorldPoint = new Vec3();
	MouseInput.worldDiff = new Vec3();


	MouseInput.prototype.pan = function(screenPoint) {
	    var fromWorldPoint = MouseInput.fromWorldPoint;
	    var toWorldPoint = MouseInput.toWorldPoint;
	    var worldDiff = MouseInput.worldDiff;
	    
	    // For panning to work at any zoom level, we use screen point to world projection
	    // to work out how far we need to pan the pivotEntity in world space 
	    var camera = this.entity.camera;
	    var distance = this.orbitCamera.distance;
	    
	    camera.screenToWorld(screenPoint.x, screenPoint.y, distance, fromWorldPoint);
	    camera.screenToWorld(this.lastPoint.x, this.lastPoint.y, distance, toWorldPoint);

	    worldDiff.sub2(toWorldPoint, fromWorldPoint);
	       
	    this.orbitCamera.pivotPoint.add(worldDiff);    
	};


	MouseInput.prototype.onMouseDown = function (event) {
		// console.log(event.event.target);
		

		// console.log("DOWN event.pointerId", event.pointerId);
		// this.app.mouse._target.onpointermove = this.onMouseMove.bind(this);
		// this.app.mouse._target.setPointerCapture(event.pointerId);


		// CUSTOM
		if (event.event.target.tagName!=="CANVAS") return;
		if (this.algowimControls !== null) {
			this.algowimControls.lockControls();
		}

		// BAU
	    switch (event.button) {
	        case MOUSEBUTTON_LEFT: {
	            this.lookButtonDown = true;
	        } break;
	        // case pc.MOUSEBUTTON_RIGHT: {
	        //     this.panButtonDown = true;
	        // } break;
	    }
	};


	MouseInput.prototype.onMouseUp = function (event) {

		// console.log("this.algowimControls", this.algowimControls);
		// console.log("UP event.pointerId", event.pointerId);
		// this.app.mouse._target.onpointermove = null;
		// this.app.mouse._target.releasePointerCapture(event.pointerId);
		
		// CUSTOM
		if (event.event.target.tagName!=="CANVAS") return;		
		if (this.algowimControls !== null) {
			this.algowimControls.unlockControls();
		}

		// BAU
	    switch (event.button) {
	        case MOUSEBUTTON_LEFT: {
	            this.lookButtonDown = false;
	        } break;
	        // case pc.MOUSEBUTTON_RIGHT: {
	        //     this.panButtonDown = false;            
	        // } break;
	    }
	};


	MouseInput.prototype.onMouseMove = function (event) {

		// console.log("MOVE event.pointerId", event);

	    app.mouse;
	    if (this.lookButtonDown) {
	        this.orbitCamera.pitch -= event.dy * this.orbitSensitivity;
	        this.orbitCamera.yaw -= event.dx * this.orbitSensitivity;
	        
	    } else if (this.panButtonDown) {
	        this.pan(event);   
	    }
	    
	    this.lastPoint.set(event.x, event.y);
	};


	MouseInput.prototype.onMouseWheel = function (event) {
	    this.orbitCamera.distance -= event.wheel * this.distanceSensitivity * (this.orbitCamera.distance * 0.1);
	    event.event.preventDefault();
	};


	MouseInput.prototype.onMouseOut = function (event) {

		// CUSTOM
		if (this.algowimControls !== null) {
			this.algowimControls.unlockControls();
		}

		// BAU
	    this.lookButtonDown = false;
	    this.panButtonDown = false;
	};

	return MouseInput;
};

// PC

const CreateTouchInput = ({...props}) => {

	// Props
	const { app } = props;

	// Touch Input
	var TouchInput = createScript('touchInput', app);

	TouchInput.attributes.add('orbitSensitivity', {
	    type: 'number', 
	    default: 0.4, 
	    title: 'Orbit Sensitivity', 
	    description: 'How fast the camera moves around the orbit. Higher is faster'
	});

	TouchInput.attributes.add('distanceSensitivity', {
	    type: 'number', 
	    default: 0.2, 
	    title: 'Distance Sensitivity', 
	    description: 'How fast the camera moves in and out. Higher is faster'
	});

	// initialize code called once per entity
	TouchInput.prototype.initialize = function() {
	    this.orbitCamera = this.entity.script.orbitCamera;
	    
	    // Store the position of the touch so we can calculate the distance moved
	    this.lastTouchPoint = new Vec2();
	    this.lastPinchMidPoint = new Vec2();
	    this.lastPinchDistance = 0;
	    
	    if (this.orbitCamera && this.app.touch) {
	        // Use the same callback for the touchStart, touchEnd and touchCancel events as they 
	        // all do the same thing which is to deal the possible multiple touches to the screen
	        this.app.touch.on(EVENT_TOUCHSTART, this.onTouchStartEndCancel, this);
	        this.app.touch.on(EVENT_TOUCHEND, this.onTouchStartEndCancel, this);
	        this.app.touch.on(EVENT_TOUCHCANCEL, this.onTouchStartEndCancel, this);
	        
	        this.app.touch.on(EVENT_TOUCHMOVE, this.onTouchMove, this);
	        
	        this.on('destroy', function() {
	            this.app.touch.off(EVENT_TOUCHSTART, this.onTouchStartEndCancel, this);
	            this.app.touch.off(EVENT_TOUCHEND, this.onTouchStartEndCancel, this);
	            this.app.touch.off(EVENT_TOUCHCANCEL, this.onTouchStartEndCancel, this);

	            this.app.touch.off(EVENT_TOUCHMOVE, this.onTouchMove, this);
	        });
	    }
	};


	TouchInput.prototype.getPinchDistance = function (pointA, pointB) {
	    // Return the distance between the two points
	    var dx = pointA.x - pointB.x;
	    var dy = pointA.y - pointB.y;    
	    
	    return Math.sqrt((dx * dx) + (dy * dy));
	};


	TouchInput.prototype.calcMidPoint = function (pointA, pointB, result) {
	    result.set(pointB.x - pointA.x, pointB.y - pointA.y);
	    result.scale(0.5);
	    result.x += pointA.x;
	    result.y += pointA.y;
	};


	TouchInput.prototype.onTouchStartEndCancel = function(event) {
	    // We only care about the first touch for camera rotation. As the user touches the screen, 
	    // we stored the current touch position
	    var touches = event.touches;
	    if (touches.length == 1) {
	        this.lastTouchPoint.set(touches[0].x, touches[0].y);
	    
	    } else if (touches.length == 2) {
	        // If there are 2 touches on the screen, then set the pinch distance
	        this.lastPinchDistance = this.getPinchDistance(touches[0], touches[1]);
	        this.calcMidPoint(touches[0], touches[1], this.lastPinchMidPoint);
	    }
	};


	TouchInput.fromWorldPoint = new Vec3();
	TouchInput.toWorldPoint = new Vec3();
	TouchInput.worldDiff = new Vec3();


	TouchInput.prototype.pan = function(midPoint) {
	    var fromWorldPoint = TouchInput.fromWorldPoint;
	    var toWorldPoint = TouchInput.toWorldPoint;
	    var worldDiff = TouchInput.worldDiff;
	    
	    // For panning to work at any zoom level, we use screen point to world projection
	    // to work out how far we need to pan the pivotEntity in world space 
	    var camera = this.entity.camera;
	    var distance = this.orbitCamera.distance;
	    
	    camera.screenToWorld(midPoint.x, midPoint.y, distance, fromWorldPoint);
	    camera.screenToWorld(this.lastPinchMidPoint.x, this.lastPinchMidPoint.y, distance, toWorldPoint);
	    
	    worldDiff.sub2(toWorldPoint, fromWorldPoint);
	     
	    this.orbitCamera.pivotPoint.add(worldDiff);    
	};


	TouchInput.pinchMidPoint = new Vec2();

	TouchInput.prototype.onTouchMove = function(event) {
	    var pinchMidPoint = TouchInput.pinchMidPoint;
	    
	    // We only care about the first touch for camera rotation. Work out the difference moved since the last event
	    // and use that to update the camera target position 
	    var touches = event.touches;
	    if (touches.length == 1) {
	        var touch = touches[0];
	        
	        this.orbitCamera.pitch -= (touch.y - this.lastTouchPoint.y) * this.orbitSensitivity;
	        this.orbitCamera.yaw -= (touch.x - this.lastTouchPoint.x) * this.orbitSensitivity;
	        
	        this.lastTouchPoint.set(touch.x, touch.y);
	    
	    } else if (touches.length == 2) {
	        // Calculate the difference in pinch distance since the last event
	        var currentPinchDistance = this.getPinchDistance(touches[0], touches[1]);
	        var diffInPinchDistance = currentPinchDistance - this.lastPinchDistance;
	        this.lastPinchDistance = currentPinchDistance;
	                
	        this.orbitCamera.distance -= (diffInPinchDistance * this.distanceSensitivity * 0.1) * (this.orbitCamera.distance * 0.1);
	        
	        // Calculate pan difference
	        this.calcMidPoint(touches[0], touches[1], pinchMidPoint);
	        this.pan(pinchMidPoint);
	        this.lastPinchMidPoint.copy(pinchMidPoint);
	    }
	};


	return TouchInput;
};

// PCUI

class SceneControls {

	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		/**
		 * [constructor description]
		 * @param  {...[type]} options.props [description]
		 * @return {[type]}                  [description]
		 */
		constructor({...props}) {
			

			// Props
			const { 
				name
				,camera
			} = props;
			this.name = name;
			this.camera = camera || false;			

	    	// Controls
	    	this.controls = {
	    		ui: htmlToDomFragment("<div></div>")
	    		,observers: {}
	    	};

			// Init
			this.init();
	        
		}

		

	////////////////////////
	// INITIALIZE
	////////////////////////

		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {

			// Create Controls
			this.createControls();

		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////
	
		/**
		 * [getControls description]
		 * @return {[type]} [description]
		 */
		getControls(opt_key) {

			return opt_key ? this.controls[opt_key] : this.controls;

		}		

	////////////////////////
	// METHODS
	////////////////////////

		/**
		 * [createControls description]
		 * @return {[type]} [description]
		 */
		createControls() {

			// Add ALL
								
				// Container
					const sceneContainer = document.createElement("DIV");

				// // UI Controls name
				// 	const uiNameContainer = document.createElement("DIV");
				// 	const uiLabel = new Label({
				// 		enabled: true,
				// 		height: null,
				// 		text: "DEV CONTROLS",
				// 		tabIndex:0,
				// 		width:null
				// 	});
				// 	uiNameContainer.appendChild(uiLabel.dom);
				// 	uiLabel.dom.style.color = "#2c393c";
				// 	// uiNameContainer.style.paddingLeft = "30px";
				// 	uiNameContainer.style.marginTop = "5px";
				// 	sceneContainer.appendChild(uiNameContainer);


				// Scene Controls name
					const sceneNameContainer = document.createElement("DIV");
					const sceneLabel = new Label({
						enabled: true,
						height: null,
						text: this.name.toUpperCase(),
						tabIndex:0,
						width:null
					});
					sceneNameContainer.appendChild(sceneLabel.dom);
					sceneLabel.dom.style.color = "#FF0000";
					sceneNameContainer.style.marginTop = sceneNameContainer.style.marginBottom = "15px";
					sceneContainer.appendChild(sceneNameContainer);

				// Scene Controls					
					const sceneStateContainer = document.createElement("DIV");

					// Camera
						if (this.camera!==false) {

							// Reset Orbit
								
								// Label
								const resetLabelContainer = document.createElement("DIV");
								const resetLabel = new Label({
									enabled: true,
									height: null,
									text: "camera orbit",
									tabIndex:0,
									width:null
								});
								resetLabelContainer.appendChild(resetLabel.dom);
								sceneStateContainer.appendChild(resetLabelContainer);

								// Button
								const resetObserver = new Observer({progress: 1});
								// Observer Callback is set from the main class
								// stateObserver.on('progress:set', function(value) {
								// 	console.log("value 4", value);
								// }.bind(this));
								const resetButton = new Button({
									enabled: true,
									height: null,
									icon: "E401",
									size: "",
									tabIndex:0,
									text:"Reset",
									width:null
								});
								// Link observer
								resetButton.link(resetObserver,'progress');
								// Add button to state export container
								sceneStateContainer.appendChild(resetButton.dom);
								// Add Listener to Button
								resetButton.on('click', function(value) {
									// Dispatch event (toggle)
									const oldValue = resetObserver.get("progress");						
									resetObserver.set("progress", -1*oldValue);
								});

								// Add
								this.controls.observers["resetcamera"] = {
									idx: "reset"
									,observer: resetObserver
									,type: "camera"
								};

							// Projection
								
								// Label
								const projectionLabelContainer = document.createElement("DIV");
								const projectionLabel = new Label({
									enabled: true,
									height: null,
									text: "camera projection",
									tabIndex:0,
									width:null
								});
								projectionLabelContainer.appendChild(projectionLabel.dom);
								sceneStateContainer.appendChild(projectionLabelContainer);

								// Button
								const projectionObserver = new Observer({progress: "o"});
								// Observer Callback is set from the main class
								// stateObserver.on('progress:set', function(value) {
								// 	console.log("value 4", value);
								// }.bind(this));
								const projectionButton = new SelectInput({
									enabled: true,
									height: null,
									icon: "E401",
									size: "",
									tabIndex:0,
									value: "o",
									width: null,
									options: [ {v:"o",t:"Orthographic"}, {v:"p",t:"Perspective"} ]
								});
								// Link observer
								projectionButton.link(projectionObserver,'progress');
								// Add button to state export container
								sceneStateContainer.appendChild(projectionButton.dom);
								// Add Listener to Button
								projectionButton.on('change', function(value) {
									// Dispatch event
									projectionObserver.set("progress", value);
								});

								// Add
								this.controls.observers["projectioncamera"] = {
									idx: "projection"
									,observer: projectionObserver
									,type: "camera"
								};
						
						}

						// Material Depth							
							
							// Label
							const materialdepthLabelContainer = document.createElement("DIV");
							const materialdepthLabel = new Label({
								enabled: true,
								height: null,
								text: "material depth",
								tabIndex:0,
								width:null
							});
							materialdepthLabelContainer.appendChild(materialdepthLabel.dom);
							sceneStateContainer.appendChild(materialdepthLabelContainer);

							// Button
							const materialdepthObserver = new Observer({progress: "e"});
							// Observer Callback is set from the main class
							// stateObserver.on('progress:set', function(value) {
							// 	console.log("value 4", value);
							// }.bind(this));
							const materialdepthButton = new SelectInput({
								enabled: true,
								height: null,
								icon: "E401",
								size: "",
								tabIndex:0,
								value: "e",
								width: null,
								options: [ {v:"e",t:"enabled"},{v:"d",t:"disabled"}]
							});
							// Link observer
							materialdepthButton.link(materialdepthObserver,'progress');
							// Add button to state export container
							sceneStateContainer.appendChild(materialdepthButton.dom);
							// Add Listener to Button
							materialdepthButton.on('change', function(value) {
								// Dispatch event
								materialdepthObserver.set("progress", value);
							});

							// Add
							this.controls.observers["depthmaterial"] = {
								idx: "depth"
								,observer: materialdepthObserver
								,type: "material"
							};

						// Opacity - Blades
							
							// Label
							const opacitybladesLabelContainer = document.createElement("DIV");
							const opacitybladesLabel = new Label({
								enabled: true,
								height: null,
								text: "opacity blades",
								tabIndex:0,
								width:null
							});
							opacitybladesLabelContainer.appendChild(opacitybladesLabel.dom);
							sceneStateContainer.appendChild(opacitybladesLabelContainer);

							// Button
							const opacitybladesObserver = new Observer({progress: 1});
							// Observer Callback is set from the main class
							// stateObserver.on('progress:set', function(value) {
							// 	console.log("value 4", value);
							// }.bind(this));							

							const opacitybladesSlider = new SliderInput({
							    enabled: true, 
								height: null,
								max: 1,
								min: 0,				
								binding: new BindingTwoWay(),
								pre: 0,
								value: 1,
								sliderMax: 1,
								sliderMin: 0,
								step: 0,
								tabIndex: 0,
								width: null
							});
							opacitybladesSlider.link(opacitybladesObserver,'progress');
							sceneStateContainer.appendChild(opacitybladesSlider.dom);

							// Add
							this.controls.observers["bladesopacity"] = {
								idx: "blades"
								,observer: opacitybladesObserver
								,type: "opacity"
							};
					
						// Opacity - Canvas
							
							// Label
							const opacitycanvasLabelContainer = document.createElement("DIV");
							const opacitycanvasLabel = new Label({
								enabled: true,
								height: null,
								text: "opacity canvas",
								tabIndex:0,
								width:null
							});
							opacitycanvasLabelContainer.appendChild(opacitycanvasLabel.dom);
							sceneStateContainer.appendChild(opacitycanvasLabelContainer);

							// Button
							const opacitycanvasObserver = new Observer({progress: 1});
							// Observer Callback is set from the main class
							// stateObserver.on('progress:set', function(value) {
							// 	console.log("value 4", value);
							// }.bind(this));							

							const opacitycanvasSlider = new SliderInput({
							    enabled: true, 
								height: null,
								max: 1,
								min: 0,				
								binding: new BindingTwoWay(),
								pre: 0,
								value: 1,
								sliderMax: 1,
								sliderMin: 0,
								step: 0,
								tabIndex: 0,
								width: null
							});
							opacitycanvasSlider.link(opacitycanvasObserver,'progress');
							sceneStateContainer.appendChild(opacitycanvasSlider.dom);

							// Add
							this.controls.observers["canvasopacity"] = {
								idx: "canvas"
								,observer: opacitycanvasObserver
								,type: "opacity"
							};

						// Separate - Blades
							
							// Label
							const separatebladesLabelContainer = document.createElement("DIV");
							const separatebladesLabel = new Label({
								enabled: true,
								height: null,
								text: "separate blades",
								tabIndex:0,
								width:null
							});
							separatebladesLabelContainer.appendChild(separatebladesLabel.dom);
							sceneStateContainer.appendChild(separatebladesLabelContainer);

							// Button
							const separatebladesObserver = new Observer({progress: 0});
							// Observer Callback is set from the main class
							// stateObserver.on('progress:set', function(value) {
							// 	console.log("value 4", value);
							// }.bind(this));							

							const separatebladesSlider = new SliderInput({
							    enabled: true, 
								height: null,
								max: 100,
								min: -100,				
								binding: new BindingTwoWay(),
								pre: 0,
								value: 0,
								sliderMax: 100,
								sliderMin: -100,
								step: 0,
								tabIndex: 0,
								width: null
							});
							separatebladesSlider.link(separatebladesObserver,'progress');
							sceneStateContainer.appendChild(separatebladesSlider.dom);

							// Add
							this.controls.observers["bladesseparate"] = {
								idx: "blades"
								,observer: separatebladesObserver
								,type: "separate"
							};

					// Add State to States Container
					sceneContainer.appendChild(sceneStateContainer);

				// Add Scene Controls to UI DOM
					this.controls.ui.appendChild(sceneContainer);
	
		}


}

class Scene {


	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		/**
		 * [constructor description]
		 * @param  {...[type]} options.props [description]
		 * @return {[type]}                  [description]
		 */
		constructor({...props}) {

			// Props
			const { controls, app, count, useLayers, algowimControls } = props;

			// Count
			this.count = count;

			// App
			this.app = app;

			// algowimControls
			this.algowimControls = algowimControls || null;

			// User Layers
			this.useLayers = useLayers || false;

			// Create Controls
			this.hasControls = (controls === true);
			this.controls = null;

			// Init
			this.init();

	        
		}


	////////////////////////
	// INITIALIZE
	////////////////////////

		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {			

			// Create Light
			this.createLight();

			// Create Camera - DEPRECATED (use script oribitCamera)
			// this.createCamera();
			// this.scene.setCameraView(); // Default View
	    	
			// Create Scipts
			this.createScripts();

			// Create Controls
			this.createControls();
		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////
	
		/**
		 * [setCameraView description] - DEPRECATED (use script oribitCamera)
		 * @param {[type]} opt_translation [description]
		 * @param {[type]} opt_lookat      [description]
		 */
		// setCameraView(opt_translation, opt_lookat) {

		// 	this.camera.translate(0, 0, 20);
		// 	this.camera.lookAt(Vec3.ZERO);

		// }

		getCamera() {
			// DEPRECATED (use script oribitCamera)
				// return this.camera;
			// SCRIPT camera
				return this.scripts.script.orbitCamera.entity;
		}

		getLight() {
			return this.light
		}

		getScripts() {			
			return this.scripts;
		}

		resetCamera() {
			this.scripts.script.orbitCamera.fire('reset');
		}

		setProjection(p) {
			this.scripts.script.orbitCamera.fire('projection', p);
		}

		/**
		 * [getControls description]
		 * @param  {[type]} opt_key [description]
		 * @return {[type]}         [description]
		 */
		getControls(opt_key) {
			return this.controls.getControls(opt_key);
		}


	////////////////////////
	// METHODS
	////////////////////////


		/**
		 * [createLight description]
		 * @return {[type]} [description]
		 */
		createLight() {

	        this.light = new Entity();
	        this.light.name = "light";
	        this.light.addComponent("light", {
	            type: "omni", //"directional",
	            color: new Color(1, 1, 1),
	            castShadows: false,
	            // range: 100,
	            // shadowBias: 0.2,
	            // shadowDistance: 25,
	            // normalOffsetBias: 0.05,
	            // shadowResolution: 2048,
	        });

	        // const worldLayer = this.app.scene.layers.getLayerByName("World");
	        // var layers = [worldLayer.id];

	        if (this.useLayers === true) {
	        	
	        	const layers = this.light.light.layers;
		        for (var i = 1; i < this.count+1; i++) {
		        	layers.push("blade"+i);
		        }
		        this.light.light.layers = layers;

		    }

	        // set the direction for our light - DEPRECATED (for directional light)
	        // this.light.setLocalEulerAngles(45, 30, 0);	        

		}

		/**
		 * [createCamera description] - DEPRECATED (use script oribitCamera)
		 * @return {[type]} [description]
		 */
		// createCamera() {

		// 	// Create an Entity with a camera component
		// 	this.camera = new Entity();
		// 	this.camera.name = "camera";
		// 	this.camera.addComponent("camera", {
		// 		clearColor: new Color(0.2, 0.2, 0.2),
		// 	});

		// }


		createScripts() {			
				
			// Scripts
			this.scripts = new Entity();
			this.scripts.name = "scripts";
			this.scripts.addComponent("script");
			// Orbit Camera
			this.scripts.script.create("orbitCamera", CreateOrbitCamera({
				app: this.app
				,count: this.count
				,defaultZoom: 20.2 //20.19
				,defaultOrthoHeight: 8.38
				,canZoom: false
				,useLayers: this.useLayers || false
			}));
			// Mouse Input
			this.scripts.script.create("mouseInput", CreateMouseInput({
				app: this.app
				,algowimControls: this.algowimControls
			}));
			// Touch Input
			this.scripts.script.create("touchInput", CreateTouchInput({
				app: this.app
			}));
			

			
			// TEST RESET orbitCamera
			// setTimeout(function() {
			// 	console.log("fire...");
			// 	this.resetCamera();
			// }.bind(this), 5000);
			

		}


		/**
		 * [createControls description]
		 * @return {[type]} [description]
		 */
		createControls() {

			// Has UI
			if (this.hasControls === true) {
			
				this.controls = new SceneControls({
					name: "scene"
					,camera: this.scripts.script.orbitCamera !== undefined
				});

			}

		}
}

// States

const presetStates = {
	base: {
	    "blade1": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	        }
	    },
	    "blade2": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 22.5
	        }
	    },
	    "blade3": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 45
	        }
	    },
	    "blade4": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 67.5
	        }
	    },
	    "blade5": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 90
	        }
	    },
	    "blade6": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 112.5
	        }
	    },
	    "blade7": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 135
	        }
	    },
	    "blade8": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 157.5
	        }
	    },
	    "blade9": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 180
	        }
	    },
	    "blade10": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 202.5
	        }
	    },
	    "blade11": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 225
	        }
	    },
	    "blade12": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 247.5
	        }
	    },
	    "blade13": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 270
	        }
	    },
	    "blade14": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 292.5
	        }
	    },
	    "blade15": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 315
	        }
	    },
	    "blade16": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 337.5
	        }
	    }
	},
	test_1: {
	    "blade1": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 0
	        }
	    },
	    "blade2": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 22.5
	        }
	    },
	    "blade3": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 45
	        }
	    },
	    "blade4": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 67.5
	        }
	    },
	    "blade5": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 90
	        }
	    },
	    "blade6": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 112.5
	        }
	    },
	    "blade7": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 135
	        }
	    },
	    "blade8": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 157.5
	        }
	    },
	    "blade9": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 180
	        }
	    },
	    "blade10": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 202.5
	        }
	    },
	    "blade11": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 225
	        }
	    },
	    "blade12": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 247.5
	        }
	    },
	    "blade13": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 270
	        }
	    },
	    "blade14": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 292.5
	        }
	    },
	    "blade15": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 315
	        }
	    },
	    "blade16": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 1,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 180,
	            "y": 0,
	            "z": 337.5
	        }
	    }
	},
	test_2: {
	    "blade1": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0.44,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": -21.5
	        }
	    },
	    "blade2": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0.44,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": -8.99
	        }
	    },
	    "blade3": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0.44,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 5.04
	        }
	    },
	    "blade4": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0.44,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 16.98
	        }
	    },
	    "blade5": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0.44,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 67.17
	        }
	    },
	    "blade6": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0.44,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 80.15
	        }
	    },
	    "blade7": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0.44,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 96.18
	        }
	    },
	    "blade8": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0.44,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 109.17
	        }
	    },
	    "blade9": {
	        "morphing": {
	            "m_Cutout_Left": 0.44,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 158.69
	        }
	    },
	    "blade10": {
	        "morphing": {
	            "m_Cutout_Left": 0.44,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 168.63
	        }
	    },
	    "blade11": {
	        "morphing": {
	            "m_Cutout_Left": 0.44,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 187.56
	        }
	    },
	    "blade12": {
	        "morphing": {
	            "m_Cutout_Left": 0.44,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 203.74
	        }
	    },
	    "blade13": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0.44,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 253.26
	        }
	    },
	    "blade14": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0.44,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 263.2
	        }
	    },
	    "blade15": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0.44,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 277.47
	        }
	    },
	    "blade16": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0.44,
	            "m_CoreDefault_Tip_S": 0.62,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 146.13,
	            "y": 155.26,
	            "z": 292.21
	        }
	    }
	},
	test_3: {
	    "blade1": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0.71,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0.6,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": 164.4
	        }
	    },
	    "blade2": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -337.5
	        }
	    },
	    "blade3": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -315
	        }
	    },
	    "blade4": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -292.5
	        }
	    },
	    "blade5": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -270
	        }
	    },
	    "blade6": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -247.5
	        }
	    },
	    "blade7": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -225
	        }
	    },
	    "blade8": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -202.5
	        }
	    },
	    "blade9": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -180
	        }
	    },
	    "blade10": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -157.5
	        }
	    },
	    "blade11": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -135
	        }
	    },
	    "blade12": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -112.5
	        }
	    },
	    "blade13": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -90
	        }
	    },
	    "blade14": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -67.5
	        }
	    },
	    "blade15": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -45
	        }
	    },
	    "blade16": {
	        "morphing": {
	            "m_Cutout_Left": 0,
	            "m_Cutout_Center": 0,
	            "m_Cutout_Right": 0,
	            "m_Cutout_Stepped": 0,
	            "m_CoreDefault_Tip_S": 0,
	            "m_CoreLarge_Tip_L": 0,
	            "m_CoreLarge_Tip_S": 0,
	            "m_CoreSmall_Tip_L": 0,
	            "m_CoreSmall_Tip_S": 0
	        },
	        "rotation": {
	            "x": 0,
	            "y": 0,
	            "z": -22.5
	        }
	    }
	}
};

// PCUI

class StatesControls {

	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		/**
		 * [constructor description]
		 * @param  {...[type]} options.props [description]
		 * @return {[type]}                  [description]
		 */
		constructor({...props}) {
			

			// Props
			const { 
				name
				,states
				,bladeRotationOffset  
				,bladeRotation
			} = props;
			this.name = name;
			this.states = states || {};			

	    	// Controls
	    	this.controls = {
	    		ui: htmlToDomFragment("<div></div>")
	    		,observers: {}
	    	};

			// Init
			this.init();
	        
		}

		

	////////////////////////
	// INITIALIZE
	////////////////////////

		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {

			// Create Controls
			this.createControls();

		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////
	
		/**
		 * [getControls description]
		 * @return {[type]} [description]
		 */
		getControls(opt_key) {

			return opt_key ? this.controls[opt_key] : this.controls;

		}		

	////////////////////////
	// METHODS
	////////////////////////

		/**
		 * [createControls description]
		 * @return {[type]} [description]
		 */
		createControls() {

			// Add ALL
								
				// Container
					const statesContainer = document.createElement("DIV");

				// States name
					const statesNameContainer = document.createElement("DIV");
					const statesLabel = new Label({
						enabled: true,
						height: null,
						text: this.name.toUpperCase(),
						tabIndex:0,
						width:null
					});
					statesNameContainer.appendChild(statesLabel.dom);
					statesLabel.dom.style.color = "#FF0000";
					statesNameContainer.style.marginTop = statesNameContainer.style.marginBottom = "15px";
					statesContainer.appendChild(statesNameContainer);

				// States Controls					
					const statesStateContainer = document.createElement("DIV");
					const states = this.states;
					// console.warn("populate controls for presetStates", states);
					// Loop add states
					for (let state in states) {


						// Label
						const stateLabelContainer = document.createElement("DIV");
						const stateLabel = new Label({
							enabled: true,
							height: null,
							text: "preset state: "+state,
							tabIndex:0,
							width:null
						});
						stateLabelContainer.appendChild(stateLabel.dom);
						statesStateContainer.appendChild(stateLabelContainer);

						// Slider
						/*
						const stateObserver = new Observer({
							progress: 0
						});						
						// observer.on('progress:set', function(value) {
						// 	// Change All blades morphTarget idx weight to value
						// 	console.log("v", value);
						// 	// for (let b in this.scope.blades) {
						// 	// 	this.scope.blades[b].updateMorphtarget(this.idx,value);
						// 	// }
						// 	this.scope.updateMorphtarget.apply(this, [this.idx,value]);

						// }.bind({
						// 	scope: this,						
						// 	idx: meshMorphs[i].idx
						// }));
						const stateSlider = new SliderInput({
						    enabled: true, 
							height: null,
							max: 1,
							min: 0,				
							binding: new BindingTwoWay(),
							pre: 0,
							sliderMax: 1,
							sliderMin: 0,
							step: 0,
							tabIndex: 0,
							width: null
						});
						stateSlider.link(stateObserver,'progress');
						statesStateContainer.appendChild(stateSlider.dom);
						*/
						// Button
						const stateObserver = new Observer({progress: 1});
						// Observer Callback is set from the main class
						// stateObserver.on('progress:set', function(value) {
						// 	console.log("value 4", value);
						// }.bind(this));
						const stateButton = new Button({
							enabled: true,
							height: null,
							icon: "E401",
							size: "",
							tabIndex:0,
							text:"Run",
							width:null
						});
						// Link observer
						stateButton.link(stateObserver,'progress');
						// Add button to state export container
						statesStateContainer.appendChild(stateButton.dom);
						// Add Export Container to States Container
						// statesContainer.appendChild(statesExportContainer);
						// Add Listener to Button
						stateButton.on('click', function(value) {
							// Dispatch event (toggle)
							const oldValue = stateObserver.get("progress");						
							stateObserver.set("progress", -1*oldValue);
						});

						// Add
						this.controls.observers[state] = {
							idx: state
							,observer: stateObserver
							,type: "state"
						};
					
					}					//
					// Add State to States Container
					statesContainer.appendChild(statesStateContainer);

				// Current State Button
					
					// Label
					const statesExportLabelContainer = document.createElement("DIV");
					const statesExportLabel = new Label({
						enabled: true,
						height: null,
						text: "new state:",
						tabIndex:0,
						width:null
					});
					statesExportLabelContainer.appendChild(statesExportLabel.dom);
					statesExportLabel.dom.style.color = "#00FF00";
					statesExportLabelContainer.style.marginTop = "15px";
					statesContainer.appendChild(statesExportLabelContainer);

					// Button
					const observerExportButton = new Observer({progress: 1});
					// Observer Callback is set from the main class
					// observerExportButton.on('progress:set', function(value) {
					// 	console.log("value 4", value);
					// }.bind(this));
					const statesExportContainer = document.createElement("DIV");
					const exportButton = new Button({
						enabled: true,
						height: null,
						icon: "E401",
						size: "",
						tabIndex:0,
						text:"Add current",
						width:null
					});
					// Link observer
					exportButton.link(observerExportButton,'progress');
					// Add button to state export container
					statesExportContainer.style.marginBottom = "15px";
					statesExportContainer.appendChild(exportButton.dom);
					// Add Export Container to States Container
					statesContainer.appendChild(statesExportContainer);
					// Add Listener to Button
					exportButton.on('click', function(value) {
						// Dispatch event (toggle)
						const oldValue = observerExportButton.get("progress");						
						observerExportButton.set("progress", -1*oldValue);
					});

					// Add to Observers
					this.controls.observers["append"] = {
						idx: 0
						,observer: observerExportButton
						,type: "append"
					};

				// Load State Button
					
					// Label
					const statesImportLabelContainer = document.createElement("DIV");
					const statesImportLabel = new Label({
						enabled: true,
						height: null,
						text: "load state:",
						tabIndex:0,
						width:null
					});
					statesImportLabelContainer.appendChild(statesImportLabel.dom);
					statesImportLabel.dom.style.color = "#00FF00";
					statesImportLabelContainer.style.marginTop = "15px";
					statesContainer.appendChild(statesImportLabelContainer);

					// Button
					const observerImportButton = new Observer({progress: 1});
					// Observer Callback is set from the main class
					// observerImportButton.on('progress:set', function(value) {
					// 	console.log("value 4", value);
					// }.bind(this));
					const statesImportContainer = document.createElement("DIV");
					const importButton = new Button({
						enabled: true,
						height: null,
						icon: "E401",
						size: "",
						tabIndex:0,
						text:"Import",
						width:null
					});
					// Link observer
					importButton.link(observerImportButton,'progress');
					// Add button to state export container
					statesImportContainer.style.marginBottom = "15px";
					statesImportContainer.appendChild(importButton.dom);
					// Add Export Container to States Container
					statesContainer.appendChild(statesImportContainer);
					// Add Listener to Button
					importButton.on('click', function(value) {
						// Dispatch event (toggle)
						const oldValue = observerImportButton.get("progress");						
						observerImportButton.set("progress", -1*oldValue);
					});

					// Add to Observers
					this.controls.observers["import"] = {
						idx: 0
						,observer: observerImportButton
						,type: "import"
					};

				// Add Blader to UI DOM
					this.controls.ui.appendChild(statesContainer);
	
		}

		/**
		 * [addStateControl description]
		 * @param {[type]} state [description]
		 */
		addStateControl(state) {

			// Container
				const stateContainer = document.createElement("DIV");

			// State Control				
				const stateStateContainer = document.createElement("DIV");

				// Label
					const stateLabelContainer = document.createElement("DIV");
					const stateLabel = new Label({
						enabled: true,
						height: null,
						text: "new state: "+state,
						tabIndex:0,
						width:null
					});
					stateLabelContainer.appendChild(stateLabel.dom);
					stateStateContainer.appendChild(stateLabelContainer);

				// Observer
					const stateObserver = new Observer({progress: 1, tojson: 1});

				// Run Button					
					// Observer Callback is set from the main class
					// stateObserver.on('progress:set', function(value) {
					// 	console.log("value 4", value);
					// }.bind(this));
					const stateButton = new Button({
						enabled: true,
						height: null,
						icon: "E401",
						size: "",
						tabIndex:0,
						text:"Run",
						width:null
					});
					// Link observer
					stateButton.link(stateObserver,'progress');
					// Add button to state export container
					stateStateContainer.appendChild(stateButton.dom);
					// Add Listener to Button
					stateButton.on('click', function(value) {
						// Dispatch event (toggle)
						const oldValue = stateObserver.get("progress");
						stateObserver.set("progress", -1*oldValue);
					});

					// Add
					this.controls.observers[state] = {
						idx: state
						,observer: stateObserver
						,type: "state"
					};
				
				// Export
					// Observer Callback is set from the main class
					// stateObserver.on('tojson:set', function(value) {
					// 	console.log("value 4", value);
					// }.bind(this));
					const exportButton = new Button({
						enabled: true,
						height: null,
						icon: "E401",
						size: "",
						tabIndex:0,
						text:"Export",
						width:null
					});
					// Link observer
					exportButton.link(stateObserver,'tojson');
					// Add button to state export container
					stateStateContainer.appendChild(exportButton.dom);
					// Add Listener to Button
					exportButton.on('click', function(value) {
						// Dispatch event (toggle)
						const oldValue = stateObserver.get("tojson");
						stateObserver.set("tojson", -1*oldValue);
					});

					// Add
					this.controls.observers[state] = {
						idx: state
						,observer: stateObserver
						,type: "state"
					};

				// Add State to States Container
				stateContainer.appendChild(stateStateContainer);


			// Add new state container to UI DOM
				this.controls.ui.appendChild(stateContainer);
		}

}

class States {

	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		/**
		 * [constructor description]
		 * @param  {...[type]} options.props [description]
		 * @return {[type]}                  [description]
		 */
		constructor({...props}) {


			// Props
			const { 
				controls
			} = props;

			// States
			this.states = objectMap(presetStates, function(v) { 
				return {
					preset: v 		// state values
					,time: 0		// time now (ms)
					,duration: 500 	// total (ms)
				}
			});

			// Create Controls
			this.hasControls = (controls === true);
			this.controls = null;

			// Init
			this.init();

		}


	////////////////////////
	// INITIALIZE
	////////////////////////

		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {

			// Create Controls
			this.createControls();
		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////

		/**
		 * [setState description]
		 * @param {[type]} id    [description]
		 * @param {[type]} state [description]
		 */
		setState(id, state) {

			this.states[id] = {
					preset: state 		// state values
					,time: 0		// time now (ms)
					,duration: 500 	// total (ms)
				};

			// Has UI
			if (this.hasControls === true) {
			
				this.controls.addStateControl(id);

			}
		
		}

		/**
		 * [getState description]
		 * @param  {[type]} id [description]
		 * @return {[type]}    [description]
		 */
		getState(id) {

			return this.states[id];

		}

		/**
		 * [getControls description]
		 * @param  {[type]} opt_key [description]
		 * @return {[type]}         [description]
		 */
		getControls(opt_key) {
			return this.controls.getControls(opt_key);
		}

	////////////////////////
	// METHODS
	////////////////////////

		/**
		 * [createControls description]
		 * @return {[type]} [description]
		 */
		createControls() {

			// Has UI
			if (this.hasControls === true) {
			
				this.controls = new StatesControls({
					name: "states"
					,states: this.states
				});

			}

		}

}

// PC

class MetaWim {
	

	////////////////////////
	// CONSTRUCTOR
	////////////////////////
	
		constructor({...props}) {
			
			// Super 
				const { canvas, ui, count, pp, algowimControls, onload } = props;			

			// Props
			
				// Onload callback
				this.onload = onload || null;

				// Use Layers (TRY to solve opacity issue)
				this.useLayers = false;

				// Canvas DOM
				this.canvas = canvas;

				// Dev Controls
				this.ui = ui || null;

				// Canvas context (see options at https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext)
				const gl = canvas.getContext("webgl2", {
					alpha: true
					,antialias: true
					,powerPreference: "high-performance"
					,premultipliedAlpha: true
				});
				// console.warn("gl",gl);
				// gl.alpha = true; // true;

				// App (see options at https://developer.playcanvas.com/en/api/pc.Application.html#Application)
				this.app = new Application(canvas, {
					mouse: new Mouse(canvas.parentElement || canvas)
					,touch: new TouchDevice(canvas.parentElement || canvas)
					,graphicsDeviceOptions: gl
					,elementInput: new ElementInput(canvas)
				});
				this.app.root.name = "MetaWim";				

				// Count of blades
				this.count = count || 16;

				// Rotation
				this.rotationOffset = 90; // default offset to correct 0 degrees state (to TOP)
				this.rotationStep = fixFloat(360/this.count);

				// Scene
				this.scene = new Scene({
					app: this.app
					,count: this.count
					,controls: this.ui !== null
					,useLayers: this.useLayers
					,algowimControls: algowimControls || null
				});
				this.app.scene.ambientLight = new Color(1, 1, 1);

				// Blades			
				this.blades = {};
				
				// All (Blades) Controls
				this.meshMorphsIndex = meshMorphs;
				this.allcontrols = null;

				// States
				this.states = new States({
					controls: (this.ui !== null)
				});
				this.lastState = {};

				// Router
				// this.router = new Router({
				// 	pp: pp || null
				// })

			// Init
				this.init();

			// Start
				this.start();

	        
		}


	////////////////////////
	// INITIALIZE
	////////////////////////
	
		/**
		 * [init description]
		 * @return {[type]} [description]
		 */
		init() {			
			
			// Setup Canvas
			this.setupCanvas();

	    	// Create Blades
			this.createBlades();			

			// Create All Controls
			this.createAllControls();


			// TOD0:
			
				/*
					- controls
					- reorder blades
					- test button for action (will simulated socket calls)
					- fx class				
					- scoket listner


				 */
			
				//console.log("this.app.root",this.app.root);
		}


		start() {


			// Add Light
				this.app.root.addChild(this.scene.getLight());

			// Add Camera - DEPRECATED (use script oribitCamera)
				// this.app.root.addChild(this.scene.getCamera());			
		    
		    // Add Scripts			    	
		    	this.app.root.addChild(this.scene.getScripts());		    

	    	// Add Blades
	    		this.addBlades();
	    
	    	// Add Controls
	    		this.addControls();
	    
	    	// Start App
	    		this.app.start();

	    	// Onload
	    	
	    		if (this.onload !== null) {
	    			this.onload("pc");	    			
	    		}

	    	// Listeners
    			// this.app.on("update", this.update, th
	    		
	    		

	    	// Test
	    		
	    		// var worldLayer = this.app.scene.layers.getLayerByName('World');
    			// // worldLayer.clearDepthBuffer = true;
    			// worldLayer.enabled = false;

    			// var depthLayer = this.app.scene.layers.getLayerByName('Depth');	    	
    			// depthLayer.clearDepthBuffer = true;
    			// depthLayer.enabled = false;
    			
	    		// setTimeout(function () {
	    		// 	this.blades['blade16'].updateMorphtarget(0,1, 'm_Cutout_Left');
	    		// 	// this.app.off();
	    		// }.bind(this), 2000);
				
				// console.log("this.app.scene.layers", this.app.scene.layers);
				// console.log("this.app", this.app);

				// CAMERA and MESHES MATERIAL
					// console.warn(this.scene.getCamera());
					// for (let b in this.blades) {
					// 	console.log(this.blades[b].meshInstance.material);
					// }
					// console.warn(this.scene);
				

				// TEXT
					console.log("----------------------------");
					console.log("root", this.app.root);
					console.log("layers", this.app.scene.layers);
					console.log("----------------------------");					 
					


					// const scripts = new Entity();
					// scripts.name = "fontsloader";
					// scripts.addComponent("script");
					// scripts.script.create("canvasFontHelper", CreateFonts({}));
					// this.app.root.addChild(scripts);	


					// console.warn("font asset", scripts.script.canvasFontHelper);

var asset = new Asset("customfont", "font", {
    url: "http://dc.local/~dogma/_sites/peter-playcanvas/dist/Roboto-Condensed-webfont.json"
});
this.app.assets.add(asset);

console.log("customfont", this.app.assets.find("customfont"));

var assetsToLoad = [
    this.app.assets.find("customfont")
];
var count = 0;
assetsToLoad.forEach(function (assetToLoad) {
    assetToLoad.ready(function (asset) {
        count++;
        if (count === assetsToLoad.length) {
            // done
            console.log("customfont loaded", this.app.assets.find("customfont"));
        }
    }.bind(this));
    this.app.assets.load(assetToLoad);
}.bind(this));


const fontsFacesAdded = [];
var font = new FontFace("custom", 'url(http://dc.local/~dogma/_sites/peter-playcanvas/dist/Roboto-Condensed-webfont.ttf)');  // ' + fontAsset.asset.getFileUrl() + '
font.load().then(function(loadedFace) {
    document.fonts.add(loadedFace);    
    fontsFacesAdded.push(loadedFace);
    console.log(fontsFacesAdded);
			       
    var testfont = document.createElement("DIV");
    testfont.innerHTML = "testing font";
    testfont.setAttribute("style", "font-family: custom; position: absolute; top: 0px; right: 0px; color: white;");
    document.body.appendChild(testfont);


					const worldLayer = this.app.scene.layers.getLayerByName("World");
					const idx = this.app.scene.layers.getTransparentIndex(worldLayer);
					const textlayer = new Layer();
					textlayer.id = textlayer.name = "text";
					// textlayer.opaqueSortMode = SORTMODE_MANUAL; //SORTMODE_MATERIALMESH; //SORTMODE_MANUAL;	
					// textlayer.transparentSortMode = SORTMODE_MANUAL;
					// this.layer.passThrough = true;
					// this.layer.clearDepthBuffer = true;
					// this.layer.shaderPass = SHADER_DEPTH;
					this.app.scene.layers.insert(textlayer, idx+1);

					// Create a 2D screen
				    // const screen = new Entity();
				    // screen.id = screen.name = "text";
				    // screen.addComponent("screen", {
				    //     referenceResolution: new Vec2(1369, 1094),
				    //     scaleBlend: 0.5,
				    //     scaleMode: SCALEMODE_BLEND,
				    //     screenSpace: false,
				    // });
				    // screen.screen.layers = [textlayer.id];
				    // this.app.root.addChild(screen);

				     // Basic Text
					    const textBasic = new Entity();
					    // textBasic.setLocalPosition(0, 200, 0);
					    textBasic.addComponent("element", {
					        // pivot: new Vec2(0.5, 0.5),
					        // anchor: new Vec4(0.5, 0.5, 0.5, 0.5),
					        // fontAsset: assets.font.id,
					        // font: 'custom', //assets.font.id,
					        fontAsset: this.app.assets.find("customfont").id,
					        fontSize: 42,
					        text: 'There are seven colors in the rainbow: [color="#ff0000"]red[/color], [color="#ffa500"]orange[/color], [color="#ffff00"]yellow[/color], [color="#00ff00"]green[/color], [color="#0000ff"]blue[/color], [color="#4b0082"]indigo[/color] and [color="#7f00ff"]violet[/color].',
					        type: ELEMENTTYPE_TEXT,
					    });				    	
					    // screen.addChild(textBasic);
					    textBasic.element.layers = [textlayer.id];
				    	this.app.root.addChild(textBasic);

				    // create box entity
					    const box = new Entity("cube");
					    box.id = box.name = "text";
					    box.addComponent("render", {
					        type: "box",
					    });
					    box.render.layers = [textlayer.id];
				    	this.app.root.addChild(box);

					const camera = new Entity();
				    camera.addComponent("camera", {
				        // clearColor: new Color(30 / 255, 30 / 255, 30 / 255),
				        clearColorBuffer: false
						,clearDepthBuffer: true //true
						,priority:2
				    });
					camera.camera.layers = [textlayer.id];
				    this.app.root.addChild(camera);		


				    const light = new Entity();
			        light.name = "light";
			        light.addComponent("light", {
			            type: "omni", //"directional",
			            color: new Color(1, 1, 1),
			            castShadows: false,
			        });
					light.light.layers = [textlayer.id];


				    console.log("text camera layers", camera.camera.layers);
				 

				   	camera.translate(0, 0, 20);
					camera.lookAt(Vec3.ZERO);

				    

				// TEST 2 - https://playcanvas.github.io/#/user-interface/world-to-screen
				
					// Create a 2D screen
				    const screen = new Entity();
				    screen.setLocalScale(0.01, 0.01, 0.01);
				    screen.addComponent("screen", {
				        referenceResolution: new Vec2(1280, 720),
				        screenSpace: true,
				    });

				    this.app.root.addChild(screen);


				    const name = new Entity();
			        name.addComponent("element", {
			            pivot: new Vec2(0.5, 0.5),
			            anchor: new Vec4(0, 0.4, 1, 1),
			            margin: new Vec4(0, 0, 0, 0),
			            fontAsset: loadedFace, //assets.font.id,
			            fontSize: 20,
			            text: `Player `,
			            useInput: true,
			            type: ELEMENTTYPE_TEXT,
			        });

			        screen.addChild(name);

//////////////
	
	var self = this;
			        /**
     * Converts a coordinate in world space into a screen's space.
     *
     * @param {pc.Vec3} worldPosition - the Vec3 representing the world-space coordinate.
     * @param {pc.CameraComponent} camera - the Camera.
     * @param {pc.ScreenComponent} screen - the Screen
     * @returns {pc.Vec3} a Vec3 of the input worldPosition relative to the camera and screen. The Z coordinate represents the depth,
     * and negative numbers signal that the worldPosition is behind the camera.
     */
    function worldToScreenSpace(worldPosition, camera, screen) {
        const screenPos = camera.worldToScreen(worldPosition);

        // take pixel ratio into account
        const pixelRatio = self.app.graphicsDevice.maxPixelRatio;
        screenPos.x *= pixelRatio;
        screenPos.y *= pixelRatio;

        // account for screen scaling
        // @ts-ignore engine-tsd
        const scale = screen.scale;

        // invert the y position
        screenPos.y = screen.resolution.y - screenPos.y;

        // put that into a Vec3
        return new Vec3(
            screenPos.x / scale,
            screenPos.y / scale,
            screenPos.z / scale
        );
    }

    function createPlayer(id, startingAngle, speed, radius) {
        // Create a capsule entity to represent a player in the 3d world
        const entity = new Entity();
        entity.setLocalScale(new Vec3(0.5, 0.5, 0.5));
        entity.addComponent("render", {
            type: "capsule",
        });

        self.app.root.addChild(entity);

        // update the player position every frame with some mock logic
        // normally, this would be taking inputs, running physics simulation, etc
        let angle = startingAngle;
        const height = 0.5;
        self.app.on("update", function (dt) {
            angle += dt * speed;
            if (angle > 360) {
                angle -= 360;
            }
            entity.setLocalPosition(
                radius * Math.sin(angle * math.DEG_TO_RAD),
                height,
                radius * Math.cos(angle * math.DEG_TO_RAD)
            );
            entity.setLocalEulerAngles(0, angle + 90, 0);
        });

        // Create a text element that will hover the player's head
        const playerInfo = new Entity();
        playerInfo.addComponent("element", {
            pivot: new Vec2(0.5, 0),
            anchor: new Vec4(0, 0, 0, 0),
            width: 150,
            height: 50,
            opacity: 0.05,
            type: ELEMENTTYPE_IMAGE,
        });

        screen.addChild(playerInfo);

        const name = new Entity();
        name.name = "textelement";
        name.addComponent("element", {
            pivot: new Vec2(0.5, 0.5),
            anchor: new Vec4(0, 0.4, 1, 1),
            margin: new Vec4(0, 0, 0, 0),
            // font: 'custom', //assets.font.id,
            fontAsset: self.app.assets.find("customfont").id,
            fontSize: 20,
            text: `Player ${id}`,
            useInput: true,
            type: ELEMENTTYPE_TEXT,
        });

        console.warn("where is the text?", name);

        name.addComponent("button", {
            imageEntity: name,
        });

        name.button.on("click", function (e) {
            const color = new Color(
                Math.random(),
                Math.random(),
                Math.random()
            );
            name.element.color = color;
            entity.render.material.setParameter("material_diffuse", [
                color.r,
                color.g,
                color.b,
            ]);
        });
        playerInfo.addChild(name);

        const healthBar = new Entity();
        healthBar.addComponent("element", {
            pivot: new Vec2(0.5, 0),
            anchor: new Vec4(0, 0, 1, 0.4),
            margin: new Vec4(0, 0, 0, 0),
            color: new Color(0.2, 0.6, 0.2, 1),
            opacity: 1,
            type: ELEMENTTYPE_IMAGE,
        });

        playerInfo.addChild(healthBar);

        // update the player text's position to always hover the player
        self.app.on("update", function () {
            // get the desired world position
            const worldPosition = entity.getPosition();
            worldPosition.y += 0.6; // slightly above the player's head

            // convert to screen position
            const screenPosition = worldToScreenSpace(
                worldPosition,
                camera.camera,
                screen.screen
            );

            if (screenPosition.z > 0) {
                // if world position is in front of the camera, show it
                playerInfo.enabled = true;

                // set the UI position
                playerInfo.setLocalPosition(screenPosition);
            } else {
                // if world position is actually *behind* the camera, hide the UI
                playerInfo.enabled = false;
            }
        });
    }

    createPlayer(1, 135, 30, 1.5);


/////////////
 }.bind(this)).catch(function(error) {
    console.error(error);
});
							   
				}

	////////////////////////
	// CALLBACKS
	////////////////////////
	
		/**
		 * Canvas update
		 * @param  {[type]} dt [description]
		 * @return {[type]}    [description]
		 */
		update(dt) {

		}

	////////////////////////
	// GETTERS / SETTERS
	////////////////////////
	
		callAction(action,newValue,oldValue) {

			switch(action) {
				case "pc-orbit-reset":
					// Reset MetaWim Orbit Camera to Initial State
					this.scene.resetCamera();
					break;
			}

		}

	////////////////////////
	// METHODS
	////////////////////////
	
		/**
		 * [setupCanvas description]
		 * @return {[type]} [description]
		 */
		setupCanvas() {

			this.app.setCanvasFillMode(FILLMODE_NONE); // https://developer.playcanvas.com/en/api/pc.Application.html#fillMode
			//this.app.setCanvasFillMode(FILLMODE_FILL_WINDOW);
	    	this.app.setCanvasResolution(RESOLUTION_AUTO);

		}

		/**
		 * [createBlades description]
		 * @param  {[type]} n [description]
		 * @return {[type]}   [description]
		 */
		createBlades() {

			let blade, name;
			let rot = 0; //this.rotationOffset; // shift to top
			// for (var i = this.count; i >= 1; i--) {
			for (var i = 1; i <= this.count; i++) {
				//rotationStep
				// Name
				name = "blade"+(i);
				// Create
				blade = new Blade({
					name: name
					,index: i
					,layers: this.app.scene.layers
					,graphicsDevice: this.app.graphicsDevice
					,controls: this.ui !== null
					,meshMorphsIndex: this.meshMorphsIndex
					,bladeRotationStep: this.rotationStep
					,bladeRotationOffset: this.rotationOffset
					,bladeRotation: {x:0,y:0,z:rot}
					,useLayers: this.useLayers
				});
				// Rotate
				// rot-=this.rotationStep;
				rot+=this.rotationStep;
				// Add 
				this.blades[name] = blade;				
				
			}
		}

		/**
		 * [createControls description]
		 * @return {[type]} [description]
		 */
		createAllControls() {

			// Has UI
			if (this.ui !== null) {
			
				this.allcontrols = new BladeControls({
					name: "all"
					,meshMorphsIndex: this.meshMorphsIndex
					,bladeRotationOffset: this.rotationOffset
					,bladeRotation: {x:0,y:0,z:0}
				});

			}

		}

		/**
		 * [addBlades description]
		 */
		addBlades() {

			for (let b in this.blades) {
    			// Blade Entity
    			this.app.root.addChild(this.blades[b].getEntity());
    		}

		}

		/**
		 * [addControls description]
		 */
		addControls() {

			if (this.ui !== null) {
				
				// SCENE
				
					// Get observers
					const sceneobserver = this.scene.getControls("observers");
					// Assign callback to all observer
    				for (let id in sceneobserver) {
    					sceneobserver[id].observer.on('progress:set', function(newValue, oldValue) {
    						// Mutate
    						switch(this.type) {
								case "camera":

									switch(this.idx) {
										case "reset":
											// Reset Orbit
											// this.scope.scene.resetCamera();
											this.scope.callAction("pc-orbit-reset");
											break;
										case "projection":
											// Change projection											
											this.scope.scene.setProjection(newValue);
											break;
									}

									break;
								case "material":

									switch(this.idx) {
										case "depth":
											// Change material depth write
											for (let b in this.scope.blades) {
												this.scope.blades[b].setDepth(newValue);
											}
											break;
									}

									break;

								case "opacity":

									switch(this.idx) {
										case "blades":
											// Change material opacity
											for (let b in this.scope.blades) {
												this.scope.blades[b].setOpacity(newValue);
											}
											break;
										case "canvas":
											// Change canvas opacity
											this.scope.canvas.style.opacity = newValue;											
											break;
									}

									break;

								case "separate":

									switch(this.idx) {
										case "blades":
											// Change material depth write
											for (let b in this.scope.blades) {
												this.scope.blades[b].translateBlade(newValue);
											}
											break;
									}

									break;

    						}    						
						}.bind({
							scope: this
							,type: sceneobserver[id].type
							,idx: sceneobserver[id].idx
							,id: id
						}));
    				}					// Add DOM
    				this.ui.appendChild(this.scene.getControls("ui"));



				// STATES				

					// Get observers
					const statesobserver = this.states.getControls("observers");
					// Assign callback to all observer
    				for (let id in statesobserver) {
    					statesobserver[id].observer.on('progress:set', function(newValue, oldValue) {
    						// Mutate
    						switch(this.type) {
    							case "append":
									// Add current state
									this.scope.addCurrentState();
									break;
								case "import":
									// Import from file
									this.scope.addImportState();
									break;
								case "state":
									// Setup 
									this.scope.setupStateCallback(this.idx);
									break;
    						}    						
						}.bind({
							scope: this
							,type: statesobserver[id].type
							,idx: statesobserver[id].idx
							,id: id
						}));
    				}					// Add DOM
    				this.ui.appendChild(this.states.getControls("ui"));

				// ALL
					
					// Get observers
					const allobserver = this.allcontrols.getControls("observers");
					// Assign callback to all observer
    				for (let id in allobserver) {
    					allobserver[id].observer.on('progress:set', function(newValue, oldValue) {
    						// Mutate
    						switch(this.type) {
    							case "morph":
									// Change Morph targets for all blades
									for (let b in this.scope.blades) {
										this.scope.blades[b].updateMorphtarget(this.idx,newValue, this.id);
									}
									break;
								case "rotation":
    								// Rotate All
    								for (let b in this.scope.blades) {
										const rot = fixFloat((this.scope.blades[b].getBladeRotation(this.idx) + newValue) % 360); // from entity
										// const rot = fixFloat((this.scope.blades[b].getRotation(this.idx) + newValue) % 360); // from blade object
    									this.scope.blades[b].setRotation({[this.idx]:rot}, this.id);
									}
									break;
    						}
						}.bind({
							scope: this
							,type: allobserver[id].type
							,idx: allobserver[id].idx
							,id: id
						}));
    				}    				// Add DOM
    				this.ui.appendChild(this.allcontrols.getControls("ui"));

				// INDIVIDUAL
					
					// Sort
					const keys = sortArrayByNumericValue(Object.keys(this.blades).map(v => parseInt(v.replace('blade',''))), "DESC");				
					// Loop
					for (var i = keys.length - 1; i >= 0; i--) {
	    				// Key
	    				const b = "blade"+keys[i].toString();
	    				// Get observers
	    				const observers = this.blades[b].getControls("observers");
	    				// Assign callback to all observers
	    				for (let id in observers) {
	    					observers[id].observer.on('progress:set', function(newValue, oldValue) {
	    						// Mutate
	    						switch(this.type) {
	    							case "morph":
	    								// Change Morph target
										this.scope.blades[b].updateMorphtarget(this.idx,newValue);
										break;
									case "rotation":
	    								// Rotate Blade
    									this.scope.blades[b].setRotation({[this.idx]:newValue});
										break;
	    						}
							}.bind({
								scope: this								
								,type: observers[id].type
								,idx: observers[id].idx
							}));
	    				}	    				// Add DOM
	    				this.ui.appendChild(this.blades[b].getControls("ui"));
	    			}
    		
	    		// Add to parent
	    		// if (window.self !== window.top) {
	    		// 	window.top.document.body.appendChild(this.ui);
	    		// }
    		}

		}

		/**
		 * [getCurrentState description]
		 * @return {[type]} [description]
		 */
		getCurrentState() {

			const currentState = {}; 
			for (let b in this.blades) {
				const rotation = this.blades[b].getStateRotation();
				const morphing = this.blades[b].getStateMorphing();
				currentState[b] = { 
					morphing: {...{}, ...morphing }
					,rotation: {...{}, ...rotation }
				}; 
			}
			
			return currentState;

		}

		/**
		 * [addCurrentState description]
		 */
		addCurrentState() {

			// Get State
			const currentState = {}; 
			for (let b in this.blades) {
				const rotation = this.blades[b].getStateRotation();
				const morphing = this.blades[b].getStateMorphing();
				currentState[b] = { 
					morphing: {...{}, ...morphing }
					,rotation: {...{}, ...rotation }
				}; 
			}

			// Append New State
			const name = "_"+Math.floor(new Date().getTime() / 1000);
			this.states.setState(name, currentState);

			// Attache Observer
			const statesobserver = this.states.getControls("observers");
			const id = name;
			statesobserver[id].observer.on('tojson:set', function(newValue, oldValue) {				
				this.scope.exportState(this.id);
			}.bind({
				scope: this
				,id: id
			}));
			statesobserver[id].observer.on('progress:set', function(newValue, oldValue) {
				// Mutate
				switch(this.type) {
					case "state":
						// Setup
						this.scope.setupStateCallback(this.idx);
						break;
				}    						
			}.bind({
				scope: this
				,type: statesobserver[id].type
				,idx: statesobserver[id].idx
				,id: id
			}));

		}

		/**
		 * [addImportState description]
		 */
		async addImportState() {

			// Load
			const importState = await importJson();
			const name = importState.name.replace(".json","");
			const currentState = Object.values(importState.data)[0].preset;

			// Append New State
			this.states.setState(name, currentState);

			// Attache Observer
			const statesobserver = this.states.getControls("observers");
			const id = name;
			statesobserver[id].observer.on('tojson:set', function(newValue, oldValue) {				
				this.scope.exportState(this.id);
			}.bind({
				scope: this
				,id: id
			}));
			statesobserver[id].observer.on('progress:set', function(newValue, oldValue) {
				// Mutate
				switch(this.type) {
					case "state":
						// Setup
						this.scope.setupStateCallback(this.idx);
						break;
				}    						
			}.bind({
				scope: this
				,type: statesobserver[id].type
				,idx: statesobserver[id].idx
				,id: id
			}));

		}

		/**
		 * [exportState description]
		 * @param  {[type]} id [description]
		 * @return {[type]}    [description]
		 */
		exportState(id) {

			// Get State
				const state = this.states.getState(id); 

			// Export to JSON
				console.info("Copy the object to some key (e.g.: "+id+") of the presetStates object in the ./presets module\n", state);
				exportJson(id,{[id]:state});

		}


		setupStateCallback(idx) {

			// Stop Other updates
			this.app.off();
			// Get current state
			const currentState = this.getCurrentState();
			
			// Get target state
			const state = this.states.getState(idx);		

			// Set New updates
			this.app.on("update", function(dt) {
				try {
					// Update run time
					this.time = Math.min(fixFloat(this.time+(dt*1000)),this.state.duration);
					// Apply changes
					// console.log("run time", this.time);
					const value = (this.time/this.state.duration);
					for (let presetBlade in this.state.preset) {
						for (let presetType in this.state.preset[presetBlade]) {
							switch(presetType) {
								case "morphing":
									// set
									for (let presetKey in this.state.preset[presetBlade][presetType]) {
										const currentWeight = this.origin[presetBlade].morphing[presetKey]; 
										const targetWeight = this.state.preset[presetBlade][presetType][presetKey];
										
										// get different
										let diffWeight= (fixFloat(targetWeight-currentWeight)); 
										// clock wise / closest path
										// if (diffWeight===0) {
										// 	// match
										// 	//console.warn('blade proportion positive', presetBlade, targetWeight, currentWeight);
										// 	diffWeight = targetWeight; //(fixFloat(targetWeight-(1+currentWeight))); 
										// }

										const propWeight = fixFloat(value*diffWeight);
										const weight = fixFloat((currentWeight + propWeight)); // % 1); this is invalid because at 1 it resets to 0

										this.scope.blades[presetBlade].updateMorphtarget(presetKey,weight,presetKey);

									}
									break;
								case "rotation":
									// keys
									const coords = {};
									// get
									for (let presetKey in this.state.preset[presetBlade][presetType]) {
										const currentRot = this.origin[presetBlade].rotation[presetKey]; 
										const targetRot = this.state.preset[presetBlade][presetType][presetKey];
										
										// get different
										let diffRot = (fixFloat(targetRot-currentRot)); 
										// correct
										if (diffRot>0) {
											// clock wise / closest path
											//console.warn('blade proportion positive', presetBlade, targetRot, currentRot);
											diffRot = (fixFloat(targetRot-(360+currentRot))); 
										} 

										const propRot = fixFloat(value*diffRot);
										const rot = fixFloat((currentRot + propRot) % 360);

										// update
										coords[presetKey] = rot;

									}
									// set
									this.scope.blades[presetBlade].setRotation(coords, Object.keys(coords)); // from blade object
									break;
							}
						}
					}											
					// Stop
					if (this.time>=this.state.duration) {
						this.scope.app.off();
					}
				} catch(error) {
					console.warn("state timer error", error);
					this.scope.app.off();	
				}
			}, {
				scope: this
				,time: 0 //state.time
				,state: state
				,origin: currentState								
			});
		}


}

export { MetaWim as default };
